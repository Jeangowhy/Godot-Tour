# Contents

[TOC]

## 🟡 Godot Docs 官方文档阅读指南
- [动画师救生手册 - 动画十二原则](https://www.bilibili.com/video/BV1x54y1e7J9)
- [GAMES101-现代计算机图形学入门 - 闫令琪](https://www.bilibili.com/video/BV1X7411F744/)
- [GAMES202-高质量实时渲染 - 闫令琪](https://www.bilibili.com/video/BV1YK4y1T7yY/)
- [GAMES202-高质量实时渲染课程主页](https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html/)
- [GAMES102-几何建模与处理基础 - 刘利刚](https://www.bilibili.com/video/BV1NA411E7Yr/)
- [GAMES103-基于物理的计算机动画入门 - 王华民](https://www.bilibili.com/video/BV12Q4y1S73g/)
- [GAMES105-计算机角色动画基础 - 刘利斌](https://www.bilibili.com/video/BV1GG4y1p7fF/)
- [GAMES104-现代游戏引擎：从入门到实践 - 王希](https://www.bilibili.com/video/BV1J3411n7WT/)
- [GAMES201-高级物理引擎实战指南 - 胡渊鸣](https://www.bilibili.com/video/BV1ZK411H7Hc)
- [CSD 15-462 Computer Graphics - Carnegie Mellon University](https://www.cs.cmu.edu/afs/cs/academic/class/15462-f11/www/)
- [CMU - 15-462/662 Computer Graphics - Keenan Crane](https://www.bilibili.com/video/BV1QZ4y1K7ga/)
- [龚大的上帝视角看GPU教程](https://www.bilibili.com/video/BV1P44y1V7bu/)
- [The Book of Shaders by Patricio Gonzalez Vivo & Jen Lowe](https://thebookofshaders.com/?lan=ch)
- [Godot Download](https://godotengine.org/download/windows)
- [Godot Demo Projects](https://godotengine.github.io/godot-demo-projects)
- [Godot Demo Projects](https://github.com/godotengine/godot-demo-projects)
- [Godot 3 Recipes](https://kidscancode.org/godot_recipes/3.x/)

Digital Content Creation (DCC) 数字内容创作工具是最现代代的生产力工具，包括但不仅限于 2D/3D、
音频/视频剪辑合成、动态/互动内容创作、图像编辑等等。

例如，用于视频游戏制作的 UE5、U3D，完全免费开源的 Godot，建模与动画工具 Blender 等等。2D 动画制作
工作如 Spine、OpenToonz 等等。程序化贴图 SubstanceDesigner，数字化布料 Style3D (国产之光)、
VStitcher、MarvelousDesigner，雕刻建模工具 ZBrush，电影特效魔术师 Houdini，工业设计和建筑设计
Rhino，以及传统的收费 3D 工具，如 3Dmax、Maya 等等。

Godot 作为一个新秀，完全开源，并且学易易用，并且具有适量的源代码，不会像 UE5 那样宏大难以分解。

要阅读好 Godot 官方文档，需要掌握文档的使用方法，并且最好有计算机图形学基础，掌握 Python 脚本语言
可以快速掌握 GDScript 脚本。

![Overview of the interface](https://docs.godotengine.org/en/latest/_images/editor-vocabulary-overview.png)

Godot 除了自带的 GDScript 脚本外，通过模块扩展支持了多种语言开发，C# 支持需要下载集成 Mono 的版本，
推荐使用自带的 GDScript 脚本开发，它相当一个支持多线程并行的 Python，支持六种 match 分支匹配模式。

- Constant pattern
- Variable pattern
- Wildcard pattern
- Binding pattern
- Array pattern
- Dictionary pattern
- Multiple patterns

计算机图形领域一个较难的领域是现代 GPU 编程，即着色器程序开发，入门体验容易，想要好效果难。一个比较
好的入门教材是 The Book of Shaders，尽管这是一个烂尾工程。Godot 3.x 使用 OpenGL GLES 2/3，
未来 Godot 4.x 会使用 Vulkan。

另外，提升动画艺术水平，学习一些动画原理很有必要，工具有 Spine、Blender、SketchBook、Krita、SAI
等等。最重要的是提升美学水平，一个作品好与坏，下限由工具决定，上限由制作人决定！

Godot 官方示范项目很赞，提供了许多基础功能的演示，Godot 3.x/4.x 版本分使用 master 或 4.0-dev 分支：

> git clone -b master -b 3.5 --depth=1 git@github.com:godotengine/godot.git
>
> git clone -b master -b 4.0-dev --depth=1 git@github.com:godotengine/godot-demo-projects.git
>
> git clone --depth=1 git@github.com:godotengine/godot-docs.git
> git clone -b master -b stable -b 3.5 -b 3.6 --depth=1 git@github.com:godotengine/godot-docs docs

Godot 源代码仓库包含了类型 API 文档，使用 xml 格式保存，可以在 doc 文件执行 make rst 或者
make markdown 进行格式转换。

克隆命令 git clone 不支持通过 -b 指定多个分支，只有最后指定的分支才有效。


为了方便在文档之间快速跳转，推荐在 Sublime Text 环境下阅读文档，只需要安装 run-snippet 插件，
使用 F9 快捷键跳转到光标下的文件或链接。

快速安装 RunSnippet 插件：

- Ctrl+Shift+P 打开 Sublime Text 命令调板；
- 执行 Add Repository 添加本插件代码仓库地址: https://github.com/jimboyeah/run-snippet
- 然后执行 Install Package 并输入 RunSnippt 进行确认安装；

手动添加 Repository，执行菜单： Perferences 🡒 Package Settings 🡒 Package Control 🡒 Settings

    "repositories":
    [
        "https://github.com/jimboyeah/run-snippet",
    ],

可以在 Packages 目录执行以下命令安装 RunSnippet 插件：

    git clone git@github.com/jimboyeah/run-snippet.git

添加配置文件，默认启用分组跳转，如果 Sublime Text 没有设置分组，则在当前 View 弹出文件跳转窗口，
这种行为有点打断思路。更合理的做法是 GUI 设置 2 个 Group，并且在另一个 Group 弹出文件 Panel。
Load settings from /Packages/Users/RunSnippet.sublime-settings

```json
    {
        "jump_between_group": true,
    }
```

Godot 文档是非常人性化的，体现在以下几点：

Godot IDE 编辑器本身集成了在线手册，按 F1 或直接在代码中按下 Ctrl 单击关键字即跳转到相关手册文档。
信息非常详细，包括类对象的继承关系、成员、方法信息等等。例如全局空间 @GDScript 和 @GlobalScope 
包含所有脚本中可以直接使用的函数等，超链接跳转非常方便。

其次 Online Docs 文档是完整的在线文档，是完整的文档，新手建议从开头两部分内容开始：

- General 基本概念及介绍，学习一个游戏引擎最好要有数学、图形学、着色器编程等基础。
- Getting started 入门引导，通过简单的教程讲解基础的概念。
- Tutorials 各个系统功能的教程，详细介绍 Godot 的组成。
- Development 引擎开发文档，这部分可以学习 Godot 应用架构组成，场景文件以及 GDScript grammar 脚本语法声明规范。
- Community 社区资讯介绍。
- Class reference 类对象 API 手册。

迪士尼的 12 项动画基本原则是迪士尼动画制作人 Ollie Johnston 和 Frank Tomas 在 1981 年出版的
 The Illusion of Life: Disney Animation 书中介绍的原则。

- Squash and Stretch 通过挤压和拉伸生动地表达体积感的变化；
- Anticipation 预备动作为观众心理预期准备一个适应性提示；
- Staging 舞台布局在画面构图上精心安排好主次元素；
- Straight Ahead Action and Pose to Pose 使用关键帧来设置动画姿态并保持动作连贯；
- Follow Through and Overlapping Action 为受力拖拽、惯性元素提供动画效果；
- Slow In and Slow Out 缓入缓出（Ease In/Out），真实世界的动画是累积的而非突变的；
- Arcs 弧线运动，这是普遍存真实世界中的运动，如手臂的摆动，身体的弯曲等等；
- Secondary Action 次要动作是丰富动画内容的重要手段，例如人物搬运重物前可以添加一个摩擦手掌的动作；
- Timing and Weight 时间节奏和重量感，时间越短或帧数越少表示动作越快；
- Exaggeration 夸张地表现情绪气氛；
- Solid Drawing 立体造型，符合透视的画面才更真实；
- Appeale 吸引力，让画面更讨喜、比例更突出，使用画面简洁而突出重点，这也是动画与插画的区别；



## 🟡 Godot Architecture 构架介绍
- [Introduction to Godot development](https://docs.godotengine.org/en/stable/development/cpp/introduction_to_godot_development.html)
- [Optimization using Servers](https://docs.godotengine.org/en/3.3/tutorials/optimization/using_servers.html)
- [Inheritance class tree](https://docs.godotengine.org/en/stable/development/cpp/inheritance_class_tree.html)
- [Overview of Godot's key concepts](https://docs.godotengine.org/en/stable/getting_started/introduction/key_concepts_overview.html)
- [Nodes and Scenes](https://docs.godotengine.org/en/stable/getting_started/step_by_step/nodes_and_scenes.html)
- [Using SceneTree](https://docs.godotengine.org/en/3.5/tutorials/scripting/scene_tree.html)
- [Using Viewports](https://docs.godotengine.org/en/3.5/tutorials/rendering/viewports.html)
- [Canvas layers](https://docs.godotengine.org/en/3.5/tutorials/2d/canvas_layers.html)
- [User Interface(UI)](https://docs.godotengine.org/en/3.5/tutorials/ui/index.html)
- [What were the motivations behind creating GDScript?](https://docs.godotengine.org/en/latest/about/faq.html#doc-faq-what-is-gdscript)
- [WebGL 可视化相机](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-visualizing-the-camera.html)
- [《迷失岛2》游戏框架开发01:实现场景转换｜Godot教程](https://www.bilibili.com/video/BV1jr4y1V7xJ/)
- [Scene Transitions By: Henrique Campos](https://www.gdquest.com/tutorial/godot/2d/scene-transition-rect/)

Godot 架构是模块化的，通过扩展模块可以实现各种功能，而各种编程语言则是通过以下三个模块实现的。
Godot 本身是 C++ 开发的，可以实现各种模块以扩展 Godot 功能，模块源代码位于 modules 子目录：

- GDScript 模块引入了 GDScript 脚本编程；
- Mono 模块引入 C# 语言；
- GDNative 模块引入原生语言，如通过 GDNative C++ Binding 使用 C++ 语言；

入门先阅读 Introduction to Godot development，- Architecture diagram 了解工程架构，搞清楚
**SceneTree** -> Nodes -> CanvasItem(Node2D, Control) and Spatial (3D Nodes) 基本关系。
Godot IDE 编辑器本身就是和游戏工程一样的应用，每个游戏可以看作一个场景树，它的节点是场景，而场景又
包含一组节点，节点是一个可以绑定脚本进行编程的对象。

![Architecture diagram](https://docs.godotengine.org/en/stable/_images/architecture_diagram.jpg)

Godot 本身支持多平台，通过源代码 platform 目录下对应各平台的实现，detect.py 脚本则用于检测当前
支持的平台，主程序入口则是在 main 目录下，入口方法是 **Main::start()**。SceneTree 类型就是一个
MainLoop 子类型，代表了游戏中的主循环，它会在程序入口中执行。

- OS_Unix    <- OS
- OS_UWP     <- OS
- OS_Windows <- OS
- OS_X11     <- OS_Unix
- OS_OSX     <- OS_Unix
- OSIPhone   <- OS_Unix
- OS_Android <- OS_Unix
- OS_JavaScript <- OS_Unix

不同平台的入口会包装 OS 类，例如 OS_Windows，但是 Web 平台特殊一点，因为它运行在浏览器上。因为
大多数系统都是类 Unix 操作系统，所以除了 Windows 平台，几乎都包装为一个 OS_Unix 类型。操作系统
与窗口的交互消息全部通过 Notification 机制转达场景树。Godot IDE 本身就是一个 EditorNode 节点，
它也是基于 Godot 引擎开发的一个游戏，只不过这个游戏是用来开发其它游戏的。

以下是入口代码的流程摘要，演示了 UWP 平台下的入口运行基本流程。Android 平台窗口消息传递方式差别
较大，MainLoop 的方法包装到了不同的函数内：

```cpp
bool Main::start() {

    MainLoop *main_loop = nullptr;
    if (editor) {
        main_loop = memnew(SceneTree);
    };

    SceneTree *sml = Object::cast_to<SceneTree>(main_loop);

    if (!project_manager && !editor) { // game
        // ...
    }

    if (editor) {
        EditorNode *editor_node = nullptr;
        editor_node = memnew(EditorNode);
        sml->get_root()->add_child(editor_node);
    }

    OS::get_singleton()->set_main_loop(main_loop);
}

void OS_UWP::run() {
    if (!main_loop)
        return;

    main_loop->init();

    uint64_t last_ticks = get_ticks_usec();

    int frames = 0;
    uint64_t frame = 0;

    while (!force_quit) {
        CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessAllIfPresent);
        if (managed_object->alert_close_handle)
            continue;
        process_events();      // get rid of pending events
        if (Main::iteration()) // -> VisualServer tick()
            break;
    };

    main_loop->finish();
}
```

整个引擎的消息处理循环结构就是 while 循环，Main::iteration() 函数就是游戏循环中要处理的工作，
在这里会发送各种通知，让节点有处理的机会。在入口方法中，会判断当前的运行状态，根据是否在编辑器状态
执行不同的代码。

游戏循环中，引擎会按 FPS 频率执行事件处理回调函数，当游戏进入空闲状态时，可以主动关闭事件处理回调，
以降低空闲时的 CPU 消耗：

```py
void _physics_process(delta: float) virtual
void _process(delta: float) virtual

void set_physics_process(enable: bool)
void set_process(enable: bool)

var fps = ProjectSettings.get_setting("physics/common/physics_ticks_per_second", 60)
Engine.set_physics_ticks_per_second(fps/3)

get_tree().paused = true
```

你可以使用两种类型的处理：

其中，`_process()` 这个事件处理回调函数在早期版本中，也称为 `_idle()` 即空闲事件处理。相对的，
物理事件的处理更优先，因为有更高的实时性需求。任何与物理引擎相关的，比如移动可能与环境相碰撞的实体，
都应使用 `_physics_process()`。

- Idle processing 空闲处理可以用来执行每帧更新节点的代码，执行频率会尽可能地快。
- Physics processing 物理处理的频率是固定的，和游戏的实际帧率无关，可以让物理平滑执行。

在一些游戏中，可以大大降低物理处理周期率，比如说，将物理新 60FPS 改变为 30 次甚至 20 次，就大大
降低 CPU 的负载。

Godot 中的节点都有“Pause Mode”设置，暂停模式定义它们应该在何时进行处理。要将游戏暂停，必须设置
暂停状态。将 SceneTree.paused 属性赋值为 true 即可。

设置暂停后会导致两件事：首先，所有节点的 2D 和 3D 物理系统都会停止。其次，根据处理模式不同，某些
节点的行为会停止或者开始。物理系统可以通过 set_active 方法激活。

- Inherit：处理与否取决于父、祖父等等节点中第一个非**继承**状态的节点。
- Stop：无条件停止节点，暂停时该节点不会进行处理。
- Process：无条件处理节点，无论暂停与否，该节点都会进行处理。
- Pausable：只在非暂停模式下处理，与 When Paused 相反，这两种是 Godot 4.x 新增模式。
- When Paused：只在 SceneTree 暂停模式下处理，和 Pausable 相反。

节点停止处理时会发生不少事情，`_process`、`_physics_process`、`_input`、`_input_event` 等
函数都不会再被调用。但信号正常工作，所连接的函数也正常执行，即便脚本附加在“Stop”暂停模式的节点上。
动画节点会暂停它们的当前动画，音频节点会暂停它们的当前音频流，粒子也会暂停。游戏不再暂停时，它们都会
自动继续运行。


Godot 编程体系的继承层次结构中，所有对象的父类是 **Object**，然后派生出各种功能的类对象，主要是
引用类和节点类两大块：

    ● Object
      +-- ● References
      |   +-- ● Resources
      +-- ● Node
      |   +-- ● CanvasItem
      |   |   +-- ● Control
      |   |   +-- ● Node2D
      |   +-- ● Spatial

Object 提供了最基本的能力，包括观察者编程模式 Signal 和 Notifications 两种机制的实现。
信号 **Signal** 在 Godot 中大量使用，这是观察者编程模式的一种实现，可以实现复杂逻辑的解耦。

相对于 Object、References、Resources 等类型，Node 是一个功能丰富的对象，因此它也更消耗 CPU，
所以，可以使用简单对象实现的功能，就尽量避免使用 Node 类型对象来实现。

场景树中可以添加的所有节点类型统一在源代码 scene 目录下：

- /scene/main 主要节点类型，包括 SceneTree、CanvasLayer、ViewPort、Node、Timer、HTTPRequest；
- /scene/gui 控件类型，包括 Control 及子类的实现，如文件对话框 FileDialog 等；
- /scene/2d  二维节点类型，包括 Node2D 及子类的实现；
- /scene/3d  三维节点类型，包括 Spatial 及子类的实现；
- /scene/animation  动画节点类型，包括AnimationPlayer、AnimationTree 等等；
- /scene/audio  音频播放节点类型，包括 AudioStreamPlayer；
- /scene/resource 资源节点类型，包括 Animation、AudioStreamPlaybackSample 等等；

和 UnrealEngine 这样的大型引擎不同，Godot 引擎没有将二维图形作为一个独立的模块包装，而是在更底层
架构了一个服务系统，以不同的服务器为音频、图形、物理及空间位置相结合的音频等提供相应的渲染服务。最后，
音频合成数据将送往系统的音频驱动器，视频则交由 OpenGL 或 Vulkan 接口进行渲染。

- VisualServer (RenderingServer) 可视渲染服务；
- Physics2DServer 二维物理引擎服务；
- PhysicsServer 三维物理引擎服务；
- SpatialSound2DServer 二维空间的音频服务；
- SpatialSoundServer 三维空间的音频服务；
- AudioServer 所有音频服务的最终于合成器；

节点类型本身不包含绘图逻辑，只是存储数据、功能逻辑以及用户交实现等等。因为节点类型众多，从音频到图形，
从网络到 AI 算法相关都有，也就不可能直接在节点类型中编写绘图等具体行为的实现代码，这些复杂的细节将
交由各种服务器类型实现。

2D 场景中，需要一个画布来绘制所有的视觉元素。而在 3D 中，所有可见对象都需要一个 scenario，它代表
可视的三维世界，通过 Spatial **get_world()** 方法访问。所有视觉元素都会绘制到 Viewport 上，
可以将其附加到场景树上，也可以使用渲染引擎 **viewport_create()** 方法实例化一个 Viewport 对象。
使用自定义场景或者画布时，通过 **viewport_set_scenario()**、**viewport_attach_canvas()** 
方法将它们附加到视口中，**scenario_create()** 创建场景。

所有三维对象都由相关资源和实例组成，可以是网格、粒子系统、灯光或任何其他 3D 对象。所以，VisualServer 
实质上就是实时的游戏渲染引擎，最新版本 Godot 4.x 中，名字也改为了 **RenderingServer**。为了渲染 
3D 资源，必须调用渲染引擎方法 **instance_set_base()** 将资源附加到渲染引擎实例上，还必须附加场景。


```py
    # Create a visual instance (for 3D).
    var instance = VisualServer.instance_create()
    # Set the scenario from the world, this ensures it
    # appears with the same objects as the scene.
    var scenario = get_world().scenario
    VisualServer.instance_set_scenario(instance, scenario)
    # Add a mesh to it.
    # Remember, keep the reference.
    mesh = load("res://mymesh.obj")
    VisualServer.instance_set_base(instance, mesh)
    # Move the mesh around.
    var xform = Transform(Basis(), Vector3(20, 100, 0))
    VisualServer.instance_set_transform(instance, xform)
```

引擎内部，所有资源都有一个 Resource ID (RID)，是服务器内部为了管理资源内存分配实现的句柄。服务器
内部几乎每个功能都需要 RID 来访问实际资源。大多数 Godot 节点和资源类型都包含来自服务器内部的 RID，
它们可以通过不同的函数获得。事实上，继承 Resource 的任何类型都可以转型为 RID。但并非所有资源都包含
RID，这种情况下，转型得到的结果为空。

- CanvasItem.get_canvas_item()
- CanvasLayer.get_canvas()
- Viewport.get_viewport_rid()


官方提供了一个 Control Gallery 示范工程，用于演示各种控件、布局容器的使用，2D 控件支持主题设置，
定制控件外观非常方便。2D 对象使用 Anchors 模型进行图形的比例、多分辨率处理：

![Size and Anchors](https://docs.godotengine.org/en/3.5/_images/anchors.png)

Godot IDE 中的每个场景就是一个 Node 对象，每个节点可以附加脚，以实现程序化操控。每个游戏结构和
Godot IDE 是一样的，都是一个场景树，每个程序中可以有多个场景，但是当前场景树中加载的活动场景只有
`root` 节点加载的这个 SceneTree，这个根节点是一个 Viewport，并且始终是加载的节点，不可以卸下。

![Scene tree](https://docs.godotengine.org/en/3.5/_images/activescene.png)

在运行之前，可以设置工程，指定一个主场景：

    Project -> Project Settings -> Application -> Run -> Main Scene

场景中 Viewports 就相当于一个屏幕，游戏世界的内容会投射到这里形成图像。场景树顶点就是一个 Viewport，
在 Godot IDE 运行调试时，点开 Scene 面板中的 Remote 栏目即可以查看运行中的顶层节点，应用运行时，
它总是处于加载状态，而且不可以手动清除。

在 3D 场景中，用一个 Viewport 节点装载 2D 节点，然后将 Viewport 的纹理图像作为 3D 场景对象的
材质贴图使用，这是一种常用的 3D 表现 2D 内容的手段。注意，Viewport 的尺寸要足够容纳 2D 内容，如果
2D 节点位置超出 Viewport 的尺寸，则内容会被裁剪掉。另外，如果内容出现上下颠倒，可以设置 Reander
Target - V Flip 进行一次竖直方向的反转即可以解决。

Viewport 可以设置背景透明，赋值给 SpatialMaterial 材质的 Albedo 作为表面反射色，需要启用材质
的透明功能，Flags -> Transparent，否则带 Alpha 通道的贴图会出现黑色块。设置 

Viewport 可以装入 ViewportContainer 这个特殊容器，且只包含一个 Viewport 子节点，用来显示图像，
方便在编辑器中观察图像输出效果，并且可以用来显示多个视图图像输出。


在计算机模拟的世界中，需要虚构一台用于成像的相机，目的是模拟人的眼眼所看到的世界。视界中的光线入射
到视网膜形成图像，在模拟世界中的成像用 Viewport 这个概念表示，光线从远处透过视口，到达相机的位置，
就是一个坐标点，而光线与视口平面相交的点就对应一个像素。通过调整相机的参数，例如改变视域 FOV 就可以
改变成像结果。而视口又可以再进行几何变换，以控制图像的渲染。

![From "Ray tracing" on Wikipedia](https://jamie-wong.com/images/16-07-11/raytrace.png)

材质设置可以使用 **SpatialMaterial**，适当调整贴图 UV1 坐标绽放、偏移，使用纹理适合于模型表面。
Godot 支持每个材质使用两个 UV 通道，次级的 UV2 通常用于环境光遮挡或发射（烘焙光）。设置 Triplanar
启用 Triplanar Mapping，在使用重复纹理时非常有用。

在 2D 场景中使用 3D 场景也是类似的思路，只过不反过来，将 Viewport 中的纹理图像设置到 2D 节点的
纹理属性上，如 Sprite 或 TextureRect 等节点都可以指定 ViewportTexture 以使用 3D 场景产生的
纹理图像。注意，要得到 3D 场景的图像，必需设置 Camera，因为需要确实世界空间的投影关系才能得到相应
的平面图像，这一点和 2D 有些差别。为 3D 节点材质指定纹理贴图时，如漫反射纹理 Albedo Texture，
需要开启 resource_local_to_scene 选项，对应材质面板的 Resource -> Local To Scene 选项。

可以参考官方示范项目，Dynamic Split Screen Demo 演示了如何使用 Viewports 在同一个显示器中
显示两个玩家的独立摄像机视口，使用了着色器程序，有一定的复杂度。


当一个节点连接到 Root Viewport，它就成为场景树中的一个部分，最后节点被移除，过程会触发系列回调方法：

```py
_enter_tree() 
_ready() 
_process(delta) 
_exit_tree()
```

节点树所有节点会按位置先后、由表层到内层依次执行 enter_tree 方法，而 ready 和 exit_tree 方法，
则不同，会先由内层到外层的顺序执行，父级节点需要等待内层节点工作完成才能执行 ready 等动作。
节点从非活跃状态转变为活跃状态，此时才会处理所有程序逻辑，包括用户输入、信号、消息处理，播放声音等。

节点提供了一个 request_ready() 方法用于请求再次执行 `_ready()` 回调，由于场景树中是后序遍历来
执行这个回调的，当需要在顶级节点执行完后再紧接进行其它任务，就可以使用利用 ready 信号和 yield 方法，
通过 yield(root, "ready")，可以等待顶级节点完成后再执行 yield 后续的代码。


完成初始化后就会进入循环处理，Godot 每帧所花销的计算时间会通过 delta 值传递到回调函数中。当计算
量大时，delta 值可能会增加，这意味着 FPS 会下降。但是，physics process 回调中接收到的 delta
值是一个恒定值，因为物理引擎需要一个精确的时间以进行模拟世界中的物理计算。

通常计算属性值需要与 delta 相乘，使用其与时间关联，而不是依赖 FPS 的变化。

使用 load、preload 方法加载场景文件得到 **PackedScene**，传递给 change_scene_to() 方法就
可以切换场景，原场景内容就会卸载掉。使用 change_scene() 方法切换场景直接使用 res:// 指定场景文件。

```py
# Methods
Error change_scene(path: String)

Error change_scene_to(packed_scene: PackedScene)

# Properties
Viewport root 
         get_root() getter

    Node current_scene
         set_current_scene(value) setter
         get_current_scene() getter
```

场景可以使用 change 方法进行切换，这会触发原场景所有节点卸载动作，也可以将场景作为一个节点实例，
再附加到当前活动的场景树中，这不会触发节点卸载行为。以下代码片段演示了节点与节点树连接的事件流程，
以及通过 load() 方法加载场景，并作为节点加载它：

```py
extends CanvasItem

onready var list = $"/root/Node2D/ItemList"

func _enter_tree():
    print(self.name, " _enter_tree")
    if list != null:
        list.add_item(self.name + " _enter_tree")

func _ready():
    print(self.name, " _ready")
    list.add_item(self.name + " _ready")

func _exit_tree():
    print(self.name, " _exit_tree")
    list.add_item(self.name + " _exit_tree")

func _on_Button_pressed():
    print(self.name, " pressed")
    list.add_item(self.name + " pressed")
    
    scene_change()
    #self.queue_free()

func scene_change():
    # change sence
    var cover = load("res://L1 Scene Tree/cover.tscn")
    #get_tree().change_scene_to(cover)
    #get_tree().change_scene("res://L1 Scene Tree/cover.tscn")
    
    # sence as node
    var acover: Node2D = cover.instance()
    print("button: ",self)
    var child = acover.get_child(0) as Control
    #acover.position = get_local_mouse_position() 
    acover.position = get_global_mouse_position()  - child.rect_size / 2
    get_node("/root").add_child(acover)
    list.add_item("Load a scene as a node")
    
    var tween:SceneTreeTween = create_tween().set_trans(Tween.TRANS_ELASTIC)
    tween.tween_property(acover, "modulate", Color.red, 2)
    tween.tween_callback(acover, "queue_free")
```

所有 **Control** 子类者都具有 mouse_filter 属性，将其设置为 MOUSE_FILTER_STOP 就可以阻挡
鼠标事件穿透到后面的对象上，用来避免在某些情形下不会触发相应的事件。配合 **SceneTreeTween** 可以
创建转场动画效果。


在节点的脚本中，使用 get_tree() 方法获取场景树引用，要获取其它节点引用则使用 get_node() 方法。
这个方法可以简写为 $，如 $"/root"，又如 $SomeNode 等价于 get_node("SomeNode")。还有一个
更方便的方法创建节点引用，只需要在 Scene 节点列表中拖动节点到脚本中即可自动生成引用，按 Ctrl 拖放
时还可以生成 onready 引用：

```py
SceneTree get_tree() const
Node get_node(path: NodePath) const
```

参数中的 **NodePath** 是一个表示节点路径的字符串，根节点 /root 始终是同一个顶级的 Viewport。
可以使用点或两点表示当前节点位置和父级位置，除了使用 / 开头表示绝对路径，其它路径都相对当前节点：

```py
get_node(".")
get_node("..")
get_node("Backpack/Dagger")
get_node("../Swamp/Alligator")
get_node("/root/MyGame")
```

虽然当前活动场景树只有一个，但是可以使用 Godot 的自动加载功能，工程配置 AutoLoad 栏目中设置，
可以实现将其它场景、或者脚本加载到全局空间运行，例如背景音乐需要避免转场中断，可以在自动加载场景中
播放 BGM 即可以解决。


可以激活 Scene Unique Nodes 模式，在节点右键菜单中，这样就在原节点名前缀 % 号作为唯一名称来访问它。
使用拖动的方式，可以很方便地将节点从场景树中拖放到脚本中，会自动生成引用，按下 Ctrl 生成引用类似如下：

    onready var label = $"%Label"

Godot 工程中的脚本文件或者场景文件都是一种资源类型 Resource，使用 load 或 preload 方法加载，
根据不同的文件返回的各种子类型，就场景资源和脚本而言，它们分别是 PackedScene 和 GDScript 类型。
并且，资源类型不同，实例化方法也不同。

对于场景，使用 instance() 方法实例化，返回的类型就是 Node，打印时会将场景根节点的名称和父类型信息，
如 RootNode:[Node2D:724501] 这样的格式。而脚本资源的实例化就是使用脚本中通用的 new() 方法，返回
的类型就是 extends 继承的类型，因为不像场景那样有节点树，所以打印脚本类型信息中只显示了父类信息。
如果指定了 class_name，这个脚本的类型就是命名的类型，会在类型列表中显示。

基类方法 Object get_class() 用来获取对象的类型，这个方法不考虑脚本中通过 class_name 定义的类型，
而是获取引擎 C++ 内部定义的类型，类似地，is_class() 方法判断的也是内部类型。内部类类型信息记录在
**ClassDB** 这个信息类中，通过 **get_class_list()** 方法可以查询引擎现有的类型列表。

有趣的是 Godot 基于节点化的编程思维中，节点只是一种数据结构，而将脚本绑定到节点上运行，就使得节点
拥有了交互的能力。脚本附加到节点后，此时 **self** 关键字既引用了类实例，又引用场景树中的节点。做类型
判断时，如 is 关键字，判断的是引擎 C++ 内部实现的类型，或者脚本定义类型。尽管场景也可以继承其它场景，
但是这仅仅是复用节点树结构的一种方法，并不是编程语言的类型系统的继承。

GDScript 脚本使用单继承，每一个脚本文件就是一个类型定义，当然可以定义内部类类。这种结合了节点的 
Object-Oriented Programming (OOP) 编程语言真的很特别，省略了复杂 OOP 规则，没有了 C++ 中的
Private、Protected、Public 访问控制机制，语法结构使用 Python 风格，脚本中定义的变量就是类成员，
具体访问规则由开发者自行把握，通过 setget 可以控制成员的读写逻辑。使用脚本能快速迭代开发产品，只在
遇到性能瓶颈时，才考虑将脚本迁移为 C/C++ 等高效的语言实现：

```py
tool

# BasicScene defined in L0 Basic Guide/entry.gd
extends BasicScene

# (optional) class definition with a custom icon
class_name SceneL8, "res://icon.png"

const tscn = preload("res://L0 Basic Guide/entry.tscn") # class PackedScene
const gd   = preload("res://L0 Basic Guide/entry.gd")   # class GDScript

func _ready():
    
    print("basic scene ", tscn, tscn.instance())
    print("basic script ", gd, gd.new())

    var scene = get_tree().current_scene
    print(self, " current_scene ", scene, " is instacne of gd? ", self is gd)

    print("note ", Something.new().note)
    print("NOTE ", Something.NOTE)
    print("enum ", Something.UNIT_ALLY, Something.Named.ANOTHER_THING)

# Inner class

class Something:
    # Member variables
    var note = "This is InnerClass."

    # Constants
    const NOTE = "This is a constant."

    # Enums
    enum { UNIT_NEUTRAL, UNIT_ENEMY, UNIT_ALLY}
    enum Named {THING_1, THING_2, ANOTHER_THING = -1}
```



## 🟡 Project Settings 项目配置
- [Multiple resolutions](https://docs.godotengine.org/en/3.5/tutorials/rendering/multiple_resolutions.html)
- [Setting up the project](https://docs.godotengine.org/en/3.5/getting_started/first_2d_game/01.project_setup.html)

Godot 项目设置中 display/window/stretch/mode 拉伸模式会影响画面的呈现：

如果设置 Stretch Mode = Viewport 意味着将根视口的大小精确设置为“项目设置 Display 配置中指定
的基本大小。调整窗口大小时，会缩放此视口以适合屏幕，除非设置了保留宽高比为 Stretch Aspect = keep。
使用像素精度游戏时，或者为了渲染到较低的分辨率以提高性能，此模式很有用。设置 2D 伸展模式，则可以保持
图像在不同显示屏幕下布局缩放的一致性。

![Stretch Mode](https://docs.godotengine.org/en/3.5/_images/stretch.png)


在高分屏设备中，默认情况下，操作系统会认为 Godot 项目是 DPI 无关的。因为操作系统的 DPI 回退缩放
比应用程序内做缩放要快很多，即便使用 viewport 拉伸模式，所以这样做可以提高在低端系统上的性能。

不过操作系统的 DPI 回退缩放功能在全屏模式下并不好用。如果你想在 hiDPI 显示器下得到清晰的画面，又
或者想要支持全屏，那么推荐启用项目设置中的 Display > Window > Dpi > Allow Hidpi 以获得高清
画面。否则，可能在高分屏幕上看到像素化的画面，这是因为像素都按 DPI 比例缩放了。

Godot 4.x 中需要启用 Advanced Settings 才可以设置 hiDPI 选项。

注意，Allow Hidpi 选项仅在 Windows 和 macOS 上有效，其它平台会忽略这个选项。

Godot IDE 本身是打开这个选项的，与 DPI 相关的，可以在编辑器中设置缩放比例，高分屏默认为 200%。
在编辑器中运行项目时，只有在项目设置里启用 Allow Hidpi 才会让项目与 DPI 相关。

Godot 尚未支持手动设置 2D 缩放比例，所以无法在非游戏应用中支持 hiDPI。因此，推荐为非游戏应用禁用
Allow Hidpi 选项，操作系统会回退到低 DPI。

高分屏系统中，还可能出现调试游戏时，在没有启用 hiDPI 时，窗口位置超出右下角的情况。这种情况可以通过
修改编辑器配置 run/window_placement 改变窗口位置，默认是居中，是启用高分屏支持就没有问题。


虽然当前活动场景树只有一个，但是可以使用 Godot 的自动加载功能，工程配置 AutoLoad 栏目中设置，
可以实现将其它场景、或者脚本加载到全局空间运行，例如背景音乐需要避免转场中断，可以在自动加载场景中
播放 BGM 即可以解决。

Godot 全局空间 @GDScript 和 @GlobalScope 包含所有脚本中可以直接使用的函数，用户要向全局空间
添加对象，可以使用工程设置自动加载，Singletons (AutoLoad)，自动加载得到位于全局空间的单态对象。

例如，将以下脚本保存到 Global.gd，并设置工程的 AutoLoad 加载它，即可以实现自动剧中窗口。运行程序
时，引擎将加载并附着 GlobalNS 到场景树上，初始化方法会被调用：

```py
extends Node

class_name GlobalNS

func _init():
    print("Global.gd _init")
    # Center window on screen
    var screen_size = OS.get_screen_size(OS.get_current_screen())
    var window_size = OS.get_window_size()
    var centered_pos = (screen_size - window_size) / 2
    OS.set_window_position(centered_pos)
```

VSync 垂直同步信号，又称场同步，显示器完整显示一个画面时产生的一个同步信号，可用于和 GPU 协作用途。
在旧式的 Cathode Ray Tube (CRT) 阴极射线显像管式显示中，一幅画面的显示需要电子枪从左到右，从上
到下，完整地扫描一遍显示屏才算完成，电子枪由高压电驱动发射电子束击打屏幕上的荧光点显示相应的图像。

游戏中打开垂直同步可以使得画面平滑、稳定，因为游戏画面的渲染需要等待显示器的同步信号。而关闭垂直同步，
则可以明显提高帧数，在高端设备上可以获得更快的速度，但是这可能带来图像不稳定的问题。一般图形引擎会
使用双缓冲区技术 Double buffering，即一个缓冲区连接到显示作为当前显示图像的数据源，另一个缓冲区
则作为下一帧图像的渲染输出缓冲区。在关闭 Vsync 的情况下，高端设备可能渲染好了画面，但显示器还示来得
及调用，又开发下一帧图像的渲染了。而下一帧图面又不一定完整，这就导致画面有断裂的现象。

FPS 低于游戏设计时，可能会有输入延迟和卡顿。在需要快速反应和复杂输入的游戏中，输入延迟尤其令人恼火。

为了提高设备性能厂家也在硬件上不断改良 VSync 技术：

- Adaptive VSync 由 Nvidia 发起，会根据监视到的 FPS 帧率来决定是否启用 VSync。
- Fast Sync 由 Nvidia 发起的更高级的自适应垂直同步形式，在必要时启用 VSync，并添加自动三重缓冲。
- Enhanced Sync 由 AMD 发起，会在帧率低于显示刷新率时禁用 VSync。

另外，还有 Nvidia 的 G-Sync 和 AMD 的 FreeSync，这两种 GPU 技术都可以将刷新率和数据与 GPU 
的帧速率同步。这些公司希望解决 VSync 的问题，特别是图像精度和均匀性，以及撕裂。但它们要求  GTX 1050
以及 AMD Radeon RX 200 级别以上的显卡。




## 🟡 MT Downloader
- [Requests: HTTP for Humans](https://requests.readthedocs.io/en/latest/)

一个 Python 实现的多线程下载器，将链接地址复制到粘贴板上，执行它就会自动下载文件并保存到当前目录。
需要安装 clipboard 模块，使用 pip install clipboard 命令安装。

尽管 Python 有一个全局锁，不能并行多线程运行，但是在多线程下的程序也有各种问题需要注意的，比如，
print 函数打印信息到控制台上，尽管这个函数本身是线程安全的，但是可能因为线程切换导致缓冲区被破坏
而输出一些奇怪的字符，包括 NULL 字符，应该在打印操作后执行 flush 清空缓冲区，以免输出内容被破坏。

```py,ignore
import os
import clipboard
import requests
import threading
import concurrent.futures
import sys
import re
import pathlib

thread_local = threading.local()

def pagelist(items):
    for line in items:
        if not line:
            continue
        p = line.split()[-1].replace("P","")
        page = int(int(p) / 3) + 1
        url = line.split()[0]
        print(url)
        for no in range(page):
            print(url.replace(".html", "_%s.html" % no))

def checkfile(items):
    for item in items:
        file = item.split("/")[-1]
        if not item or os.path.exists(file):
            continue
        print(item)

def checkalbum(items):
    albumsum = 0
    error = 0
    for item in items:
        if not item:
            continue
        p = int(item.split()[-1].replace("P", ""))
        id = item.split('/')[-1].split('.')[0]
        match = pathlib.Path().cwd().glob("%s*" % id)
        count = len(sorted(match))
        state = "===Done!" if p == count else "---Miss!"
        print(state, item, " <== ", count)
        albumsum += p
        error += p - count
    print("Album: %d/%d,  error: %d " %((albumsum-error), albumsum, error))

def default_filter(content, url):
    root = "/".join(url.split("/")[:3])
    lines = content.decode().split('\r\n')
    contents = ""
    for line in lines:
        if len(contents)>0 and re.search(r"</?div", line) :
            break
        elif line.startswith('<p align="center">') or line.startswith('<div class="content"><p') or contents:
            contents += line
    match = re.findall(r'https?://[^" ]+', contents.replace('src="/', 'src="%s/' % root))
    for m in match:
        print("%s#/%s" %(m, url.split('/')[-1].replace("html","jpg")))
    sys.stdout.flush()
    return None #s.encode()


def argument(name):
    if "filter" in sys.argv:
        return ""
    for a in sys.argv[1:]:
        if a.startswith("%s=" % name):
            return a.replace("%s=" % name, "")
    return None

def content_filter(content, url):
    filter = argument("filter")
    if None == filter:
        return content
    elif "" == filter:
        return default_filter(content, url)
    else:
        lines = content.decode().split('\n')
        for line in lines:
            if line.find(f"{filter}") > -1:
                print(line) 
        return None

def get_session():
    if not hasattr(thread_local, "session"):
        thread_local.session = requests.Session()
    return thread_local.session


def download(url):
    session = get_session()
    headers = {
        'Accept-Encoding': 'gzip, deflate',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36'
    }
    try:
        res = session.get(url, headers=headers)
        if not res.ok or res.text.find("页面出错")>-1:
            return print(url, " status", res.status_code, res.reason)
        save(url.split('/')[-1], res.content, url)
    except Exception as ex:
        print("%s %s" %(url, type(ex))) # class.__class__

def save(name, content, url):
    content = content_filter(content, url)
    if type(content) is not bytes:
        return None
    fd = os.open(name, os.O_BINARY|os.O_RDWR|os.O_CREAT)
    ret = os.write(fd, content)
    os.close(fd)
    print(['# save to: ', name, ret, content[:9]])
    # fd = open(name, "wb")
    # ret = fd.write(content)
    # fd.flush()
    # fd.close()

def download_all(urls):
    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        executor.map(download, urls)


if __name__ == "__main__":
    txt = clipboard.paste()
    items = txt.split('\r\n')
    if "checkfile" in sys.argv:
        checkfile(items)
    elif "pagelist" in sys.argv:
        pagelist(items)
    elif "checkalbum" in sys.argv:
        checkalbum(items)
    else:
        download_all(items)
```

## 🟡 sango2 三国群英传2兵种与阵法相克规则设计

三国群英传2兵种相克表：

- 以朴刀、武斗、藤甲为代表的短兵器;
- 以长枪、大刀、铁锤为代表的长兵器;
- 以弓箭、弩兵、飞刀为代表的远程兵种。

黄巾兵、朴刀兵作为最常见的两个兵种，它们克制的兵种相对少，前者克制蛮族、女兵、飞刀，后者在这些之上还克制弓箭、武斗、黄巾。

相克顺口溜：

    远克长，长克短，短兵循环又克远。
    大刀破短很能干，飞刀爆的链锤惨。
    弩兵全能很能干，飞弓藤甲干就完。
    武斗不惧箭飞锤，黄巾只克女飞蛮。
    藤甲不畏箭飞朴，朴蛮黄女倒霉蛋。

长克短、短克远，远克长，具体如下，最倒霉的三大兵种是蛮族、黄巾、女兵：

        | 朴刀 长枪 大刀 弓箭 链锤 飞刀 武斗 蛮族 铁锤 藤甲 黄巾 弩兵 女兵 | 总和
    ----|--------------------------------------------------------|----
    朴刀 |   0 -42 -58  44  -47  47  21  14  -51 -31  22  -8   10 | -79
    长枪 |  42   0 -12 -58  -23 -53  60  49   27  66  44  -52  39 |  129
    大刀 |  58  12   0 -66   22 -64  63  53  -14  68  68  -18 -43 |  139
    弓箭 | -44  58  66   0   54   8 -56 -36   47 -54  28   32 -29 |   74
    链锤 |  47  23 -22 -54    0 -48 -26  36   13  65  37  -45  32 |   58
    飞刀 | -47  53  64 -8    48   0 -55 -39   39 -67 -24   56 -32 | -12
    武斗 | -21 -60 -63  56   26  55   0   8   42  16  33  -18   6 |   80
    蛮族 | -14 -49 -53  36  -36  39 -8    0  -41  17 -62  -10  30 | -151
    铁锤 |  51 -27  14 -47  -13 -39 -42  41    0  64  41  -28  36 |   51
    藤甲 |  31 -66 -68  54  -65  67 -16 -17  -64   0  21    8  26 | -89 
    黄巾 | -22 -44 -68 -28  -37  24 -33  62  -41 -21   0  -24  56 | -176
    弩兵 |   8  52  18 -32   45 -56  18  10   28 -8   24    0  12 |  119
    女兵 | -10 -39  43  29  -32  32 -6  -30  -36 -26 -56  -12   0 | -143


阵型相克表：

- 以方形、园形、鱼丽形为代表的平头阵，强度依次减弱，并且鱼丽有倒克方形之势；
- 以钩形、雁形、为代表的凹头阵，强度依次减弱；
- 以冲锋形、锥形、箭矢形为代表的尖头阵，强度依次减弱；

玄襄形像十字星，既有平头属性，又有凹头属性，克制尖头阵，冲锋形，还有箭矢形，同时又被圆形、方形克制。

《左传·桓公五年》 晋 杜预：“《司马法》：‘车战二十五乘为偏。’以车居前，以伍次之，承偏之隙而弥缝阙漏也。五人为伍。此盖鱼丽陈法。”

平克凹、凹克尖、尖克平。负值表示在表格竖向的阵法被横向所示的阵法克制，负数绝对值越大克制越强：

          方形 圆形 锥形 雁形 玄襄 鱼丽 钩形 冲锋 箭矢
    ----|--------------------------------------
    方形 |   0
    圆形 | -7     0
    锥形 |  18   12   0
    雁形 | -19  -22  19   0
    玄襄 | -13  -21  11  5    0
    鱼丽 |  6   -6  -25  11  18   0
    钩形 | -23  -12  25 -3   6  -23   0
    冲锋 |  23   24  7  -15 -24  10 -14   0
    箭矢 |  15   18 -6  -20 -19  17 -15  12   0
    ----|--------------------------------------
    总和 |  0    0   1   0   -1   0   1   1   -2


## 🟡 GDNative/GDExtension 扩展开发
- [Godot Engine Download](https://downloads.tuxfamily.org/godotengine/)
- [Godot API Headers](https://github.com/godotengine/godot-headers)
- [godot-cpp](https://github.com/godotengine/godot-cpp)
- [GDNative demos](https://github.com/godotengine/gdnative-demos) 
- [GDNative C++](https://docs.godotengine.org/en/latest/tutorials/scripting/gdnative/index.html)
- [Custom modules in C++](https://docs.godotengine.org/en/stable/development/cpp/custom_modules_in_cpp.html)
- [Godot Compiling](https://docs.godotengine.org/en/stable/development/compiling/index.html)
- [Godot Engine – Multi-platform 2D and 3D game engine](https://github.com/godotengine/godot/releases)
- [Godot Rust bindings - GDNative and GDExtension APIs](https://godot-rust.github.io/)
- [Platform Support](https://doc.rust-lang.org/nightly/rustc/platform-support.html)
- [The godot-rust Book](https://godot-rust.github.io/book/gdextension/)
- [Introducing GDNative's successor, GDExtension](https://godotengine.org/article/introducing-gd-extensions)

避免重新编译 Godot 源代码进行功能扩展的方法有 GDNative 和 GDExtension，分别在 Godot 3.x 和 4.x 中使用。

通常，在产品需要快速迭代前期开发阶段，GDScript 主要的开发语言工具，只有在需要处理性能瓶颈问题时，
或者有潜在性能瓶颈的功能需要处理，才会考虑使用 C/C++ 或者 Rust 等语言进行静态编译，以获得高性能
模块，这当然是以软件结构复杂性为代价的。

Godot 本身是 C++ 开发的，使用 C++ 可以实现各种模块以扩展 Godot 功能。通过现有的 GDNative C Binding 
模块，可以使用 C/C++ 来开发 Godot 应用。源代码开发需要使用 Python，编译工具使用 SCons，支持 C++14 规范，
可以使用 `clang`, `gcc` 等兼容的编译器。

GDNative 是 Godot 用于和原生共享库交互的扩展模块，和直接编写 Godot C++ 模块不同，通过 Godot
已经集成的 GDNative 扩展模块进行扩展开发，只需要提供动态连接库即可以调用。所以基于 GDNative 开发
Godot 扩展不需要重新编译源代码，开发插件更方便。

而为 Godot 直接编写 C++ 扩展模块则不同，需要重新编译 Godot 源代码。

需要注意的是，GDNative 要求严格的版本兼容，例如 Godot 3.4.x GDNative 就不兼容 3.3.x 或 3.5.x 版本。
所以在项目创建时，需要使用正确的 Godot API Headers 版本，GDNative demos 演示项目最好也选择兼容版本。

使用 git 克隆仓库时可以指定分支版本，注意 godot-cpp 依赖 godot-headers 仓库，并作为子模块，在初始化
项目时，需要递归获取子模块：

```sh
mkdir gdnative_cpp_example
cd gdnative_cpp_example
git init
git submodule add -b 3.x https://github.com/godotengine/godot-cpp
cd godot-cpp
git submodule update --init --recursive
# just download the repositories or clone them into your project folder,
# git clone --recursive -b 3.x https://github.com/godotengine/godot-cpp
```

下载 GDNative C Bindings 后，需要为 Python 环境安装 SCons 模块，然后再编译绑定模块，再
编译基于 GDNative 的共享库供 Godot 工程使用：

```sh
pip install SCons
# scons platform=PLATFORM
# Building the C++ bindings
cd godot-cpp
scons platform=windows generate_bindings=yes -j4
# Building the GDNative library project
cd ..
scons platform=windows target=release -j4
```

SCons 支持多平台编译，PLATFORM 可以指定 `windows`, `linux`, `osx`，编译 godot-cpp 生成文件
保存在 bin 和 gen 目录下，共享库可以供 GDNative demos 示范项目使用，其配置脚本 SConstruct 文件
已经设置好相关目录路径。先编译 godot-cpp，再编译项目使用的共享，库文件生成后保存于 `project/gdnative`。

```py
#!python
import os

opts = Variables([], ARGUMENTS)

# Define the relative path to the Godot headers.
godot_headers_path = "godot-cpp/godot-headers"
godot_bindings_path = "godot-cpp"

# Gets the standard flags CC, CCX, etc.
env = DefaultEnvironment()

# Define our options. Use future-proofed names for platforms.
platform_array = ["", "windows", "linuxbsd", "macos", "x11", "linux", "osx"]
opts.Add(EnumVariable("target", "Compilation target", "debug", ["d", "debug", "r", "release"]))
opts.Add(EnumVariable("platform", "Compilation platform", "", platform_array))
opts.Add(EnumVariable("p", "Alias for 'platform'", "", platform_array))
opts.Add(BoolVariable("use_llvm", "Use the LLVM / Clang compiler", "no"))
opts.Add(PathVariable("target_path", "The path where the lib is installed.", "project/gdnative/"))
opts.Add(PathVariable("target_name", "The library name.", "libdodgethecreeps", PathVariable.PathAccept))


# ellipsis ...

env.Append(
    CPPPATH=[
        godot_headers_path,
        godot_bindings_path + "/include",
        godot_bindings_path + "/include/gen/",
        godot_bindings_path + "/include/core/",
    ]
)

env.Append(
    LIBS=[
        env.File(os.path.join("godot-cpp/bin", "libgodot-cpp.%s.%s.64%s" % (platform, env["target"], env["LIBSUFFIX"])))
    ]
)

env.Append(LIBPATH=[godot_bindings_path + "/bin/"])
# ellipsis ...
```

ClassDB 是扩展类型数据库管理类型，提供了各种绑定方法，用于向 GDScript 提供方法绑定。以下代码片段
摘自 Godot-CPP 中的示范工程：

```cpp,ignore
    // Methods.
    ClassDB::bind_method(D_METHOD("simple_func"), &Example::simple_func);
    ClassDB::bind_method(D_METHOD("simple_const_func"), &Example::simple_const_func);
    ClassDB::bind_method(D_METHOD("return_something"), &Example::return_something);
    ClassDB::bind_method(D_METHOD("return_something_const"), &Example::return_something_const);
    ClassDB::bind_method(D_METHOD("return_empty_ref"), &Example::return_empty_ref);
    ClassDB::bind_method(D_METHOD("return_extended_ref"), &Example::return_extended_ref);
    ClassDB::bind_method(D_METHOD("extended_ref_checks", "ref"), &Example::extended_ref_checks);

    ClassDB::bind_method(D_METHOD("test_array"), &Example::test_array);
    ClassDB::bind_method(D_METHOD("test_tarray_arg", "array"), &Example::test_tarray_arg);
    ClassDB::bind_method(D_METHOD("test_tarray"), &Example::test_tarray);
    ClassDB::bind_method(D_METHOD("test_dictionary"), &Example::test_dictionary);
    ClassDB::bind_method(D_METHOD("test_node_argument"), &Example::test_node_argument);

    ClassDB::bind_method(D_METHOD("def_args", "a", "b"), &Example::def_args, DEFVAL(100), DEFVAL(200));

    ClassDB::bind_static_method("Example", D_METHOD("test_static", "a", "b"), &Example::test_static);
    ClassDB::bind_static_method("Example", D_METHOD("test_static2"), &Example::test_static2);

    {
        MethodInfo mi;
        mi.arguments.push_back(PropertyInfo(Variant::STRING, "some_argument"));
        mi.name = "varargs_func";
        ClassDB::bind_vararg_method(METHOD_FLAGS_DEFAULT, "varargs_func", &Example::varargs_func, mi);
    }

    {
        MethodInfo mi;
        mi.arguments.push_back(PropertyInfo(Variant::STRING, "some_argument"));
        mi.name = "varargs_func_nv";
        ClassDB::bind_vararg_method(METHOD_FLAGS_DEFAULT, "varargs_func_nv", &Example::varargs_func_nv, mi);
    }

    {
        MethodInfo mi;
        mi.arguments.push_back(PropertyInfo(Variant::STRING, "some_argument"));
        mi.name = "varargs_func_void";
        ClassDB::bind_vararg_method(METHOD_FLAGS_DEFAULT, "varargs_func_void", &Example::varargs_func_void, mi);
    }

    // Properties.
    ADD_GROUP("Test group", "group_");
    ADD_SUBGROUP("Test subgroup", "group_subgroup_");

    ClassDB::bind_method(D_METHOD("get_custom_position"), &Example::get_custom_position);
    ClassDB::bind_method(D_METHOD("get_v4"), &Example::get_v4);
    ClassDB::bind_method(D_METHOD("set_custom_position", "position"), &Example::set_custom_position);
    ADD_PROPERTY(PropertyInfo(Variant::VECTOR2, "group_subgroup_custom_position"), "set_custom_position", "get_custom_position");

    // Signals.
    ADD_SIGNAL(MethodInfo("custom_signal", PropertyInfo(Variant::STRING, "name"), PropertyInfo(Variant::INT, "value")));
    ClassDB::bind_method(D_METHOD("emit_custom_signal", "name", "value"), &Example::emit_custom_signal);

    // Constants.
    BIND_ENUM_CONSTANT(FIRST);
    BIND_ENUM_CONSTANT(ANSWER_TO_EVERYTHING);

    BIND_CONSTANT(CONSTANT_WITHOUT_ENUM);
```

Godot 4.x 引入 GDExtension 作为 GDNative 的替代模块，或者说是 GDNative 应用层的重构版本，
扩展的目标还为了减轻给 Godot 引擎开发插件的难度。GDExtension 是 C++ API，提供方法注册动态库中的类。
注册后的类，就可以供 Godot 引擎使用，因为是平台编译的共享库，所以能更好地集成到引擎内。配合现有的
godot-cpp 库，可以非常方便地使用 C++ 开发静态编译的模块。

与 C++ 扩展中直接使用 Godot 引擎源代码的头文件不同，Rust 绑定需要使用它强大的宏编程能力，以生成
Godot 引擎的 API 绑定代码，Godot 命令行提供 dump-extension-api 选项导出当前版本的 GDNative
类型信息到 JSON 文件，Godot Rust 绑定模块会分析 JSON 文件并生成相应的绑定代码。

使用 Rust 编写好的扩展时，先为 Godot 工程准备好 GDExtension 配置文件 example.gdextension：

```sh
[configuration]

entry_symbol = "example_library_init"

[libraries]

macos.debug = "res://bin/libgdexample.macos.template_debug.framework"
macos.release = "res://bin/libgdexample.macos.template_release.framework"
windows.debug.x86_64 = "res://bin/libgdexample.windows.template_debug.x86_64.dll"
windows.release.x86_64 = "res://bin/libgdexample.windows.template_release.x86_64.dll"
...
```

然后在 godot 工程文件中添加 GDExtension 配置：

```sh
[native_extensions]

paths=["res://example.gdextension"]
```

配置文件中的入口需要对应 C++ 代码中的 GDE_EXPORT 导出函数：

```cpp
extern "C" {
// Initialization.
GDExtensionBool GDE_EXPORT example_library_init(const GDExtensionInterface *p_interface, GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization) {
    godot::GDExtensionBinding::InitObject init_obj(p_interface, p_library, r_initialization);

    init_obj.register_initializer(initialize_example_module);
    init_obj.register_terminator(uninitialize_example_module);
    init_obj.set_minimum_library_initialization_level(MODULE_INITIALIZATION_LEVEL_SCENE);

    return init_obj.init();
}
}
```


目前，使用 Rust 语言编写 GDExtension 扩展还不稳定，编译后的扩展库可能不可以正常使用：

    git clone --depth=1 git@github.com:godot-rust/book
    git clone --depth=1 git@github.com:godot-rust/gdnative
    git clone --depth=1 git@github.com:godot-rust/gdextension

编程思想 Rust vs. C++：前者只有能被证明是正确代码的才被允许，后者则是允许任何不能证明是错误的代码。

Rust 编译脚本中，需要根据具体情况添加 C++ 头文件的目录，因为 godot-rust 绑定依赖 godot-headers，
这些 C/C++ 头文件需要通过 Rust FFI 接口绑定，Rust 中常用的 API 绑定工具有以下这些：

- `bindgen` automatically generates Rust FFI bindings to C (and some C++) libraries.
- `cbindgen` creates C/C++11 headers for Rust libraries which expose a public C API.
- `cpp` rust-cpp - Embed C++ code directly in Rust.

其中，gdnative-sys 这个模块会包装 godot-headers，它会依赖一部分平台相关的头文件，可以直接修改
buider.rs 编译脚本，添加 clang_arg 指定编译器参数 -I 来指定头文件路径，但不推荐直接修改。

Godot 4.x 中的 GDExtension 代码结构有改变，并且目前还未发布稳定版本。并且 godot-ffi 模块会调用
godot4 可执行程序用于生成 API JSON 信息文件，也可以配置 `GODOT4_BIN` 环境变量指向可执行程序：

```sh
    # powershell
    [System.Environment]::SetEnvironmentVariable("GODOT4_BIN", "C:\games\Godot_v4.0-beta10_win64.exe")
```

交叉编译涉及问题很多，通常根据当前平台的架构来编译是容易通过的，可以使用 rustup 查询当前的平台构架
及工具链。即使在交叉编译时，bindgen 也需要访问平台标头以了解平台的类型定义么。gdnative syscrate
尝试根据平台检测头文件路径，也许可以通过 C_INCLUDE_PATH 环境变量提供自定义路径。

```sh
> rustup toolchain install stable
> rustup toolchain install stable-x86_64-pc-windows-gnu
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
stable-x86_64-pc-windows-gnu
> rustc --print target-list
...
x86_64-pc-windows-gnu
x86_64-pc-windows-gnullvm
x86_64-pc-windows-msvc
...
> cargo build --target=x86_64-pc-windows-msvc
```

```rust
let mut builder = bindgen::Builder::default()
    .header("godot_headers/gdnative_api_struct.gen.h")
    .allowlist_type("godot.*")
    .allowlist_function("godot.*")
    .allowlist_var("godot.*")
    .allowlist_type("GDNATIVE.*")
    .derive_default(true)
    .ignore_functions()
    .size_t_is_usize(true)
    .ctypes_prefix("libc")
    // .clang_arg("-IC:/mingw/include")
    .clang_arg("-IC:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt")
    .clang_arg("-IC:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.26.28801\\include")
    .clang_arg(format!("-I{}/godot_headers", manifest_dir));
```

错误的交叉编译配置，可以会导致类型不匹配等问题：

    error[E0308]: mismatched types - types differ in mutability

Clang 自身没有配备自己完整的工具链，它通常使用本地平台使用的标准的 C/C++ 库和头文件。Windows 平台上
，Visual C++ 和 Mingw 是两个比较常用的工具链，应该指定合适的 target 参数:

    clang --target=i686-pc-vs2013
    clang --target=i686-pc-mingw32
    clang --target=x86_64-pc-mingw32

Rust 中使用 `cpp` crate 定义的 `cpp!` 宏来嵌入 C++ 代码，它通过获取所有的内联 C++ 代码并将
其写入一个单独的 cpp 文件来实现这一点，该文件将被编译为 Rust crate 的最终目标代码。

当将 Rust 库绑定到 C/C++ 时，核心逻辑层和 FFI 层之间应该存在明显的分离。在做好的情况下，FFI 代码
应该在单独的 crate，因此设计 Rust API 不会受到 FFI 的太多影响，并且选择可变性修饰符变得更加容易。

Rust 编译生成的库文件类型有以下这些：

- **lib** — Generates a library kind preferred by the compiler, currently defaults to rlib.
- **rlib** — A Rust static library.
- **staticlib** — A native static library.
- **dylib** — A Rust dynamic library.
- **cdylib** — A native dynamic library.
- **bin** — A runnable executable program.
- **proc-macro** — Generates a format suitable for a procedural macro library that may be loaded by the compiler.

GDExtension 扩展入口函数原型定义在 gdextension\godot-codegen\input\gdnative_interface.h

```cpp
/* Define a C function prototype that implements the function below and expose it to dlopen() (or similar).
 * This is the entry point of the GDExtension library and will be called on initialization.
 * It can be used to set up different init levels, which are called during various stages of initialization/shutdown.
 * The function name must be a unique one specified in the .gdextension config file.
 */
typedef GDNativeBool (*GDNativeInitializationFunction)(const GDNativeInterface *p_interface, const GDNativeExtensionClassLibraryPtr p_library, GDNativeInitialization *r_initialization);
```

使用 #[gdextension] 过程宏定义入口函数，默认入口函数名为 `gdextension_rust_init`：

```rust
/// Defines the global entry point for the GDExtension library.
///
/// Typical usage:
/// ```
/// use godot::init::{gdextension, ExtensionLibrary};
///
/// // This is just a type tag without any functionality
/// struct MyExtension;
///
/// #[gdextension]
/// unsafe impl ExtensionLibrary for MyExtension {}
/// ```
///
/// # Safety
/// By using godot-rust, you opt-in to the library's safety requirements (to be described in detail).
/// The library cannot enforce any guarantees outside Rust code, which means users need to adhere to certain rules for a safe usage.
#[proc_macro_attribute]
pub fn gdextension(meta: TokenStream, input: TokenStream) -> TokenStream {
    translate_meta(meta, input, gdextension::transform)
}
```

参考 GDExtension 扩展配置文件内容如下，参考文件名 some.gdextension：

```sh
    [configuration]
    entry_symbol = "gdextension_rust_init"

    [libraries]
    linux.64 = "res://../../../target/debug/libsome.so"
    macos.64 = "res://../../../target/debug/libsome.dylib"
    windows.64 = "res://../../../target/debug/some.dll"
```

## 🟡 GDExtension 扩展机制
- [Introducing GDNative's successor, GDExtension](https://godotengine.org/article/introducing-gd-extensions/)
- [GDNative is here!](https://godotengine.org/article/dlscript-here/)
- [A look at the GDNative architecture](https://godotengine.org/article/look-gdnative-architecture/)
- [GLES2 and GDNative, progress report #7](https://godotengine.org/article/gles2-and-gdnative-progress-report-7/)
- [GLES2 and GDNative, progress report #6](https://godotengine.org/article/gles2-and-gdnative-progress-report-6/)
- [GLES2 and GDNative, progress report #5](https://godotengine.org/article/gles2-and-gdnative-progress-report-5/)
- [GLES2 and GDNative, progress report #4](https://godotengine.org/article/gles2-and-gdnative-progress-report-4/)
- [Waht is GDNative](https://docs.godotengine.org/en/stable/tutorials/scripting/gdnative/what_is_gdnative.html)
- [GDNative C Example](https://docs.godotengine.org/en/3.1/tutorials/plugins/gdnative/gdnative-c-example.html)
- [GDNative C++ Example](https://docs.godotengine.org/en/3.1/tutorials/plugins/gdnative/gdnative-cpp-example.html)
- [Function like Macros](https://gcc.gnu.org/onlinedocs/cpp/Function-like-Macros.html)
- [Common Engine Methods & Macros](https://docs.godotengine.org/en/stable/development/cpp/common_engine_methods_and_macros.html)
- [Compiling with Mono](https://docs.godotengine.org/en/latest/contributing/development/compiling/compiling_with_mono.html)
- [Compiling for Windows](https://docs.godotengine.org/en/latest/contributing/development/compiling/compiling_for_windows.html)
- [Best practices for engine contributors](https://docs.godotengine.org/en/latest/contributing/development/best_practices_for_engine_contributors.html)
- [Engine core and modules](https://docs.godotengine.org/en/latest/contributing/development/core_and_modules/index.html)
- [Custom modules in C++](https://docs.godotengine.org/en/latest/contributing/development/core_and_modules/custom_modules_in_cpp.html)
- godot-3.5.1-stable\modules\gdnative\gdnative.h
- godot\core\extension\gdextension_interface.h


Engine development - Best practices for engine contributors

#1: The problem always comes first
#2: To solve the problem, it has to exist in the first place
#3: The problem has to be complex or frequent
#4: The solution must be discussed with others
#5: To each problem, its own solution
#6: Cater to common use cases, leave the door open for the rare ones
#7: Prefer local solutions
#8: Don't use complex canned solutions for simple problems

![breaks down problem](https://docs.godotengine.org/en/latest/_images/best_practices6.png)

GDNative 是旧版本 Godot 扩展方案，使用原始 C API 比较繁杂，对移植很不友好。Godot 4 使用全新的
GDExtension，这个新的扩展机制 API 更轻量化！任何可以编译为动态库的语言中，都可以轻易地编写与
Godot 4 交互的胶水层。并且，基于 GDExtension 开发的扩展类型与 Godot 内置类型没有区别。

总的来说，有多种基本方法来扩展 Godot，前两种需要重新编译引擎，后面两种只需要编译扩展部分。而最后
一种可以说最方便，没有编译过程，可以编写 Godot 编辑器工具脚本。脚本用 `tool` 或 `@tool` 开头，
这样的脚本就会在编辑器运行，而不必等到游戏运行时。另外还可以编写编辑器插件，完善现有 Godot 功能：

- Godot source development
- C++ Modules (like /modules/gdnative, /modules/gdscript )
- GDNative Extension (Godot 3.x)
- GDExtension (Godot 4.x)
- GDScript (all versions, tool script, editor plugins)

可以说开发自定义 C++ 模块是最直观的，就像 Godot 开发者一样，在 modules 目录下给 Godot 添加各
种模块。这种方法需要重新编译 Godot 源代码，这是一个非常花时间的过程。如果还要支持 C# 语言，则还需要
配置 Mono SDK。

无论如何扩展 Godot，有一个类是始终离不开的：`ClassDB` 类型信息库。Godot 所有内置类型都注册在这里。

开发 GDExtension 扩展，系统环境要求：

01. a Godot 4.x executable,
02. a C++ compiler,
03. SCons as a build tool,
04. a copy of the godot-cpp repository

而使用 GDNaive 或 GDExtension 扩展模块进行功能扩展，则免去重新编译引擎源代码，使用动态链接库。
有三个地方可以获取到扩展 Godot 的头文件资源：

- [Godot Source](https://github.com/godotengine/godot)
- [GDExtension header and API](https://github.com/godotengine/godot-cpp)
- [GDNative Extensions API headers](https://github.com/godotengine/godot-headers)

引入 GDNative 的目的主要有两个，解决性能瓶颈与接入第三方代码：

- performance critical code.
- binding third party code to Godot.

Godot 本身使用 GDNative 实现各种功能，其中就有 NativeScript，源代码位于 modules/gdnative
目录下。

- godot-3.5.1-stable\modules\gdnative\gdnative.h
- godot-3.5.1-stable\modules\gdnative\nativescript\nativescript.h

所谓 NativeScript，就是将 C/C++ 编译得到的动态连接库按 GDNative 规则供 Godot 调用，但是又
像用 GDScript 脚本一样方便地使用各种节点进行开发。使用 `GDNativeLibrary` (.gdnlib) 资源加载
动态连接库，其它它就是一个配置文件，记录不同平台下使用的动态链接库文件。使用 `NativeScript` (.gdns)
资源告诉 Godot 动态链接库中的类型信息。

```py
extends Control

# load the Simple library
onready var data = preload("res://bin/simple.gdns").new()

func _on_Button_pressed():
    $Label.text = "Data = " + data.get_mock_data()
```

GDNativeLibrary 动态库配置资源文本文件内容参考：

```sh
    [general]

    singleton=false
    load_once=true
    symbol_prefix="godot_"
    reloadable=true

    [entry]

    OSX.64="res://bin/libsimple.dylib"
    OSX.32="res://bin/libsimple.dylib"
    Windows.64="res://bin/libsimple.dll"
    X11.64="res://bin/libsimple.so"

    [dependencies]

    OSX.64=[  ]
    OSX.32=[  ]
    Windows.64=[  ]
    X11.64=[  ]
```

动态库的入口函数及初始化、结束等函数名称定义在 gdnative.cpp 文件中：

```C++
    static const String init_symbol = "gdnative_init";
    static const String terminate_symbol = "gdnative_terminate";
    static const String default_symbol_prefix = "godot_";
```


开发 Godot 扩展的标配是官方提供的 godot-cpp，这是官方 C++ 扩展集成库。注意，godot-cpp 仓库
在不同分支上管理不同版本的扩展方案：

- **master** 分支对应 Godot 4.0 (GDExtension)
- **3.5** 这些指定版本号的分支对应 Godot 3.x (GDNative)

```sh
> git clone git@github.com:godotengine/godot-cpp
Cloning into 'godot-cpp'...
remote: Enumerating objects: 7557, done.
remote: Counting objects: 100% (1364/1364), done.
remote: Compressing objects: 100% (280/280), done.
remote: Total 7557 (delta 1165), reused 1143 (delta 1076), pack-reused 6193
Receiving objects: 100% (7557/7557), 7.25 MiB | 566.00 KiB/s, done.
Resolving deltas: 100% (4824/4824), done.
> git branch -a
* master
  remotes/origin/3.0
  remotes/origin/3.1
  remotes/origin/3.2
  remotes/origin/3.3
  remotes/origin/3.4
  remotes/origin/3.5
  remotes/origin/3.x
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/origin/nativescript-1.0
  remotes/origin/nativescript-1.1
```

GDNative 和 GDExtension 都是可以避免重新编译 Godot 源代码而进行功能扩展的方法，它们分别用于
Godot 3.x 和 Godot 4.x。前者使用 C API，稍显繁杂，与 Godot 本身使用的 C++ 开发的方式有点不
一致。而新版本的 GDExtension 则改用 C++ 绑定，与 Godot 源代码使用的 C++ 更协调。

如果现有的头文件与 API json 文件没更新为所使用的 Godot 版本，可以编译相应版本的 Godot，并执行
以下命令生成 **extension_api.json** 文件，并取得相应的 gdextension_interface.h 头文件：

    godot --dump-extension-api --dump-gdextension-interface


Function-like Macros 像函数一样，但是其格式更严格，宏名后面多一个空格都不一样。宏编程常常被看作
是一种高级别的编程技术，许多大型工程都有非常广泛的应用，但同时想用好它真的不容易。

以下是宏函数的几种示范，及其对应的展开内容：

```C++
#define lang_init()  c_init()
// lang_init()
//      → c_init()

#define lang_init ()    c_init()
// lang_init()
//      → () c_init()()

extern void foo(void);
#define foo() /* optimized inline version */
// …
//   foo();
//   funcptr = foo;
```

注意最后一种，只定义了宏名而没有宏体，当有一个同名函数，并且有时希望使用该函数时，这可能很有用。
使用宏函数只有在其名称后面出现一对括号时才会展开，如果只写名称，它将被保留。在这里，foo() 将调用宏，
展开内容为空。但函数指针将获得实际函数的地址，如果要扩展宏，则会导致语法错误。

使用 GCC 编译器的 -E 选项可以对宏定义的内容进行扩展，即只做预处理，而不编译、链接程序：

```sh
    g++ -IC:\godot -IC:\godot\platform\windows -E .\demo.cpp >> out.h
    g++ -IC:\godot -IC:\godot\platform\windows -E .\demo.cpp 2>&1 >> out.h
```

宏定义中有三个特别有用的特殊扩展符号：`#`，`##`，`#@`

- `x##y` 表示 x 拼接 y，数值或字符串；
- `#@x` 给 x 加上单引号，结果返回是一个 const char。举例说：
- `#x` 原意是给 x 加双引号变成字符串：

注意，宏定义可以嵌套宏调用，但是使用'#'或'##'扩展后，宏内容即使是一个宏名，也不会再进行宏调用。

ANSI 标准还说明了五个预定义的宏名，它们分别可以获取源代码文件名、当前行号，日期时间等等： 

```c
__LINE__ /* %d */
__FILE__ /* %s */
__DATE__ /* %s */
__TIME__ /* %s */
__FUNCTION__  or __func__
```


Godot 4.0 RC 1 版本代码中使用了更丰富的宏编程，可以减少代码量，但一定程序度上给代码阅读增加难度：

```C++
    // godot\core\object\object.h:344
    // _gdvirtual__poll_call<false>(__VA_ARGS__)
    #define GDVIRTUAL_CALL(m_name, ...) _gdvirtual_##m_name##_call<false>(__VA_ARGS__)
    #define GDVIRTUAL_CALL_PTR(m_obj, m_name, ...) m_obj->_gdvirtual_##m_name##_call<false>(__VA_ARGS__)

    #ifdef DEBUG_METHODS_ENABLED
    #define GDVIRTUAL_BIND(m_name, ...) ::ClassDB::add_virtual_method(get_class_static(), _gdvirtual_##m_name##_get_method_info(), true, sarray(__VA_ARGS__));
    #else
    #define GDVIRTUAL_BIND(m_name, ...)
    #endif

    // godot\scene\main\multiplayer_api.h:84
    class MultiplayerAPIExtension : public MultiplayerAPI {
        GDCLASS(MultiplayerAPIExtension, MultiplayerAPI);
        // ...
        // Extensions
        GDVIRTUAL0R(Error, _poll);
        GDVIRTUAL1(_set_multiplayer_peer, Ref<MultiplayerPeer>);
        GDVIRTUAL0R(Ref<MultiplayerPeer>, _get_multiplayer_peer);
        GDVIRTUAL0RC(int, _get_unique_id);
        GDVIRTUAL0RC(PackedInt32Array, _get_peer_ids);
        GDVIRTUAL4R(Error, _rpc, int, Object *, StringName, Array);
        GDVIRTUAL0RC(int, _get_remote_sender_id);
        GDVIRTUAL2R(Error, _object_configuration_add, Object *, Variant);
        GDVIRTUAL2R(Error, _object_configuration_remove, Object *, Variant);
    };

    // godot\scene\main\multiplayer_api.cpp:84
    Error MultiplayerAPIExtension::poll() {
        Error err = OK;
        GDVIRTUAL_CALL(_poll, err);
        return err;
    }

    void MultiplayerAPIExtension::_bind_methods() {
        GDVIRTUAL_BIND(_poll);
        GDVIRTUAL_BIND(_set_multiplayer_peer, "multiplayer_peer");
        GDVIRTUAL_BIND(_get_multiplayer_peer);
        GDVIRTUAL_BIND(_get_unique_id);
        GDVIRTUAL_BIND(_get_peer_ids);
        GDVIRTUAL_BIND(_rpc, "peer", "object", "method", "args");
        GDVIRTUAL_BIND(_get_remote_sender_id);
        GDVIRTUAL_BIND(_object_configuration_add, "object", "configuration");
        GDVIRTUAL_BIND(_object_configuration_remove, "object", "configuration");
    }

    // godot\core\extension\gdextension_interface.h
    typedef void (*GDExtensionClassCallVirtual)(GDExtensionClassInstancePtr p_instance, const GDExtensionConstTypePtr *p_args, GDExtensionTypePtr r_ret);
    typedef GDExtensionClassCallVirtual (*GDExtensionClassGetVirtual)(void *p_userdata, GDExtensionConstStringNamePtr p_name);
```

前面的 `GDVIRTUAL_CALL(_poll, err)` 就是调用生成的 `_gdvirtual__poll_call()` 这个函数。
这个函数是通过 Python 脚本生成的，直接在源代码中搜索不到。

源代码中有一个 make_virtuals.py 脚本，执行 scons 构建工具时，会生成 gdvirtual.gen.inc 代码
文件，包含有一系列的宏函数。名称按 `GDVIRTUAL$VER` 模板格式，后缀标记有 R (return)，C (const)。
分别表示生成的代码中的返回类型，后函数签名中的 const 声明。共 52 个，13 个版本，每版本 4 个后缀组合。
这些生成代码与 GDExtension 扩展模块相关，**GDExtensionClassCallVirtual** 是扩展中虚函数指针。

MultiplayerAPI 头文件中会使用 Python 脚本生成的 GDVIRTUAL0C、 GDVIRTUAL0RC 等等这些宏函数
来生成类声明，以及默认的方法实现。`GDVIRTUAL_CALL` 宏就是调用这些宏函数生成的默认方法实现。

以下就摘取其中一个宏定义，展示其展开后会产生的全局符号，后缀 RC 差别在于生成函数的参数、变量类型，
和函数签名中的 const 符号，版本号 `$VER` 对应的数值为宏函数可接收的类型参数个数，最高版本号为
12，对应类型参数最多有 12 个。另外，加上 m_ret 和 m_name 两个参数，最多有 14 个宏参数，对应的
虚函数生成宏就是 `GDVIRTUAL12R` 和 `GDVIRTUAL12RC`。

```C++
    #define GDVIRTUAL0RC(m_ret,  m_name ) \
    StringName _gdvirtual_##m_name##_sn = #m_name;\
    mutable bool _gdvirtual_##m_name##_initialized = false;\
    mutable GDExtensionClassCallVirtual _gdvirtual_##m_name = nullptr;\
    template<bool required>\
    _FORCE_INLINE_ bool _gdvirtual_##m_name##_call( m_ret& r_ret) const { /* ... */ }\
    _FORCE_INLINE_ bool  _gdvirtual_##m_name##_overridden() const { /* ... */ }\
    _FORCE_INLINE_ static MethodInfo _gdvirtual_##m_name##_get_method_info() { /* ... */ }\


    #define GDVIRTUAL0C( m_name ) \
    _FORCE_INLINE_ bool _gdvirtual_##m_name##_call() const //...


    #define GDVIRTUAL0RC(m_ret,  m_name ) \
    _FORCE_INLINE_ bool _gdvirtual_##m_name##_call( m_ret& r_ret) const //...


    #define GDVIRTUAL3( m_name , m_type1, m_type2, m_type3) \
    _FORCE_INLINE_ bool _gdvirtual_##m_name##_call(m_type1 arg1, m_type2 arg2, m_type3 arg3) //...
```

要用它们生成虚函数默认实现，就将要生成的目标函数的参数类型依次传入宏函数中。例如，以 `_rpc` 这个
虚拟函数为例，为它生成默认的函数实现：

    GDVIRTUAL4R(Error, _rpc, int, Object *, StringName, Array);

根据虚函数生成宏的名称规则，4R 代表有返回类型，函数 4 个参数类型为 int, Object * , StringName, Array。


以上 MultiplayerAPIExtension 绑定的虚函数和文档显示的对应关系：

```py
 MultiplayerPeer _get_multiplayer_peer() virtual
PackedInt32Array _get_peer_ids() virtual const
             int _get_remote_sender_id() virtual const
             int _get_unique_id() virtual const
           Error _object_configuration_add(object: Object, configuration: Variant) virtual
           Error _object_configuration_remove(object: Object, configuration: Variant) virtual
           Error _poll() virtual
           Error _rpc(peer: int, object: Object, method: StringName, args: Array) virtual
            void _set_multiplayer_peer(multiplayer_peer: MultiplayerPeer) virtual
```

这些方法在父类 MultiplayerAPI 中全都是定义为纯虚函数：

```C++
    // godot\scene\main\multiplayer_api.h:37
    class MultiplayerAPI : public RefCounted {
        GDCLASS(MultiplayerAPI, RefCounted);
        // ...
        virtual Error poll() = 0;
        virtual void set_multiplayer_peer(const Ref<MultiplayerPeer> &p_peer) = 0;
        virtual Ref<MultiplayerPeer> get_multiplayer_peer() = 0;
        virtual int get_unique_id() = 0;
        virtual Vector<int> get_peer_ids() = 0;

        virtual Error rpcp(Object *p_obj, int p_peer_id, const StringName &p_method, const Variant **p_arg, int p_argcount) = 0;
        virtual int get_remote_sender_id() = 0;

        virtual Error object_configuration_add(Object *p_object, Variant p_config) = 0;
        virtual Error object_configuration_remove(Object *p_object, Variant p_config) = 0;
    };
```


## 🟡 Godot with CSharp
- http://www.mono-project.com/docs/about-mono/compatibility
- https://docs.godotengine.org/en/3.5/tutorials/scripting/c_sharp/c_sharp_features.html
- https://docs.godotengine.org/en/3.5/tutorials/scripting/c_sharp/c_sharp_differences.html
- https://docs.godotengine.org/en/stable/tutorials/scripting/cross_language_scripting.html
- https://docs.godotengine.org/en/stable/tutorials/scripting/creating_script_templates.html
- https://docs.godotengine.org/en/stable/development/compiling/compiling_with_mono.html
- https://docs.godotengine.org/en/latest/contributing/development/compiling/compiling_with_mono.html
- https://docs.godotengine.org/en/latest/tutorials/scripting/c_sharp/index.html
- https://docs.godotengine.org/en/latest/tutorials/scripting/c_sharp/c_sharp_basics.html
- https://docs.godotengine.org/en/latest/tutorials/scripting/c_sharp/c_sharp_exports.html
- https://docs.godotengine.org/en/latest/tutorials/scripting/c_sharp/c_sharp_differences.html
- https://docs.godotengine.org/en/latest/tutorials/scripting/c_sharp/c_sharp_signals.html
- https://docs.godotengine.org/en/latest/contributing/development/core_and_modules/object_class.html#doc-binding-properties-using-set-get-property-list
- [Bunnymark](https://github.com/cart/godot3-bunnymark)
- [Godot.NET.Sdk](https://www.nuget.org/packages/Godot.NET.Sdk/#versions-body-tab)
- [Mono SDK](https://www.mono-project.com/download/stable/#download-lin)
- [.NET SDK](https://dotnet.microsoft.com/download)
- [Visual Studio Code](https://code.visualstudio.com/)
- [C# support on Android](https://godotengine.org/article/csharp-android-support/)
- [Godot 3.5.1 Mono](https://downloads.tuxfamily.org/godotengine/3.5.1/mono/)
- [CustomType for Godot 3.x](https://github.com/Jeangowhy/Godot-Tour/tree/main/mono-3x/addons/CustomType)
- [CustomType for Godot 4.x](https://github.com/Jeangowhy/Godot-Tour/tree/4.x/mono-4x/addons/CustomType)
- godot-docs\tutorials\scripting\c_sharp\c_sharp_basics.rst

Godot 有两套语言支持构建：

- 默认的支持 GDScript，GDExtension
- 另一套则集成了 .NET 6 支持 C#, GDScript, GDExtension。

要使用 C# 语言进行 Godot 项目开发，系统上需要安装 .NET SDK 6.0 或 7.0，.NET 7.0 的支持还不完善。
相比 GDScript 脚本，C# 是一个编译型的高级语言，Godot 通过开源的 Mono 6.x 框架支持 C# 8.0 语言版本。
与作用快速原型开发使用 GDScript 脚本不同，每次执行之前都需要进行编译，以生成最新的 C# 程序集。但是，
作为预编译语言，它的运行效率虽然不能和 C++ 看齐，但比 GDSCript 有非常大的效率提升，简单情况有 4x 提升。
并且，在使用的便利程序上，要比 C++ 好，所以在不是极限性能需要情况下，C# 是值得一试的方案。

怎么选开发语言，就是权衡开发效率与程序运行性能：

- 选择 GDScript 可以快速地做原型迭代；
- 选择 C# 一方面提升了性能，另外它比 C++/Rust 更容易上手，同时编译速度也不太慢；
- 最后，极致性能要求，那么就选择 C++/Rust 折腾去吧！

参考 Bunnymark V2 测试数据，数值越大越好，测试 Sprite 绘制并使用 GetChildren() 迭代：

| Language             | Bunnies Rendered |
|----------------------|------------------|
| ECMAScript/Javascript| 4660             |
| GDScript (Release)   | 18560            |
| C#/Mono              | 27555            |
| GDNative (D)         | 28020            |
| GDNative (Nim)       | 29920            |
| GDNative (C++)       | 37480            |

测试平台信息：

    ### Hardware:

    * CPU: Intel i7 7700k 4.2GHz
    * GPU: Nvidia GeForce GTX 1070
    * RAM: 16GB DDR4

    ### Build Info:

    * OS: Arch Linux
    * Official Godot 3.1 release

Godot 3.2.3 开始，不需安装 Mono SDK，除非需要从源代码构建 Godot，但是 .NET SDK 还是要安装。
注意，使用的 Godot 要与 SDK 的版本比特位一致，建议使用 64-bit 的版本。由于 Godot 只提供了 C#
的最小支持，可以考虑使用外部编辑器，如 Visual Studio Code，以提供更完善的自动完成、调试等功能。
Godot 目前支持以下作用外部编辑器，可以通过 Editor → Editor Settings → Mono → Editor 修改：

- Visual Studio 2019
- Visual Studio Code
- MonoDevelop
- Visual Studio for Mac
- JetBrains Rider

以 VSCode 配置为例，最新的 Godot 4 不需要配置 Builds：

- Set **Mono** -> **Editor** -> **External Editor** to **Visual Studio Code**.
- Set **Mono** -> **Builds** -> **Build Tool** to **dotnet CLI**.

并且在 Visual Studio Code 中安装以下扩展：

- [C#](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp)
- [Mono Debug](https://marketplace.visualstudio.com/items?itemName=ms-vscode.mono-debug)
- [C# Tools for Godot](https://marketplace.visualstudio.com/items?itemName=neikeq.godot-csharp-vscode)

C# Tools for Godot 扩展支持 Godot 3.2.2 以上版本，可以提供以下功能：

- Debugging.
- Launch a game directly in the Godot editor from VSCode.
- Additional code completion for Node paths, Input actions, Resource paths, Scene paths and Signal names.

如果使用 Linux 操作系统，需要安装 Mono SDK 以支持 Godot 的 C# 工具插件。

配置 VSCdoe 以实现 Godot 工程的运行：

- 执行菜单 Run → **Add Configuration...**  → **C# Godot**
- 编辑配置文件 ``tasks.json`` 和 ``launch.json``，使用 executable 和 Command 指向正确的 Godot 可执行文件。

完成以上配置后，就可以直接在 VScode 中运行 Godot 项目：

- 使用命令调板，Ctrl-Shift-P 打开面板并输入 C# Godot 查询相关命令；
- 在状态栏中，点击 Godot Project 字样处选择工程目录；
- 在状态栏中，点击 Play in Editor (mono) 字样处运 Godot 工程；
- 直接打开 Run and Debug 侧栏面板选择 ``launch.json`` 配置的调试的方式：
    - Play in Editor 直接通过编辑器中运行；
    - Launch 执行 `Godot.exe --path ${workspaceRoot}`
    - Launch (Select Scene) 选择场景执行 `Godot.exe --path ${workspaceRoot} ${command:SelectLaunchScene}`
    - Attach 附着到本地调试进程；

如果工程不能正常运行，而 VScode 又看不到错误信息，就可以到 Godot 的 MSBuild 面板查询编译日志信息，
例如，当前系统曾经删除过 Xamarin 的 NuGet 模块目录，导致 Godot 编译时出现问题，只需要恢复目录即可：

    SDK 解析程序失败: 
    "尝试解析 SDK "Godot.NET.Sdk/4.0.0-beta.16" 时，SDK 解析程序 "NuGetSdkResolver" 失败。
    异常: "NuGet.Packaging.Core.PackagingException: 无法找到回退包文件夹“C:\Microsoft\Xamarin\NuGet\”。

NuGet 是依赖管理工具，包含为开放源代码 .NET 库而创建的 NuGet.org 包管理平台，上面公开发布了
所有包的推荐元数据。NuGet 包 `*.nupkg` 是一个 zip 文件，其中包含 .NET 程序集和关联的元数据。

NuGet 是 .NET 生态系统的包管理器，并且是开发人员用来发现并获取 .NET 开放源代码库的主要方法。
NuGet.org（由托管 NuGet 包的 Microsoft 提供的免费服务）是公共 NuGet 包的主要主机，但可以
发布到自定义 NuGet 服务，如 MyGet 和 Azure Artifacts。

创建 NuGet 包有两种主要方式。 较新的推荐方式是从 SDK 样式项目，其内容以 `<Project Sdk="Microsoft.NET.Sdk">` 
开头的项目文件创建包。 程序集和目标会自动添加到包，剩余元数据会添加到 MSBuild 文件，如包名称和版本号。
使用 `dotnet pack` 命令编译会输出 `*.nupkg` 文件，而不是程序集。

本地下载安装的缓冲目录可以使用以下命令查询及清理：

    nuget locals all -list
    nuget locals all -clear

配置文件 ``tasks.json`` 默认只提供了一个构建任务，可以通过菜单 Terminal → Run Build Task... 执行： 

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "build",
      "command": "Godot_v4.0-beta16_mono_win64.exe", //"<insert-godot-executable-path-here>",
      "type": "process",
      "args": [
        "--build-solutions",
        "--path",
        "${workspaceRoot}",
        "--no-window",
        "-q"
      ],
      "problemMatcher": "$msCompile"
    }
  ]
}
```

如果添加运行配置时，没有提供 **C# Godot** 配置，请检查以上三个扩展是否完成安装，并且处于启用状态。
配置好开发环境，就可以在 Godot 给节点附加脚本时，在 Attach Script 对话框中选择 C# 语言。

Node 节点类扩展代码示例：

```C#,ignore
    using Godot;
    using System;

    public class MyNode2D : Node
    {
        // Member variables here, example:
        private int a = 2;
        private string b = "textvar";

        public override void _Ready()
        {
            // Called every time the node is added to the scene.
            // Initialization here.
            GD.Print("Hello from C# to Godot :)", Time.GetTicksMsec());
        }

        public override void _Process(float delta)
        {
            // Called every frame. Delta is time since the last frame.
            // Update game logic here.
        }
    }
```

使用 C# 与 GDScript 的一些差异：

- C# 使用 ``PascalCase`` 代码风格，GDSCript/C++ 使用 ``snake_case`` 风格，`AddChild()` vs. `add_child()`。
- C# 类名要求代码文件名一致，否由会提示 *"Cannot find class XXX for script res://XXX.cs"*
- C# 中使用 Godot 命令空间下的 GD 管理 @GDscript 和 @GlobbalScope 全局函数符号。
- C# 导出符号生效之前，需要重新编译程序集，通过 Godot 界面右上角的 Build 按钮构建工程。
- C# 语句使用分号作为结束符号，而 GDScript 不需要。
- C# 中以 `Godot.Object` 作为所有类型的基类，新版本更名为 `Godot.GodotObject`。
- C# 使用 `this` 引用当前类实例，GDScript 使用 `self` 引用当前类实例。
- C# 使用 `base` 引用父类实例或构造器，GDScript 使用 `super(args)` 引用父类构造。

在 C# 中，也不能像 GDScript 那样，直接拖动节点到脚本中创建引用，也不能使用 onready，而需要在
Ready 这类事件中，使用 FindNode 或者 GetNode 获取节点引用：

```C#
    //Button n = FindNode("Button") as Button; // FindNode -> FindChild (Godot 4)
    Button n = (Button) GetNode("Button");
    if (n != null) {
        // n.Connect(nameof(Button.Pressed), this, "handle_button_click");
        n.Connect("pressed", this, "handle_button_click");
        GD.Print($"button: {n.Text}");
    }
```

使用 C# 进行 Godot 项目开发，还需要解决以下这些基本问题：

- 不同语言之间的相互调用问题；
- Godot 信号系统的使用方式的差异；
- C# 与 GDScript API 之间的差异；
- Godot 不同版本之间的差异处理等等；


Godot 考虑到了不同语言之间相互调用，C# 调用 GDScript API 或者属性读写使用 GodotObject 提供的方法：

```C#,ignore
    //
    // 摘要:
    //     Calls the method on the object and returns the result. This method supports a
    //     variable number of arguments, so parameters are passed as a comma separated list.
    //     Example:
    //     call("set", "position", Vector2(42.0, 0.0))
    [GodotMethodAttribute("call")]
    public object Call(string method, params object[] args);
    //
    // 摘要:
    //     Calls the method on the object during idle time. This method supports a variable
    //     number of arguments, so parameters are passed as a comma separated list. Example:
    //     call_deferred("set", "position", Vector2(42.0, 0.0))
    [GodotMethodAttribute("call_deferred")]
    public void CallDeferred(string method, params object[] args);
    //
    // 摘要:
    //     Calls the method on the object and returns the result. Contrarily to Godot.Object.Call(System.String,System.Object[]),
    //     this method does not support a variable number of arguments but expects all parameters
    //     to be via a single Godot.Collections.Array.
    //     callv("set", [ "position", Vector2(42.0, 0.0) ])
    [GodotMethodAttribute("callv")]
    public object Callv(string method, Collections.Array argArray);

    //
    // 摘要:
    //     Assigns a new value to the given property. If the property does not exist or
    //     the given value's type doesn't match, nothing will happen.
    [GodotMethodAttribute("set")]
    public void Set(string property, object value);
    //
    // 摘要:
    //     Returns the Variant value of the given property. If the property doesn't exist,
    //     this will return null.
    [GodotMethodAttribute("get")]
    public object Get(string property);
```

而在 GDscript 访问 C# API 则是直接调用，就像使用其它 GDScript 对象一样，实例化操作如下所示：

```py
    # Instantiating C# nodes from GDScript
    var my_csharp_script = load("res://path_to_cs_file.cs")  # CSharpScript
    var my_csharp_node = my_csharp_script.new()
    print(my_csharp_node.some_property)
```

```C#
    // Instantiating GDScript nodes from C#
    GDScript MyGDScript = (GDScript) GD.Load("res://path_to_gd_file.gd");
    Object myGDScriptNode = (Godot.Object) MyGDScript.New();
    myGDScriptNode.Call("some_method", new int[] { 1, 2, 3 }); // some_method(1, 2, 3)
    myGDScriptNode.Call("some_method", (object)new int[] { 1, 2, 3 }); // some_method([1, 2, 3])
```

注意，实例化得到的类型以 Godot 内置类型为准，而不是按 C# 或 GDScript 中声明的类型作为判断标准。
比如，后面的 MyNode2D 在使用 GDScript `is` 关键字做类型判断时，需要使用内置类型 Node 作为参考。
C# 调用 GDScript API 时注意，如果第一个参数是一个数组，那么就需要显式转换为 `object` 类型。否则，
数组元素就会被当作一个参数使用，并可能导致函数签名不匹配。


编写 C# 类代码时注意，类名与 ``.cs`` 代码文件名一致，否则提示错误：

    Invalid call. Nonexistent function `new` in base.

比如，MyCoolNode.cs 文件就应该定义 MyCoolNode 类型。并且需要继承自 ``Godot.Object`` 或其它
子类。最后，C# 工程文件 ``.csproj``中要正确引用``.cs`` 文件，这样才会生效。



Godot 4.x Mono 信号机制在 C# 使用委托机制实现，并且可以使用更高效的 += 和 -= 运算符监听、或者
取消监听。另外，Connect 方法也有更新，使用 Callable 对象包装回调函数及回调参数。另外，通过节点的
嵌套类 SignalName 可以访问信号名称，它继承自 GodotObject.SignalName。清理节点时，Godot 会
负责所有信号监听事件的清理：

```C#
    Timer myTimer = GetNode<Timer>("Timer");
    myTimer.Timeout += () => GD.Print("Timeout!");
    // public Error Connect(StringName signal, Callable callable, uint flags = 0);

    await ToSignal(GetTree(), SceneTree.SignalName.ProcessFrame);
```

以下是 Callable 类参考文档中展示的用法，使用了嵌套类 MethodName 或者 nameof 获取方法名称。但是
在默认参数绑定操作上有差别，GDScript 中可以直接调用 Callable 对象的 bind() 方法绑定默认参数。
而目前在 C# 中给信号绑定默认参数则需要使用 lambdas 来构造出一个包含默认参数的 Callable 对象。
如果方法没有参数，也没有返回值，可以包装成 Action，由 Callable.From() 再包装成可调用对象。

```C#,ignore
    // Default parameter values are not supported.
    public void PrintArgs(Variant arg1, Variant arg2, Variant arg3 = default)
    {
        GD.PrintS(arg1, arg2, arg3);
    }

    public void Test()
    {
        Callable callback = Callable.From(() => GD.Print("Hello World"));

        // Invalid calls fail silently.
        Callable callable = new Callable(this, MethodName.PrintArgs);
        callable.Call("hello", "world"); // Default parameter values are not supported, should have 3 arguments.
        callable.Call(Vector2.Up, 42, callable); // Prints "(0, -1) 42 Node(Node.cs)::PrintArgs".
        callable.Call("invalid"); // Invalid call, should have 3 arguments.
    }
```

Godot 4.x Mono 所有信号定义名称使用 EventHandler 结尾，定义好信号后，完成后，Godot 在幕后
自动使用 C# `event` 关键字创建相应的事件。然后，可以像其他 Godot 信号一样使用自定义信号事件。
注意，类型定义使用的 partial class，即表示类定义代码是分开文件存放的，还可以包含在其它代码文件。
除了直接使用委托方式定义信号，还可以使用 AddUserSignal() 方法添加自定义信号。


Godot 3.x Mono 自定义信号的使用有些差别，获取信号名称使用 nameof(MySignal) 语法，并且信号
连接依然是使用节点的 Connect 方法进行。信号名称的获取这种操作一致性不够好，例如，获取按钮节点的
信号就不能使用 nameof(Button.Pressed) 这样的表达，而是直接使用 "pressed" 字符串字面量。

总结起来，C# 中有三种获取或使用信号名称的方式，Godot 3.x 只支持前两种：

- `EmitSignal("MySignal");` 直接使用字符串字面量
- `EmitSignal(nameof(MySignal));` 使用 nameof 关键字
- `EmitSignal(SignalName.MySignal);` 使用内嵌类 SignalName


```C#,ignore
    //     Represents the method that handles the Godot.EditorPlugin.SceneChanged event
    //     of a Godot.EditorPlugin class.
    //public delegate void SceneChangedEventHandler(Node sceneRoot);
    //public event SceneChangedEventHandler SceneChanged;

    public partial class MyNode2D : Node2D
    {
        // Declaring a signal in Godot 3.x with C# is done with the [Signal] attribute on a delegate.
        [Signal]
        delegate void MySignal();

        [Signal]
        delegate void MySignalWithArguments(string foo, int bar);

        public override void _Ready() 
        {
            MyMethodEmittingSignals();
        }

        // Emitting signals is done with the EmitSignal method.
        public void MyMethodEmittingSignals()
        {
            //AddUserSignal("MyOtherSignal");
            EmitSignal(nameof(MySignal));
            EmitSignal("MySignalWithArguments", "hello there", 28);
        }
    }

    public partial class AnotherNode : Node2D
    {
        MyNode instance;

        public override void _Ready()
        {
            instance = GetNode("MyNode")
        }
        // These signals can then be connected either in the editor or from code with Connect.
        public void MyCallback()
        {
            GD.Print("My callback!");
        }

        public void MyCallbackWithArguments(string foo, int bar)
        {
            GD.Print("My callback with: ", foo, " and ", bar, "!");
        }

        public void SomeFunction()
        {
            instance.Connect("MySignal", this, "MyCallback");
            instance.Connect("MySignal", this, "MyCallbackWithArguments", new Godot.Collections.Array{"Mono", 123});
            instance.Connect(nameof(MySignalWithArguments), this, "MyCallbackWithArguments");
        }
    }
```

使用自定义信号可能遇到的问题是：调用 EmitSignal() 时报错，表示信号不存在，而调用 AddUserSignal()
手动添加信号时，又表示不能重复添加已经定义的信号，这可能是定义信号的代码没有写到类体内部：

    E 0:00:07.120   emit_signal: Can't emit non-existing signal "MySignal".
      <C++ Error>   Condition "!signal_is_valid && !script.is_null() && !Ref<Script>(script)->has_script_signal(p_name)" is true. Returned: ERR_UNAVAILABLE
      <C++ Source>  core/object.cpp:1177 @ emit_signal()
      <Stack Trace> :0 @ void Godot.NativeCalls.godot_icall_2_695(IntPtr , IntPtr , System.String , System.Object[] )()
                    Object.cs:365 @ void Godot.Object.EmitSignal(System.String , System.Object[] )()
                    Node_2D.cs:17 @ void Node_2D.MyMethodEmittingSignals()()

    E 0:00:03.798   add_user_signal: Trying to add already existing signal 'MySignal'.
      <C++ Error>   Condition "signal_map.has(p_signal.name)" is true.
      <C++ Source>  core/object.cpp:1121 @ add_user_signal()
      <Stack Trace> :0 @ void Godot.NativeCalls.godot_icall_2_694(IntPtr , IntPtr , System.String , IntPtr )()
                    Object.cs:337 @ void Godot.Object.AddUserSignal(System.String , Godot.Collections.Array )()
                    Node_2D.cs:18 @ void Node_2D.MyMethodEmittingSignals()()


一些 GDScript 遇不到的问题，如下：

```C#,ignore
public partial class MyNode2D : Node2D
{
    public override _Ready()
    {
        // Position.X = 100.0f;
        // CS1612: Cannot modify the return value of 'Node2D.Position' because
        // it is not a variable.
        var newPosition = Position;
        newPosition.X = 100.0f;
        Position = newPosition;

        // C# 10 is required:
        // Position = Position with { X = 100.0f };
    }
}
```

一个类型中结构体，Vector2，在 C# 中是通过拷贝进行赋值的，也就是说在获取 Position 属性时，获取到
的是一个副本，对这个副本赋值并不会影响到原来归属的节点。解决方法：创建一个变量引用 Position 再进行
赋值操作。在 C# 10 版本中，可以对结构体使用 with 表达式来解决这种问题。

通常，使用 C# 编程而不是 GDScript，一个主要的目的可能是为了提升程序运行速度，所以应该避免编写无
效率的代码，以下是两种节点的移动方式对比，后者更高效：

```C#,ignore
using Godot;

public partial class YourCustomClass : Node3D
{
    private void ExpensiveReposition()
    {
        for (var i = 0; i < 10; i++)
        {
            // Position is read and set 10 times which incurs native interop.
            // Furthermore the object is repositioned 10 times in 3D space which
            // takes additional time.
            Position += new Vector3(i, i);
        }
    }

    private void Reposition()
    {
        // A variable is used to avoid native interop for Position on every loop.
        var newPosition = Position;
        for (var i = 0; i < 10; i++)
        {
            newPosition += new Vector3(i, i);
        }
        // Setting Position only once avoids native interop and repositioning in 3D space.
        Position = newPosition;
    }
}
```

给 Godot C# API 传递原始的 byte[] 或者字符串，需要 marshalling 操作，这相对不够高效。隐式转换
string 为 NodePath 或 StringName 会产生原生互操作和 marshalling 成本，因为字符串必须编组并
传递给相应的原生构造函数。


### 🟠🔵 Export in CSharp

以下演示在 Godot 4.x Mono 中使用 C# [Export] 标注导出符号，以及使用 [Signal] 自定义信号：

```C#,ignore
using Godot;

[Signal]
public delegate void MySignalEventHandler();

[Signal]
public delegate void MySignalWithArgumentEventHandler(string myString);

public partial class MyNode : Node
{
    [Export]
    private NodePath _nodePath;

    [Export]
    private string _name = "default";

    [Export(PropertyHint.Range, "0,100000,1000,or_greater")]
    private int _income;

    [Export(PropertyHint.File, "*.png,*.jpg")]
    private string _icon;

    public void MyMethodEmittingSignals()
    {
        EmitSignal(SignalName.MySignal);
        EmitSignal(SignalName.MySignalWithArgument, "World");
    }
}
```

其它导出标注用法参考，高级导出参考 get_property_list 方法的使用，目前 Godot 3 不支持导出分组：

```C#,ignore
    [ExportGroup("My Properties")]
    [Export]
    private int Number = 3;

    [ExportSubgroup("Extra Properties")]
    [Export]
    private string Text = "";
    [Export]
    private bool Flag = false;

    [ExportCategory("Main Category")]
    [Export]
    private int Number = 3;
    [Export]
    private string Text = "";

    [ExportCategory("Extra Category")]
    [Export]
    private bool Flag = false;


    [Export]
    private Resource Resource;

    [Export]
    private AnimationNode Resource;

    [Export]
    private Color Col;

    [Export(PropertyHint.ColorNoAlpha)]
    private Color Col;


    [Export]
    private Vector3[] Vector3s = new Vector3[0];
    [Export]
    private String[] String = new String[0];


    [Export(PropertyHint.Layers2dPhysics)]
    private int Layers2dPhysics;
    [Export(PropertyHint.Layers2dRender)]
    private int Layers2dRender;
    [Export(PropertyHint.Layers3dPhysics)]
    private int layers3dPhysics;
    [Export(PropertyHint.Layers3dRender)]
    private int layers3dRender;


    // Set any of the given flags from the editor.
    [Export(PropertyHint.Flags, "Fire,Water,Earth,Wind")]
    private int SpellElements = 0;


    [Export(PropertyHint.ExpEasing)]
    private float TransitionSpeed;

    [Export(PropertyHint.Range, "0,20,")]
    private int Number;

    [Export(PropertyHint.Range, "-10,20,")]
    private int Number;

    [Export(PropertyHint.Range, "-10,20,0.2")]
    private float Number;

    [Export(PropertyHint.Range, "0,100,1,or_greater,or_lesser")]
    private int Number;

    [Export(PropertyHint.ExpRange, "100,1000,20")]
    private float Number;


    [Export(PropertyHint.File)]
    private string GameFile;

    [Export(PropertyHint.Dir)]
    private string GameDirectory;

    [Export(PropertyHint.File, "*.txt,")]
    private string GameFile;


    [Export]
    private NodePath MyNodePath;
    private Label MyNode;

    public override void _Ready()
    {
        MyNode = GetNode<Label>(MyNodePath);
    }

    // Editor will enumerate as 0, 1 and 2.
    [Export(PropertyHint.Enum, "Warrior,Magician,Thief")]
    private int CharacterClass;
    
    [Export(PropertyHint.Enum, "Rebecca,Mary,Leah")]
    private string CharacterName;

    private enum NamedEnum
    {
        Thing1,
        Thing2,
        AnotherThing = -1
    }
    [Export(PropertyHint.Enum)]
    private NamedEnum X;
```

### 🟠🔵 Godot Plugin in CSharp
- https://github.com/m50/Godot-CSharp-Node-Exports
- [.NET project SDKs](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview)
- [Attribute 基类](https://learn.microsoft.com/zh-cn/dotnet/api/system.attribute?view=net-7.0)
- [CompilerServices 命名空间](https://learn.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices)
- https://referencesource.microsoft.com/#mscorlib/system/runtime/compilerservices/datetimeconstantattribute.cs
- https://docs.godotengine.org/en/3.5/tutorials/plugins/editor/index.html
- https://godotengine.org/asset-library/

C# 中没有 class_name 这样的关键字用来注册自定义节点，这可以使用插件的 Custom types。通过菜单
创建插件：Project → Project Settings → Plugins → Create new Plugin。使用 C# 创建插件时，
注意脚本名称和类名要一致。

也可以使用 AssetLib → Plugins 打开插件管理面板，并且使用 AssetLib 提供的 Import 按钮来安装
插件。开发好的插件只需要打包成 zip 文件，注意要将 addons 目录层级一并打包，Import 执行安装是直接
解压文件到工程根目录。

开发好的插件还可以上传 Godot Asset Library 分享，只需要注册一个账户即可。上传资产时只需要登记
相关的插件信息，下载链接地址，使用 Github 托管很容易处理，填写相应的 Commit ID 和预览图即可，
然后等待审核通过后即可以在列表中搜索到，Feed 页面可以查看资产的审核状态。


C# 中可以自定义标注实现类似 GDScript 中的 classname 注册自定义类型：

- **System.Attribute** 自定义标注需要继承的基类；
- **System.AttributeUsage** 设置自定义标注的用途，以及 AllowMultiple，Inherited 等属性；
- **System.AttributeTargets** 提供标注用途的枚举类型定义，如 Class, Method, Property 等等用途；
- [System.AttributeUsage(System.AttributeTargets.Class)] 指定自定义标注作用于类型定义；
- [System.AttributeUsage(System.AttributeTargets.Method)] 指定自定义标注作用于类型定义；

此外，System.Runtime.CompilerServices 命名空间下提供了一系列编译获取信息的标注，如：

- **CallerFilePathAttribute** 获取包含调用方的源文件的完整路径。 这是编译时的文件路径。
- **CallerLineNumberAttribute** 获取源文件中调用方法的行号。
- **CallerMemberNameAttribute** 获取方法调用方的方法或属性名称。
- **DateTimeConstantAttribute** 为字段或参数永久保存一个 8 字节的 DateTime 常数。

Caller 和 Callee 分别表示一个方法调用另一个方法的双方，Caller 是主动调用，Callee 是被调用方。
向 Godot 注册自定义类型需要使用其脚本，需要使用 [CallerFilePath] 标注获取脚本路径，并通过资源
管理器 ResourceLoader 加载它得到脚本对象。加载脚本得到的是一个资源类型，可以使用多种方式进行转换：

```C#
    Script script = ResourceLoader.Load(target.ScriptPath) as Script;
    Script script = ResourceLoader.Load<Script>(target.ScriptPath);
    Script script = (Script) ResourceLoader.Load(target.ScriptPath);
```

最新的 Godot 4 beta 16 提供了一个 GodotClassNameAttribute 标注，但它不是用来注册自定义类型。
它用来在生成的 C# 代码中的类名不一致时指定引擎类名，以允许内省代码查找与类关联的名称。

C# 元数据编程中，一个方格号内可以包含多个标注，每个标注使用圆括号通过 = 运算符对其属性进行赋值。
对标注好的代码进行处理时，使用程序集对象 Assembly 提供的反射方法，对当前运行中的程序集进行处理。
通过处理程序集中标注过的类型，使用 AddCustomType() 将自定义类型注册到 Godot 系统内：

```C#
    using System.Reflection;

    var assembly = Assembly.GetExecutingAssembly();
    foreach (var t in assembly.GetTypes())
    {
        MyAttribute mytype = t.GetCustomAttribute<MyAttribute>();
        if (item == null) continue;
        ...
    }

    // in Godot 4.x
    Connect("resource_saved", new Callable(this, nameof(OnResourceSaved)));
    AddToolMenuItem("Reload C# Resources", new Callable(this, nameof(BuildTypes)));
    // in Godot 3.x
    Connect("resource_saved", this, "OnResourceSaved");
    AddToolMenuItem("Reload C# Resources", this, nameof(BuildTypes));
```

在 Godot 触发自定义节点注册行为，可以通过添加工具菜单 AddToolMenuItem() 来让用户操作，它会向
Project → Tools 添加菜单，需要在禁用插件配合 RemoveToolMenuItem() 做菜单清理，避免重复添加。
也可以使用 EditorPlugin 的信号来触发，插件提供的信号包含场景变动、资源保存、工程配置变动等等。保存
文件，包括各种资源文件，就会触发 **resource_saved** 信号。

插件中的自定义标注需要在 Godot 工程中其它代码引用，C# 工程文件 ``.csproj`` 要正确引用``.cs``，
并且需要构建好 C# 项目使其生效。否则，启用插件时就会提示不能加载插件脚本，因为 Godot 不能通过脚本
提供类型名称找到相应的程序集中对应的类型。

```sh
<Project Sdk="Godot.NET.Sdk/4.0.0-beta.16">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <EnableDynamicLoading>true</EnableDynamicLoading>
    <EnableDefaultCompileItems>false</EnableDefaultCompileItems>
  </PropertyGroup>
  <ItemGroup>
    <Compile Include="addons/**/*.cs" Condition=" '$(Configuration)' == 'Debug' " />
    <Compile Include="src/*.cs" />
  </ItemGroup>
</Project>
```

一个最简单的插件可以只包含两个方法，它向引擎注册自定义节点：

```py
    tool
    extends EditorPlugin

    func _enter_tree():
        # When this plugin node enters tree, add the custom type
        add_custom_type("Heart", "Node2D", preload("res://addons/custom_node/heart.gd"), preload("res://addons/custom_node/heart_icon.png"))
        # public void AddCustomType(string type, string @base, Script script, Texture2D icon);

    func _exit_tree():
        # When the plugin node exits the tree, remove the custom type
        remove_custom_type("Heart")
        # public void RemoveCustomType(string type);
```

```C#,ignore
    #if TOOLS
    using Godot;
    using System;

    [Tool]
    public partial class Plugin : EditorPlugin
    {
        public override void _EnterTree()
        {
            // Initialization of the plugin goes here.
        }

        public override void _ExitTree()
        {
            // Clean-up of the plugin goes here.
        }
    }
    #endif
```

一个节点，包括插件，连接到 Root Viewport 即成为场景树中的一个部分，最后节点被移除，依次触发回调方法：

```py
_enter_tree() 
_ready() 
_exit_tree()
```

节点树所有节点会按位置先后、由表层到内层依次执行 enter_tree 方法，而 ready 和 exit_tree 方法，
则不同，会先由内层到外层的顺序执行，父级节点需要等待内层节点工作完成才能执行 ready 等动作。

对于插件，Project → Project Settings → Plugins 面板中启用它，即添加到场景树上，禁用时即移除。
插件代码如果有更新，也需要通过禁用再重新启用来更新，并重新执行初始化。Godot 4 beta 16 中，只要
重新执行构建，插件功能即可以随之更新，不需要重新设置工程插件配置，但初始化在下次启用插件时执行。

以下是 CustomTypes 插件的实现，有两个 C# 代码文件，一个标注定义，另一个是主脚本。通过工程配置
启用插件：Project → Project Settings... → Plugins → CustomTypes → Enable/Disable。

然后，插件会向 Project → Tools 工具菜单中注册两个功能，分别用于更新自定义类型的注册和清理：

- Project → Tools → C# Custom Types: Register
- Project → Tools → C# Custom Types: Clear

标注定义代码文件 ClassNameAttribute.cs 内容：

```C#,ignore
    using System;
    using System.Runtime.CompilerServices;

    namespace CustomTypes.Attributes
    {
      [AttributeUsage(AttributeTargets.Class, Inherited = false)]
      class ClassNameAttribute : Attribute
      {
        // [DateTimeConstantAttribute(1675150868847)]
        // public DateTime timestamp;
        public string Name = "";
        public string Icon = "";
        public string ScriptPath = "";

        public ClassNameAttribute([CallerFilePath] string scriptPath = "")
        {
          ScriptPath = scriptPath;
        }
      }
    }
```

Custom Types 插件主脚本文件 Plugin.cs，在创建插件时将其填写到 Script Name 字段中：

```C#,ignore
    #if TOOLS
    using Godot;
    using System;
    using System.Reflection;
    using System.Collections.Generic;
    using CustomTypes.Attributes;

    namespace CustomTypes
    {
        
    [Tool]
    /// <summary>
    /// Register custom types like GDScript class_name.
    /// to enable/disable CustomType plugin, use Project Setting:
    ///         Project → Project Settings... → Plugins → CustomTypes → Enable/Disable
    /// 
    /// to register/unregister, use Project menu :
    ///         Project → Tools → C# Custom Types: Register
    ///         Project → Tools → C# Custom Types: Clear
    /// </summary>
    ///
    /// example:
    ///
    /// ```csharp
    /// using CustomTypes.Attributes;
    /// using Godot;
    ///
    /// [ClassName(Icon="res://Path/To/Icon.png")]
    /// public class MyResource : Resource
    /// {
    ///     //...
    /// }
    /// 
    /// [ClassName(Name="MyCsharpNode2D", Icon="res://bullet.svg")]
    /// public partial class MyNode2D : Node2D
    /// {
    ///     // ...
    /// }
    /// ```
    public partial class Plugin : EditorPlugin
    {
        
        string toolname_add = "C# Custom Types: Register";
        string toolname_clear = "C# Custom Types: Clear";
        List<string> types = new List<string>();

        public void RegCustomTypes()
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            foreach (var item in assembly.GetTypes())
            {
                var target = item.GetCustomAttribute<ClassNameAttribute>();
                // GD.Print("target: ", item);
                
                if (target == null) continue;
                if (!item.IsSubclassOf(typeof(Godot.Resource)) && !item.IsSubclassOf(typeof(Godot.Node)))
                {
                    GD.Print($"CustomTypes can be Godot.Resource or Godot.Node, but not {item}!");
                    continue;
                }
                Script script = ResourceLoader.Load(target.ScriptPath) as Script;
                // Script script = (Script) ResourceLoader.Load(target.ScriptPath);
                // Script script = ResourceLoader.Load<Script>(target.ScriptPath);
                Texture2D icon = new Texture2D();
                if (target.Icon != "") {
                    icon = ResourceLoader.Load(target.Icon) as Texture2D;
                }
                string name = target.Name == ""? item.Name : target.Name;
                AddCustomType(name, item.BaseType.Name, script, icon);
                types.Add(name);

                GD.Print($"Add Custom Type: {name}:{item.BaseType.Name}");
            }
        }

        public override void _EnterTree()
        {
            // Initialization of the plugin goes here.
            SceneChanged += (Node sceneRoot) => GD.Print("SceneChanged: ", sceneRoot);
            SceneClosed += (string filepath) => GD.Print("SceneClosed: ", filepath);
            MainScreenChanged += (string screenName) => GD.Print("MainScreenChanged: ", screenName);
            ResourceSaved += (Resource resource) => GD.Print("ResourceSaved: ", resource);
            ProjectSettingsChanged += () => GD.Print("ProjectSettingsChanged");
            GD.Print("Signals tester registered.");
            AddToolMenuItem(toolname_add, new Callable(this, nameof(RegCustomTypes)));
            AddToolMenuItem(toolname_clear, new Callable(this, nameof(ClearCustomType)));
            RegCustomTypes();
        }

        public override void _Ready()
        {
            GD.Print("plugin ready: CustomTypes");
        }

        public override void _ExitTree()
        {
            RemoveToolMenuItem(toolname_add);
            RemoveToolMenuItem(toolname_clear);
            ClearCustomType();
        }

        void ClearCustomType()
        {
            foreach (var item in types)
            {
                RemoveCustomType(item);
                GD.Print($"RemoveCustomType: {item}");
            }
        }
    }
    }

    #endif
```

## 🟡 Godot XR
- [Godot XR Tools - AR and VR helper library](https://godotengine.org/asset-library/asset/214)
- [Godot XR Tools](https://github.com/GodotVR/godot-xr-tools)
- [Godot XR Docs](https://godotvr.github.io/godot-xr-tools)
- [Godot XR Update](https://godotengine.org/article/godot-xr-progress-update-jan-2023/)
- [Godot XR Template](https://github.com/GodotVR/godot-xr-template)

Godot XR Tools - AR and VR helper library 3.2.0

These are support scenes for creating AR and VR applications in Godot.
Please note: Godot XR Tools v3 has breaking changes compared to v2!
They need to be used in combination with one of the AR or VR interfaces.
This plugin requires features added to Godot 3.5


## 🟡 CLI & LSP 命令行工具与代码提示
- https://docs.godotengine.org/en/stable/tutorials/editor/command_line_tutorial.html
- [GDScript support for Sublime Text](https://packagecontrol.io/packages/GDScript%20(Godot%20Engine)
- [LSP - Language Server Protocol for Sublime Text](https://packagecontrol.io/packages/LSP)
- [LSP Client - GDScript (Godot Engine)](https://lsp.sublimetext.io/language_servers/#gdscript-godot-engine)
- [Language Server Protocol Specification](https://microsoft.github.io/language-server-protocol/specification)
- [TypeScript Wiki - Writing a Language Service Plugin](https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin)
- godot\3.5.1-stable\editor\editor_settings.cpp
- godot\3.5.1-stable\modules\gdscript\language_server\lsp.hpp
- godot\3.5.1-stable\modules\gdscript\language_server\gdscript_language_server.h
- godot\master\modules\gdscript\language_server\godot_lsp.h
- godot\master\modules\gdscript\language_server\gdscript_language_server.h
- godot\master\modules\gdscript\language_server\gdscript_language_protocol.h
- [Vulkan SDK Download](https://vulkan.lunarg.com/sdk/home)
- [COC - Make your Vim/Neovim as smart as VSCode](https://github.com/neoclide/coc.nvim)
- [COC Wiki - Language servers](https://github.com/neoclide/coc.nvim/wiki/Language-servers)

命令行创建远程 git 工程：

```sh
    $user="jimboyeah"
    $repo="godot-tour"
    git init
    curl -u "$user" https://api.github.com/user/repos -d "{`"$name`":`"$repo`"}"
    git remote add origin git@github.com:$user/$repo.git
    git add readme.md
    git commit -m "Welcome to Godot Tour!"
    git push origin master
```
<!-- 
github-recovery-codes.txt

    50ae9-a6438
    07419-b92e9
    f985e-157ee
    d9397-bea24
    8ec6c-fb375
    89d80-27bea
    9fc36-42790
    f60ec-c9f8f
    7144d-c127e
    6ddec-f4fc3
    3d0f5-a5e44
    c5224-3ddf2
    0156c-a5f3e
    f2a36-88cf1
    552af-80475
    cf28b-9621b
 -->

COC 是一个 NVim 上使用的自动完成功能插件，其本身并不提供具体语言的补全功能，而是一个通过插件机制和
LSP 服务提供补全功能的平台。执行 `:CocInfo` 命令查询安装是否成功：

    ## versions

    vim version: NVIM v0.7.0
    node version: v14.0.0
    coc.nvim version: 0.0.82-b7375d5f 2023-01-30 05:09:03 +0800
    coc.nvim directory: C:\Users\OCEAN\.vim\plugged\coc.nvim
    term: vtpcon
    platform: win32

使用 `:h coc-config-languageserver` 命令查询语言服务配置帮助文档：

```json
{
    "languageserver": {
        "godot": {
          "host": "127.0.0.1",
          "filetypes": ["gd", "gdscript", "gdscript3"],
          "port": 6008
        }
    }
}
```
执行 Vim 命令 `:CocConfig` 进入配置页面，并保存配置，再执行`:CocInstall coc-godot` 安装。

Vim 剪贴复制操作需要使用其寄存器，剪贴析默认为 * 寄存，操作寄存器使用 ” 符号，粘贴命令为 P，所以
整个粘贴操作的命令就是 `"*P`，复制命令为 `"*Y`，查看寄存器内容使用命令 `:reg`。

安装插件集市 `:CocInstall coc-marketplace` 然后再执行 `:CocList marketplace` 命令查询
可用插件，并选择安装或卸载，打勾表示已经安装。在 extensions 管理列表中，星号表示启用。

01. 安装命令 `:CocInstall plugin_name`
02. 移除命令 `:CocUninstall plugin_name`
03. 已装扩展 `:CocList extensions`
04. 更新命令 `:CocUpdate`
05. 已安装服务 `:CocList services`
06. 查询可用命令 `:CocList commands`
07. 当前检测到的文件类型 `:CocCommand document.echoFiletype`




LSP - Language Server Protocol 是一种用于给编辑器提供代码提示功能的协议，LSP 协议定义的是
代码编辑器与指定语言语法、关键字和各种对象符号之间的通信文档格式，编辑在编写代码的过程中，会将内容
发送到 LSP 服务器。而各种语言的官方通常会实现自家的 LSP Client，LSP 服务器根据配置文件相询指定
语言对应的 LSP Client，并从其获取符合 LSP 协议规范的数据，并反馈给代码编辑器，通常代码编辑器中
会通过插件的形式提供 LSP 功能。比如，VSCode 或者 Sublime Text 等软件都有相应的 LSP 插件。

LSP - Language Server Protocol 是一种编程辅助工具，简单地说 LSP 协议有两个主体：

- Editor 按照 LSP 的消息规范向 Language Server 方发送用户操作、当前编辑代码的相关信息；
- Server 按照 LSP 协议提供查询服务，响应编辑器请求，并根据程序上下文给出建议、语法检查、自动完成等等。

LSP 的好处就是统一，所以语言通过服务器提供智能操作，通数据通信使用 JSON RPC protocol，用性极高。

除了使用 LSP 本地代码提示服务，另外还有 Language Server Index Format (LSIF) 语言服务器索引，
这种数据格式的目标是支持开发工具或 Web UI 中的丰富代码导航，而不需要源代码的本地副本。该格式在本质上
类似于语言服务器协议(LSP)，它简化了将丰富的代码编辑功能集成到开发工具中的过程。

LSP 提供了丰富的代码创作功能，例如自动完成、类型格式化和丰富的代码导航。为了有效地提供这些功能，语言
服务器要求所有源代码文件都在本地磁盘上可用。LSP 语言服务器还可以将部分或全部文件读入内存并计算抽象
语法树以支持这些功能。LSIF 的目标是增强 LSP 协议以支持没有这些要求的丰富代码导航功能。LSIF 为语言
服务器或其他编程工具定义了一种标准格式，以发布他们关于代码工作空间的知识。此持久化信息稍后可用于响应
对同一工作区的 LSP 请求，而无需运行语言服务器。

当前 LSIF 规范版本还支持：

   1. Document symbols
   2. document links
   3. Go to Definition
   4. Go to Declaration
   5. Go to Type Definition
   6. Find All References
   7. Go to Implementation

LSP Specification 3.16 Major new feature are:

   1. Semantic Token support
   2. Call Hierarchy support
   3. Linked Editing support
   4. Moniker support
   5. Events for file operations (create, rename, delete)
   6. Change annotation support for text edits and file operations (create, rename, delete)


LSP 2.x Messages overview 注意箭头表示消息流向，右侧为 Client ➡️ Server，带回钩表示有回复：

| Document                          | General                               |
| ⬅️ textDocument/publishDiagnostics | ------------------------------------- |
| ➡️ textDocument/didChange          | ↩️ initialize                         |
| ➡️ textDocument/didClose           | ↩️ shutdown                           |
| ➡️ textDocument/didOpen            | ➡️ exit                               |
| ➡️ textDocument/didSave            | ➡️ $/cancelRequest                    |
| ↩️ textDocument/completion         | ------------------------------------- |
| ↩️ completionItem/resolve          | Window                                |
| ↩️ textDocument/hover              | ------------------------------------- |
| ↩️ textDocument/signatureHelp      | ⬅️ window/showMessage                 |
| ↩️ textDocument/references         | ↪️ window/showMessageRequest          |
| ↩️ textDocument/documentHighlight  | ⬅️ window/logMessage                  |
| ↩️ textDocument/documentSymbol     | ⬅️ telemetry/event                    |
| ↩️ textDocument/formatting         | ------------------------------------- |
| ↩️ textDocument/rangeFormatting    | Workspace                             |
| ↩️ textDocument/onTypeFormatting   | ------------------------------------- |
| ↩️ textDocument/definition         | ➡️ workspace/didChangeConfiguration   |
| ↩️ textDocument/codeAction         | ➡️ workspace/didChangeWatchedFiles    |
| ↩️ textDocument/codeLens           | ↩️ workspace/symbol                   |
| ↩️ codeLens/resolve                |                                       |
| ↩️ textDocument/documentLink       |                                       |
| ↩️ documentLink/resolve            |                                       |
| ↩️ textDocument/rename             |                                       |

在 VSCode 或 Sublime Text 使用 LSP 插件。安装插件后，使用 LSP: Troubleshoot Server
来检测 clangd 等语言服务是否正常，即安装了 Clangd 并可以在路径环境变量中搜索到它。


Godot 也实现了 LSP Client 服务，新旧版本默认服务端口分别是 6005 和 6008。这些配置都可以通过
EditorSettings 进行设置：

```C++
// Godot 3.5
GDScriptLanguageServer::GDScriptLanguageServer() {
    thread_running = false;
    started = false;
    use_thread = false;
    host = "127.0.0.1";
    port = 6008;

    _EDITOR_DEF("network/language_server/remote_host", host);
    _EDITOR_DEF("network/language_server/remote_port", port);
    _EDITOR_DEF("network/language_server/enable_smart_resolve", true);
    _EDITOR_DEF("network/language_server/show_native_symbols_in_editor", false);
    _EDITOR_DEF("network/language_server/use_thread", use_thread);
}

// Godot 4.x
class GDScriptLanguageServer : public EditorPlugin {
    GDCLASS(GDScriptLanguageServer, EditorPlugin);

    GDScriptLanguageProtocol protocol;

    Thread thread;
    bool thread_running = false;
    bool started = false;
    bool use_thread = false;
    String host = "127.0.0.1";
    int port = 6005;
    static void thread_main(void *p_userdata);

private:
    void _notification(int p_what);

public:
    GDScriptLanguageServer();
    void start();
    void stop();
};

void GDScriptLanguageServer::start() {
    host = String(_EDITOR_GET("network/language_server/remote_host"));
    port = (int)_EDITOR_GET("network/language_server/remote_port");
    use_thread = (bool)_EDITOR_GET("network/language_server/use_thread");
    if (protocol.start(port, IPAddress(host)) == OK) {
        EditorNode::get_log()->add_message("--- GDScript language server started ---", EditorLog::MSG_TYPE_EDITOR);
        if (use_thread) {
            thread_running = true;
            thread.start(GDScriptLanguageServer::thread_main, this);
        }
        set_process_internal(!use_thread);
        started = true;
    }
}

void GDScriptLanguageServer::stop() {
    if (use_thread) {
        ERR_FAIL_COND(!thread.is_started());
        thread_running = false;
        thread.wait_to_finish();
    }
    protocol.stop();
    started = false;
    EditorNode::get_log()->add_message("--- GDScript language server stopped ---", EditorLog::MSG_TYPE_EDITOR);
}

// godot\modules\gdscript\register_types.cpp     
static void _editor_init() {
    Ref<EditorExportGDScript> gd_export;
    gd_export.instantiate();
    EditorExport::get_singleton()->add_export_plugin(gd_export);

#ifdef TOOLS_ENABLED
    Ref<GDScriptSyntaxHighlighter> gdscript_syntax_highlighter;
    gdscript_syntax_highlighter.instantiate();
    ScriptEditor::get_singleton()->register_syntax_highlighter(gdscript_syntax_highlighter);
#endif

#ifndef GDSCRIPT_NO_LSP
    register_lsp_types();
    GDScriptLanguageServer *lsp_plugin = memnew(GDScriptLanguageServer);
    EditorNode::get_singleton()->add_editor_plugin(lsp_plugin);
    Engine::get_singleton()->add_singleton(Engine::Singleton("GDScriptLanguageProtocol", GDScriptLanguageProtocol::get_singleton()));
#endif // !GDSCRIPT_NO_LSP
}
```

配置 Sublime Text 以运行 GDScript 脚本：

- 先创建构建配置，执行菜单： Tools -> Build System -> New Build System ...
- 将以下 JSON 配置粘贴到配置文件中，并保存到 Packages\User\Godot.sublime-build 文件
- 然后打开 GDScript 脚本，按 Ctrl+B 执行构建命令

```json
{
    "shell_cmd":"%Godot% --help",
    "file_regex": "^(.*.gd):(\\d+):(\\d+):",
    "selector": "text.plain, source.gd, source.gdscript",
    "encoding": "gbk",
    "quiet": true,
    "working_dir": "${file_path:${project_path}}",
    "env": {
        "PATH":"c:/download/games",
        "Godot":"Godot_v3.5.1-stable_win64.exe",
        "Godot4":"Godot_v4.0-beta16_win64.exe",
    },
    "variants":
    [
        {"name": "3.5 Help",            "shell_cmd": "%Godot% --help", },
        {"name": "3.5 Check GDScript",  "shell_cmd": "%Godot% --no-window --check-only -s \"${file}\"", },
        {"name": "3.5 Run GDScript",    "shell_cmd": "%Godot% --no-window -s \"${file}\"", },
        {"name": "3.5 Run GDScript[GUI]", "shell_cmd": "%Godot% -s \"${file}\"", },
        {"name": "3.5 Run Scene",       "shell_cmd": "%Godot% -e \"${file}\"", },
        {"name": "3.5 Run Project",     "shell_cmd": "%Godot% --path \"${file_path}\"", },
        {"name": "4.x Help",            "shell_cmd": "%Godot4% --help", },
        {"name": "4.x Check GDScript",  "shell_cmd": "%Godot4% --headless --check-only -s \"${file}\"", },
        {"name": "4.x Run GDScript",    "shell_cmd": "%Godot4% --headless -s \"${file}\"", },
        {"name": "4.x Run GDScript[GUI]", "shell_cmd": "%Godot4% -s \"${file}\"", },
        {"name": "4.x Run Scene",       "shell_cmd": "%Godot4% \"${file}\"", },
        {"name": "4.x Run Project",     "shell_cmd": "%Godot4% --path \"${file_path}\"", },
    ]
}
```

推荐安装以下插件，以提供语法高亮和自动完成功能：

- GDScript support for Sublime Text
- LSP - Language Server Protocol for Sublime Text

安装好插件后，需要配置 LSP，将以下配置写入 Preferences > Package Settings > LSP > Settings，
添加 "godot-lsp" 客户服务后就可以通过 LSP 提供自动完成，以及上下文提示：

```json
{
    "clients": {
        "godot-lsp": {
            "enabled": true,
            "command": [
                "/PATH/TO/godot-editor.exe", // Update the PATH
                "--headless",  // No rendering, No Window 
                "--script", "path/to/some/scenetree.gd"
            ],
            "tcp_port": 6008, // Godot 4.x 6008, Godot 3.x 6005
            "selector": "source.gdscript",
        }
    }
}
```

启动 Godot 编辑器后，默认就会启用 LSP Client，在编辑器设置中可以修改默认配置。Sublime Text 的
快捷命令面板中，Ctrl-Shift-P，执行 LSP: Troubleshoot Server 可以对语言服务进行检测。如果配置
的端口不一致，就会导致服务连接不上，如果没有使用对应 Godot 版本的端口，那么提供的提示信息就可能不
是最准确的。比如，旧版 ClassDB.instance() 和新版本的 instantiate() 是用于执行类型实例的函数，
可能因为使用的 Godot LSP Client 版本不同而出现不同的提示信息。

Sublime Text 中，启用 Godot LSP 服务时，会自动打开配置中 Godot 编辑器以运行 LSP Client。
如果，已经运行其它同版本的 Godot 编辑器，那么 LSP Client 就可能已经在运行了，自动打开的可以关闭。
Godot 在项目管理列表界面下，LSP Client 是关闭的。

为了解决 Sublime Text 中 LSP 插件默认总是自动运行 Godot 问题，可以使用 --headless 参数启动
Godot，并且使用 --script 指定一个脚本让 Godot 自动结束程序，脚本中只需要执行 quit() 方法，
或者，在其中一个 process 回调方法中返回 true，即可以结束 Godot：

<!-- c:\\download\\games\\Godot_v4.0-beta16_win64.exe --headless --script "C:\\download\\games\\scenetree.gd" -->

```py
#!/usr/bin/env -S godot -s
class_name MyScene
extends SceneTree

func _init():
    print_debug("step 1: _init")
    quit() # exit command: godot --headless --script scenetree.gd

func _iteration(delta):
    assert(Engine.get_version_info().major == 3)
    print_debug("step 3: _iteration (Node._physics_process)")

func _idle(delta):
    assert(Engine.get_version_info().major == 3)
    print_debug("step 3: _idle (Node._process)")

func _physics_process(delta):
    assert(Engine.get_version_info().major == 4)
    root.title = "MyScene 4.x" # root is Window in Godot 4
    #root.set("theme_override_colors/title_color", Color.YELLOW)
    print_debug("step 3: _physics_process")

func _process(delta):
    assert(Engine.get_version_info().major == 4)
    print_debug("step 4: _process")

func _initialize():
    print_debug("step 2: _initialize")

func _finalize():
    print_debug("step 5: _finalize")
```

在双显卡系统，使用 --gpu-index 可以指定显卡，--verbose 可以打印详细信息，Godot 运行项目时就
会打印出当前系统中的显卡信息，Vulkan 驱动默认选择独立显卡：

    Vulkan devices:
      #0: NVIDIA NVIDIA GeForce GTX 1050 - Supported, Discrete
      #1: Intel Intel(R) UHD Graphics 620 - Supported, Integrated
    Vulkan API 1.3.224 - Using Vulkan Device #0: NVIDIA - NVIDIA GeForce GTX 1050

安装 Vulkan SDK，使用 Vulkan Configurator (vkconfig) 可以对程序的 Vulkan 环境配置进行修改。


以下，新建测试脚本 sayhello.gd 以演示通过 Godot 命令运行脚本，方便编辑代码和做测试。

注意，脚本必须继承 **SceneTree** 或 **MainLoop** 类型，这是 Godot 游戏的入口类型。场景树类型
没有 Node 类型中的 ready 之类的回调，使用的是另一套回调。如果代码有语法错误，Godot 运行可能不会
给出信息提示，而是直接退出。比如，混用 TAB 和空格作为缩进，又如圆括号不匹配：

```py
#!/usr/bin/env -S godot -s
extends SceneTree

func _init():
    var a = Vector2 (-10, -10) 
    var b = Vector2 (1, 1)
    var format = "Normalized vector %s is %s, angle between %s and %s is %d degree"
    print(format % [a, a.normalized(), a, b, (a - b).angle()*180/PI])
    quit()


func _ready():
    quit() # why not? SceneTree no _ready() life cycle funtion
```

MainLoop 实现需要提供给 OS 调用，错误就会导致 Godot 终止执行并退出，以下是类型结构参考：

```py
class_name CustomMainLoop
extends MainLoop

var time_elapsed = 0

func _initialize():
    print("Initialized:")
    print("  Starting time: %s" % str(time_elapsed))

func _process(delta):
    time_elapsed += delta
    # Return true to end the main loop.
    return Input.get_mouse_button_mask() != 0 || Input.is_key_pressed(KEY_ESCAPE)

func _finalize():
    print("Finalized:")
    print("  End time: %s" % str(time_elapsed))
```


    Godot Engine v3.5.1.stable.official.6fed1ffa3 - https://godotengine.org
    Free and open source software under the terms of the MIT license.
    (c) 2007-2022 Juan Linietsky, Ariel Manzur.
    (c) 2014-2022 Godot Engine contributors.

    Usage: Godot_v3.5.1-stable_win64.exe [options] [path to scene or 'project.godot' file]

    General options:
      -h, --help                       Display this help message.
      --version                        Display the version string.
      -v, --verbose                    Use verbose stdout mode.
      --quiet                          Quiet mode, silences stdout messages. Errors are still displayed.

    Run options:
      -e, --editor                     Start the editor instead of running the scene.
      -p, --project-manager            Start the project manager, even if a project is auto-detected.
      --debug-server <address>         Start the editor debug server (<IP>:<port>, e.g. 127.0.0.1:6007)
      -q, --quit                       Quit after the first iteration.
      -l, --language <locale>          Use a specific locale (<locale> being a two-letter code).
      --path <directory>               Path to a project (<directory> must contain a 'project.godot' file).
      -u, --upwards                    Scan folders upwards for project.godot file.
      --main-pack <file>               Path to a pack (.pck) file to load.
      --render-thread <mode>           Render thread mode ('unsafe', 'safe', 'separate').
      --remote-fs <address>            Remote filesystem (<host/IP>[:<port>] address).
      --remote-fs-password <password>  Password for remote filesystem.
      --audio-driver <driver>          Audio driver ('WASAPI', 'Dummy').
      --video-driver <driver>          Video driver ('GLES3', 'GLES2').

    Display options:
      -f, --fullscreen                 Request fullscreen mode.
      -m, --maximized                  Request a maximized window.
      -w, --windowed                   Request windowed mode.
      -t, --always-on-top              Request an always-on-top window.
      --resolution <W>x<H>             Request window resolution.
      --position <X>,<Y>               Request window position.
      --low-dpi                        Force low-DPI mode (macOS and Windows only).
      --no-window                      Run with invisible window. Useful together with --script.
      --enable-vsync-via-compositor    When vsync is enabled, vsync via the OS' window compositor (Windows only).
      --disable-vsync-via-compositor   Disable vsync via the OS' window compositor (Windows only).
      --enable-delta-smoothing         When vsync is enabled, enabled frame delta smoothing.
      --disable-delta-smoothing        Disable frame delta smoothing.
      --tablet-driver                  Tablet input driver ('wintab', 'winink') (Windows only).

    Debug options:
      -d, --debug                      Debug (local stdout debugger).
      -b, --breakpoints                Breakpoint list as source::line comma-separated pairs, no spaces (use %20 instead).
      --profiling                      Enable profiling in the script debugger.
      --remote-debug <address>         Remote debug (<host/IP>:<port> address).
      --debug-collisions               Show collision shapes when running the scene.
      --debug-navigation               Show navigation polygons when running the scene.
      --debug-shader-fallbacks         Use the fallbacks of the shaders which have one when running the scene (GL ES 3 only).
      --frame-delay <ms>               Simulate high CPU load (delay each frame by <ms> milliseconds).
      --time-scale <scale>             Force time scale (higher values are faster, 1.0 is normal speed).
      --disable-render-loop            Disable render loop so rendering only occurs when called explicitly from script.
      --disable-crash-handler          Disable crash handler when supported by the platform code.
      --fixed-fps <fps>                Force a fixed number of frames per second. This setting disables real-time synchronization.
      --print-fps                      Print the frames per second to the stdout.

    Standalone tools:
      -s, --script <script>            Run a script.
      --check-only                     Only parse for errors and quit (use with --script).
      --export <preset> <path>         Export the project using the given preset and matching release template. The preset name should match one defined in export_presets.cfg.
                                       <path> should be absolute or relative to the project directory, and include the filename for the binary (e.g. 'builds/game.exe'). The target directory should exist.
      --export-debug <preset> <path>   Same as --export, but using the debug template.
      --export-pack <preset> <path>    Same as --export, but only export the game pack for the given preset. The <path> extension determines whether it will be in PCK or ZIP format.
      --doctool [<path>]               Dump the engine API reference to the given <path> (defaults to current dir) in XML format, merging if existing files are found.
      --no-docbase                     Disallow dumping the base types (used with --doctool).
      --build-solutions                Build the scripting solutions (e.g. for C# projects). Implies --editor and requires a valid project to edit.
      --gdnative-generate-json-api     Generate JSON dump of the Godot API for GDNative bindings.
      --test <test>                    Run a unit test ('string', 'math', 'basis', 'transform', 'physics', 'physics_2d', 'render', 'oa_hash_map', 'gui', 'shaderlang', 'gd_tokenizer', 'gd_parser', 'gd_compiler', 'gd_bytecode', 'ordered_hash_map', 'astar', 'xml_parser', 'theme').


    Godot Engine v4.0.beta16.mono.official.518b9e580 - https://godotengine.org
    Free and open source software under the terms of the MIT license.
    (c) 2014-present Godot Engine contributors.
    (c) 2007-2014 Juan Linietsky, Ariel Manzur.

    Usage: Godot_v4.0-beta16_mono_win64.exe [options] [path to scene or 'project.godot' file]

    General options:
      -h, --help                        Display this help message.
      --version                         Display the version string.
      -v, --verbose                     Use verbose stdout mode.
      -q, --quiet                       Quiet mode, silences stdout messages. Errors are still displayed.

    Run options:
      --, ++                            Separator for user-provided arguments. Following arguments are not used by the engine, but can be read from `OS.get_cmdline_user_args()`.
      -e, --editor                      Start the editor instead of running the scene.
      -p, --project-manager             Start the project manager, even if a project is auto-detected.
      --debug-server <uri>              Start the editor debug server (<protocol>://<host/IP>[:<port>], e.g. tcp://127.0.0.1:6007)
      --quit                            Quit after the first iteration.
      -l, --language <locale>           Use a specific locale (<locale> being a two-letter code).
      --path <directory>                Path to a project (<directory> must contain a 'project.godot' file).
      -u, --upwards                     Scan folders upwards for project.godot file.
      --main-pack <file>                Path to a pack (.pck) file to load.
      --render-thread <mode>            Render thread mode ['unsafe', 'safe', 'separate'].
      --remote-fs <address>             Remote filesystem (<host/IP>[:<port>] address).
      --remote-fs-password <password>   Password for remote filesystem.
      --audio-driver <driver>           Audio driver ['WASAPI', 'Dummy'].
      --display-driver <driver>         Display driver (and rendering driver) ['windows' ('vulkan', 'opengl3'), 'headless' ('dummy')].
      --rendering-method <renderer>     Renderer name. Requires driver support.
      --rendering-driver <driver>       Rendering driver (depends on display driver).
      --gpu-index <device_index>        Use a specific GPU (run with --verbose to get available device list).
      --text-driver <driver>            Text driver (Fonts, BiDi, shaping).
      --tablet-driver <driver>          Pen tablet input driver.
      --headless                        Enable headless mode (--display-driver headless --audio-driver Dummy). Useful for servers and with --script.
      --write-movie <file>              Writes a video to the specified path (usually with .avi or .png extension).
                                        --fixed-fps is forced when enabled, but it can be used to change movie FPS.
                                        --disable-vsync can speed up movie writing but makes interaction more difficult.

    Display options:
      -f, --fullscreen                  Request fullscreen mode.
      -m, --maximized                   Request a maximized window.
      -w, --windowed                    Request windowed mode.
      -t, --always-on-top               Request an always-on-top window.
      --resolution <W>x<H>              Request window resolution.
      --position <X>,<Y>                Request window position (if set, screen argument is ignored).
      --screen <N>                      Request window screen.
      --single-window                   Use a single window (no separate subwindows).
      --xr-mode <mode>                  Select XR (Extended Reality) mode ['default', 'off', 'on'].

    Debug options:
      -d, --debug                       Debug (local stdout debugger).
      -b, --breakpoints                 Breakpoint list as source::line comma-separated pairs, no spaces (use %20 instead).
      --profiling                       Enable profiling in the script debugger.
      --gpu-profile                     Show a GPU profile of the tasks that took the most time during frame rendering.
      --gpu-validation                  Enable graphics API validation layers for debugging.
      --gpu-abort                       Abort on graphics API usage errors (usually validation layer errors). May help see the problem if your system freezes.
      --remote-debug <uri>              Remote debug (<protocol>://<host/IP>[:<port>], e.g. tcp://127.0.0.1:6007).
      --debug-collisions                Show collision shapes when running the scene.
      --debug-paths                     Show path lines when running the scene.
      --debug-navigation                Show navigation polygons when running the scene.
      --debug-stringnames               Print all StringName allocations to stdout when the engine quits.
      --frame-delay <ms>                Simulate high CPU load (delay each frame by <ms> milliseconds).
      --time-scale <scale>              Force time scale (higher values are faster, 1.0 is normal speed).
      --disable-vsync                   Forces disabling of vertical synchronization, even if enabled in the project settings. Does not override driver-level V-Sync enforcement.
      --disable-render-loop             Disable render loop so rendering only occurs when called explicitly from script.
      --disable-crash-handler           Disable crash handler when supported by the platform code.
      --fixed-fps <fps>                 Force a fixed number of frames per second. This setting disables real-time synchronization.
      --print-fps                       Print the frames per second to the stdout.

    Standalone tools:
      -s, --script <script>             Run a script.
      --check-only                      Only parse for errors and quit (use with --script).
      --export-release <preset> <path>  Export the project in release mode using the given preset and output path. The preset name should match one defined in export_presets.cfg.
                                        <path> should be absolute or relative to the project directory, and include the filename for the binary (e.g. 'builds/game.exe').
                                        The target directory must exist.
      --export-debug <preset> <path>    Export the project in debug mode using the given preset and output path. See --export-release description for other considerations.
      --export-pack <preset> <path>     Export the project data only using the given preset and output path. The <path> extension determines whether it will be in PCK or ZIP format.
      --convert-3to4 [<max_file_kb>] [<max_line_size>]
                                        Converts project from Godot 3.x to Godot 4.x.
      --validate-conversion-3to4 [<max_file_kb>] [<max_line_size>]
                                        Shows what elements will be renamed when converting project from Godot 3.x to Godot 4.x.
      --doctool [<path>]                Dump the engine API reference to the given <path> (defaults to current dir) in XML format, merging if existing files are found.
      --no-docbase                      Disallow dumping the base types (used with --doctool).
      --build-solutions                 Build the scripting solutions (e.g. for C# projects). Implies --editor and requires a valid project to edit.
      --dump-gdextension-interface      Generate GDExtension header file 'gdextension_interface.h' in the current folder. This file is the base file required to implement a GDExtension.
      --dump-extension-api              Generate JSON dump of the Godot API for GDExtension bindings named 'extension_api.json' in the current folder.
      --startup-benchmark               Benchmark the startup time and print it to console.
      --startup-benchmark-file <path>   Benchmark the startup time and save it to a given file in JSON format.




## 🟡 TSCN & TRES 资源文件格式
- https://docs.godotengine.org/en/stable/development/file_formats/tscn.html
- https://github.com/godotengine/godot/blob/master/scene/resources/resource_format_text.cpp
- https://github.com/godotengine/godot/blob/master/core/variant_parser.cpp
- godot-docs\development\file_formats\tscn.rst
- godot\scene\resources\resource_format_text.cpp
- godot\core\variant_parser.cpp

TSCN (text scene) 字符串格式场景文件，Godot 加载后会编译成二进制文件保存在 `.import/` 或 
工作目录，Godot 4.x 则保存在 `.godot/imported/`。

Godot 在底层定义了一个专用用于文本文件格式的解析器，VariantParser，通过个变体解析器，可以将各种
Godot 资源保存到文本格式文件中。场景文件 TSCN 就是其中的一种，资源文件，这里指的是 `Resource`
这种资源类型保存的文件，也同样使用文本格式。每个文本文件都包含一个 File Descriptor，用于表示其
记录的类型。

TSCN 文件有 5 个区段，分别开头表示注解：

0. File Descriptor    - ``[gd_scene]``
1. External resources - ``[ext_resource]``
2. Internal resources - ``[sub_resource]``
3. Nodes              - ``[node]``
4. Signal Connections - ``[connection]``

所有区段中使用的实体使用方括号包括，实体可以添加任意的 key="value" 键值对，实体后可以紧跟属性设置，
使用 property=value 这样的格式书写。

Godot 4.x 使用的格式版本为 Version 3，使用字符串作为资源 ID、UID，与前一个版本不兼容：

- Version 2: changed names for Basis, AABB, Vectors, PoolVectors, etc.
- Version 3: new string ID for ext/subresources, and uid, breaks forward compat.

需要将 Godot 4.x 工程降级为低版本的 Godot 3.x 工程，则需要考虑类型名称变化、资源文件格式问题，
还有新版本中 GDScript 关键字、注解功能的差别。手动降级 Godot 工程的操作步骤：

- 修改 project.godot 中的版本号，将新版本 config_version=5，旧版本 Godot 3.x 版本为 4；
- 修改场景文件中的版本号，改为 format=2；
- 删除场景中的 uid 属性，并重新设置实体的 id 属性，去掉双引号及字符串，直接使用一个唯一的数值；
- 相应地修改资源引用 SubResource(id) 或 ExtResource(id)；
- 根据节点及数据类型修改 type 属性，更新相应的名称，以及结构；
- 更新 GDScript 脚本中关键字、注解的使用，同时修改类型名称；

例如，Godot 4.x 中的 RPC 标注与 Godt 3.5 中的关键字等价关系：

|      Godot 3.5 keywords     |                 Godot 4 @rpc annotations                |
|-----------------------------|---------------------------------------------------------|
| remote                      | "any_peer", "call_remote"                               |
| remotesync                  | "any_peer", "call_local"                                |
| master                      | "authority", "call_remote"                              |
| mastersync                  | "authority", "call_local"                               |
| rpc_unreliable()            | @rpc("unreliable")                                      |
| rpc_unreliable(master func) | @rpc or @rpc("authority", "call_remote", "reliable", 1) |


```py
    ; Godot 3.5
    [gd_scene load_steps=3 format=2]
    
    [ext_resource path="res://Sprite_2D.gd" type="Script" id=1]
    [ext_resource path="res://MyNode2D.cs" type="Script" id=2]
    [ext_resource path="res://icon.svg" type="Texture" id=3]

    [node name="Cube" type="Spatial" parent="."]
    transform=Transform( 1.0, 0.0, 0.0 ,0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 )

    ; Godot 4.x
    [gd_scene load_steps=3 format=3 uid="uid://bxv0sdh81ec2f"]
    [ext_resource path="res://Sprite_2D.gd" type="Script" id="Script_xxx1"]
    [ext_resource path="res://MyNode2D.cs" type="Script" id="Script_xxx2"]
    [ext_resource path="res://icon.svg" type="Texture" id="Script_xxx3"]

    [node name="Cube" type="Node3D" parent="."]
    transform=Transform( 1.0, 0.0, 0.0 ,0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 )
```

文件描述符号是场景文件的开头区段，定义场景文件的格式版本和加载步骤数：外部资源数量+场景文件本身。即使
load_steps 数值不正确，引擎还是会加载场景文件，但会影响使用这个值的代码。

除了外部资源，场景文件还可以内嵌资源，比如节点内嵌的脚本，分别使用 `ExtResource` 和 `SubResource`
引用 ID 指定的外部资源和内嵌资源。内嵌资源包括 meshes, materials, GDScript 等等数据。

比如以下场景文件，根节点引用了内嵌脚本资源，内嵌资源使用 [sub_resource] 实体定义，并通过资源属性
`script/source` 指定脚本源代码，代码按原样直接紧接资源属性的 = 后面，并使用双引号包括，源代码中
的双引号和 \ 会被转义为 \" 和 \\：

```py
    [gd_scene load_steps=2 format=2]

    [sub_resource type="GDScript" id=1]
    resource_name = "builtin-gdscript"
    script/source = "extends Spatial

    # Declare member variables here. Examples:
    # var b = \"text\\newline\"


    # Called when the node enters the scene tree for the first time.
    func _ready():
        pass # Replace with function body.
    "

    [node name="Spatial" type="Spatial"]
    script = SubResource( 1 )
```

节点和外部资源是场景树层次结构组织的基本方式，[ext_resource] 实体定义外部资源，[node] 定义节点。
场景文件中第一个定义节点即为场景的根节点，子节点通过 parent 属性指定父级节点。

```py
    [node name="Player" type="Node3D"]             ; The scene root
    [node name="Arm" parent="." type="Node3D"]     ; Parented to the scene root
    [node name="Hand" parent="Arm" type="Node3D"]
    [node name="Finger" parent="Arm/Hand" type="Node3D"]
```

场景树中一些节点需要引用其它节点，场景文件中需要使用``NodePath(Path/To/Node)``来指定节点路径，
比如，MeshInstance3D 中的骨架属性，需要使用``NodePath()``引用指定骨架节点。动画节点 Animation
也类似地使用``NodePath()``引用指定节点的属性：

```py
    [node name="mesh" type="MeshInstance3D" parent="Armature001"]
    mesh = SubResource(1)
    skeleton = NodePath("..:")


    [sub_resource id=3 type="Animation"]
    ...
    tracks/0/type = "transform"
    tracks/0/path = NodePath("Cube:")
    ...
```

资源类型作为 Godot 最常用的类型之一，它本身也可以像场景一样，使用 TSCN 这样的通用文本格式保存，
只是扩展名为 .tres，一个新创建的资源类型，它的文本格式内容如下，只有一个 File Descriptor 实体，
和一个类型实体 [resource]。文件描述符用于标志这个资源文件所属的类型，这里的类型就是 `Resource`，
而资源类型实体 [resource] 用于定义资源类型的属性数据，这里没有任何属性数据，所以它就是一个全新的
资源对象：

```py
[gd_resource type="Resource" format=2]

[resource]
```

通过 GDSCript 扩展资源类型后，可以使用资源拥有各种功能，例如 `MyResource`：

```py
    class_name MyResource
    extends Resource

    export var title = ""
    export var subtitle = ""
    export(NodePath) var visual = null
    export(String, FILE) var file_path = "user://local.file"
    export(String, MULTILINE) var text = ""

    # Called when the node enters the scene tree for the first time.
    func _ready():
        pass # Replace with function body.
```

资源类型的属性也可以是资源，也可使用 ExtResource 或 SubResource 进行扩展，使得自定义资源类型
拥有各种用途，记录各种数据资源。

在 Godot 编辑器中双击打开资源文件，在属性面板中可以将 MyResource 附加到资源文件的脚本属性，这样
设置后，资源文件中的定义的资源就成为 MyResource 类型，并且可以通过脚本中的导出变量设置更多的资源
属性或数据。比如将，MyResource 脚本内容作为资源的 **text** 属性记录到资源文件：

```py
[gd_resource type="Resource" load_steps=2 format=2]

[ext_resource path="res://course/MyResource.gd" type="Script" id=1]

[resource]
script = ExtResource( 1 )
title = "Demo Resource"
subtitle = ""
visual = NodePath("Robot")
file_path = "user://local.file"
text = "extends Resource

export var title = \"\"
export(String, MULTILINE) var text = \"\"

# Called when the node enters the scene tree for the first time.
func _ready():
    pass # Replace with function body.
"
```

注意 `script = ExtResource( 1 )` 这里，MyResource 脚本将附加到资源上，并作为资源的扩展类型。
将脚本附加到一种类型中，并通过脚本扩展这种类型的这种机制是 Godot 顶级父类 Object 提供的能力。这是
与通知机制、信号机制等等之外的，另一种最基础的能力。


提示：修改自定义类型后，再编辑资源文件时，可能出现资源属性不能更新为最新状态，这时可以重新加载工程。


此外，场景文件中还有其它许多不同的节点类型，及数据格式，参考 TSCN 文件格式文档。

源代码中定义了文本资源加载器，使用 is_scene 指示加载的是 TSCN 场景资源文件，即等同 [gd_scene]。
ResourceLoaderText::open() 负责打开文本资源文件，并通过 VariantParser::parse_tag() 解析
资源文件中的实体定义。VariantParser::parse_value() 中定义了支持使用的数据类型：

- godot\scene\resources\resource_format_text.cpp
- godot\core\variant_parser.cpp

```py
    # Godot 3.5
    } else if (id == "Vector2") {
    } else if (id == "Rect2") {
    } else if (id == "Vector3") {
    } else if (id == "Transform2D" || id == "Matrix32") { //compatibility
    } else if (id == "Plane") {
    } else if (id == "Quat") {
    } else if (id == "AABB" || id == "Rect3") {
    } else if (id == "Basis" || id == "Matrix3") { //compatibility
    } else if (id == "Transform") {
    } else if (id == "Color") {
    } else if (id == "NodePath") {
    } else if (id == "RID") {
    } else if (id == "Object") {
    } else if (id == "Resource" || id == "SubResource" || id == "ExtResource") {
    } else if (id == "InputEvent") {
    } else if (id == "PoolByteArray" || id == "PackedByteArray" || id == "ByteArray") {
    } else if (id == "PoolIntArray" || id == "PackedInt32Array" || id == "PackedInt64Array" || id == "IntArray") {
    } else if (id == "PoolRealArray" || id == "PackedFloat32Array" || id == "PackedFloat64Array" || id == "FloatArray") {
    } else if (id == "PoolStringArray" || id == "PackedStringArray" || id == "StringArray") {
    } else if (id == "PoolVector2Array" || id == "PackedVector2Array" || id == "Vector2Array") {
    } else if (id == "PoolVector3Array" || id == "PackedVector3Array" || id == "Vector3Array") {        } else if (id == "PoolColorArray" || id == "PackedColorArray" || id == "ColorArray") {

    # Godot 4.x
    } else if (id == "Vector2i") {
    } else if (id == "Rect2") {
    } else if (id == "Rect2i") {
    } else if (id == "Vector3") {
    } else if (id == "Vector3i") {
    } else if (id == "Vector4") {
    } else if (id == "Vector4i") {
    } else if (id == "Transform2D" || id == "Matrix32") { //compatibility
    } else if (id == "Plane") {
    } else if (id == "Quaternion" || id == "Quat") { // "Quat" kept for compatibility
    } else if (id == "AABB" || id == "Rect3") {
    } else if (id == "Basis" || id == "Matrix3") { //compatibility
    } else if (id == "Transform3D" || id == "Transform") { // "Transform" kept for compatibility with Godot <4.
    } else if (id == "Projection") { // "Transform" kept for compatibility with Godot <4.
    } else if (id == "Color") {
    } else if (id == "NodePath") {
    } else if (id == "RID") {
    } else if (id == "Object") {
    } else if (id == "Resource" || id == "SubResource" || id == "ExtResource") {
    } else if (id == "Array") {
    } else if (id == "PackedByteArray" || id == "PoolByteArray" || id == "ByteArray") {
    } else if (id == "PackedInt32Array" || id == "PackedIntArray" || id == "PoolIntArray" || id == "IntArray") {
    } else if (id == "PackedInt64Array") {
    } else if (id == "PackedFloat32Array" || id == "PackedRealArray" || id == "PoolRealArray" || id == "FloatArray") {
    } else if (id == "PackedFloat64Array") {
    } else if (id == "PackedStringArray" || id == "PoolStringArray" || id == "StringArray") {
    } else if (id == "PackedVector2Array" || id == "PoolVector2Array" || id == "Vector2Array") {
    } else if (id == "PackedVector3Array" || id == "PoolVector3Array" || id == "Vector3Array") {
    } else if (id == "PackedColorArray" || id == "PoolColorArray" || id == "ColorArray") {
```


## 🟡 Debug & Profiler 调试与性能分析、优化
- [The Profiler](https://docs.godotengine.org/en/latest/tutorials/scripting/debug/the_profiler.html)
- [Optimization](https://docs.godotengine.org/en/stable/tutorials/performance/index.html)
- [Debugging and profiling](https://docs.godotengine.org/en/latest/contributing/development/debugging/index.html)
- [Using C++ profilers](https://docs.godotengine.org/en/stable/development/cpp/using_cpp_profilers.html)
- [GDQuest Optimization 3D](https://www.gdquest.com/tutorial/godot/3d/optimization-3d/)
- [GDQuest Optimization Code](https://www.gdquest.com/tutorial/godot/gdscript/optimization-code/)
- [Optimizing for size](https://docs.godotengine.org/en/stable/development/compiling/optimizing_for_size.html)
- https://github.com/VerySleepy/verysleepy/wiki/User-Interface
- godot-docs\tutorials\scripting\debug\overview_of_debugging_tools.rst
- godot-docs\tutorials\scripting\debug\the_profiler.rst
- godot-docs\development\cpp\using_cpp_profilers.rst

使用 Godot 命令行参数调调整窗口位置、大小以及置顶状态方便网络调试开发：

```sh
    #  -t, --always-on-top               Request an always-on-top window.
    #  --resolution <W>x<H>              Request window resolution.
    #  --position <X>,<Y>                Request window position (if set, screen argument is ignored).

    $godot3 = "C:\download\games\Godot_v3.5.1-stable_win64.exe"
    $godot4 = "C:\download\games\Godot_v4.0-rc1_win64.exe"
    $godot3m = "C:\download\games\Godot_v3.5.1-stable_mono_win64\Godot_v3.5.1-stable_mono_win64.exe"
    $godot4m = "C:\download\games\Godot_v4.0-rc1_mono_win64\Godot_v4.0-rc1_mono_win64.exe"
    &$godot3 --path . --client --gpu-index 1 -t --resolution 180x240 --position 1200,500
    # &$godot4 --path . --client --gpu-index 1 -t --resolution 180x240 --position 800,400
```

![the Graphics Monitor](https://gdquest.com/tutorial/godot/3d/optimization-3d/monitors.png)

Godot 自带的图形监视面板收集以下几个重要的 3D 场景绘制的信息：

- **Mat changes** are when the CPU tells the GPU to replace a material with a new one.
- **Shader changes** are when you change shader code.
- **Surface changes** are when you update the world’s geometry.
- **Draw calls** are the CPU telling the GPU to render something.

通过优化网格、着色器等等，可以降低对 GPU 执行的 Draw calls，并提供 GPU 性能。

在使用 C++ 分析器之前，需要为 Godot 主程序设置调试符号信息，官方提供的下载已经清理了调试符号数据以
减小下载数据。需要在本地重新编译 Godot 并且按以下编译配置保留调试符号数据：

- For editor binaries: ``target=release_debug use_lto=yes``
- For debug export templates: ``target=release_debug use_lto=yes``
- For release export templates: ``tools=no target=release debug_symbols=yes``

默认情况下，导出模板中已经删除调试符号，对于导出模板 ``debug_symbols=yes`` 是必需的。

不要使用编译器的 ``strip`` 命令，它会清理调试符号，这样编译的程序并不能有效地进行性能分析。

Godot 4.x 受到 Windows 10 配置影响，在开发过程中，调试程序遇到首次启动慢的情况，因为开发中每次
启动都是一个新程序，需要配置，即每次启动都是首次运行，所以特别慢，旧版本中不存在这样的问题。

表现为两个层面：

- Godot 编辑器中执行调试时，程序启动慢。
- 导出的工程执行程序在首次启动慢，后面启动速度正常，但修改可执行程序文件名后，首次启动依然慢。

测试程序不涉及网络访问，所以不需要修改防火墙规则配置。

问题指向 NVIDIA 驱动安装未正确安装，可能是因为禁用了独立显卡，导致程序启动慢。Godot 4.x 升级后
使用了 Vulkan 驱动，这需要程序重新进行配置。也有可能是 Godot 尝试检查所有连接的 USB 设备，检查
键盘、游戏控制器、VR耳机等。USB 控制器/驱动程序未正确安装，重新安装驱动程序将解决此问题。


C++ 应用性能分析器推荐：

- VerySleepy (Windows) http://www.codersnotes.com/sleepy/
- HotSpot (Linux) https://github.com/KDAB/hotspot
- Xcode Instruments (macOS) https://developer.apple.com/xcode/

在使用 VerySleepy 分析器前，先启动 Godot，或者工程，如果启动了项目管理器，需要确保 Godot 运行了项目。
因为分析器并不能分析 Godot 工程管理器产生的子线程，每个 Godot 编辑器都是它的子线程运行的。

然后运行 VerySleepy 对已经运行中的 Godot 进程实例进行分析，从进程列表中选择。点击 **Profile All** 
按钮启动分析并记录数据，然后操作 Godot 工程进行测试。完成测试后，点击 **Stop** (*not* Abort) 结束记录。
然后，对记录到的 API 数据进行分析。

数据记录包含一个函数列表，可以使用右键菜单过滤指定模块的 API：

- **Name** - the name of the function. If debugging symbols are not available, the instruction address will be displayed instead.
- **Exclusive** - displays the time spent during the execution of that function, but not of any of its callees.
- **Inclusive** - displays the time spent during the execution of that function, including any other functions called from it (and their callees, and so on).
- **% Exclusive**, **% Inclusive** - as above, but as a percentage of the program's total execution time.
- **Module** - the module (.exe or .dll file) this function belongs to.
- **Source File** - the path to the source code file containing the function. If debugging symbols are not available, this column will display [unknown]).
- **Source Line** - the line number corresponding to the beginning of the function's definition. If debugging symbols are not available, this column will display 0).
- **Address** - the address in memory of the function's compiled code.


Godot 自带的性能分析器在调试器面板中，通过手动点击 Start 按钮启动，然后运行工程就可以记录相应 API
的时间消耗信息，收集到数据后就可以关闭 Profiler，然后对数据进行分析，以确定性能瓶颈在 CPU 还 GPU。


Measuring manually in microseconds by get_ticks_usec()

```py
class_name MyMainLoop
extends MainLoop

var time_elapsed = 0

func _initialize():
    print("Initialized:")
    print("  Starting time: %s" % str(time_elapsed))
    _test()

func _process(delta: float):
    time_elapsed += delta
    # Return true to end the main loop.
    return Input.get_mouse_button_mask() != 0 || Input.is_key_pressed(KEY_ESCAPE)

func _physics_process(delta: float):
    pass
    return true # exit main loop

func _finalize():
    print("Finalized:")
    print("  End time: %s" % str(time_elapsed))

# in Godot 3.x 
# bool _idle(delta: float) virtual      -> Node._process().
# bool _iteration(delta: float) virtual -> Node._physics_process().

func _test():
    var dim = 9455
    var arr2D = [range(dim)]
    arr2D.resize(dim) # 10000x10000 array, value of new element is null

    # OS.get_ticks_usec() in Godot 3.x
    var ticks = Time.get_ticks_usec()
    print_debug("Ticks start: %d" % [ticks])

    for i in range(dim):
        arr2D[i] = range(dim)
        for j in range(dim):
            var k = i+j*dim
            arr2D[i][j] = k

    var elapsed = (Time.get_ticks_usec() - ticks) / 1000000
    print_debug("  time_elapsed: %d seconds." % elapsed)

    var arr1D = range(dim * dim)
    ticks = Time.get_ticks_usec()

    for i in range(dim * dim):
        arr1D[i] = i

    elapsed = (Time.get_ticks_usec() - ticks) / 1000000
    print_debug("  time_elapsed: %d seconds." % elapsed)

    # print_debug("  123".to_int(), int("456"), "789" as int)
```

从输出结果来看，CPU Intel i7-8650U，二维数组因为多了一个 for 结构，以及函数 range()，它涉及
内存动态分配的调用，这非常消耗时间：

    Initialized:
      Starting time: 0
    Ticks start: 1533756
      time_elapsed: 19 seconds.
      time_elapsed: 6 seconds.
    Finalized:
      End time: 0.15

Godot 没有提供直接初始化大数组的方法，使用 range() 和 resize() 函数间接获取大数组需要的内存，
或者通过 C++ 底层进行内存动态分配。

每个 Variant 实例至少占用内存为 20 bytes，使用 float 作为浮点数类型，如果使用 double 则
占用 30 bytes。另外像 PoolVector，aabb，metrix 这些数组或专用类型的额外内存占用另计。

以 10000 方形二维数组为例，使用默认的变体类型大小就占用 2GB = 10000 * 10000 * 20 内存，
这是相当占用内存！


## 🟡 Signals & Notifications 信号与消息
- [Using signals](https://docs.godotengine.org/en/stable/getting_started/step_by_step/signals.html)
- [Godot notifications](https://docs.godotengine.org/en/3.5/tutorials/best_practices/godot_notifications.html)
- [GDScript grammar](https://docs.godotengine.org/en/stable/development/file_formats/gdscript_grammar.html)
- [Idle and Physics Processing](https://docs.godotengine.org/en/stable/tutorials/scripting/idle_and_physics_processing.html)
- [process and physics_process in Godot](http://kehomsforge.com/tutorials/single/process-physics-process-godot)

Godot 在基础类型 **Object** 实现了消息机制，用于响应各种 engine-level 的消息，比如，引擎要对 
CanvasItem 执行绘图功能，它不会直接去调用 darw() 方法，而是通过发送一个绘图消息，然后由需要响应
这一消息的 CanvasItem 进行绘图动作，而不需要响应绘图消息的对象就不会有相应的动作，对象之间实现了解耦。

```py
_notification(NOTIFICATION_DRAW)
```

典型的场景节点，它的整个生命周期中有一系列专用消息以及相应的专用函数，大多消息常量都定义在 Node：

```py
_ready() : NOTIFICATION_READY

_enter_tree() : NOTIFICATION_ENTER_TREE

_exit_tree() : NOTIFICATION_EXIT_TREE

_process(delta) : NOTIFICATION_PROCESS

_physics_process(delta) : NOTIFICATION_PHYSICS_PROCESS

_draw() : NOTIFICATION_DRAW
```

脚本中可以定义 `_notification(what:int)` 函数响应引擎发出的所有消息，通常只需要处理一部分消息，
只需要定义指定的响应函数，如上面罗列的响应函数对应一个消息。

如果脚本在没有场景的情况下初始化自己的节点子树，那么代码应该在初始化方法 `_init()` 这里执行，其他
属性或 SceneTree 独立初始化也应在此处运行。初始化方法在 `_ready` 或 `_enter_tree` 之前触发，
但在脚本创建并初始化其属性之后触发。

如果一个节点需要触发作为另一个节点的父节点发生的行为，无论它是否作为主/活动场景的一部分发生，可以使用
PARENTED 通知。

例如，将节点的方法连接到父节点上的自定义信号，而不会失败：

```py
extend Node

# "one" is an "initialized value". These DO NOT trigger the setter.
# If someone set the value as "two" from the Inspector, this would be an
# "exported value". These DO trigger the setter.
export(String) var test = "one" setget set_test

func _init():
    # "three" is an "init assignment value".
    # These DO NOT trigger the setter, but...
    test = "three"
    # These DO trigger the setter. Note the `self` prefix.
    self.test = "three"

func set_test(value):
    test = value
    print("Setting: ", test)


var parent_cache

func connection_check():
    return parent.has_user_signal("interacted_with")

func _notification(what):
    match what:
        NOTIFICATION_PARENTED:
            parent_cache = get_parent()
            if connection_check():
                parent_cache.connect("interacted_with", self, "_on_parent_interacted_with")
        NOTIFICATION_UNPARENTED:
            if connection_check():
                parent_cache.disconnect("interacted_with", self, "_on_parent_interacted_with")

func _on_parent_interacted_with():
    print("I'm reacting to my parent's interaction!")
```

信号是节点之间进行通信的手段，和消息一样，它们不仅仅在节点对象中使用。观察者模式中，有三个要素：

- 被观察者：是消息、信号的生产方，通过调用 emit_signal() 方法发布消息；
- 观察者：是消息、信号的消费方，调用被观察者的 connect() 方法注册处理函数，然后等待要处理的信号；
- 消息、信号：是一个数据集，通过一个名称将观察者与被观察者联系起来；

基础类 **Object** 中与信号相关的方法如下：

```py
void add_user_signal(signal: String, arguments: Array = [  ]) const 

Error connect(signal: String, target: Object, method: String, binds: Array = [  ], flags: int = 0) 

void disconnect(signal: String, target: Object, method: String)

void emit_signal(signal: String, ...) vararg
```

通过 add_user_signal 方法可以添加用户自定义信号，也可以通过 GDScript 脚本中 signal 关键字
定义用户信号，GDScript grammar 规范文档显示有两条与信号有关的规则：

    signalDecl = "signal" IDENTIFIER [ signalParList ] NEWLINE ;
    signalParList = "(" [ IDENTIFIER { "," IDENTIFIER } ] ")" ;

定义一个用户信号使用 **signal** 关键字，后跟信号标识符，还可以设置信号要传递的参数列表。

创建一个结构如下的场景用于演示自定义信号：

    +-- Node2D
        +-- Label
        +-- ButtonA
        +-- ButtonB

给根节点 Node2D 绑定以下脚本：

- 脚本定义了一个 SignalReceived 信号，它带一个整数作为参数；
- 定义了一个 `_on_pressed()` 方法用来响应按键动作；
- 当按按下时触发处理，并调用 emit_signal() 方法发布自定义信号；

```py
extends Node2D

signal SignalReceived(count)

var count = 0

func _ready():
    pass

func _on_pressed(name):
    $Label.text = name + " pressed"
    count += 1
    emit_signal("SignalReceived", count)
```

给两个按钮绑定以下脚本，脚本在按钮节点加载完成时，向根节点 Node2D 注册信号响应函数：

- connect() 方法注册 `_on_feedback()` 作为自定义信号的响应函数；
- 响应函数的参数将由 Node2D 在 emit_signal() 方法中传递过来，使用空数组表示连接信号时不绑定参数；
- 响应函数中使用 SceneTreeTween 做一个延时效果后，再更新按钮的文字，显示当前动作次数累计值；

```py
extends Button

func _ready():
    $"..".connect("SignalReceived", self, "_on_feedback", [], CONNECT_PERSIST)

func _on_feedback(count:int):
    var tween = create_tween()
    tween.tween_interval(1)
    tween.tween_callback(self, "_update_log", [count])
    
func _update_log(count:int):
    self.text = "count %s" % (count)
```

需要注意一点，两个按钮都会响应 SignalReceived 信号，所以按下任意一个按钮后，Node2D 会更新 Label
内容，然后发布自定义信号后，两个按钮都会响应这个信号，并更新按钮的文字。

另外，按键动作响应函数可以使用 Godot IDE 绑定信号，先选择场景节点，再在 Node -> Signals 面板
进行信号绑定操作，包括添加参数绑定。IDE 绑定信号就是在场景文件中添加一条 connection 信息，如：

    [connection signal="pressed" from="Node" to="Node" method="_some_func"]


信号还可以配合 yield() 方法使用，以下代码片段都是在等待信号，在信号出现前会暂停函数的执行：

```py
yield(get_tree(), "idle_frame") # 下一帧恢复执行
yield(get_node("AnimationPlayer"), "finished") #  动画 AnimationPlayer 播放完毕后继续执行
yield(get_tree().create_timer(5.0), "timeout") #  暂停5秒后执行
yield(button_func(), "completed") #   函数执行完毕后执行
yield($Button0, "pressed") #  按钮点击后执行
```


## 🟡 InputMap 用户输入与映射
- [User Inputs](https://docs.godotengine.org/en/3.5/tutorials/inputs/index.html)
- https://github.com/expressobits/character-controller


现代的游戏输入硬件非常丰富，三大游戏平台分别是：

- PC Game 台式机游戏；
- Console Game 主机游戏，如 PS2、XBox 等；
- Web Game 网页游戏，以浏览器页面为载体；

可用的输入设备也是五花八门，有传统的键盘、Joystick、Gamepad，也有仿真赛车方向盘，甚至是触屏虚拟手柄，
Godot 就提供了一个 TouchScreenButton 用于触摸屏的输入。对于一个支持多端开发的游戏引擎，这么多的
输入设备，如果直接硬编码，会给后期带来各种适配麻烦。而在输入与游戏应用之间设置一个映射层，可以很好地解耦。
用户操作硬件产生各种 InputEvent，通过 InputMap 设置相应的 Action，在游戏逻辑中直接使用 Action 
作为用户输入，不同的 Action 由什么硬件产生就不再需要开发者关注。只需要设置好 Action 与 InputEvent 
的映射关系，用户操作按映射关系产生相应的动作。

![Input Event Flow](https://docs.godotengine.org/en/3.5/_images/input_event_flow.png)

用户输入会先进入标准 `Node._input()` 函数，任何节点中覆盖这个函数就可以处理用户的所有输入，只要
还没有使用 `Node.set_process_input()` 禁用输入处理。如果任何用户输入的是正要处理的事件，可以
调用 SceneTree 或 Viewport 的 `set_input_as_handled()` 函数告诉引擎，这个事件已经被处理好，
不必再传播，这确保可以过滤所有感兴趣的事件。对于游戏输入，`Node._unhandled_input()` 通常更适合，
因为它允许 GUI 拦截事件。

标准输入处理后，事件会流向 GUI 事件处理，控件可以在 `Control._gui_input()` 接收到 GUI 事件，
gui_input 信号会在此发布。如果控件处理好事件，应该调用 `Control.accept_event()` 避免事件再
传播。GUI 控件可以设置 mouse_filter 属性来避免鼠标穿透到下一层的控件上。

如果，前两步中还没有表明事件被处理好，事件就会送入 `_unhandled_input()` 及 `_unhandled_key_input()` 
函数中处理，只要没有通过以下方法禁用。

处理未经处理的输入是全屏游戏事件处理的理想选择，因此当 GUI 处于活动状态时，它们不会被接收。如果到
这一步还没表示该事件已经被处理，在启用 Object Picking 的情况下将摄影机指定给视口，则事件将会
投射到光线方向的物理世界。对于根视口，也可以在项目设置中启用此选项，如果此光线击中对象，它将调用
`CollisionObject._input_event()` 函数，默认情况下，主体会接收此回调，但区域不会，可以通过
区域属性进行配置。key_input 只包含键盘事件，鼠标、手柄按键、轴运动等不属于键盘事件。

最后，如果事件未处理，它将被传递到树中的下一个视口，否则将被忽略。GUI 事件也会在场景树中向上传播，
但由于这些事件针对特定控件，因此只有目标控件节点的直系上级节点才能接收事件。

需要注意，事件在节点中的传播是从后面、深层往根节点传播的，当一个节点调用 `accept_event()` 或者
`set_input_as_handled()` 函数后，只能阻止上层节点接收相应的事件，而不能阻止下层或后面的节点
接收事件。同时，节点还可以直接在 process 等函数中调用 Input 主动轮询输入状态，而不必被动接收事件。

![reverse depth-first order](https://docs.godotengine.org/en/3.5/_images/input_event_scene_flow.png)

总结一下输入数据的走向，在没有事件传播干预的条件下，用户输入的流向：

```py
# Step 1: Node 
void _input(event: InputEvent) virtual

# Step 2: Control
void _gui_input(event: InputEvent) virtual

# Step 3: Node
void _unhandled_input(event: InputEvent) virtual
void _unhandled_key_input(event: InputEventKey) virtual
```

对输入数据传播进行干扰的方法：

```py
# SceneTree
void set_input_as_handled()

# Node
void set_process_input(enable: bool)
void set_process_unhandled_input(enable: bool)
void set_process_unhandled_key_input(enable: bool)

# Control
void accept_event()
```

就键盘输入而言，不同国家使用的键盘布局也不尽相同，按键物理位置分布有所差异。Godot 工程设置 Input Map
可以将以下 5 种输入事件映射到一个 Action 上：

- Key 键盘输入，与按键扫描码关联，扫描码保存在 scancode 属性；
- Physical Key 键盘输入，与按键物理位置关联，扫描码保存在 physical_scancode 属性；
- Joy Button 手柄按键输入，用户每按一下就触发一次事件；
- Joy Axis 手柄轴输入，如方向轴，只要用户保持按键状态，事件就不断接收输入数据；
- Mouse Button 鼠标按键输入，包括滚轮，但不包含移动事件；

InputEventKey 事件接收到键盘输入的数据中，包含 scancode 和 physical_scancode，物理扫描码
记录的是按键在键盘的序号，101/102-key US QWERTY 标准键盘布局常用作参照。例如，WASD 常用于游戏，
使用 Physical Key 绑定时，就是以这些按键在标准键盘布局的位置对应的按键，而 Key 方式绑定具体的按键。

同一台机器上，除键盘输入外，手柄、鼠标等设备可能同时存在多个，需要指定设备号。

用户输入设备有两种形式：

- 连续的 Axis 输入，如手柄上的方向十字轴，包含上下一个轴和左右一个轴；
- 单次触发的按键输入，如鼠标按键；

从输入处理的方式来看，也有两种：

- 等待事件通知式，如 `_input()` 中处理的事件，包含按键式和手柄 Axis 输入；
- 主动式轮询，通过 `Input` 对象主动查询按键的状态，也可以实现类型 Axis 输入的效果；

Godot 工程设置中，可以映射键盘、鼠标按键、手柄按键、手柄轴输入等等，但是没有提供鼠标移动事件的映射。
InputEventMouseMotion 需要查询事件类型进行处理。Mouse Motion 不仅仅包含鼠标的移动，还可能是
压感笔的移动，这种情况会有参数传递倾斜度、压力、笔杆倒转等信息。速度 speed 为移动像素量每秒。

```py
    Vector2 tilt [default: Vector2( 0, 0 )]
      float pressure [default: 0.0]
       bool pen_inverted [default: false]
    Vector2 relative [default: Vector2( 0, 0 )]
    Vector2 speed [default: Vector2( 0, 0 )]
```

单次触发的事件和连续触发的轴事件有一个明显的差别，就是数据的持续性，全局的 Input 对象可以轮询按键状态，
Events versus polling 两种方式如下：

```py
func _input(event):
    if event.is_action_pressed("jump"):
        jump()


func _physics_process(delta):
    if Input.is_action_pressed("move_right"):
        # Move as long as the key/button is pressed.
        position.x += speed * delta
```

判断一个动作是否触发，Input 提供了两个检测方法，其中一个是 **is_action_just_pressed()**，它只在事件
刚触发时返回真值，后续只有在复位后再次触发时才返回真值。


用户输入时产生的事件数据保存在 InputEvent 类型及其子类中，不同的硬件事件使用不同的事件类型包装数据：

- **InputEvent** - 这是所有输入事件类型的基类；
- **InputEventWithModifiers** - 带有修饰按键的事件，键盘、鼠标事件等，修饰键有 Shift、Alt 等；
- **InputEventKey** - 键盘输入事件；
- **InputEventMouse** - 鼠标事件基类，包含鼠标在场景内的位置 position 以及全局屏幕位置 global_position；
- **InputEventGesture** - 手势事件；
- **InputEventMouseButton** - 鼠标按键事件，包含双击状态 doubleclick 或者滚动因数 factor 等等；
- **InputEventMouseMotion** - 鼠标移动事件，包含速度 speed 以及相对距离 relative 等等；

手柄事件和鼠标类似，有两种，InputEventJoypadButton, InputEventJoypadMotion，手柄的轴输入
是一个模拟量，通常在 [-1.0, 1.0] 的范围，手柄可以有多个轴，方向十字键就包含 X/Y 轴，这些数据分别
以 axis 和 axis_value 属性表示。

另外，触屏事件 **InputEventScreenTouch** 相当鼠标单击，**InputEventScreenDrag** 相当于鼠标移动。


对于未处理的事件，可以用两个方法进行处理，默认是激活的，不需要时可以在 `_ready()` 调用后设置为禁用：

```py
func _unhandled_input(event):
  print("unhandled input", event)

func _unhandled_key_input(event):
  print("unhandled key input", event)


void set_process_unhandled_input(enable: bool)

void set_process_unhandled_key_input(enable: bool)
```

使用 InputMap 可以不考虑 Action 具体由什么设备触发，或者由多少个设备触发同一个 Action，同时
还可以实现运行时重新配置映射关系，根据用户喜好重新设置设备按键的功能，或者通过代码触发 Action：

```py
var ev = InputEventAction.new()
# Set as move_left, pressed.
ev.action = "move_left"
ev.pressed = true
# Feedback.
Input.parse_input_event(ev)
```

以下是代码片段用于管理 Action，在场景中添加四个 Button，将节点名称改为对应的 Actoin 名称，点击
按键时，就触发重新映射 Action：

- 使用 has_action() 方法检测工程是否配置了指定 Action；
- 如果没有定义指定的 Action，就调用 add_action() 添加动作定义；
- 新的 Action 要和任意的事件对象建立映射关系，使用 action_add_event() 方法；
- 如果旧的映射关系不需要保留，调用 action_erase_events() 等方法擦除；

根据项目 Input Map 配置不同，按键会有两种扫描码，保存在 InputEventKey 的两个属性中，将其转换
为可阅读的字符时，需要按对 scancode、physical_scancode 属性进行相应处理。

```py
extends Node2D

onready var up: = $PanelContainer/GridContainer/move_up
onready var down: = $PanelContainer/GridContainer/move_down
onready var left: = $PanelContainer/GridContainer/move_left
onready var right: = $PanelContainer/GridContainer/move_right

var remap:Button = null
var actions:Array = ["move_up", "move_right", "move_down", "move_left"]

func get_key(event:InputEventKey):
    var key = OS.get_scancode_string(event.get_scancode_with_modifiers())
    var code = event.scancode | event.physical_scancode
    var fallback = OS.get_scancode_string(code)
    return key if key else fallback

func get_button_name(raw_name):
    var name = remap.name.split("_")[1]
    assert(name != null)
    return name.capitalize()

func reset_button():
    if remap != null:
        var event = InputMap.get_action_list(remap.name)[0] as InputEventKey
        remap.text = "%s(%s)" % [get_button_name(remap.name), get_key(event)]
        remap = null
    
func _ready():
    up.connect("pressed", self, "_on_pressed", [up])
    down.connect("pressed", self, "_on_pressed", [down])
    left.connect("pressed", self, "_on_pressed", [left])
    right.connect("pressed", self, "_on_pressed", [right])
    init_actions()

func init_actions():
    for act in actions:
        if not InputMap.has_action(act):
            InputMap.add_action(act)
    print_all_actions()
    print_action_events("move_up")

func print_all_actions():
    print("all actions has defined: ", InputMap.get_actions())

func print_action_events(action):
    print("events for %s:" % action, InputMap.get_action_list(action))

func _on_pressed(button:Button):
    reset_button()
    remap = button
    remap.text = "%s(%s)" % [get_button_name(remap.name), "..."]
    print(button)
    # set_process_unhandled_key_input(true)

func _unhandled_key_input(event):
    if event.scancode == KEY_ESCAPE:
        reset_button()
    
    if remap != null:
        var action = remap.name
        InputMap.action_erase_events(action)
        InputMap.action_add_event(action, event)
        remap.text = "%s(%s)" % [get_button_name(remap.name), get_key(event)]
        remap = null
    # set_process_unhandled_key_input(false)
```

输入映射可以通过 `ProjectSettings` 保存到工程文件内，或者通过 I/O 写入用户配置文件：

```C++
Error ProjectSettings::save() {
    Error error = save_custom(get_resource_path().plus_file("project.godot"));
    if (error == OK) {
        last_save_time = FileAccess::get_modified_time(get_resource_path().plus_file("project.godot"));
    }
    return error;
}
```

一般的手柄轴输入处理与键盘模拟手柄方向轴输入：

```py
extends Node2D

onready var icon = $"."

var base = 60
var sprint = 0

func _input(event):
    if event.is_action_pressed("move_sprint"):
        sprint = base * 2
    else:
        sprint = 0

func _axis_simulate(delta):
    if Input.is_action_just_pressed("move_down"):
        print("move_down")
    
    # Simualte X axis by keyboard
    if Input.is_action_pressed("move_right"):
        icon.position.x += (base + sprint) * delta
    elif Input.is_action_pressed("move_left"):
        icon.position.x -= (base + sprint) * delta
    
    # Simualte Y axis by keyboard
    if Input.is_action_pressed("move_down"):
        icon.position.y += (base + sprint) * delta
    elif Input.is_action_pressed("move_up"):
        icon.position.y -= (base  + sprint) * delta

    var axis_x = int(Input.is_key_pressed(KEY_A)) - int(Input.is_key_pressed(KEY_D))
    var axis_z = int(Input.is_key_pressed(KEY_W)) - int(Input.is_key_pressed(KEY_S))
    var direction:Vector3 = Vector3(-axis_x, 0, -axis_z)

func _process(delta):
    #Input.get_action_strength("move_up")
    var axis_y = Input.get_axis("move_up", "move_down")
    var axis_x = Input.get_axis("move_left", "move_right")
    var velocity = Vector2(axis_x * (base + sprint), axis_y * (base + sprint))
    if Input.is_action_just_released("move_sprint"):
        print("speed [%d, %d] %s" % [axis_x, axis_y, velocity])
    # This is a shorthand for writing 
    # Input.get_action_strength("positive_action") - Input.get_action_strength("negative_action").
    icon.position += velocity * delta
```

项目开发中，一般都会将输入事件的处理流程抽像为一个 Player Controller 对象来接管，提高代码复用。
Godot 文档关于玩家控制器设计的内容几乎没有，只有两个页面提到了一下。以下示意参考 UE4 的类结构：

                        +-------------+
                        |    Game     |
                        |  GameMode   |
                        |  GameState  |
                        +------^------+
                               |
         Contains:  +----------+-----------+           +---------------+
       +----------- |    PlayerController  |           |  AIController |
       |            +----------+-----------+           +-------+-------+
       |                       |                               |
       |    +---------+        | Possess  +---------+  Possess |
       +--> |   HUD   |        +--------> |   Pawn  | <--------+
       |    +---------+                   +---------+
       |    +---------+
       +--> |  Input  |
       |    +---------+
       |    +------------------------+
       +--> |  PlayerCameraManager   |
            +------------------------+

                    GamePlay Framework Class Relationships




## 🟡 IO & Serialization 序列化与存档读档
- [Input and Output (I/O)](https://docs.godotengine.org/en/3.6/tutorials/io/index.html)
- [File System](https://docs.godotengine.org/en/latest/tutorials/scripting/filesystem.html)
- [Resources](https://docs.godotengine.org/en/latest/tutorials/scripting/resources.html)
- [Background loading](https://docs.godotengine.org/en/latest/tutorials/io/background_loading.html)
- [Exporting packs, patches, and mods](https://docs.godotengine.org/en/latest/tutorials/export/exporting_pcks.html)

Godot 使用 res:// 和 user:// 两个文件路径协议，前者表示工程内部资源路径，后者表示用户操作系统
资源路径。游戏存档、用户配置等就需要使用后者，可以使用 OS.get_executable_path() 提供的路径将，
保存数据到相对于主程序的目录中。

资源加载有多种方式，资源路径除了以上两种协议，不能使用其它方式，不支持相对路，如果活力协议，API 会
自动添加默认的 res:// 协议为路径前缀：

```py
    # @GDscript global functions
    Resource load(path: String)
    Resource preload(path: String)

    # ResourceLoader singleton
    Resource load(path: String, type_hint: String = "", no_cache: bool = false)
    ResourceInteractiveLoader load_interactive(path: String, type_hint: String = "")
```

- `load()` 全局函数动态加载 path 指定资源，为了避免重复执行加载，可以将资源保存到变量中。
- `preload` 关键字提供的这种加载方法只在解析时执行预载，path 是一个常量。
- `ResourceLoader.load()` 是全局 load() 函数的完成版。
- `ResourceInteractiveLoader` 以交互方式加载资源，允许高粒度执行 chunks 加载过程，依次调用其 poll() 方法。

注意，preload 不是函数，是关键字，在解析器提供的方法，load() 是全局函数，它们的功能不太一样。

前面 `load()` 和 `preload` 两种方法都会阻塞线程，为了解决资源加载时出现卡顿问题提供了交互式
资源加载器，还过在 Godot 4 中移除了。还可以使用 ResourcePreloader 按列表加载资源，甚至是使用
多线程进行资源加载处理。

- https://docs.godotengine.org/en/latest/_downloads/bc54982daa1be2e5b495d74f01a098f1/resource_queue.gd

Godot 导出工程会将所有资源打包生成 .pck 资源包文件，相比 zip，非压缩的这种资源包优点如下：

- incremental updates/patches
- offer DLCs
- offer mod support
- no source code disclosure needed for mods
- more modular project structure
- users don't have to replace the entire game

Downloadable Content (DLC) 是游戏更新的一种方法，pck 资源包就可以在运行时加载：

```py
func _your_function():
    # This could fail if, for example, mod.pck cannot be found.
    var success = ProjectSettings.load_resource_pack("res://mod.pck")

    if success:
        # Now one can use the assets as if they had them in the project from the start.
        var imported_scene = load("res://mod_scene.tscn")
```

默认设置下，DLC 加载会覆盖相同路径的原工程资源，可以在加载资源包时传入参数避免这种覆盖行为。

对于 C# 工程，需要编译生成程序集的 DLL 并先放置到工程目录中，在加载资源包之前加载这个程序集：

```C#
    Assembly.LoadFile("mod.dll")
```

典型的系统中用户数据默认路径位置如下：

|     Type     |                              Location                             |
|--------------|-------------------------------------------------------------------|
| Default      | Windows: %APPDATA%\Godot\app_userdata\[project]                   |
|              | macOS: ~/Library/Application Support/Godot/app_userdata/[project] |
|              | Linux: ~/.local/share/godot/app_userdata/[project]                |
|--------------|-------------------------------------------------------------------|
| Custom dir   | Windows: %APPDATA%\[project]                                      |
|              | macOS: ~/Library/Application Support/[project]                    |
|              | Linux: ~/.local/share/[project]                                   |
|--------------|-------------------------------------------------------------------|
| Custom       | Windows: %APPDATA%\[custom_user_dir_name]                         |
| dir and name | macOS: ~/Library/Application Support/[custom_user_dir_name]       |
|              | Linux: ~/.local/share/[custom_user_dir_name]                      |


编辑器使用的数据路径：

|       Type      |                   Location                  |
|-----------------|---------------------------------------------|
| Editor data     | Windows: %APPDATA%\Godot\                   |
|                 | macOS: ~/Library/Application Support/Godot/ |
|                 | Linux: ~/.local/share/godot/                |
|-----------------|---------------------------------------------|
| Editor settings | Windows: %APPDATA%\Godot\                   |
|                 | macOS: ~/Library/Application Support/Godot/ |
|                 | Linux: ~/.config/godot/                     |
|-----------------|---------------------------------------------|
| Cache           | Windows: %TEMP%\Godot\                      |
|                 | macOS: ~/Library/Caches/Godot/              |
|                 | Linux: ~/.cache/godot/                      |

存档首先要考虑什么数据需要保存，Godot 提供了分组功能，可以将需要持久化的节点归类。比如，Persist
分组用于表示需要保存数据的节点分类。在 Godot Node -> Group 面板中，添加这个分类，然后再打开
Group Editor 编辑分组，将需要持久化的节点添加到此分组中，再配置以下代码版本进行处理：

```py
var save_nodes = get_tree().get_nodes_in_group("Persist")
for i in save_nodes:
    # Now, we can call our save function on each node.
```

分组管理有两种方式：

- During design, by using the Node dock in the editor.
- During execution, by calling **Node.add_to_group()** **Node.remove_from_group()**.


分组功能还可以用于批量操作，SceneTree 提供相应的方法：

```py
Variant call_group(group: String, method: String, ...) vararg

void notify_group(group: String, notification: int)
```

GDScript 提供了 **to_json()** 和  **parse_json()** 两个方法来处理 JSON 数据文件，用于游戏
数据持久化处理非常方便。所谓序列化 Serialization 即将内存中的数据按一定的格式整理后保存起来，后续
可以逆向复原来数据，使游戏的运行状态与存档时一样。

持久化数据处理步骤如下：

- 设计一个 Dictionary 字典对象作保存必要的数据，例如父节点路径、自身类型数据等；
- 为需要持久化的节点定义 save() 方法，返回一个字典数据对象；
- 创建一个 save_game() 方法，按持久化分组中的节点，调用 save() 方法获取数据；
- 数据使用 **to_json()** 格式化然通过 File 对象保存到文件中，为了简化可以逐行保存；

逆向处理恢复存档步骤如：

- 先读取文件，确保数据文件正常、可用；
- 为了简化，先处理掉被标记为持久化分组的节点；
- 逐行读入数据，**parse_json()** 还原出数据字典；
- 根据数据创建新节点，将各种属性数据恢复到新节点，再添加到节点树对应的父节点下；

更高效的持久化使用二进制，File 提供了 **get_var** 和 **store_var** 方法来方块字变体类型数据。
还有数据打包工具 PacketPeer，这种方式不在二进制场景、资源文件中使用。

Godot 提供了 File 和 Directory 对象处理文件读写，可以通过它们来创建、删除文件或目录，以下简单地
演示如何将节点数据保存到文件，以及读取后再恢复到节点上：

```py
var path = "user://save_game.json"

func _ready():
    save_button.connect("pressed", self, "save_game")
    load_button.connect("pressed", self, "load_game")


func save_game():
    # game state data
    var content = []
    for node in get_tree().get_nodes_in_group("Persist"):
        if node.get('text') == null:
            print("Node has no data, ignore it: ", node)
            continue
        var item = {
            path = $bg/note.get_path(),
            text = $bg/note.text
            }
        content.append(item)
    var file = File.new()
    var err = file.open(path, File.WRITE)
    if err:
        $bg/note.text = "Fail to open file: " + path
    file.store_string(to_json(content))
    file.close()
    $bg/note.text = "Save game to file:" + path

func load_game():
    var file = File.new()
    file.open(path, File.READ)
    var content = file.get_as_text()
    file.close()
    for variant in parse_json(content):
        print("load: ", variant)
        get_node(variant.path).text = variant.text
    return content

```

Godot 4.x 文件及目录 API 改写为 FileAccess 和 DirAccess，同时也取消了 close() 方法，在
超出作用域、通过赋值 null 释放文件引用时，FileAccess 会自动关闭文件，而在 C# 中必需 disposed。

```py
# Godot 3.x
    var path = "user://path/to/save.json"
    var file = File.new()
    var dir = Directory.new()
    if not file.file_exists(path):
        dir.make_dir_recursive(path)
        dir.remove(path)
        var json: String = to_json({NodePath=self.get_path()})
        var err = file.open(path, File.WRITE)
        if err != OK:
            return print("fail to write file: ", path)
        file.store_string(json)
        print("json save to file: ", path)
    else:
        file.open(path, File.READ)
        var json = file.get_as_text()
        var variant = parse_json(json)
        print("json read from file: ", path, "\n", variant)
    file.close()

# Godot 4.x
    path = "user://path/to/save.json"
    if not FileAccess.file_exists(path):
        DirAccess.make_dir_recursive_absolute(path)
        DirAccess.remove_absolute(path)
        var json: String = var_to_str({NodePath=self.get_path()})
        var file = FileAccess.open(path, FileAccess.WRITE)
        if FileAccess.get_open_error() != OK:
            return print("fail to write file: ", path)
        file.store_string(json)
        file = null
        print("json save to file: ", path)
    else:
        var file = FileAccess.open(path, FileAccess.READ)
        var json = file.get_as_text()
        var variant = str_to_var(json)
        print("json read from file: ", path, "\n", variant)
        file = null # File is closed. not file.close()
```

另外，String 类型提供了几个方法用于处理文件相关的字符串：

- get_base_dir()
- get_basename()
- get_extension()
- get_file()
- plus_file(file: String)

```py
print("/path/to/file.txt".get_extension())  # "txt"
print("file.txt".get_extension())  # "txt"
print("file.sample.txt".get_extension())  # "txt"
print(".txt".get_extension())  # "txt"
print("file.txt.".get_extension())  # "" (empty string)
print("file.txt..".get_extension())  # "" (empty string)
print("txt".get_extension())  # "" (empty string)
print("".get_extension())  # "" (empty string)
```


## 🟡 Audio Stream 声频流处理
- [Audio Generator Demo](https://godotengine.org/asset-library/asset/526)
- [Audio Mic Record Demo](https://godotengine.org/asset-library/asset/527)
- [Audio Spectrum](https://godotengine.org/asset-library/asset/528)
- [Audio Device Changer Demo](https://godotengine.org/asset-library/asset/525)
- [Godot 3.2 will get new audio features](https://godotengine.org/article/godot-32-will-get-new-audio-features/)
- [Importing audio samples](https://docs.godotengine.org/en/3.5/tutorials/assets_pipeline/importing_audio_samples.html)
- [Audio Buses](https://docs.godotengine.org/en/3.5/tutorials/audio/audio_buses.html)
- [Audio Stream](https://docs.godotengine.org/en/3.5/tutorials/audio/audio_streams.html)
- [Sync the gameplay with audio and music](https://docs.godotengine.org/en/3.5/tutorials/audio/sync_with_audio.html)
- [Recording with microphone](https://docs.godotengine.org/en/3.5/tutorials/audio/recording_with_microphone.html)

|           Godot 3.5            |            Godot 4.x             |
|--------------------------------|----------------------------------|
| AudioServer                    | AudioServer                      |
| AudioBusLayout                 | AudioBusLayout                   |
| AudioStream                    | AudioStream                      |
| - AudioStreamGenerator         | - AudioStreamGenerator           |
| - AudioStreamMP3               | - AudioStreamMP3                 |
| - AudioStreamMicrophone        | - AudioStreamMicrophone          |
| - AudicStreamOGGVorbis         | - AudicStreamOggVorbis           |
| - AudioStreamRandomPitch       | - AudioStreamRandomizer          |
| - AudioStreamSample            | - AudioStreamPolyphonic          |
| -                              | - AudioStreamWAV                 |
| AudioStreamPlayback            | AudioStreamPlayback              |
| - AudioStreamPlaybackResampled | - AudioStreamPlaybackResampled   |
| -                              | --- AudioStreamGeneratorPlayback |
| -                              | --- AudioStreamPlaybackOggVorbis |
| - AudioStreamGeneratorPlayback | - AudioStreamGeneratorPlayback   |
| AudioStreamPlayer              | AudioStreamPlayer                |
| AudioStreamPlayer2D            | AudioStreamPlayer2D              |
| AudioStreamPlayer3D            | AudioStreamPlayer3D              |
| -                              | AudioListener2D                  |
| -                              | AudioListener3D                  |

![AudioBuses](https://docs.godotengine.org/en/3.5/_images/audio_stream_reverb_bus2.png)

声效类型较多另外展示，并且升级后效果类型没有变化：

- AudioEffect
- - AudioEffectAmplify
- - AudioEffectCapture
- - AudioEffectChorus
- - AudioEffectCompressor
- - AudioEffectDelay
- - AudioEffectDistortion
- - AudioEffectEQ
- --- AudioEffectEQ10
- --- AudioEffectEQ21
- --- AudioEffectEQ6
- - AudioEffectFilter
- --- AudioEffectBandLimitFilter
- --- AudioEffectBandPassFilter
- --- AudioEffectHighPassFilter
- --- AudioEffectHighShelfFilter
- --- AudioEffectLowPassFilter
- --- AudioEffectLowShelfFilter
- --- AudioEffectNotchFilter
- - AudioEffectLimiter
- - AudioEffectPanner
- - AudioEffectPhaser
- - AudioEffectPitchShift
- - AudioEffectRecord
- - AudioEffectReverb
- - AudioEffectSpectrumAnalyzer
- - AudioEffectStereoEnhance
- AudioEffectInstance
- - AudioEffectSpectrumAnalyzerInstance

一个只有基本功能的 MP3 播放器：

```py
extends AudioStreamPlayer

var position = 0.0

func _ready():
    stream: AudioStreamMP3 = preload("res://some.mp3")

func _input(event):
    if not event is InputEventKey:
        return
    
    match [event.keycode, event.is_pressed(), event.ctrl_pressed, is_playing()]:
        [KEY_SPACE, true, _, true]:
            position = get_playback_position()
            stop()
            #set_stream_paused(true)
        [KEY_SPACE, true, _, false]:
            play(position)
            #set_stream_paused(false)
        [KEY_ESCAPE, true, _, _ ]:
            position = 0.0
            stop()
        [KEY_LEFT,  true, _, true ]:
            play(get_playback_position() + -5)
        [KEY_RIGHT, true, _, true ]:
            play(get_playback_position() + 5)
        [KEY_DOWN,  true, false, true]:
            set_volume_db(get_volume_db() + -1.0)
        [KEY_UP,    true, false, true]:
            set_volume_db(get_volume_db() + 1.0)
        [KEY_DOWN,  true, true, true]:
            set_pitch_scale(get_pitch_scale() + -0.01)
        [KEY_UP,    true, true, true]:
            set_pitch_scale(get_pitch_scale() + 0.01)
```











## 🟡 UI 用户界面
- [User Interface(UI)](https://docs.godotengine.org/en/3.5/tutorials/ui/index.html)
- [BBCode in RichTextLabel](https://docs.godotengine.org/en/3.5/tutorials/ui/bbcode_in_richtextlabel.html)
- [Using Containers](https://docs.godotengine.org/en/3.5/tutorials/ui/gui_containers.html)
- [Introduction to GUI skinning](https://docs.godotengine.org/en/3.5/tutorials/ui/gui_skinning.html)
- [Bitmap Font Generator](https://www.angelcode.com/products/bmfont/)

官方提供了一个 Control Gallery 示范工程，用于演示各种控件、布局容器的使用，2D 控件支持主题设置，
定制控件外观非常方便。2D 对象使用 Anchors 模型进行图形的比例、多分辨率处理：

![Size and Anchors](https://docs.godotengine.org/en/3.5/_images/anchors.png)

现代的屏幕尺寸多变，如何解决在不同尺寸下图像布局保持不变？有几种方法可以处理这个问题，屏幕分辨率改变，
控件需要重新定位。有些人需要跟随屏幕底部，其他人则需要跟随屏幕顶部，或者可能是左右边距。

通过编辑控件的 Margin 边距属性来设置，每个控件有四个边距设置：左、右、下和上。默认情况下，它们都表示
相对于父控件左上角的距离，以像素为单位，如果没有父控件就相对于视口。

锚点 Anchors 也是四个值，是百分比，并且 Left 小于 Right，Top 小于 Bottom，当值全部为 0 表示
和父节点的左上角为锚定位，全设置为 1 表示锚定父节点的右下角，不会影响节点尺寸。

当 Left/Top 为 0，Bottom/Right 为 1，则表示锚定整个父节点空间。假设父节点尺寸 100x100，通过
Margin(0, 0, 100, 100) 设置，子节点同样设置为 100x100 却会有加倍的尺寸。因为，Margin 四个值
对应的是父节点的整个区域，边距 Right 锚定父节点的右侧，边距 Left 锚定父节点的左侧，依此解析，子
节点就会伸出父节点区域下侧、右侧各 100 像素的空间，边长加倍。

属性面板上只能设置 Anchors 的值为 [0, 1] 区间，通过 Layout Presets 可以修改，点击船锚图标
可以激活拖动节点时直接修改锚点位置。

Godot 3.x 升级到 4.x 后，Anchor & Margin 两个属性合并，并使用 Anchors Preset 预配置替代。

控件可以选择使用主题，也可以在主题覆盖设置中进行修正。主题主要保存 5 类数据：

- Colors 颜色，主要用于背景、字体颜色，以及 modulation 用于调制控件颜色。
- Constants 整数常量，用于控件的数值或 boolean flags 属性，如 BoxContainer 的间隔。
- Fonts 字体，Godot 默认字体不支持中文，显示中文需要导入中文字体。
- Icon 图标，纹理图像，用作按钮控件的图标等等；
- Styleboxs 样式盒，包含一组配置项用于控件平面的绘图，不限用于 Panel 控件；

Godot 支持 BitmapFont, DynamicFont 两类字体，分别对应字体纹理和矢量字体，矢量字体渲染使用通过
FreeType library 实现，支持常用格式，包括：

- TrueType (.ttf)
- OpenType (.otf)
- Web Open Font Format 1 (.woff)
- and Web Open Font Format 2 (.woff2)

BitmapFont 则是按 BMFont 格式渲染字体纹理，位图字体也就是用图像保存文字图形，通常将文字一个接一个
紧密排列在一起，渲染文字时就按对应坐标输出其中的图案。使用 Bitmap Font Generator 工具可以很方便
地从现有矢量字体文件中导出位图字体，使用 Edit -> Select characters from text file 可以选择
文件内容中用到的字符，文件编码支持 UTF16，使用 UTF8 似乎有兼容问题。导出图片时配置为 32-bit 颜色
深度以保证 Alpha 通道生效，如果使用 8-bit 尝试可能导致字体符号透明区不能正确处理。


Godot 目前提供的四种样式盒可以给控件设置不同的外观属性：

- **StyleBoxEmpty** 空盒，只简单继承 StyleBox 提供的边距属性；
- **StyleBoxLine** 除了边距属性外，给控件增加一条线，可以设置线宽、颜色、位置等等；
- **StyleBoxFlat** 除了边距属性外，增加了背景填充、Skew 切变、边框、圆角、阴影等等；
- **StyleBoxTexture** 纹理样式盒，可以给控制设置纹理和 Normal Map，以及边距扩展等等；

Godot 给纹理样式图片提供了 9 宫格功能，TextureRegion，即通过一个矩形区将纹理按四边分割为 9 块，
除了四个边角的部分不缩放，居中的这块，和上下左右 4 块可以自由绽放以匹配不同大小的内容。注意，6 个
控制点与 4 条线之间的内容作为周边宫格显示的图像。可将项目设置 Ninepatch Mode 默认的 Scaling 
配置改为 Fixed 模式，以免边框部分被缩放导致变形。

Godot 4.x 版本中，Ninepatch Mode 配置已经移除，九宫格面板也改为 Sub-Regon -> Edit Region。



通常，主题数据以控件名进行分类，Manager Theme Item 主题条目管理器中可查看、编辑，或创建类型变体。
例如，一个 font_color 颜色，可能有 Label 类型，也可能有 RichTextLabel 类型，影响不同的控件。
主题是一种资源，创建时从 FileSystem 面板的右键菜单中选择 New Resource ... 并且选择 Theme 类型。
创建好的主题可以直接从 FileSystem 中拖放到控件属性面板中的 Theme 属性上，或拖放到场景树的节点上。
双击打开主题资源，在默认的主题预览面板中可以看到各种控件的外观，或者点击 Add Preview 添加要预览
的场景。点击主题编辑器右上角的 Manage Items... 打开主题数据管理器，将需要的使用的数据导入，或者
使用吸管在 Default Preview 视图中吸取展示的控件。

有时控件需要与主题定义的外观有所差异，就可以使用主题数据类型变体，Theme type variations。
每个控件节点都有主题属性重写 Theme Overrides，允许重新定义每个 UI 元素的样式。但在控件数量很多
的情况下，使用主题类型变体，则是更灵活的方法。变体需要扩展了另一种基本类型，替换基本类型的某些设置，
但又保留其他方面不变，变体还可以定义基础样式尚未定义的特性。例如，定义一个 GrayButton 变体以覆盖
基本的 Button 常规样式，并添加 Button 从未定义的 font_color。

例如，为 Label 创建一个主题变体，操作步骤如下：

- 双击主题文件打开主题编辑器；
- 点击面板的 Type 列表右侧的 + 号以打开 Add Item Type，输入一个新名称，如 MyLabel 作为类型变体；
- 点击标签栏右侧的工具图标，在 Base Type 中填写 Label，或者点击右侧 + 号挑选一个基础类型；

通过以上三个步骤就创建了新的主题类型变体，控件使用变体只需在 Theme Type Variation 属性中指定。
一个新创建的变体通常没有新数据，打开 Show Default 开关，可以显示已经继承的数据。


2D 界面元素可以使用布局容器进行排版，Godot 提供以下布局容器：

- AspectRatioContainer 图形比例保持布局；
- BoxContainer > HBoxContainer and VBoxContainer 用于纵横排列布局；
- CenterContainer 居中布局；
- EditorProperty 属性容器，用于给属性探测器 EditorInspector 中添加内容；
- FlowContainer > HFlowContainer and VFlowContainer 流式布局，节点前后紧密相连。
- GraphNode 包含多个输入、输出插槽，用于连接其它的 GraphNode，Godot 节点编程中有使用；
- GridContainer 多行、多列布局；
- MarginContainer 可调整边距；
- PanelContainer 面板布局；
- ScrollContainer 内容可滚动布局；
- SplitContainer > HSplitContainer and VSplitContainer 可活动的纵横方向分割；
- TabContainer 标签栏切换布局；
- ViewportContainer 特殊容器，只包含一个 Viewport 子节点，以显示其图形；

使用容器时，容器会按子节点的相关属性设置来处理进位置、大小的调整，子节点可以通过最小尺寸 Min Size，
或者 Size Flags 启用不同的行为模式来控制子节点的大小、位置，或者直接使用 Layout Presets 提供
的预配置来快速设置这些属性：

- Fill 充满整个容器；
- Expand 尽量扩展以占满容器；
- Shrink Center 紧凑排列到容器中央；
- Shrink End 紧凑排列到容器末尾；


Godot 的基础类 **Object** 提供了以下两个方法来读写子对象的属性，在属性探测器面板中，可以获取各种
属性的路径，使用鼠标右键菜单 Copy Property Path (Ctrl+Shift+C) 复制属性路径供以下方法使用。
例如，通过脚本修改 Label 控件的字体颜色、阴影，覆盖 RichTextLabel 控件的主题设置，属性面板位置
Theme Overrides -> Colors -> Default Color 和 Selection Color：

```py
void set(property: String, value: Variant)
Variant get(property: String) const

$RichTextLabel.set("custom_colors/default_color", Color.red)
$RichTextLabel.set("custom_colors/selection_color", Color.red)

$Label.set("custom_colors/font_color", Color.whitesmoke)
$Label.set("custom_colors/font_color_shadow", Color.darkorange)
$Label.set("custom_constants/shadow_offset_x", 2)
$Label.set("custom_constants/shadow_offset_y", 2)
```


往场景中添加一个 RichTextLabel 节点，并附加以下脚本可以实现 BBCode 内容显示，并且支持超链接：

```py
extends RichTextLabel

onready var rich = $"."

# Called when the node enters the scene tree for the first time.
func _ready():
    bbcode_enabled = true
    bbcode_text = """
    Bitmap Font Generator
    字体示范 
    Example: The word [url=https://www.bbcode.org]BBCode[/url] is clickable.
    [url=https://godotengine.org/][img]res://icon.png[/img][/url]
    The word BBCode is clickable, use meta_clicked signal to handle it.
    """
    connect("meta_clicked", self, "_on_meta_clicked", [], CONNECT_ONESHOT)

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta):
    pass

func _on_dragged(offset):
    rich.bbcode_text += ":%d " % offset

func _on_meta_clicked(meta):
    print(meta)
    OS.shell_open(meta)
```

注意，在 Godot 4.x 中，如果编写图片连接时有缩进，行前空格或 TAB 可能会导致无法触发点击事件。




## 🟡 Maths 图形学的数学
- [Vector math](https://docs.godotengine.org/en/stable/tutorials/math/vector_math.html)
- [3blue1brown 线性代数的本质](https://www.bilibili.com/video/BV1ys411472E)
- [张筑生《数学分析新讲》（共三册）](http://fdjpkc.fudan.edu.cn/d201353/2015/0408/c17008a34495/page.htm)
- [GAMES101-现代计算机图形学入门-闫令琪](https://www.bilibili.com/video/BV1X7411F744/)
- [CMU 15-462/662 计算机图形学 Computer Graphics](https://www.bilibili.com/video/BV1QZ4y1K7ga)
- Mathematical Logic for Computer Science
- [Eigen - C++ template library for linear algebra](https://eigen.tuxfamily.org/index.php)

掌握线性代数的重要性在图形学中特别明显，不像一些算法库，开发好了就可以直接调用，完全不用考虑数学问题。
而图形学中，随处都需要使用数学去解决实际问题，比如角色的正面朝向，投掷武器前如何面向敌人，相机角度的
控制，如何跟随玩家的角度作变换，等等问题，都需要线性代码来解决。

线性代数 Linear Algebra 是一个解决线性问题的工具，从几何的观点去理解线性代数是一个能直观感受什么
是线性的本质。核心是线性空间和线性变换，而不是算行列式。

以下是 Jean Dieudonné 一段话：

> 尽管一批教授和教科书编者用关于矩阵的荒唐至极的计算掩盖了线性代数的简明性，这鲜有与之相较更为初等的理论。
>
> There is hardly any theory which is more elementary than linear algebra, in 
> spite of the fact that generations of professors and textbook writers hav 
> obscured its simplicity by preposterous calculations with matrices.
>
> -- Jean Dieudonné

代数思想是进入线性代码的起步，从实数的四则运算到符号的代入是一个分界线。数学才从等式方程、不等式，
Equations，Inequalities，进入代数时代。

代数的运算也同样遵守优先规则，这些规则简称为 BODMAS!

- **B** - Brackets first
- **O** - Orders (i.e. Powers and Square Roots, etc.)
- **DM** - Division and Multiplication (left-to-right)
- **AS** - Addition and Subtraction (left-to-right)

即先算括号，再算阶数（即幂和平方根等），然后除法和乘法（从左到右），最后加法和减法（从左到右）。

或者叫做 PEMDAS !

- **P** Parentheses first
- **E** Exponents (ie Powers and Square Roots, etc.)
- **MD** Multiplication and Division (left-to-right)
- **AS** Addition and Subtraction (left-to-right)




### 🟠🔵 Functions 函数
- 数学分析(全二卷)(第7版) by B.A.卓里奇
- 张筑生《数学分析新讲》（全三册）
- [Maths is fun - Algebra](https://www.mathsisfun.com/algebra/index.html)

数学上的函数概念其实是映射关系，当年引入苏联教材时翻译作函数有些令人费解，这个词意思应该是依赖关系。
说到函数就必需有集合 Sets，两个集合中的数，通过函数映射规则产生对应关系，如下图：

![单射、满射和双射](https://www.shuxuele.com/sets/images/function-mapping.svg)

图中，将一对多的情况列为不是函数的例子，但在是复变函数，即以复数作为自变量和因变量的函数，就存在一
对多的映射关系。对于 A、B 两个集合元素之间的映射存在各种情况：

- 一般函数映射特点：A 集合元素一对一映射 B 集合元素，B 集合有多余元素；
- 单射 **Injective**：A 集合元素一对一映射 B 集合元素，且没有多对一的情况；
- 满射 **Surjective**：B 集合元素在 A 集合中都有一个元素对应；
- 满射 **Bijective**：A 和 B 集合的元素一一对应，没有多余，没有重复；

比如，对于 A、B 集合分别为 {1, 2, 3} 和 {2, 4, 9}，映射规则为"平方"，即 f(x) = x²，，那么这
就是一个满射，即一一对应映射关系的函数：

- A 集合作为输入称为定义域 **Domain**；
- B 集合作为函数的实际输出称为值域 **Range**；
- 而函数可能的输出称为培域 **Codomain**；

所以，函数是按映射规则将输入集合的元素与输出集合的元素上关联的功能，如图，表达为 x 的函数等于 x 的平方。

![What is a functions?](https://www.mathsisfun.com/sets/images/function-fx-x2.svg)

闭包 **Closure** 性质是：对某个集合的成员进行一种运算，输出结果仍然是这个集合的成员，则该称该集合为
这个运算下的闭包。在编程语言中，闭包一词也作为术语在使用，并且常见，但是含义有所差别，编程上更多是指
引用自由变量的函数。从某种角度上讲，如果自由变量算作同一个集合中的输入，那么也不违反闭包的数学定义。

复合函数 Function Composition 是指将函数的输出作为另一个函数的输入，记作 (g º f)(x)，意思是
g(f(x))。

和几何可以变换一样，函数也可以变换，Function Transformations，例如：g(x) = x² 在直角坐标中
显示为一条经过原点的向上弯曲的二次曲线，变换为 g(x) = x² + C 形式后，它的曲线就沿 y 轴向上移动
C 个偏移量，如果 C 小于 0，则向下偏移。

![Function Transformations](https://www.mathsisfun.com/sets/images/function-translation-a.gif)

函数的复合与变换在图形学中经常发生，几乎在每一个着色器中都需要使用。

逆函数，或称反函数，Inverse Functions，即运算规则完全相反的函数，比如，f(x)=2x+3，那么反函数
就是 f⁻¹(y)=(y-3)/2，将 f(x) 的结果作为反函数的输入就可以得到 x，记作 f(x) 与 f⁻¹(y) 互为
反函数。又如，Reciprocal 数的倒数互为反函数，1/x <=> 1/y，又如 sin(x) <=> sin⁻¹(y) 互为
反函数，注意这个负一不是指数，是反函数标记。

注意，不是所有函数都有反函数，x² 只在 x >= 0 时才有反函数，小于 0 时，不能通过开方 √(x) 求解负值，
即竖直对称的函数都没有反函数。



### 🟠🔵 Trigonomery 三角函数
- [Maths is fun - Trigonometry](https://www.mathsisfun.com/algebra/trigonometry.html)
- [Maths is fun - Trigonometry zh_CN](https://www.shuxuele.com/algebra/trigonometry.html)
- [Trigonometry](https://www.math.net/trigonometry)

Trigonometry 三角函数这个西方术语词源来自希腊的三角学，trigonon + metron，即三角形 + 测量。
这也是三角函数的最初用途，用它来测量。那时测量的可能是一棵大树高度，也可能是测量天空的星星。

进入近代数学让数域扩展到复数，也让三角函数走上了封神之路。自从欧拉公式的出现，三角函数就和复数关联，
一些纯代数的东西也能导出三角函数的影子，尤其是在复变函数领域，三角函数简直泛滥，因为三角函数本质上
与圆有关，也间接的导致复变函数中 π 泛滥。傅里叶将三角函数推向了另一个方向，他提出任意周期函数 s 都
可以用三角函数去表示，所以可以用三角函数描述所有曲线，甚至用来绘图，这就是傅里叶级数。由于三角函数
通用于描述各种波，物理上的各种波都用三角函数表示，比如薛定谔的波函数，量子力学，三角函数都要凑个热闹。

1579年，韦达出版了《应用于三角形的数学定律》，从理论的层面定义分析了三角函数，在这本书中就出现的韦达
定理有让无数中学生头疼的和差化积，积化和差公式。

17 世纪是牛顿莱布尼兹创造微积分的世纪，也在这个世纪，笛卡尔提出了笛卡尔坐标系，从此三角函数就有了
属于自己的图像，费马提出了导数的概念，不久之后三角函数就有了导数，而且三角函数的导数的特殊性。

基础的正弦、余弦、正切函数，Sine，Cosine 和 Tangent 的正三角形定义如图所示，此外有单位圆定义方式：

![Trigonometry](https://www.mathsisfun.com/algebra/images/sin-cos-tan.svg)

在单位圆的定义中，斜边对应半径，对边对应于竖直边，邻近边则对应于贴紧 X 轴的边。沿逆时针方向旋转半径，
角度为正，顺时针旋转为负，使用弧度表示一周为 2π 弧度，而用角度表示一周为 360°。

- Sine 和 Cosine 的值域都是 [-1, 1]，周期都是 2π。
- Sine 在 -π/2 到 π/2 区间是递增，而 Cosine 在 -π 到 0 区间是递增。

![sine graph](https://www.mathsisfun.com/algebra/images/sine-graph.svg)
![cosine graph](https://www.mathsisfun.com/algebra/images/cosine-graph.svg)
![tangent graph](https://www.mathsisfun.com/algebra/images/tangent-graph.svg)

Tangent 正切函数是根据角度 α 求解对边与邻边的比值，而反向三角函数 atan 则反过来根据比值求角度。

    sin(α) = opposite side / hypotenuse    = a / h
    cos(α) = adjacent side / hypotenuse    = a / h
    tan(α) = opposite side / adjacent side = a / b

最早的勾股定理就是对直角三角形边长的研究结论，勾三股四弦五，指的是直角三角形的两直角边为 3、4，那么
斜边长为 5。国外称为毕达哥拉斯定理 Pythagoras theorem，即斜边长的平方等于两直角边的平方和。

![Unit circle](https://www.mathsisfun.com/geometry/images/unit-circle-xy.svg)

对于单位圆，unit circle，根据勾股定理可得以下恒等式：

    x² + y² = 1²  <=>  x² + y² = 1

在单位圆上，x = cos(θ) 且 y = sin(θ)，代入上式就可以得到最重要的一条三角函数恒等式，也是圆的方程：

    cos(θ)² + sin(θ)² = 1

因为圆的关系，在图形学上，经常需要使用三角函数来作旋转变换操作。


    勾股定理       a² + b² = c²        （只适用于直角三角形）
                     
    余弦定理       a² + b² − 2ab cos(C) = c²

    正弦定理       a/sin A = b/sin B = c/sin C



### 🟠🔵 Vectors 向量
- [Vectors](https://www.math.net/vector)
- [Vectors - Maths is fun](https://www.mathsisfun.com/algebra/vectors.html)
- [Vectors - 3Blue1Brown](https://www.3blue1brown.com/lessons/vectors)
- [Math Typography](https://bisqwit.iki.fi/jutut/typography.html)

向量 Vector 也称为欧几里得向量、几何向量、矢量，指具有大小（magnitude）和方向的量。与向量对应的
量叫做数量 Scalar，物理学中称标量，或者叫一维向量，数量只有大小，没有方向，如重量、时间等，英文
的速度用 speed 表示标量，而 velocity 表示向量，一般说平均速度是指 average speed。

数学上向量的规范表达有三种方式，代数表示、几何表示、坐标表示。几何图上为带箭头的线段，箭头表向量的方向，
线段长度代表向量的大小。代数符号表达记作黑体字母，如 **𝒂**、**𝒃**、**𝒖**、**𝒗**，书写时在字母顶上
加一小箭头“→”表示指向，如 u⃗  v⃗  w⃗  x⃗ y⃗。如果给定向量的起点（A）和终点（B），可将向量记作 AB 并于
顶上加箭头符号表示方向。在文档中，为了简化输入，就直接表示为 **AB**。

向量空间也称为线性空间，是集合的载体，标量可以被组织在一起。标量通常被认为是实数，也存在标量乘以复数。
向量空间是线性代数的主题，维度通过它们可以很好地表征，粗略地说，它指定了空间中独立方向的数量。无限维
向量空间在数学分析中自然出现，作为函数空间，其向量是函数。这些向量空间通常具有附加结构，可以是拓扑结构，
允许考虑接近度和连续性问题。

此外，还有第三种量，张量 Tensor，标量、向量是张量的特殊形式，没有方向分量的张量就是标量，有模有方向
的张量就是向量，如果有两个方向就是并矢、并向量。

标量、向量、矩阵、张量这 4 个概念是维度不断上升的关系，用点、线、面、体的概念来比喻解释会直观一点：

- 点 —— 标量（scalar）
- 线 —— 向量（vector）
- 面 —— 矩阵（matrix）
- 体 —— 张量（tensor）

张量理论是数学的一个分支学科，在力学中有重要应用，术语起源于力学，最初用来表示弹性介质中各点应力状态，
后来张量理论发展成为力学和物理学的一个有力的数学工具。

向量 Vector 是 2D 或 3D 世界中处理问题的基本工具，在图形学上经常将它当作方向指示器来使用，一般
不关心向量的起点，或者说根据需要给它一个起点坐标。归一化 Normalized 是矢量中经常出现的操作，它将
约束矢量的模长为 1，即**单位向量**就是长度为 1 的向量，Unit vectors。

根据勾股定理，向量的模可以表示如下，用两条竖线表示，在数学记号中，在向量符号两侧都使用双竖线：

    |a| = √( x² + y² )

单位向量还经常用作表示法线 normals，法向量就是垂直于曲面的单位向量，用来指示方向，在光照技术、物体
碰撞等等操作中都需要用它来解决后续响应。

笛卡尔向量是特殊的单位向量，指向和个轴向，对应于笛卡尔坐标系中的 x/y/z 轴： 

    i=[1,0,0]ᵀ      j=[0,1,0]ᵀ      k=[0,0,1]ᵀ

实际应用中为了简化运算，需要引入`基底` Basis Vectors 的概念，为每个轴上定义一个单位向量。也就是
建立坐标系统进等距分割数轴时，沿 x 轴分割的一等分记作沿 x 正方向的单位向量 i，正式书写时，它应该
上面加个盖帽。还有 y 轴上的单位向量 j，同样也应该在上面加个盖帽，但是这里为了方便打字省略了。

这样一来，向量相加和数乘就可以理解为，对各轴单位向量的缩放再相加，这个思想既重要又基础。

可以这样理解线性，在一个平面中选取两个向量，保持其中一个不变，另外一个任意伸缩，那么这两个向量相加的
结果就是扫过这个平面上的一条直线。

当两个向量都进行伸缩时，那么它们就会扫过整个平面，而这些变化中的向量集合成的平面就叫作`张成空间` 
Span space。例外的情况是，这两个向量的方向重叠时，它们张成空间是一条直线。

同样，在三维空间上的三个不同方向的向量，它们张成的空间就是三维空间的体积。只要其中有两个向量其线，
那么张成空间就压缩为平面，如果三向量都共线，张成空间就压缩为一条线。有个极端的情况，即向量都为 0 向量，
张成空间就是原点。

当一个维度的的向量的增加或数乘不能增加张成空间的维度时，也即称为`线性相关` Linearly dependent，
或者理解为这个向量约束在其它向量张成的空间内。原文是 dependent 原单是依赖、束缚的意思，中文的相关
一词略显松垮不严谨。当某向量的加入可以增加原有向量的张成空间的维度，就是非线性约束，即`线性不相关`
 Linearly independent。

当我们要考虑很多向量的时候，使用箭头表达向量的方式会让空间显得过于拥挤，可以使用简化的圆点来表示，
只要原点指向圆点的位置符合原先的向量方向即是等价的。



在 Godot 2D 环境下，坐标朝向如下图所示，屏幕左上角为原点，右、下为正向。

![Coordinate systems (2D)](https://docs.godotengine.org/en/3.5/_images/vector_xy1.png)

例如，从原点到坐标 (4, 3) 位置就可以用向量表示为 Vector2(4, 3)。

编写以下这样的一个 sayhello.gd 脚本，使用 godot.exe --headless -s sayhello.gd 命令执行，
就可以得到脚本运行输出的结果，并不需要运行整个 Godot 编辑器：

```py
extends SceneTree

func _init():
    var a = Vector2 (2, 5) 
    var b = Vector2 (3, 1)
    var format = "Normalized vector %s is %s, "
    var angle = "angle of %s - %s is %d degree"
    print(format % [a, a.normalized()])
    print(angle % [a, b, (a - b).angle()*180/PI])
    print(angle % [b, a, (b - a).angle()*180/PI])
    print("dot(%s, %s) = %s " % [a, b,  a.dot(b)])
    quit()
# Output:
# Normalized vector (2, 5) is (0.371391, 0.928477), 
# angle of (2, 5) - (3, 1) is 104 degree
# angle of (3, 1) - (2, 5) is -75 degree
# dot((2, 5), (3, 1)) = 11 
```

Godot Vector2.angle() 方法返回的值是 [-π, π] 之间的弧度值，X 轴正向为 0 度，逆时针方向为正。

向量的加减运算，就是按分量进行标量的加减运算，在图形上等效于两个向量首尾连接在一起，终点就表示结果。
减法，相当于将分量乘以 -1 反转 180° 方向再相加。如下图，蓝色向量表示 **a**，绿色向量表示 **b**：

```py
# create a vector with coordinates (2, 5)
var a = Vector2(2, 5)
# create a vector and assign x and y manually
var b = Vector2()
b.x = 3
b.y = 1

# Adding vectors
var c = a + b  # (2, 5) + (3, 1) = (5, 6)
```

![Vector Addition](https://docs.godotengine.org/en/3.5/_images/vector_add1.png)

向量与标量积，则等效于多次相加。理解这些内容，就可以用向量来做游戏的中运动。用一个向量表示速度，例如，
上图中的 **b** 表示速度，每次运行时间间隔后，物体就会从 **a** 位置移到 **a+b** 位置上。要表达
加速度，也是同一个道理，只需要在间隔时间内将加速与速度相加，即得到当前的速度。

向的减法可以用来求方向，假设 tank 是玩家，robot 是对手，二者位置分别用 **A** 和 **B** 向量表示，
要确定从玩家指向对手的方向，只需向量减法，红色向量为 **C** 即表示方向，从当前玩家的位置往这个方向射击
或者投掷武器就可以击中对手：

![Pointing toward a target](https://docs.godotengine.org/en/3.5/_images/vector_subtract2.png)

由 A 指向 B，就需要用 B - A，按向量加法的思维去理解，则先将 A 反转 180° 再相加，得到的就是一个
从原点出发的表示方向的向量。注意，减法的顺序不能反，含义完全不同，C = B - A，等价于 A + C = B，
A - B = -C，所以，结果是反转 180°。记作，负号在哪方，箭头就由哪方往外，B - A 记作 B <- A。

向量乘法形式定义有三种：

- **Scalar multiplication** 最简单的是标量积量，相当于多次加法，结果还是向量；
- **Dot product** 点积，几何意义是求解两个同方向的向量的模长的数量积，结果是标量；
- **Cross product** 叉积，求解的是另一个向量，方向与当前向量平面相互垂直；

前面已经解析过标量积，点积结果也一样是标量，将两个同方向的向量的模长相乘。对于不同方向的向量，通过
余弦值可以求正交投影长度，即投影长度即可获得同方向上的分量，物理上用来计算合力和功：

    a · b = |a| × |b| × cos(θ)

除了点积的几何意义的计算方法，还有在高维度上更常用的通过坐标计算的方式，定义如下：A、B 都是 n 维向量，
，点积定义为 sum(aᵢbᵢ)，i 取值为范围 [1, n]。如何证明这种定义与向量的几何点积运算两者等价呢？使用
余弦定理，在平面上的两个向量 A、B，首尾连接即可以构成一个三角形。而两向量的坐标已知，三条边长可通过
坐标求得，将坐标代入余弦定理公式中，即可以证明两者等价关系。

给定两个向量坐标 v = [v₁, v₂] 和 w = [w₁, w₂]，计算点积为 v ∙ w = v₁w₁ + v₂w₂，表达更简洁。
例如，给定 v = [3, 5]ᵀ 和 w = [-2, 7]ᵀ，计算 v · w 和 v · v，上标 T 表示矩阵转置，行变列。

向量点积在图形学中一大用途就是利用点积结果来判断夹角的大小，向量自身的点积就是模的平方：

- 点积结果为 0 表示两者互相垂直；
- 点积结果大于 0 表示两者同向；
- 点积结果小于 0 表示两者反方向；

对于多维向量点积，也一样的计算方法。在游戏中利用点积，可以判断对手是否处于可视角度上。

![between two vectors](https://docs.godotengine.org/en/3.5/_images/vector_dot3.png)


向量叉积 a x b 是一个向量，其模长等于向量 a 和 b 组成的平行四边形的面积，且方向垂直于此平面：

![Cross product](https://www.mathsisfun.com/algebra/images/cross-product-area.svg)
![Cross product](https://img2018.cnblogs.com/i-beta/1046925/202002/1046925-20200204181223998-1486309.png)

使用右手定则确定叉积方向，使拇指、食指、中指相互垂直，侧拇指代表叉积指向，食指和中指分别代表 a 和 b。
根据点积和叉积的线性关系含义，又分别将它们称为 Inner product 内积、Outer product 外积。

在二维平面中，叉积可以用以下公式计算，使用夹角和单位向量：

    a × b = |a| |b| sin(θ) n

1. `|a|` is the magnitude (length) of vector a
2. `|b|` is the magnitude (length) of vector b
3. `θ` is the angle between a and b
4. `n` is the unit vector at right angles to both a and b

使用行列式计算二维向量叉积：

            | x₁ y₁ |
    a x b = |       | = x₁y₂ - y₁x₂
            | x₂ y₂ |

在二维空间不能表示的叉积，放在在三维空间中，都可以按以行列式的方式计算，假定向量起点为原点 (0,0,0)，
向量 a = (x₁, y₁, z₁) 和向量 b = (x₂, y₂, z₂)，那么外积计算可表示为：

            | i  j  k  |
    a x b = | x₁ y₁ z₁ | = (y₁z₂ - z₁y₂)i - (x₁z₂ - z₁x₂)j + (x₁y₂ - y₁x₂)k
            | x₂ y₂ z₂ |

向量叉积在图形学上的作用：

- 可以计算表面的法向量 `N = (a x b)/|a x b|`；
- 可以计算平行六面体的体积；
- 判断点是否在同一平面，一点在此平面的向量和法向量做点积即可以判断；



### 🟠🔵 Vector in Godot 向量的应用
- [Advanced vector math](https://docs.godotengine.org/en/3.5/tutorials/math/vectors_advanced.html)

单位向量作为法向量 Normal 使用时不仅可以用来指示方向，利用法向量还可以作各种应用，不限于以下这些：

- 通过法向量求点到面的距离；
- 通过法向量求碰撞动作响应方向；

假设有一个过原点的平面，法向如图所示：

![distance from the point to the plane](https://docs.godotengine.org/en/3.5/_images/tutovec11.png)
![distance from the point to the plane - Away from the origin](https://docs.godotengine.org/en/3.5/_images/tutovec12.png)

尽管图片展示的是平面投影在二维的一条直线，但这个平面在 3D 世界，将整个空间分割为上下两部分，使用
2D 也一样可以演示。空间上任何一点都可以与这个法向量做点积运算，得到的结果为点到平面的距离。原理就是，
可以将空间上的点看作是从原点指向这个点的向量 P，和法向量进行点积 P·N，结果就是沿着法向上的长度积，
也就是到平面的距离。向量点积运算，可以交换两向量位置，结果还是一样。和法向量做点积也可以理解为，沿着
向量 P 方向上的长度积，结果还是一样多。无论选取哪个方向作参考，另外一个向量都需要先取得下次投影，再
算数量积。只是距离有正负值之分，在法向的空间点为正距离，反向则为负距离。

```py
var distance = normal.dot(point)
```

然而，空间上的平面并不总是经过原点的，当然这也不是大问题，只需添加一个偏移距离 D 就可以解决。记住，
平面不仅将空间一分为二，而且还具有极性。就像有完全重叠的两个平面，但它们的负半空间和正半空间被交换。
所以 Godot 考虑到这一点，将整个平面描述为法线 N 和距原点标量 D 的距离，平面由 N 和 D 表示。基本上，
使用 N 和 D 可以表示空间中的任何平面，无论是 2D 还是 3D，取决于 N 的维数，两者的数学原理相同。
从原点到平面的向量可以表示为 N * D，任意点到平面的距离只需要减去偏移值 D，而在 **Plane** 类型的
方法实现中，已经处理了这个偏移值：

```py
# var point_in_plane = N*D
var distance = N.dot(point) - D

# The same thing, using a built-in function:
var distance = plane.distance_to(point)

var inverted_plane = -plane
```

翻转平面的极性可以通过 -N 和 -D 来完成，这使用平面处于相同位置，但具有反转的正负半空间，这个取反
运算操作可以直接在 **Plane** 对象上执行，它实现了取反运算符。

所以，记住，平面就是这样，它的主要实际用途是计算空间点到它的距离。那么，为什么计算点到平面的距离有用呢？

它非常有用！看一些简单的例子：

- 在 2D 空间创建平面；
- 判断空间点是否在平面内；
- 判断 3D 物体是否碰撞；

平面显然不是凭空而来的，所以必须建造。在 2D 中构建平面，只需要法线（单位向量）和一个点，或者空间中
的两个点来决定一个平面。在法线和点的情况下，大部分工作都已完成，因为法线已经计算完毕，所以只需法线
和点之间的点积计算 D 即可。

对于通过空间中的两个点建立平面，意图是先通过两点计算法向量。所以，实际上有两个平面，分别穿过这两点，
共享相同的空间，但法线指向相反的方向。要从两点计算法线，必须首先获得方向向量，然后根据需要将其旋转
90° 至任意一侧：

```py
# Calculate direction vector from `a` to `b`.
var dvec = (point_b - point_a).normalized()
# Rotate 90 degrees.
var normal = Vector2(dvec.y, -dvec.x)
# Alternatively (depending the desired side of the normal):
# var normal = Vector2(-dvec.y, dvec.x)

var N = normal
var D = normal.dot(point_a)
# this works the same
# var D = normal.dot(point_b)
```

在 3D 空间上操作会复杂点。


向量在图形学上的一个重要应用就是判断点是否平面内部，下面是一个有用的 Plane 应用例子。假设你有一个
凸多边形 Convex polygon，没有面向内弯曲的多边形，例如，矩形、梯形、三角形。

对于多边形的每一线段，计算经过该段的平面。一旦建立了平面列表，就可以做一些简单的事情，例如，检查点
是否在多边形内。透过所有平面，如果我们能找到一个到该点的距离为正的平面，那么该点在多边形之外。否则，
点就在平面内部，因为凸多边形的特性，可以使得只要出现一次距离为正，就可以确定点在多边开外。

凸多边形的特性在于凸集 convex set，每两点之间的直线上的点都落在该集合中的点集合。

![Convex polygon](https://docs.godotengine.org/en/latest/_images/tutovec13.png)


```py
var inside = true
for p in planes:
    # check if distance to plane is positive
    if (p.distance_to(point) > 0):
        inside = false
        break # with one that fails, it's enough
```

再改进一下，类似的逻辑可以用来检测两个凸多边形是否重叠，这称为 Separating Axis Theorem (SAT)
分离轴定理，大多数物理引擎使用它来检测碰撞。分轴理论由 Hermann Minkowski 提出，可用于解决凸多边形
碰撞问题，该理论表明：如果存在一条轴线，凸面体在该轴上的投影不重叠，则凸面体间就不重叠。

对于点，仅检查平面是否返回正距离就足以判断该点是否在外部。对于另一个多边形，必须找到一个平面，其所有
点到该平面的距离都为正值。该检查先是用 A 平面与 B 的点进行的测试，然后用 B 平面与 A 的点进行：

![SAT & Convex](https://docs.godotengine.org/en/latest/_images/tutovec14.png)


```py
var overlapping = true

for p in planes_of_A:
    var all_out = true
    for v in points_of_B:
        if (p.distance_to(v) < 0):
            all_out = false
            break

    if (all_out):
        # a separating plane was found
        # do not continue testing
        overlapping = false
        break

if (overlapping):
    # only do this check if no separating plane
    # was found in planes of A
    for p in planes_of_B:
        var all_out = true
        for v in points_of_A:
            if (p.distance_to(v) < 0):
                all_out = false
                break

        if (all_out):
            overlapping = false
            break

if (overlapping):
    print("Polygons Collided!")
```

以上是使用平面空间分割实现的基本逻辑，对于非凸面体，通常只是通过将凹多边形分割成较小的凸多边形来处理，
或使用二叉空间分割 Binary Space Partitioning(BSP)（现在很少使用）等技术来处理。

通过凸面体上的面来检测重叠现象，这也适用于 3D 场景中多面体的碰撞检测，无法找到分离平面时就发生了碰撞。
如果发现了分离平面，那么这些形状肯定不会发生碰撞。

但是，在 3D 环境中，存在这种情况，即找不到分离平面，但物体确实没有碰撞在一起：

![box collision](https://docs.godotengine.org/en/latest/_images/tutovec22.png)
![box collision](https://docs.godotengine.org/en/latest/_images/tutovec23.png)

这种情况，需要添加额外的平面作为分离平面，进行测试。这些平面所在是多边形 A 的边和 B 的边之间的叉积，
即垂直于这些边确定的平面。


### 🟠🔵 Vector & Normal Mapping 向量与法线贴图
- [Tangent Space Normal Mapping](https://docs.cryengine.com/display/SDKDOC4/Tangent%2BSpace%2BNormal%2BMapping)
- [Normal map (Bump mapping)](https://docs.unity.cn/2020.3/Documentation/Manual/StandardShaderMaterialParameterNormalMap.html)
- [LearnOpenGL Advanced Lighting - Normal Mapping](https://learnopengl.com/Advanced-Lighting/Normal-Mapping)
- [Real Shading in UE4 by Brian Karis, Epic Games](https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf)
- [Real-Time Rendering, Fourth Edition](http://www.realtimerendering.com/)
- OpenGL Programming Guide Eighth Edition - The Official Guide to Learning OpenGL, Version 4.3

3D 渲染中如果模式制作要真实，那么就会需要巨大量的网格 Mesh 面数，这直接给 GPU 渲染流水线出了一道
性能难题。为了给 GPU 减轻负担，通常可以采用材质贴图的方式来增加模型的真实感，同时大降低模型面数。
为了提供更轻量化的真实凹凸感，可以使用法线贴图 Normal Texture，还有置换映射 Displacement Mapping，
视差映射 Parallax Mapping 等技术，它们都属于凹凸映射范畴，**Bump Map**，都基于 Normal Map。

如下图，Normal Maps, Height Maps 都表示简单多边形网格表面上的细节的数据，但存储数据方式不同。

![Height Maps vs. Normal Maps](https://docs.unity.cn/2020.3/Documentation/uploads/Main/BumpMapHeightMapNormalMapComparison.jpg)

在现代游戏开发艺术工作流程中，艺术家将使用他们的 3D 建模程序，基于非常高分辨率的源模型生成法线贴图。
然后在游戏发行版本上使用低分辨率模型，并将法线贴图映射在模型上，通过法线贴图渲染原始的高分辨率细节。

![Normal mapping across three polygons, viewed as a 2D diagram](https://docs.unity.cn/2020.3/Documentation/uploads/Main/BumpMapBumpShadingDiagram.svg)

示意图上，上面的黑色长线条表示物体表面，绿色线条表示 Smooth shading 模式下的平滑法线走向，表面
交接点的红色箭头就是顶点的法向量。下面的偏紫色方块表示法线贴图上的像素值，以及像素对应的法线向量。

法线向量 Normal Vector 是影响光的折射传播的参考向量，每个网格的顶点 Vertex，或者网格构成的面都
有一个法线向量指示它们的朝向，改变法线向量就会改变这个面的光照细节呈现。


几乎所有引擎都会提供默认支持法线贴图的材质功能，法线贴图是一张保存法线信息的图片文件，直接打开看起来
就是紫色调的图像，或者是多彩的图像，这取决于法线贴图采用的格式或者参考坐标：

- World Space Normal Mapping
- Object Space Normal Mapping
- Tangent Space Normal Mapping

在 3D 场景中每个物体每个面的朝向都不同，法线指向也变化多端，不能以固定方向的形式保存法向量。所以使用
世界空间 World Space 保存的法线贴图，只有在场景不改变，表面保持原来朝向才适用。

对于复杂模型确实可以把朝向各个方向的法线储存在同一张贴图上，你可能看到过不只是蓝色的法线贴图，不过
用那样的法线贴图有个问题是，必须记住模型的起始朝向，如果模型运动了还要记录模型的变换，这非常不方便，
这就是 Object space 法线贴图的弊端。

另一个解决方案是使用切线空间 Tangent Space，这个坐标空间里，法线贴图中保存的向量总是指向 +Z 方向，
所有的法线向量都相对与这个 +Z 方向进行变换，这样就能始终使用同样的法线贴图，而不管朝向问题。所谓切线，
即垂直方向的线，如在一个圆的表面，切线就是过圆边上一点的直线，并且这个条与这点到圆心之间的连线垂直。
所以，切线空间上的向量都相对于物体表面法向量，这种法线贴图产生的色调是偏蓝色的，因为所有法线的基本指向
都偏向 Z 轴（0, 0, 1），对于法线映射而言，该矢量为“向上”，表示模型表面没有变化。

为了将法线向量保存到贴图文件中像素中的 RGB 三个分量中，则需要将 XYZ 坐标取值范围 [-1, 1] 重新映射
到 OpenGL 中通常使用的 RGBA 浮点数表示范围 [0.0, 1.0]。所以，为了表示负值，(0, 0, 1）会映射为
(0.5,0.5,1)，即 RGB(127,127,255)，就是蓝色分量为主色调的像素值。

在着色器中读取法线贴图时，就需要将 RGB 分量重新映射为 [-1, 1] 区间：

```c
// transforms from [-1,1] to [0,1]
// vec3 rgb_normal = normal * 0.5 + 0.5;

// obtain normal from normal map in range [0,1]
normal = texture(normalMap, fs_in.TexCoords).rgb;
// transform normal vector to range [-1,1]
normal = normalize(normal * 2.0 - 1.0);   
```

切线空间的法向就是 Z 轴方向，也就是物体表面法向量所指的方向，无论是什么物体的表面，都通过计算，将
法线贴图的坐标对应到表面。并且表面的凹凸不平的点对应的法向量按 Z 轴这个基本指向进行偏移，就可以控制
模型表面法线的偏移。

算法上用一个 TBN 矩阵就能将切线空间中的法线向量坐标转成世界坐标，使它们转向到最终的贴图表面的方向。
先在世界空间定义三个轴，Tangant（T）、Bitangent（B）及法线轴（N），TBN 构成一个 3x3 的矩阵。
直观地讲，模型顶点中的纹理坐标，就和切向共平面，即二维的 UV 纹理坐标，分别对应切线空间 TB 两轴。
模型中不同的三角面，都有对应的切线空间，TB 两轴所确定的平面就是三角形所在平面，N 等价平面法向量。

TBN 是转换矩阵，并且是正交矩阵，即矩阵转置就是逆矩阵，它将切线空间的向量坐标变换为其他空间的坐标。

                [ Tx Bx Nx ]
    [T, B, N] = [ Ty By Ny ]
                [ Tz Bz Nz ]

![TBN vectors](https://learnopengl.com/img/advanced-lighting/normal_mapping_tbn_vectors.png)
![Normal mapping surface edges](https://learnopengl.com/img/advanced-lighting/normal_mapping_surface_edges.png)

计算切向量和副切向量不像法向量那样简单，基于法线贴图的切线和副切线的方向与定义曲面 UV 纹理坐标对齐
的这个事实，可以用 UV 坐标来计算每个曲面的切线和副线向量。

```c
// git@github.com:JoeyDeVries/LearnOpenGL.git
// \src\6.pbr\1.2.lighting_textured\1.2.pbr.fs
// ----------------------------------------------------------------------------
// Easy trick to get tangent-normals to world-space to keep PBR code simplified.
// Don't worry if you don't get what's going on; you generally want to do normal 
// mapping the usual way for performance anways; I do plan make a note of this 
// technique somewhere later in the normal mapping tutorial.
vec3 getNormalFromMap()
{
    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;

    vec3 Q1  = dFdx(WorldPos);
    vec3 Q2  = dFdy(WorldPos);
    vec2 st1 = dFdx(TexCoords);
    vec2 st2 = dFdy(TexCoords);

    vec3 N   = normalize(Normal);
    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);
    vec3 B  = -normalize(cross(N, T));
    mat3 TBN = mat3(T, B, N);

    return normalize(TBN * tangentNormal);
}
```

GLSL 偏导数函数（HLSL: ddx ddy，GLSL: dFdx dFdy）在片元着色器中的用于计算任何变量基于屏幕空间像素变化率的变化率。 
dFdx, dFdy — return the partial derivative of an argument with respect to x or y
- [An introduction to shader derivative functions](http://www.aclockworkberry.com/shader-derivative-functions/)

- dFdx(v) = 该像素点右边的v值 - 该像素点的v值 // v 可以是任意值
- dFdy(v) = 该像素点下面的v值 - 该像素点的v值
- fwidth（v） = abs( dFdx(v) + dFdy(v))

![Shader partial derivative functions](http://www.aclockworkberry.com/wp-content/uploads/2016/02/Shader-Derivatives-1.png)


切线空间的优点有几个，由于法线的单位长度属性和限制 Z 始终为正，重建一个 Z 分量只需要存储两个分量，
内存上就节省了 2 个字节而不是占用 4 个字节，另外一个字节通常用于对齐。并且有多种 GPU 支持的格式，
用于 2 通道纹理，通常为 1 字节而不是 2 字节。这些格式节省内存，减少内存带宽，并且解压缩成本也很低，
因此使用它们可以提高流和渲染性能。

由于切线空间法线总指向表面外部，因此假定单位长度，可以从 X 和 Y 分量重建法线 Z 坐标。坐标从 0..1 
扩展到 -1..1 范围后，就可以计算 Z = sqrt(1 - X²+Y²)。这使得可以使用两个通道纹理来存储法线贴图，
每个纹理像素为 2 个字节，大大提高了纹理压缩性能。

切线空间格式的法线贴图独立于基础几何体，即纹理也可以用于其他几何体，无论镜像、旋转、缩放或平移如何，
它都将自动与曲面对齐。而使用对象空间，或世界空间的法线贴图仅支持后两者。几何独立性允许高效重用，例如，
以平铺法线贴图的形式，从而节省更多内存并减少生产时间。

切线空间法线映射的基本思想也有其缺陷，对艺术家来说，拆开复杂模型并将接缝放在暴露较少的区域会很棘手。

对于场景中一个 XY 平面上的表面，法线贴图的像素颜色大概对应的法线方向如下，法线向量的 XY 偏移量对应
RGB 中的 RG 分量，手绘法线贴图可以参考：

- (0.5, 0.5, 1.0) 垂直向外，浅蓝；
- (0.5, 1.0, 0.6) 指向南边，浅绿；
- (1.0, 0.5, 0.6) 指向东边，粉红；
- (1.0, 0.0, 0.6) 指向东北，紫红；
- (0.0, 1.0, 0.6) 指向西南，青色；

只要面法向带蓝色，那么法线就是朝外的，正常。不带蓝色分量，就朝向内表面。






### 🟠🔵 Matrix & Determinant 矩阵与行列式
- [Linear Algebra](https://www.3blue1brown.com/topics/linear-algebra)
- [Solving Systems of Linear Equations Using Matrices](https://www.mathsisfun.com/algebra/systems-linear-equations-matrices.html)
- [Solving Systems of Linear Equations Using Matrices zh_CN](https://www.shuxuele.com/algebra/systems-linear-equations-matrices.html)
- [Determinant of a Matrix](https://www.mathsisfun.com/algebra/matrix-determinant.html)
- [Matrix Calculator](https://www.mathsisfun.com/algebra/matrix-calculator.html)
- [Determinant](https://www.math.net/determinant)
- [Matrix](https://www.math.net/matrix)

线性代数之所以叫线性代数，因为它就是用来解决线性问题的，而线性问题可以理解为，能用二维坐标中的线条表示的问题。

列表有一系列食品：

|    食品   |  单价 |
|-----------|------|
| Apple     | $3   |
| Cherry    | $4   |
| Blueberry | $2   |

销售量：

|           | Mon | Tue | Wed | thu |
|-----------|-----|-----|-----|-----|
| Apple     | 13  | 9   | 7   | 15  |
| Cherry    | 8   | 7   | 4   | 6   |
| Blueberry | 6   | 4   | 0   | 3   |
| Count     | $83 | $63 | $37 | $75 |

把它们当作两个只有一行的矩阵，计算周一的销售额，就是点积 dot product。反过来，假如知道当天的销售额，
而不知道某一个销售量，这就一个典型的线性代数问题。

    ($3, $4, $2) • (13, 8, 6) = $3×13 + $4×8 + $2×6 = $83

注意一点，实际上第二个圆括号的内容应该是竖直方向书写的，因为矩阵乘法是一行乘一列，每行元素和后者的
每列元素匹配。这里为了简便，就没有按照数学上的习惯书写。

矩阵（Matrix）是一个阵列排列的复数或实数集合，元素是实数的矩阵称为实矩阵，元素是复数的矩阵称为复矩阵。
注意，"因为这种表达方式有行有例，所以称之为行列式"这种由于名字暗示得出的是错误的理解。

这种，用矩阵的行、列中的各个数相乘再相加的得到的值叫行列式 The determinant，当然这只是一种形象的
名称，同时也是令人费解的名字。

简单的说，行列式就是一个定义在方阵上的函数 det: ℝ^(n×n) → ℝ，只是名字翻译作行列式。行列式这个值
可以帮助寻找到矩阵的逆矩阵，the inverse of a matrix，矩阵在线性方程、微积分等系统中有用的东西。

- 仅当行列式 ≠ 0 时，矩阵才可逆。
- 线性方程组系数矩阵的行列式 ≠ 0，则方程组有唯一的解；如果为 0，则方程组无解或有不同的解。

矩阵与行列式的区别有四点，下面就是具体介绍：

- 本质上，矩阵是一个数表，包含线性空间中的元素；而行列式是一个数值，n 阶的方阵。
- 符号上，矩阵用花括号表示，行列式用双竖线表示。
- 结构上，矩阵的行数和列数可以不一样，行列式的行数与列数一致。
- 运算上，一个数乘以行列式，只能乘以行列式的一行或者一列。一个数乘以矩阵，就要和矩阵的每个元素相乘。
  两个矩阵相等是指对应元素都相等；两个行列式相等不要求对应元素都相等，甚至阶数也可以不一样，只要运算
  代数和的结果一样就行了。行列式相等，就是值相等，行和列数目不必相等，数据也不必相等。矩阵相等，行和列
  数目必须相等，对应位置的数据也必须相等。行列式相加减，就是两个数值相加减，结果还是数值。矩阵相加减，
  对应位置的数据相加减。

对于一个 2×2 方阵，行列式(值)即为矩阵中的元素交叉相乘再求差值，两侧的竖线也表示这是一个绝对值：

        | a  b |
    A = |      |        The determinant is:      |A| = ad − bc
        | c  d |

对于更多维的方阵，只需要拆分第一行，单独与后面两行中的小方阵相乘，结果求和，更高维度依样处理：

![Det of 3x3 Matrix](https://www.mathsisfun.com/algebra/images/matrix-3x3-det.svg)


        | a  b  c |      a                  b                  c  
        |         |       x                 x                 x   
    A = | d  e  f | =>    | e  f |  -  | d     f |  +  | d  e |   
        |         |       |      |     |         |     |      |   
        | g  h  i |       | h  i |     | g     i |     | g  h |   

         |A| = a(ei − fh) − b(di − fg) + c(dh − eg)

![Det of 4x4 Matrix](https://www.mathsisfun.com/algebra/images/matrix-4x4-det.svg)

以上这种展开方法称为“拉普拉斯展开”，我喜欢它，因为模式很容易记住，当然还有其他方法。比如，萨鲁斯规则
Sarrus’s rule，这种方法是将行列式往右边循环扩展，从左上角往右下角连线的数乘积相加，再减去从右上角
往左下角连线的数乘积。

向量和行列式结合时，通常以列向量的形式编写，方便做计算，其中向量中的每个值表示向量的一个分量。

给定两个向量坐标 v = [v₁, v₂] 和 w = [w₁, w₂]，计算点积为 v ∙ w = v₁w₁ + v₂w₂，表达更简洁。
例如，给定 v = [3, 5]ᵀ 和 w = [-2, 7]ᵀ，计算 v · w 和 v · v，上标 T 表示矩阵转置，行变列。


矩阵的重要之处在于它将许多的代数问题给方便的表示，特别是利用矩阵的乘法将使代数问题得到简洁的表示和求解。
矩阵的加法定义为两个具有同样维度的矩阵之前进行的叠加运算，两个矩阵中行列坐标对应位置的数相加并保持结果
在同样的位置。

矩阵的乘法有两种，一种是**标量乘法**，即矩阵与一个标量相乘，矩阵中所有的元素都要乘上这个标量。另一种是
矩阵与矩阵之间的乘法，简称**矩阵乘法**，只有左侧矩阵的列数与右侧矩阵的行数一致时才可以进行。并且，行列
上的数一对一对相乘，结果求和再放到结果矩阵上。最终得到一个矩阵行数、列数分别和乘号左侧、右侧矩阵对应。
对于 m×n 矩阵与 n×p 矩阵相乘，n 必须相同，相乘结果是 m×p 矩阵。

![Matrix multiply](https://www.shuxuele.com/algebra/images/matrix-multiply-a.svg)
![Matrix multiply](https://www.shuxuele.com/algebra/images/matrix-multiply-b.svg)
![Matrix multiply](https://www.shuxuele.com/algebra/images/matrix-multiply-c.svg)

乘法的互换律在矩阵的领域通常是不适用的，矩阵乘法并非可互换，除特殊的单位矩阵外，它与任何矩阵相乘都
不会改变原矩阵。**单位矩阵** Identity matrix 是矩阵领域里的 "1"：

- 符号为大写字母 I。
- 单位矩阵是"方形"的（行与列数目相同）。
- 对角线上，即左上角到右下角的连线上全是 1，其他全是 0。
- 它是个特别的矩阵，任何矩阵和单位矩阵相乘，保持不变。

逆矩阵的定义如下，A 的逆（矩阵）是 A⁻¹，仅当：

    AA⁻¹ = A⁻¹A = I

但有些矩阵是没有逆矩阵的，当矩阵的行列式为 0 即不在逆矩阵。对于一个 2x2 矩阵来说，逆矩阵求法如下：

           -1                  
    [ a b ]      1   [  d  -b ]
    [     ]  = ----- [        ]
    [ c d ]     det  [ -c   a ]

即，将原矩阵的斜角元素换位，给另外两个数加负号，最后除以行列式。

例如，以下 2x2 矩阵的逆的求法，以及通过 AA⁻¹ = A⁻¹A = I 验证逆矩阵：

           -1
    [ 4 7 ]      1   [  6  -7 ]   [0.6 -0.7]     [0.6 -0.7][ 4 7 ]   [ 1 0 ]
    [     ]  = ----- [        ] = [        ] ==> [        ][     ] = [     ]
    [ 2 6 ]    24-14 [ -2   4 ]   [-0.2 0.4]     [-0.2 0.4][ 2 6 ]   [ 0 1 ]

矩阵并不总是有逆矩阵的，就像方程组并不总是有解一样。

- 首先，矩阵一定要是"方形"即可以计算行列式，才可能有逆矩阵。
- 同时，行列式不能是零，求解线程方程组时便要除以零了。

例如，以下这个矩阵就没有逆矩阵，行列式为 0，对于求解逆矩阵时，1/0 除法没有定义。

    [ 3 4 ]
    [     ]  ==> det = 3x8 - 4x6 = 0
    [ 6 8 ]

这种矩阵叫**降秩矩阵**，Singular，就是行列式为零的矩阵。从线性关系上来看，这很合理。来看矩阵第二行
的数字，它们不过是第一行的双倍，也就是说并没有提供新的信息。在线性相关上，还是原来的线性关系。它们就
是平面上的同一条直线，通过原方程式就可以将这个 2 倍系数约分掉，行列式的作用就是告诉这个线性关系。

对于高阶矩阵的逆，需要使用其它方法来求解：

- Inverse of a Matrix using Elementary Row Operations (Gauss-Jordan)
- Inverse of a Matrix using Minors, Cofactors and Adjugate
- Use a computer (such as the Matrix Calculator)

別忘了，我們的目的要得到線性方程的解，而不是逆矩陣的每一個元。如果尋覓逆矩陣公式的行動單純源於人類
天生想要探索未知世界的好奇心，尚可理解。不過，倘若只因為要解線性方程而計算逆矩陣，可就要奉勸諸位：
「你們的時間有限，所以不要浪費時間在逆矩陣的計算上。」正如 Steve Jobs 在美國史丹佛大學畢業典禮上說：

>Your time is limited, so don’t waste it living someone else’s life.”

用初等行运算来求逆矩阵是最基本的求逆方法，也称高斯－若尔当方法，"初等行运算"包括行相加，乘，对换位置
等等。注意只能做以下这些 "初等行运算"：

- 对换两行的位置，这和交换原线性方程的先后顺序一样；
- 把一行里的每个元素乘以或除以一个常数，这对应在原线性方程上同时两边乘一个系数；
- 一行加上另一行，并取代前者；

以后续要使用的矩阵为例，先将矩阵 A 与其单位矩阵 I 并排写下来，这个叫**增广矩阵**：

    [ 13  8  6 | 1 0 0 ]
    [  9  7  4 | 0 1 0 ]
    [  7  4  0 | 0 0 1 ]

接着尽力去把增广矩阵左边的矩阵变成单位矩阵，目标是把矩阵 A 变成单位矩阵，对角线变成全是 1。尽量先
将对角线外的数变成 0，再将对角线的数归一化。对增广矩阵右边的矩阵也做同样的运算，最终得到一个 A⁻¹。
这里很多的操作，只需要占一下矩阵计算器 "inv(A)" 键。


用余子式、代数余子式和伴随来求逆矩阵，步骤如下:

一、求余子式矩阵，
二、转成代数余子式矩阵，
三、转成伴随矩阵，
四、乘以行列式倒数。

所谓余子式矩阵，即一个用来存放“余子式”的矩阵。余子式是特殊的行列式，即选中原矩阵中的一个元素，比如
第一个元素，它位于第一行、第一列，那么就将这些行、例的元素排除掉，对余下的元素所构成的矩阵求行列式，
这个结果保存到余子式矩阵中。

所谓代数余子式矩阵，就是将"纵横交错"排列的正负号放在"余子式矩阵"上。换句话说，每隔一个格改变正负号，
第一个为正，第二个为负，等等，隔一行则顺序反过来。

伴随矩阵，即转置以上的矩阵。就是沿对角线对调元素的位置，在对角线上的元素不变。


矩阵相乘运算规则类似向量做点积运算，右侧矩阵中的向量为 Column Vector 表达，而不是一行的形式。
所以，回到前面食品销售数据处理上来，重点是要把价钱和销售量正确地使用矩阵表示出来：

                 [ 13 9  7  15 ]
    [$3 $4 $2] x [ 8  7  4  6  ] = [ $83 $63 $37 $75 ]
                 [ 6  4  0  3  ]

反过来，假如知道当天的销售额和和各种食品数量，但不知道售价，这就一个典型的线性代数问题。利用矩阵就
可以求解线性方程组。最主要的就是写出未知数的系数矩阵，这里就使用 xyz 替代掉价钱，并改写为如下形式：

    [ 13  8  6 ] [x]   [$83]
    [  9  7  4 ] [y] = [$63]
    [  7  4  0 ] [z]   [$37]
    [ 15  6  3 ]       [$75]

对于三元一次方程组，其实只要有和未知数一样多的方程即可以求解，以上多出来一条方程的数据可以去掉。通过
矩阵计算器，可以得到 det = -62。同样，利用矩阵计算器可以帮助自动进行大量的矩阵计算，求得 xyz。

这三个矩阵称为 "A", "X" 和 "B"，方程组的矩阵表示便是 AX = B，只不过将原来零散的方程集中以多维
数据呈现。而线性方程组的求解也变成了矩阵求逆的操作，通过逆矩阵求解就可以解线性方程组，公式是：

    X = A⁻¹B

这个公式的意思是：x、y 和 z 的值（X 矩阵）等于 **A 矩阵的逆**乘以 **B 矩阵**。矩阵与逆矩阵的关系
就是一个数与其倒数的关系，把矩阵与其逆相乘，结果是单位矩阵，就像是矩阵里的"1"。

如果矩阵等式 AX = B 每边都可以除以 A 得到 X=B/A 就最好了，但不能除矩阵。每边乘以 A⁻¹ 是可行的：

    XAA⁻¹ = BA⁻¹
       XI = BA⁻¹
        X = BA⁻¹

我们知道 AA⁻¹ = I，所以可以将 AA⁻¹ 作为 I 拿走，就如同从代数数式子 1x = ab 拿走 "1" 一样。
注意，做矩阵相乘次序是重要的，AB 几乎永远都不会等于 BA。如果式子是反序的，同样按照顺序：

       AX = B
    A⁻¹AX = A⁻¹B
       IX = A⁻¹B
        X = A⁻¹B



### 🟠🔵 Complexes 复数
- [闫令琪 GAMES101-现代计算机图形学入门 - 04 Transformation Cont.](https://www.bilibili.com/video/BV1X7411F744/?p=3)
- [Imaginary Numbers Are Real - Welch Labs](https://www.bilibili.com/video/BV1Ts411u7iH?p=5)
- [Imaginary Numbers Are Real - Welch Labs](https://www.welchlabs.com/resources/freebook)
- [How Imaginary Numbers Became “Real”](https://www.themathdoctors.org/how-imaginary-numbers-became-real)
- [A Short History of Complex Numbers - Orlando Merino](https://www.math.uri.edu/~merino/spring06/mth562/ShortHistoryComplexNumbers2006.pdf)
- [Imaginary Numbers](https://www.mathsisfun.com/numbers/imaginary-numbers.html)
- [Complex Plane](https://www.mathsisfun.com/algebra/complex-plane.html)
- [Imaginary Multiplication vs. Imaginary Exponents](https://betterexplained.com/articles/imaginary-multiplication-exponents/)
- [A Visual, Intuitive Guide to Imaginary Numbers](https://betterexplained.com/articles/a-visual-intuitive-guide-to-imaginary-numbers/)
- [数学里最美的公式： e^iπ+1=0 - Surein Aziz 博士](https://www.meipian.cn/588prp7)
- [复数的实矩阵表示 - Shenelry](https://zhuanlan.zhihu.com/p/160270375)
- [Maths - Rotation Theory](http://euclideanspace.com/maths/geometry/rotations/theory/index.htm)
- [Rotations And Infinitesimal Generators](https://www.reedbeta.com/blog/rotations-and-infinitesimal-generators/)

任意一个复数 𝑧 ∈ ℂ 都可以表示为 𝑧 = 𝑎 + 𝑏𝑖 的形式，其中 𝑎, 𝑏 ∈ ℝ 而且 𝑖² = −1．我们将 𝑎 称之
为这个复数的实部（Real Part），𝑏 称之为这个复数的虚部（Imaginary Part）。Imaginary 本身译作
“抽象的”更合适，它本身不虚，只是太抽象。历史上，高斯认为这个数的名字应该叫做侧数 lateral 更恰当。

![Complex Number](https://www.mathsisfun.com/numbers/images/complex-number.svg)

Girolamo Cardano (or Cardan) (1501-1576) 在 16 世纪发明了复数，但直到很久以后，这一观点才在
Leonhard Euler (1707-1783) 和 Carl Friedrich Gauss (1777-1855) 作品中确定下来。

Gauss 增写到虚数应该叫做侧数，这样可以避免被人误解：

    "That this subject [imaginary numbers] has hitherto been surrounded by 
    mysterious obscurity, is to be attributed largely to an ill adapted notation. 
    If, for example, +1, -1, and the square root of -1 had been called direct, 
    inverse and lateral units, instead of positive, negative and imaginary 
    (or even impossible), such an obscurity would have been out of the question."


其实 𝑧 = 𝑎 + 𝑏𝑖 就是对于 {1, 𝑖} 这个基底（Basis）的线性组合（Linear Combination），所以，
复数还是线性代数的范畴，可以用向量来表示一个复数，也可以用复数来表示向量。复数和向量一样有长度和方向，
magnitude (length) and direction。

复数最大的意义不在于虚数单位 i 的创造，而在于复数的创立正式将数学从一维抽象世界带入二维抽象世界去
看问题。设想一下，有个人有 2 个苹果，你拿走 3 个，请问还乘几个？在人类抽象功能发挥之前，这显然是不
可解决的问题。但是抽象一下，用“借”的方法，抽象地借走一个不存在的东西也是可以的，引入负数来解决它。
在复数创造出来之前，数学一直都是实数空间下的一维世界，它也不断地补充小数、有理数、无理数等等的概念。
从实数的演变，到复数的发明，这一切的本质都是代表了人类对未知的探索。

向量尽管也具有二维属性，但它在数学上的模型还是基于一维的实数，所以本质上是一维的数学思想。

复数引入的出发点是在人类无法解决对负数开方问题，即在解二次方程时遇到 √(-1) 无解问题，也就是实数无法
解决一个数的平方为负数的情况。而引入虚数后，使得 **i² = -1**，就可以用 √(-1) = i 代表二次方程的解。
在图形直观上，使用复数平面表达，水平轴为实数轴，竖直轴为虚数轴。虚数 i 通过复数乘法，可以在实数与虚数
之间变换，这种能力使得虚数与实数相乘在复数平面上表示为旋转的直观现象。

如下图，从实轴上的 1 开始，乘上虚数单位 i 就变成旋转 90° 到了虚轴上方。再乘 i 即得到 i² = -1，
就到了实轴的负数位置，又是旋转了 90°。同理，乘上负值的虚数，旋转角度就是负值。例如，(3 + 4i) 乘以
i 后得到 (-4 + 3i)，在复数平面上，前后两者坐标旋转了 90°。可以使用向量运算进行验证，对两个向量做
点积，结果为 0。所以，只是引入了虚数，复数和几何就完美结合在一起。

![Positive & Negative Rotation](https://betterexplained.com/wp-content/webp-express/webp-images/uploads/complex/positive_negative_rotation.png.webp)

至此，数学上出现了三个最常用的坐标形式：

- Cartesian Coordinates 笛卡尔坐标系统，即表示距离的 XY 轴直角坐标系；
- Polar Coordinates 极坐标系，即表示旋转角度与距离的关联；
- Complex Plane 复数平面，即实数与虚数二维坐标系统；

在复数二维世界中，具有了更维度解决问题的方法，向量的功能也完全在复数的范围之内，同样具有模和方向。
向量加减和复数加减完全一致，只需要将复数的分量对应相加减。例如，7+2i 与 3+5i 相减结果为 4-3i：

![Complex addition](https://www.mathsisfun.com/algebra/images/complex-plane-vector-add.svg)

复数的乘法却要比向量更简洁明了：

![Complex Multiplying](https://www.mathsisfun.com/algebra/images/foil-complex.svg)

两个复数相乘，两分量俩俩相乘再相加，归纳如图，"FOIL" 即 "Firsts, Outers, Inners, Lasts"：

    (a+b𝑖)(c+d𝑖) => ac + ad𝑖 + bc𝑖 + bd𝑖² => (ac − bd) + (ad + bc)𝑖

- Firsts: a × c
- Outers: a × d𝑖
- Inners: b𝑖 × c
- Lasts: b𝑖 × d𝑖

使用 Matlab 等工具可以很方便地执行复数的计算：

    >> a = sqrt(2) + sqrt(2)*i;
    >> a^2

    ans = 0.0000 + 4.0000i

    >> b = 1 + i;
    >> b^2

    ans = 0.0000 + 2.0000i

Matlab 向量计算则，直接使用方括号表示向量：

    >> dot([3 4], [-4 3])

    ans = 0

计算辐角使用复数参数，计算模长用 abs 函数，复数相乘的一个特点是辐角相加模相乘：

    >> rad2deg(angle(3+4i)) %phase angle

    ans = 53.1301

    >> rad2deg(angle(-4+3i))

    ans = 143.1301

    >> rad2deg(angle((-4+3i)*(3+4i)))

    ans = -163.7398

    >> abs((-4+3i)*(3+4i))  %magnitude

    ans = 25

    >> abs(-4+3i)

    ans = 5

对于除法，需要使用共轭复数。何谓共轭？共轭即为按一定的规律相配的一对，通俗点说就是孪生。共轭复数就是
两个实部相等，虚部互为相反数的复数，Conjugate complex number，一个复数的共轭表示为其符号上加一横，
为了输入方便，有时也可以这样表示，z* 与 z 共轭。一对共轭复数，在复平面上关于实轴对称。

轭，最早是用来表示拉车时，架在牛脖子上的曲木，古代拉车通常两头牛并驾齐驱，因此说这两头牛是“共轭”。

复数除法的诀窍就是在分式上同时乘以分母的共轭复数！一个复数与其共轭复数相乘可以用以下公式：

    (a + b𝑖)(a − b𝑖) = a² + b²：

证明过程也简单：

    (a + b𝑖)(a − b𝑖) = a² (- ab𝑖 + ab𝑖) -b²𝑖²
                     = a² - b²𝑖²
                     = a² + b²

计算 (2 + 3𝑖) 与 (4 − 5𝑖) 相除为例：

    (2 + 3𝑖) / (4 − 5𝑖) = (2 + 3𝑖)(4 + 5𝑖) / (4 - 5𝑖)(4 + 5𝑖)
                       = (8 - 15) + (10 + 12)𝑖 / (4² + 5²)
                       = -(7 + 22𝑖) / 41
                       = -7/41 + 22𝑖/41

复数的代数乘法看上去并没有什么特别的，借助复数的矩阵表示，可以重新理解它所表示的实际含义。

一个复数可以用来表示一个旋转、缩放变换，多个复数相乘，可以看作是多个旋转缩放变换的叠加。由于 2D 旋转
和缩放无顺序差别，所以复数相乘满足交换律。

构造一个从复数集合 ℂ 到特定矩阵集合 𝕄 的映射，使任意复数 𝑍 = 𝑎 + 𝑏𝑖 一一对应映射到矩阵 M：

    [ 𝑎  -𝑏 ]
    [ 𝑏   𝑎 ]

当然，这样的映射当然不是满射，即矩阵的维数不仅有 2x2，所以对值域加这个维数限制，则使之成为满射。
这样定义复数的矩阵表达，可以使复数的矩阵运算完全和一般矩阵无异，加、减、乘、除运算规则都一致。

复数表示的 2D 旋转如下，在复平面内，假设向量 𝑍 与实轴的夹角为 Θ，则：

    cos(Θ) = 𝑎 / √(𝑎² + 𝑏²)

    sin(Θ) = 𝑏 / √(𝑎² + 𝑏²)

提取因子，即可将以上两个条件代入复数 𝑍 = 𝑎 + 𝑏𝑖 对应的矩阵表达式中：

    [ 𝑎  -𝑏 ]               [ cos(Θ)  -sin(Θ) ]
               = √(𝑎² + 𝑏²) 
    [ 𝑏   𝑎 ]               [ sin(Θ)   cos(Θ) ]

所以，复数的矩阵形式代表的是一个旋转、缩放变换，旋转角度为 Θ，绽放比例为 √(𝑎² + 𝑏²)。



回到三角函数表达的单位圆方程，将其变换到复数平面上，它就可以用来任意角度旋转复数。

    cos(θ)² + sin(θ)² = 1

介绍一下极坐标(polar coordinate)，常用的 xy 两轴坐标称为 Cartesian 坐标，极坐标的也用 xy 轴，
不同的是，极坐标加入了旋转角度，用来 θ 表示沿 x 轴正方向逆时针旋转度数。在极坐标平面系统中的任意点
可以用半径和旋转角度来表示 (r,θ)，复平面内的点可以变换为极坐标的形式。

可用 x = r cos(θ) 和 y = r sin(θ) 来转化到笛卡尔坐标，所以复数极坐标 (r, θ) 表示如下：

    z = x + 𝑖y 
      = r cos(θ) + 𝑖 r sin(θ)
      = e^(𝑖θ)

特别的，如果 r = 1， 则 

    z = cos(θ) + 𝑖 sin(θ)

形如 r e^(𝑖θ) 的复数为极坐标形式，并且与之相对的 x+𝑖y 为笛卡尔形式. 1743 年，瑞士数学家欧拉
给出了著名的欧拉公式，对所有实数 θ 都成立。这就是用对数形式表示的欧拉公式，但是，要理解这个公式是
如何来的，我们需要一样东西，叫做泰勒级数 Taylor series。

    e^(𝑖θ) = cos(θ) + 𝑖 sin(θ)

特别当 θ = π 时，按复数平面规则运算，右边的值为 -1，欧拉公式的特殊形式更是被评为数学上最美的公式：

    e^(𝑖π) + 1 = ０

这个简洁公式包括了数学上最重要的 5 个常数：

- 0，1 自然数的基本单位；
- e 描述变化率的自然指数；
- π 圆周率；
- 𝑖 虚数的基本单位。

最奇怪的问题是：我们怎样取一个数的 𝑖 次方？指数上有虚数怎么算？那就是用对数形式导出的欧拉公式。

用几何的方法证明该等式，不同的 θ 值对应的极坐标 e^θ，特别注意复平面旋转角度 180° 落到 -1 的时刻。

由数学家布鲁克·泰勒发现的 Taylor series 在近似计算中有重要作用。函数 e^x 的泰勒级数扩展如下，
因为阶乘 0! 和 1! 的值都定义为 1，式子前两项为 1 + x:

    eˣ = x⁰/0! + x¹/1! + x²/2! + x³/3! + x⁴/4! ... xⁿ/n!

阶乘是基斯顿·卡曼（Christian Kramp，1760～1826）于 1808 年发明的运算符号，是数学术语。一个正
整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 0 阶乘为 1。自然数 n 阶乘写作 n!。
1808年，基斯顿·卡曼引进这个表示法。

如果 n 比较大，结果几乎等于 e^x，且添加的求和项数越多，两个结果越靠近。在某些时候，计算器上的两个
结果是一样的，因为计算器精度无法检测它们之间的微小区别。当你对无穷多项求和时，两个结果是一模一样的。
当你对无穷多项求和时，两个结果是一模一样的。欧拉公式包含以下两个函数的泰勒级数，注意角度使用弧度。

    cos(x) = 1 - x²/2! + x⁴/4! - x⁶/6! + ...
    sin(x) = x - x³/3! + x⁵/5! - x⁷/7! + ...

现在，让我们将泰勒级数中的变量 x 换成 ix 就得到：

    eⁱˣ = (𝑖x)⁰/0! + (𝑖x)¹/1! + (𝑖x)²/2! + (𝑖x)³/3! + (𝑖x)⁴/4! ... (𝑖x)ⁿ/n!

某些 𝑖 的次方可以简化，例如，按定义 𝑖² = −1，𝑖³ = -𝑖 及 𝑖⁴ = 1，等等。上式简化后，涉及 𝑖 的项
合并在一起，简化式会包含两个级数与前面 sin(x) 和 cos(x) 的级数一样，将它们代入而得欧拉公式。



复数的引入，不仅仅解决了负数的开方问题，在各行业上也大放异彩。例如，信号处理领域利用傅里叶变换可以
实现频谱分析仪 Spectrum Analyzer，可以用来做音频、视频滤波处理。电子领域上，AC (Alternating Current)
交流电按正弦函数规律变化，直接使用正弦函数很难处理交流电的叠加，但是使用复数平面就容易解决的多。

还可以使用复数来放大 Mandelbrot Set 曼德布罗特集分形图形，分形之父创造的这种分形基于复数方程
zₙ+1 ＝ zₙ² + c，重复该步骤直到：

- 发散到无穷远处，根据发散的速度选择颜色；
- 不会发散，并形成实际的 Mandelbrot 集，显示为黑色。


### 🟠🔵 Quaternions 四元数
- [四元数的可视化 by 3Blue1Brown](https://www.bilibili.com/video/av33385105/)
- [Visualizing quaternions, an explorable video series](https://eater.net/quaternions/video/intro)
- [Understanding Quaternions](https://www.3dgep.com/understanding-quaternions/)
- [四元数与三维旋转 - Krasjet](https://krasjet.github.io/quaternion/quaternion.pdf)
- Visualizing Quaternions by Andrew J. Hanson
- [四元数——基本概念 - 杨智为](https://zhuanlan.zhihu.com/p/27471300)
- [四元数应用——转矩阵、Slerp插值与万向节](https://zhuanlan.zhihu.com/p/28189289)
- [如何形象地理解四元数？ - Yang Eninala](https://www.zhihu.com/question/23005815/answer/33971127)
- [维度：数学漫步 Dimensions: A Walk Through Mathematics (2008)](https://www.bilibili.com/video/BV1rx411J7EL)
- [GAMES105-计算机角色动画基础-刘利斌](https://www.bilibili.com/video/BV1GG4y1p7fF/)
- [08.游戏引擎的动画技术基础 GAMES104-现代游戏引擎：从入门到实践](https://www.bilibili.com/video/BV1jr4y1t7WR?t=3794.3)

![Hamilton plaque at Broombridge, Cabra](https://ingeniousireland.ie/wp-content/uploads/2011/10/Broombridge-plaque-BDolan-2010-web-600x450.jpg)

相比矩阵，用四元数处理 3D 旋转的优势是毋庸置疑的，但是 Quaternions 四元数概念复杂，难于理解。
四元数的定义和复数非常类似，唯一的区别就是四元数有三个虚部，而复数只有一个．所有的四元数 𝑞 ∈ ℍ，
ℍ 代表四元数的发现者 William Rowan Hamilton，都可以写成下面这种形式。

    𝑞 = 𝑎 + 𝑏𝑖 + 𝑐𝑗 + 𝑑𝑘 ∈ ℍ (𝑎, 𝑏, 𝑐, 𝑑 ∈ ℝ)

    𝑖² = 𝑗² = 𝑘² = 𝑖𝑗𝑘 = −1

    𝑖𝑗 = -𝑗𝑖 = 𝑘
    𝑗𝑘 = -𝑘𝑗 = 𝑖
    𝑘𝑖 = -𝑖𝑘 = 𝑗

一个四元数由一个实数和一个三维向量构成，四元数就是一个高阶复数，四元数其实就是基底 {1, 𝑖, 𝑗, 𝑘} 
的线性组合，也可以写成向量的形式。有说法指出，向量这个名字就是汉密尔顿发明的，向量的叉乘也是四元数的
副产物：

    q = (𝑣⃗ + 𝒘)ᵀ = ((x,y,z),𝒘)ᵀ

    q₁q₂ = (𝒘₁ + x₁𝑖 + y₁𝑗 + z₁𝑘) (𝒘₂ + x₂𝑖 + y₂𝑗 + z₂𝑘)
         = (𝒘₁𝒘₂ - x₁x₂ - y₁y₂ - z₁z₂) +
           (𝒘₁x₂ + x₁𝒘₂ + y₁z₂ - z₁y₂ )𝑖 +
           (𝒘₁y₂ + y₁𝒘₂ + z₁x₂ - x₁z₂ )𝑗 +
           (𝒘₁z₂ + z₁𝒘₂ + x₁y₂ - y₁x₂ )𝑘

        = (𝒘₁, 𝑣⃗₁) (𝒘₂, 𝑣⃗₂)
        = (𝒘₁𝒘₂ - 𝑣⃗₁ ∙ 𝑣⃗₂, 𝒘₁𝑣⃗₂ + 𝒘₂𝑣⃗₁ + 𝑣⃗₁ ⨉ 𝑣⃗₂)


其它表达形式及运算：

- 纯四元数   𝑞 = 0 + 𝑏𝑖 + 𝑐𝑗 + 𝑑𝑘, (𝑎, 𝑏, 𝑐, 𝑑 ∈ ℝ)
- 单位四元数 q = (𝒘, 𝑣⃗)ᵀ = (cos(Θ/2), 𝑢 sin(Θ/2))  |𝑢| = x² + y² + z² + 𝒘² = 1
- 共轭四元数 q* = (𝒘, -𝑣⃗)ᵀ
- 标量积    s𝒒 = (s𝒘, s𝑣⃗)ᵀ
- 加法     q₁ + q₂ = (𝒘₁+𝒘₁, 𝑣⃗₂+𝑣⃗₂)ᵀ
- 点积     q₁ · q₂ = (𝒘₁𝒘₁ + 𝑣⃗₂·𝑣⃗₂)
- 点积共轭  (q₁ · q₂)* = q₂* · q₁*
- 模长     |q| = √(𝒘₁𝒘₁ + 𝑣⃗₂·𝑣⃗₂) = √(q · q)
- 模长平方  |q|² = q · q* = q* · q
- 倒数     q⁻¹ = q* / |q|²
- 倒数积   qq⁻¹ = q⁻¹q = 1


在三维空间的旋转操作中，即工程中的刚体旋转问题，需要考虑物体如何旋转，是根据全局坐标系统，还是物体
局部坐标系统。一般操作上是以全局空间定义的，通常物体的初始状态下，本地坐标与全局坐标是对齐的。

Blender 中提供了三种旋转方式，向负轴向看，以逆时针旋转为正旋转角度：

- **Euler** The gizmo handles are aligned to the Euler axis, allowing you to see 
    the discreet XYZ axis underlying the Euler rotation, as well as possible Gimbal Lock.
- **Axis Angle** The X, Y, and Z coordinates define a point relative to the 
    object origin. This point and the origin define an axis around the W value 
    defines the rotation.
- **Quaternion** X, Y, Z and W correspond to the Quaternion components.

欧拉角旋转旋转轴与 XYZ 各坐标轴对齐，即各坐标轴就是旋转轴，按先后顺序旋转 有 6 种顺序组合，列表中
的名称中的各轴顺序与 Gimbal 设备中的各轴由内到外的套接顺序相同。例如，ZYX Euler 旋转就是优先读取
Z 轴旋转角度，最后读取 X 轴旋转角。或者可以这样理解，无论其它轴如何旋转，名字开头的这个轴总是绕物体
局部坐标对应轴作为旋转轴，而名字结尾的 X 则相当于全局空间的 X 坐标轴作为旋转轴。
名字中间的旋转轴就取决于另外两者的旋转状态，因为有优先级的关系，算法就可能存在 Gimbal Lock 现象。

![Gimbal](https://pic2.zhimg.com/v2-2f3d8c9c2de8c7f225ab65092598685d_b.webp)

以轴角表示旋转，Axis Angle 方式需要两个参数，旋转轴向量 𝑢 和旋转角度 Θ。即表示物体绕过原点的 𝑢 轴
旋转 Θ 角度。因该轴穿过原点，只需要一个三维单位矢量表示该轴方向。在三维空间中，旋转轴 𝑢 的坐标以及
旋转角组成四个自由度 (Degree of Freedom)，多于欧拉角的三个自由度。

轴角法有两个优点，两个硬伤：

- 优点一：同轴的两次旋转可以直接相加来等效为一次旋转。
- 优点二：定义简单，相对直观。
- 硬伤一：两个坐标系 xyz 和 x'y'z'，轴角法表示不唯一（角度规定在0-180）。当旋转角度为 0，旋转轴
  可以为任意方向。但是在应用中，一一对应很重要，这也就暴露出了轴角法表示的最致命的问题。
- 硬伤二：两次连续的旋转怎样合成呢？或者说是两个旋转如何做差呢？答案是没办法，除非借助其他表示方法。

下图演示了以微积分思想的三维旋转表达，d𝑢⃗/dθ = 𝑎⃗ x 𝑢⃗：

![Axis-Angle Rotations in 3D](https://www.reedbeta.com/blog/rotations-and-infinitesimal-generators/rotation03.png)

四元数旋转也定义了四个数，其中 W 定义一个角度，但它与轴角度截然不同。默认 w = 1.0 的前提下，旋转
1.0 相当 90°，但永远到达不了 180°，并且不是线性关系，设置系数 w = 0.5，旋转角度相当于加倍，
最大旋转角依然为 180°。

轴角旋转方式 Axis Angle (𝑣⃗, Θ) 可以对应到四元数旋转，但这种对应不是一一对应，即非满射关系，形式
也不同。

    q = (𝒘, 𝑣⃗)ᵀ = (cos(Θ/2), 𝑢 sin(Θ/2))
    Θ = 2argcos(𝒘)
    𝑢 = 𝑣⃗/|𝑣⃗|

按 𝑢 向量所对齐的轴旋转 𝑝 得到 𝑝' 可以表示为，q 或 -q 表示同样的旋转的两个方向，两个四元数旋转
可以变换成这两个四元数的叉积的旋转：

    (0, 𝑝')ᵀ = q (0, 𝑝')ᵀ q* = (-q) (0, 𝑝')ᵀ (-q*)

一个四元数值可以在几何学上解释为，定义 4D 空间中单位球体上的点。沿着球体的任何大圆移动，表示围绕固定
轴旋转，一个完整的圆匹配两个完整的旋转。

使用四元数进行旋转操作的优点：

- 提供球形旋转的平滑插值功能，Spherical Linear Interpolation (SLERP)；
- 解决万向节死锁（Gimbal Lock）问题；
- 仅需存储 4 个浮点数，相比矩阵更加轻量；
- 四元数无论是求逆、串联等操作，相比矩阵更加高效；

所以综合考虑，主流游戏或动画引擎都会组合缩放向量、旋转四元数、平移向量数据存储角色的运动。

总结一下已经得出的四元数特性：

- 四元数是四维空间中一个超球上面的点，满足 w²+x²+y²+z²=1。
- 四元数是复数虚部扩展的结果，复数的虚部为 1 个，而四元数虚部有 3 个，且两两互相正交。
- 由于 w²+x²+y²+z²=1 约束，四元数旋转只有 3 个自由度，且每个四元数可以对应一个特征向量，即 n。但请记住四元数并不是与特征向量一一对应。

在二维平面空间中圆表示为 x²+y²=1，在三维空间中球体表示为 x²+y²+z²=1，而四元数可表示一个超球体，
Hypersphere，而其中的 3 个虚部分即拥有三维空间，可以表示为一个球体。Grant Sanderson 尝试用
Stereographic projection 球极平面投影，降维投射的方式帮助理解四元数，将二维圆作为一维球极投影
得到一条投影线，球作为二维球极平面投影得到一个平面，超球作为三维球极平面投影得到一个球体。

由于四元数存在于四维空间，所以需要利用低维信息去理解高维信息。用三维球为例，代数方程为 x²+y²+z²=1，
虽然球上面的点是由 x，y，z 三个参数来确定，但实际上只需要两个，因为已经方程关系。假设 x 和 z 表示，
其中 y 可以通过 x 和 z 进行求解。所以将 y 轴信息给隐去，三维球就可以投影为平面上的圆，如下图所示。
图片来自 Visualizing Quaternions Chapter 8 Visualizing Spheres，教材用 q 表示四元向量。

![3D Sphere projection](https://pic2.zhimg.com/80/v2-8934d9751fb9f2485156b87b2d718171_1440w.webp)

> FIGURE 8.9 The standard sphere S² visualized as two filled 2D discs, the northern 
> and southern hemispheres, together with the equatorial circle (i.e., S¹ ) that 
> forms the border exactly between the two, at q₀ = 0, or equivalently at |q| = 1.

这张图的意思是，三维球在 xOz 平面上投影是一个圆，当球面一点投影在过圆心的平面与球面相交的圆上时，
y = 0，投影结果就是图上的圆。当投影位于圆内，则分两种情况，y > 0 处于北半球，y < 0 处于南半球，
两个半圆交界就是圆。所以，通过投影后的圆即可还原出整个球体。

![4D Sphere Projection](https://pic2.zhimg.com/80/v2-d636d27ab4a72b31925b1d610469b32d_1440w.webp)

> FIGURE 8.11 The quaternion S³ visualized as two solid 3D balls, the northern 
> and southern hemispheres, together with the equatorial S² that forms the border 
> exactly between the two, at q₀ = 0, or equivalently at |q| = 1.

推广到四维空间，w²+x²+y²+z²=1 中取 x、y、z 来表示超球 hypersphere 在三维空间上的投影。四维空间
的超球投影到三维超平面可能是一个 two-sphere，当投影点在整个 two-sphere 的交界时，w = 0。投影点
落在 two-sphere 的内部时，也分为两种情况，w > 0 和 w < 0。这两种情况下对应的特征向量是一样的，
所以我们将旋转矩阵向四元数转换时，是有两个对应值的，四元数的范围是 2 倍覆盖于 3D 旋转（2:1 mapping）。



### 🟠🔵 Calculus 微积分
- [Highlights of Calculus - Bilbert Strang](https://www.bilibili.com/video/BV13v411t7A6/)

微积分，包括微分和积分两种完全相反的问题处理思维，differential and integral，微分向细微处求解，
积分将细微变化累积成为一个完整的结构。

∫ₙᵐ


### 🟠🔵 Transformations 变换
- [Matrices and transforms](https://docs.godotengine.org/en/latest/tutorials/math/matrices_and_transforms.html)
- [Matrices and transforms](https://docs.godotengine.org/en/3.5/tutorials/math/matrices_and_transforms.html)
- [Viewport and canvas transforms](https://docs.godotengine.org/en/3.5/tutorials/2d/2d_transforms.html)
- [Using 3D transforms](https://docs.godotengine.org/en/3.5/tutorials/3d/using_transforms.html)
- [Matrix Transform Demo](https://github.com/godotengine/godot-demo-projects/tree/master/misc/matrix_transform)
- [Geometry Transformations](https://www.mathsisfun.com/geometry/transformations.html)
- [Visualization - Geometric Algorithms](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
- [GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)
- [GAMES101-现代计算机图形学入门-闫令琪](https://www.bilibili.com/video/av90798049)
- [Grant Sanderson - 3blue1brown 线性代数的本质](https://www.bilibili.com/video/BV1ys411472E)
- [CSD 15-462 Computer Graphics - Carnegie Mellon University](https://www.cs.cmu.edu/afs/cs/academic/class/15462-f11/www/)

图形学上的变换操作与矩阵运算密切联系，这需要掌握矩阵运算方法，主要是矩阵乘法。

这里说的变换是二维的仿射变换（Affine Transformation），即两种简单变换的叠加：线性变换加平移变换。
仿射变换后原来的直线还是直线，原来的平行线经过仿射变换之后还是平行线，这就是仿射。拉丁语 affine 
意思为“和…相关”，即和原型线性相关的变换。平移不是线性变换，因为平移并没发生线性关系的改变，如同一个
苹果放到另一个位置上，还是一个苹果，这个比喻可能不太恰当。

仿射变换变化基本包括：

- 缩放 Scale
- 平移 translation
- 旋转 rotate
- 反射 reflection
- 错切 shear mapping

仿射变换中集合中的一些性质保持不变：

- 凸性保持不变；
- 共线性：若几个点变换前在一条线上，则仿射变换后仍然在一条线上；
- 平行性：若两条线变换前平行，则变换后仍然平行；
- 共线比例不变性：变换前一条线上两条线段的比例，在变换后比例不变；

卡耐基梅隆大学计算机图形学 CMU 15-462/662 Computer Graphics 课件直观地演示了什么是线性变换。

![Linear Maps - Geometric Definition](http://15462.courses.cs.cmu.edu/fall2020content/lectures/02_linearalgebra/thumbs/slide_041.jpg)

课程对代数知识的讲解也非常全面，比如对方程组这个概念的解析，System of Linear Equations 即类似
以下一组方程，左手边是线性函数，右手边是常量。未知量有时也叫做自由度，degrees of freedom (DOFs)。
方程有时也叫做约束，方程组的目标是求解同时满足所有约束的 DOFs。

     x + 2y = 3
    4x + 5y = 6


对于一个集合 𝕏 的仿射变换可以定义为：

    f(x) = Ax + b, x ∈ 𝕏

二维平面上的点进行仿射变换只需要一个 2x2 矩阵，左乘两个矩阵具有连续几何变换作用，如下两种几何变换：

    [ 1 1 ]   [ 0 -1 ]   [ x ]     [ 1 -1 ] [ x ]   [ x - y]
    [ 0 1 ]   [ 1  0 ]   [ y ]  =  [ 1  0 ] [ y ] = [ x    ]

     Shear    Rotation   Input      Composition

代数化表达的各种线性变换矩阵：

    [ s 0 ]   [ 1 a ]   [  cosθ sinθ ]
    [ 0 s ]   [ a 1 ]   [ -sinθ cosθ ]
     Scale     Shear       Rotation

两个独立的变换等价于一个复合变换，按照矩阵乘法，旋转矩阵可以映射 [x, y] 为 [-y, x]，原先 x 映射
到了 -y 上，原先 y 映射到 x 轴上，也就是顺时针旋转 90 度。然后沿 x 轴切变为 [x - y, x]。注意，
这两个变换的矩阵运算顺序会影响结果。变换矩阵计算和书写顺序都从右往左，和复合函数 f(g(x)) 表达一致。
可以计算出等价的组合变换矩阵替代两个变换矩阵，但是现在记住两个矩阵相乘的几何意义更重要。

利用几何变换的意义去替代实际的运算，即通过跟踪向量基底的运动方向来理解矩阵运算产生的几何意义，这样
更有助于理解线性变换的意义。

图形学上，二维图像处理一般用 3x3 矩阵表达仿射变换的线性关系：

    [ x']   [ R₀₀ R₀₁ Tx ]   [ x ]
    [ y'] = [ R₁₀ R₁₁ Ty ] = [ y ]
    [ 1 ]   [ 0   0   1  ]   [ 1 ]

![Affine transformation - from Wiki](https://img-blog.csdnimg.cn/20190809112449680.png)


至于为何需要额外给矩阵添增加一个维度，即齐次坐标 Homogeneous coordinates，目的是为达成矩阵乘法
运算的条件，使能处理平移变换，增加 w 分量值意义取决于用途。

> “齐次坐标表示是计算机图形学的重要手段之一，它既能够用来明确区分向量和点，同时也更易用于进行仿射几何变换。”
> —— F.S. Hill, JR

- 2D point  = (x, y, 1)ᵀ
- 2D vector = (x, y, 0)ᵀ
- 3D point  = (x, y, z, 1)ᵀ
- 3D vector = (x, y, z, 0)ᵀ

Valid operation if w-coordinate of result is 1 or 0

- vector + vector = vector 向量相加还是向量
- point – point = vector 产生一个向量
- point + vector = point 移动一个点
- point + point = ?? 两点的中点 (x, y, w) --> (x/w, y/w, 1)，两点相加后 w 分量加倍，要变回 1 就需要除以 w。

通过齐次坐标，可以用它来区别点与向量，也可以在做运算时保持向量的平衡不变性质。

完整仿射变换包含 Geometric contraction、expansion、dilation、reflection、rotation、shear、
similarity transformations、spiral similarities 和 translation 等类别的组合，通常来讲，
可以简单地认为仿射变换由 Rotations、Translations、Dilations 和 Shears 四类组合而成。

在三维变换中，将二维变换推广使用，在 [4x4] 的仿射矩阵中，使用左上角的 [3x3] 作为缩放、切变、旋转
变换使用，多维度变换再组合到一块就是 3D 变换。对于旋转，通常也是按指定轴进行旋转，而不是按任意向量
进行旋转，这样会很复杂。

    [ x 0 0 0 ]  [ 1 0 0 x ]  [ 1     0     0 0 ]  [ cosα 0 sinα 0 ]  [ cosα -sinα 0 0 ]
    [ 0 y 0 0 ]  [ 0 1 0 y ]  [ 0  cosα -sinα 0 ]  [ 0    1    0 0 ]  [ sinα  cosα 0 0 ]
    [ 0 0 z 0 ]  [ 0 0 1 z ]  [ 0  sinα  cosα 0 ]  [-sinα 0 cosα 0 ]  [ 0     0    1 0 ]
    [ 0 0 0 1 ]  [ 0 0 0 1 ]  [ 0     0     0 1 ]  [ 0    0    0 1 ]  [ 0     0    0 1 ]
     S(x,y,z)     T(x,y,z)        Rx(α)                 Ry(α)                Rz(α)     

注意，旋转变换中的三角函数位置，对什么轴进行旋转操作，对应轴上的坐标就保留单位矩阵的取值。绕一个轴向
旋转，这个轴对应的矩阵系数就可以保持不变，即将位于对角线上的值设置为 1，行、列内其它的值设置为 0。

另外，旋转矩阵中的负号位置取决于坐标系统，以上这种写法适用于右手坐标系统，拇指指向 X，食指指向 Y，
中指指向 Z，并且三者相互垂直。即 XY 叉积指向 Z，而 YZ 叉积指向 X，ZX 叉积指向 Y。如沿 X 轴旋转，
负号跟着 Z 对应的矩阵元素，沿 Y 轴旋转，负号跟着 X 对应的矩阵元素，依次类推。使得向负轴方向看，
旋转角 α 的正负值始终和数学定义的正负方向一致，逆时针为正方向旋转。

关于旋转矩阵的推理求解过程，可以参考闫令琪的网课 GAMES101-现代计算机图形学入门 
[03 Transformation](https://www.bilibili.com/video/BV1X7411F744/?t=1111.3&p=3)

三维空间的角用 Euler angles 欧拉角表示，其旋转按不同的轴向进行，以平驶飞机为主体参考：

- **Yaw**  - 偏航角，飞机绕垂直机身的中轴左右旋转的角度；
- **Pitch**- 俯仰角，飞机绕机翼方向平行的中轴上下摇摆机头的角度；
- **Roll** - 横滚角，飞机绕行驶方向平行的中轴顺/逆时针旋动的角度。

欧拉角是多轴独立的、有序的旋转组合，可能导致 Gimbal lock，另一个问题是不容易插值实现平滑的运动。
所以，最好不要使用 `rotation`，而是使用变换矩阵。

3D 环境下三种旋转方式对比：

|     方式   |              优点                  |                 缺点                     |
|-----------|------------------------------------|-----------------------------------------|
| 矩阵旋转   | 使用齐次坐标可以算是平移，可按任意向量旋转 | 数据占用空间和时间上有些浪费，乘法操作增加计算量 |
| 欧拉角旋转  | 形象直观，只需要x、y、z轴的旋转角度       | 使用3个3x3的矩阵做变换，效率不如四元数        |
| 四元数旋转  | 4维的四元数可以绕原点任意旋转，可平滑插值 | 多了一个维度，比欧拉旋转复杂，不直观          |

欧拉角旋转通常要按照一个固定的坐标轴的优先顺序旋转，因此不同的顺序会造成不同的结果。这种优先处理方式
会造成万向节锁（Gimbal Lock）现象，因此种情形，欧拉旋转无法实现球面平滑插值。理论上，欧拉旋转可以
靠这各轴独立的旋转让一个物体指到任何一个想要的方向。

而万向节锁问题 gimbal lock，是在旋转过程中出现失去一个轴向上的自由度状态。

万向节，或平衡环架 Gimbal 是一具有枢纽的装置，作用是使得一物体能以单一轴旋转。由彼此垂直的枢纽轴
所组成的一组三只平衡环架，则可使架在最内的环架的物体维持旋转轴不变，而应用在船上的陀螺仪、罗盘、饮料
杯架等用途上，而不受船体因波浪上下震动、船身转向的影响。

![Gimbal](https://pic2.zhimg.com/v2-2f3d8c9c2de8c7f225ab65092598685d_b.webp)

这种装置在出现两个枢纽对齐重叠，就有引起一个自由度失效的问题。三维软件算法上处理不当，也会有类似现象。


仿射变换是二维平面重要的变换形式，在图形处理领域有广泛的应用，Godot 提供以下类型支持变换操作：

|    Class    |              Usage              |
|-------------|---------------------------------|
| Vector2     | Vector used for 2D math.        |
| Vector3     | Vector used for 3D math.        |
| Transform2D | 2D transformation (2×3 matrix). |
| Transform3D | 3D transformation (3×4 matrix). |

2D 节点只需要 global_position 就可以定位在屏幕空间，3D 节点则需要一个变换矩阵，并且有全局、本地
两个变换，在层级关系中，父节点的变换会传递给子节点，影响子节点的位置。

以下是 3D 节点与变换矩阵相关的属性默认值，以及变换矩阵的默认值：

```c
// Node3D
      Vector3 translation           [default: Vector3( 0, 0, 0 )]
      Vector3 rotation_degrees      [default: Vector3( 0, 0, 0 )]
      Vector3 rotationVector3scale  [default: Vector3( 1, 1, 1 )]
    Transform global_transform
      Vector3 global_translation
      Vector3 global_rotation
    Transform transform [default: Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0 )]

// Transform3D
        Basis basis [default: Basis( 1, 0, 0, 0, 1, 0, 0, 0, 1 )]
      Vector3 origin [default: Vector3( 0, 0, 0 )]

// Basis
Basis Basis(from: Quat)
Basis Basis(from: Vector3)
Basis Basis(axis: Vector3, angle: float)
Basis Basis(x_axis: Vector3, y_axis: Vector3, z_axis: Vector3)
```

全局平移 `global_translation` 对应是节点的全局位置坐标，等价 global_transform.origin。
基矩阵包含三个旋转轴向量，x、y、z，每个向量都指向其轴旋转的方向，因此它们有效地描述了节点的总旋转。
也可以说，基矩阵包含了旋转后的各轴指向。

Godot 场景中，摄像机总是朝向其 z-negative 方向摄像的：

![Camera in Godot Scene](https://docs.godotengine.org/en/stable/_images/transforms_camera.png)

所以，如果将一个相机与玩家视角绑定，那么玩家的前行方向就应该和摄像机的基矩阵中的 basis.z 一致。
相机则只做俯仰角度的调整（pitch），而玩家角度做偏航角度的调整（yaw），这种情况比较容易处理，不会
有欧拉角的约束问题。也不需要直接考虑复杂的空间旋转问题，只需要根据玩家的 yaw 方向来决定前行方向。

Godot 坐标系统中，按以下向量确定方向，x 轴指向 RIGHT，y 轴指向 UP，z 轴指向 BACK(backward)：

    Vector3.UP (0, 1, 0)
    Vector3.RIGHT (1, 0, 0)
    Vector3.FORWARD (0, 0, -1)

基矩阵有四种构造方法，可以接收一个四元数，也可以接收旋转轴向量和对应的旋转角。或者以一个向量给定的
Euler 角度构造纯旋转基矩阵，在 YXZ 约定中：合成时首先是 Y，然后是 X，最后是 Z，以矢量格式给出
X 角度、Y 角度、Z 角度。应该优先考虑使用四元数，而不是欧拉角。


根据变换矩阵的维度不同，2D 或 3D，变换矩阵对象包含的只是一系列存储浮点数值的向量，也就是 xyz 三轴
对应的三个向量，通过下标可以访问这此矩阵元素，就像访问数组的元素一样。注意，变换矩阵只是定义如何变换，
而变换后的结果，如 3D 物体的旋转角度这些值则是另外的属性中存储的数据，在属性探测器 Transform 分组，
而变换矩阵数据则在 Matrix 分组中显示。变换后的属性值通过导出属性读取，如当前物体的旋转角度：

```py
var rotation:Vector3 = get("rotation_degrees")

var t = Transform2D()
# Translation
t.origin = Vector2(350, 150)
# Rotation
var rot = -0.5 # The rotation to apply.
t.x.x = cos(rot)
t.y.y = cos(rot)
t.x.y = sin(rot)
t.y.x = -sin(rot)
# Scale
t.x *= 3
t.y *= 3
transform = t # Change the node's transform to what we just calculated.
```

根据，数组在内存中的顺序结构，矩阵的第一个维度表示一行，第二维度表示列，如 t.x.y 表示 y 行 x 列。
一般不会直接修改变换矩阵的元素，而是通过方法来间接修改，最基本的就是旋转、缩放、平移三种仿射变换：

```py
Transform rotated(axis: Vector3, angle: float)
Transform scaled(scale: Vector3)
Transform translated(offset: Vector3)
```

```py
Transform affine_inverse()
Transform interpolate_with(transform: Transform , weight: float)
Transform inverse() 
bool is_equal_approx(transform: Transform )
Transform looking_at(target: Vector3, up: Vector3)
Transform orthonormalized()
Variant xform(v: Variant)
Variant xform_inv(v: Variant)
```

画布中的图像要显示到屏幕上，即从画布项目坐标系统转换到屏幕坐标系统，会经历以下四个变换。并且，画布
与 CanvasLayer 是可以嵌套的，即节点之间的层次受到本身坐标影响外，还受到 CanvasLayer 的影响：

- CanvasItem Coordinates
    - > CanvasItem Global Transform `CanvasItem.get_global_transform()`
    - > Canvas Layer Transform `CanvasItem.get_canvas_transform()`
    - > Viewport Global Canvas Transform
    - > Viewport Stretch Transform
- Screen Coordinates

注意，屏幕坐标是指程序窗口所占据的屏幕区域，左上角为原点，右下角为正方向。其中，Stretch Transform 
变换和项目设置 Stretch Mode 相关，可以通过 SceneTree 提供的方法手动给视口设置延申变换矩阵，目的是为了处理多分辨率显示的适应问题。

```py
void set_screen_stretch(mode: StretchMode, aspect: StretchAspect, minsize: Vector2, scale: float = 1)
```

使用 `CanvasItem.get_viewport_transform()` 获取 CanvasLayer、GlobalCanvas、Stretch 
三合一变换矩阵。

在输入事件`MainLoop._input_event()` 中，坐标数据是经过 Stretch Transform 变换后的值，这个
值对应的是窗口坐标。另外还提供了 `CanvasItem.make_input_local()` 函数方便转换到画布对象坐标。

默认状态下，输入事件中的鼠标位置是指全局空间下相对于当前节点的 CanvasLayer 的坐标，可以将其转换为
节点本地坐标，本地坐标方向与全局坐标不同，以左下角为原点，右上方向为正方向。全局坐标则以左上角为原点，
右下角为正方向，即上下反转关系。

```py
Vector2 get_global_mouse_position() const # 获取鼠标位于当前节点相对当前 CanvasLayer 的坐标

Vector2 get_local_mouse_position() const  # 获取鼠标位于当前节点本地坐标

InputEvent make_input_local(event: InputEvent) const # 输入事件的鼠标位置转换为当前节点本地坐标

Vector2 make_canvas_position_local(screen_point: Vector2) const
# Assigns screen_point as this node's new local transform.
```

本地坐标要转换为全局坐标，只需要按以下顺序做逆变换，即可以得到屏幕坐标。还可以模拟鼠标事件，将带有
指定坐标信息的鼠标事件投喂到 SceneTree 事件输入队列中：

```py
var screen_coord = get_viewport_transform() * (get_global_transform() * mouse.position)

var local_pos = Vector2(10, 20) # local to Control/Node2D
var ie = InputEventMouseButton.new()
ie.button_index = BUTTON_LEFT
ie.position = get_viewport_transform() * (get_global_transform() * local_pos)
get_tree().input_event(ie)
```


### 🟠🔵 Curve & Geometry 曲线与几何抽象思维
- [Geometry](https://www.mathsisfun.com/geometry/index.html)
- [从零开始学图形学 - 贝塞尔曲线](https://zhuanlan.zhihu.com/p/344934774)
- [曲线篇: 贝塞尔曲线](https://zhuanlan.zhihu.com/p/136647181)
- [Bezier Curve Demos](http://math.hws.edu/eck/cs424/notes2013/canvas/bezier.html)
- [Animated Bézier Curves](https://www.jasondavies.com/animated-bezier/)
- [【华中科技大学】计算机图形学 #万琳教授](https://www.bilibili.com/video/BV1V7411k74z?p=32)
- [GAMES101 现代计算机图形学入门  Geometry - 闫令琪](https://www.bilibili.com/video/BV1X7411F744/?p=11)
- [清华大学-计算机图形学基础 - 胡事民](https://www.bilibili.com/video/BV13441127CH/)
- [CS3621 Introduction to Computing with Geometry Notes](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/)
- [Mesh Shimplification](https://pages.mtu.edu/~shene/COURSES/cs3621/SLIDES/Simplification.pdf)
- [Multiresolution Modeling A Very Brief Introduction](https://pages.mtu.edu/~shene/COURSES/cs3621/SLIDES/Multiresolution.pdf)
- [Beziers, curves and paths](https://docs.godotengine.org/en/latest/tutorials/math/beziers_and_curves.html)
- [Interpolation](https://docs.godotengine.org/en/latest/tutorials/math/interpolation.html)

曲线与插值密切相关，Godot 提供的矢量类型都有线性插值方法，Vector2.lerp() 或 Vector3.lerp()，或者，
进行三次插值，Vector2.cubic_interpolate() 或 Vector3.cubic_interpolate()，它们都是 Bezier 插值。
Curve2D, Curve3D, Path 和 Path2D 都是插值绘制的曲线节点，只需要提供相应的控制点坐标。

以下代码演示插值方法来移动一个 Sprite 节点来跟踪鼠标位置：

```py
const FOLLOW_SPEED = 4.0

func _physics_process(delta):
    var mouse_pos = get_local_mouse_position()

    $Sprite2D.position = $Sprite2D.position.lerp(mouse_pos, delta * FOLLOW_SPEED)
```

变换矩阵也可以进行插值：

```py
var t = 0.0

func _physics_process(delta):
    t += delta

    $Monkey.transform = $Position1.transform.interpolate_with($Position2.transform, t)
```

Bézier Curve 贝塞尔曲线是计算机图形学二维图形应用程序的数学曲线，曲线定义有起始点、终止点、控制点，
通过调整控制点，贝塞尔曲线的形状会发生变化。

1962 年，法国数学家 Pierre Bézier 第一个研究了这种矢量绘制曲线的方法，并给出了详细的计算公式，
因此按照公式绘制出来的曲线就用他的姓氏来命名，称为贝塞尔曲线。

二次 Bézier 曲线只需要一个控制点，可以画一条 1/4 圆弧。三次贝赛曲线，前两个是控制点坐标。可以通过
调节控制点的位置，进而调整整个曲线，比如使用两个控制点可以画 1/2 圆。

![Bézier curve](https://pic1.zhimg.com/80/c5e0a5463172222a82983fde34ccac5c_1440w.webp)

以二次 Bézier 曲线的实现过程解析，有起点、控制点和终点 P0、P1、P2，曲线的产生完全与这三个点位置相关。
为了确定画线，需要两个运动的参考点：

- R1 从 P0 到 P1 匀速移动；
- R2 从 P1 到 P2 匀速移动；

在期间 R1 R2 连线，其线段可能会长短变化，但只需按比例取 R1-R2 线上的点进行绘制即可得到平滑的曲线。
对于三次或更高阶的 Bézier 曲线，需要在参考点连线上再连参考线，依照处理，同样得到平滑曲线。

虽然贝塞尔曲线的阶数可以很高，但是阶数过高，调整控制点对曲线的影响就比较小，调整起来相当麻烦。于是，
通常用分段的贝塞尔曲线，保证每一小段不会太复杂。这样每次只用调小段，还可以做到只调局部不影响大局。

分段带来的唯一问题是，曲线在段与段的交界处，如何保证平滑？所谓平滑，就是一阶导数连续，左右导数的极限相同。
曲线 Anti-Aliasing，只需要在曲线附近做点插值就行，满足离曲线越近的像素的像素值越高，越远的越低，即可。

改进的样条曲线就是一种方便单独控制线段的曲线描述，最常用的是 B-Splines，即 Basis-Splines。样条中
每个顶点都有两个控制点，通过这两个控制点就可以改变线段的外观。

由样条曲线与平面结合，就可以产生任意的曲面，Non-Uniform Rational B-Splines (NURBS) 非均匀
有理 B 样条曲面是工业常用的曲面生成工具。通过曲线控制平面上的顶点偏移，从而构造出任意的曲面：

![Curve & surface](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/surface/bs-local-mod-2.jpg)


曲面细分是指将一个模型的面合理的分成更多小的面，从而提升模型精度，提高渲染效果。而曲面简化是指将一个
模型的面合理的合成更少的面，从而降低模型精度，为特定情形下提供使用，如 Level Of Detail (LOD) 技术。

几何模型简化是图形学的难点，与之相反的是几何图形细分问题。细分的基本思想是在每条边上插入一个新的顶点，
随着细分次数的增加，折线逐渐变成一条光滑的曲线。曲面细分需要有几何规则和拓扑规则，几何规则用于计算新的
顶点位置，拓扑规则用于确定新顶点的连接关系。Catmull-Clark 细分是一种四边形网格的细分法则，每个面
计算生成一个新的顶点，每条边计算生成一个新的顶点，同时每个原始顶点更新位置。

时钟拨回到 1972 年, 在 Utah 大学的计算机科学课程上, 一位博士, 用贝塞尔曲线算法, 为这节课提交了
一个课程项目：A Computer Animated Hand，这只手, 是美国历史上最早记载的计算机生成动画(CG)。
这位博士就是卡特缪尔 Edwin Catmull，在此前 3 年，他刚拿到自己的物理系学位，凭借着对于图形的热情，
他成为了一家叫 Applicon 的做 CAD 软件的公司的雇员。直到他遇到了 Ivan Sutherland 而开始了计算机
科学博士学位的进修，仿佛重获新生，找到了将自己的艺术理想与理工科学结合的希望。Catmull 博士的毕业论文 
A subdivision algorithm for computer display of curved surfaces 至今超过一千引用。

Ivan Sutherland 是图灵奖得主、计算机先驱、冯诺伊曼奖章、工程与科学院院士、ACM会士、计算机历史博物馆会士，
伊凡·苏泽兰是计算机图形学之父，是 Sun 研究院的高级技术顾问，是隐藏在 Sun 团队背后真正的导师。


曲线是数学抽象思维的表达，通过数学语言来组织思考，并进行高度抽象思维，是一种从无到有的又准确的概括思维。
抽象是一个孤立的过程，是思考着逐渐将信息降维，以保留最普遍信息的一个过程。缺乏抽象思维，则面临被信息淹没。
缺乏逻辑，则难以建立问题与求解的关系。一边简化信息，一边建立问题与解的关系，才是最根本也是最重要的做法。

按以下将 6 项思维能力归类：

- 改变世界 <-- 创新思维
- 理解世界 <-- 整体思维、辩证思维、逻辑思维
- 感受世界 <-- 形象思维

可以把理解世界的 3 个基本的思维作为一个整体的抽象思维：

- 逻辑思维（一元思维、线形、明确的因果关系）
- 辩证思维（二元思维，对立统一的两个要素）
- 整体思维（多元思维，认为事物是相互联系的整体，既见树木又见森林）

思维是人脑借助于语言对事物的概括和间接的反应过程，看苹果是苹果，这就是`形象思维`。从一个苹果一根黄瓜
抽象出数字 1 的概念，进一步抽象出加减乘除四则运算的概念，这应该是大部分智力正常的人都能达到的。
然后从具体的数字运算抽象出用字母代替数字，出来方程、代数概念，这一步已经能淘汰一些人了。再抽象到集合，
抽象到函数，这一步能淘汰掉大半人以上。`函数`、`集合论`的抽象这一步过不去，就很难做进一步的抽象。函数
之上还有 epsilon-delta 语言，这是很多人第一次接触真正意义上的现代数理逻辑。是的，很多人的抽象思维
能力还根本没达到能读懂形式逻辑的地步，还有抽象代数，还有拓扑。

罗素说过，数学是符号加逻辑。大卫·希尔伯特 David Hilbert 说过，听别人讲解某些数学问题时，常觉得很难理解，
甚至不可能理解。这时便想，是否可以将问题化简些呢﹖往往，在终于弄清楚之后，实际上，它只是一个更简单的问题。


几何图形表达有显式、隐式两种基本形式：

- 隐式 Implicit：用解析式表示。易于判断点相对于面的位置，不易判断哪些点在面上。
    - 数学公式：解析几何使用数学公式表达几何体，缺点是不容易表示复杂形状。
    - Constructive Solid Geometry (CSG)：通过一系列基本几何的基本运算（例如布尔运算）来形成新的几何。
    - Distance Functions：如符号距离函数 Signed Distance Functions (SDF)。
    - Fractals 分形
- 显式 Explicit：显式给出或参数映射来定义几何表面。易于判断哪些点在面上，不易判断点相对于面的位置。
    - Point Cloud：点云是大量点的列表。它通过密集的点来给人以面的感觉。点云一般是扫描后得到的数据。
    - Polygon Mesh：多边形面是最常见的显式表示方式。

The Wavefront Object File（.obj）文件定义空间中的点、法线、纹理坐标等，然后组织起来表示多边形面。

距离函数描述空间中任何一个点到表面的最小距离，表面外部的为正数，表面内部为负数，SDF 为 0 的位置
就是物体的表面。使用距离函数对两个物体进行混合的做法是：先混合它们的 SDF，然后将结果恢复成形状。

例如 (x - a)² + (x - b)² = r² 表示一个圆形，但是对于一个没有接解过代数几何的人，是很难相像它
是什么的，这就是几何图形的隐式表达。即使受过高等数学教育的人，也难以想象一个复杂图形的代数表达。比如，
(R - √(x² + y²))² + z² = r² 就很难看出来是一个圆环。

但是，这种隐式几何图形的表达在计算处理时却非常有用，比如判断一个点是否在几何体内。

而一种比较直观的图形表达方式是图形的布尔运算，布尔是英国的数学家，在 1847 年发明了处理二值之间关系
的逻辑数学计算法，包括：

- 联合 unionwaov
- 相交 intersection
- 相减 subtraction

在图形处理操作中引用了这种逻辑运算方法，以使简单的基本图形组合产生新的形体，还可以进行图形打散，并由
二维布尔运算发展到三维图形的布尔运算。

考虑图形关系的几种情况：

- 两图形没有相交部分，做布尔运算都简单。
- 其中一个图形包含另一个图形，这也是容易的情形，将其中一个图形反转方向绘制，这样得到的 Loop 就是镂空的。
- 当两个图形相交时，情况就复杂了。可能是点线相交，也可以是部分相交，根据不同的运算需求不一样。

Path 元素可能是所有 SVG 图形中最通用的形状，可能也是最难掌握的元素。图形学软件实现图形逻辑运算，
SVG 矢量图形对象布尔运算是常规需求，这是很有趣的问题，在一维的数学中 1+1=2，到了二维就是一个图和
另一图的运算。


Godot 提供 CSG 节点支持显式几何的构造，父类 `CSGShape` 派生以下 CSG 节点：

- CSGCombiner 
- CSGPrimitive
    - CSGBox
    - CSGCylinder
    - CSGMesh
    - CSGPolygon
    - CSGSphere
    - CSGTorus

CSG 合并节点下添加任意基本几何体，然后在其属性面板中选择所要使用的 CSG 运算方式，联合、相交、相减。
目前 Godot 3.x 或 4.0 都没有为 CSG 实现碰撞形状的生成工具，只有 MeshInstance3D 才有此功能。
即使是 Mesh 提供的碰撞体生成工具，它也不会处理几何体的绽放，会将绽放属性直接复制到生成的碰撞体中。
而 Godot 又不能像 Blender 那样，可以应用几何体的仿射变换操作。




## 🟡 Color Theory 色彩理论
- [色彩构成理论基础](https://www.bilibili.com/video/BV1Vx411G7ZV)
- [色彩搭配基础理论](https://www.bilibili.com/video/BV1t7411o79q)
- [Jerry Vickery 光影色彩理论](https://www.bilibili.com/video/BV14t41127Xz)
- [色彩搭配的原理](https://www.bilibili.com/video/BV15b411q75C/)
- Contemporary Color : Theory and Use, Cengage Learning, by Steven Bleicher
- Color and Light: A Guide for the Realist Painter, Andrews McMeel Publishing, James Gurney
- [Victo Ngai 倪传婧 Mastering Color: Simple Steps to Create Vivid Art](https://www.bilibili.com/video/BV1At4y1S76A)
- 画家之眼 the Eye of the Painter and Elements of Beauty by Andrew Loomis
- [Key to Drawing 素描的诀窍 (美)伯特·多德森](https://book4you.org/book/15425289/667bb9)
- [The Complete Introduction to Drawing](https://book4you.org/book/3690965/5f8857)
- [观看之道 （Ways of Seeing, 1972）约翰·伯格](https://www.bilibili.com/video/av15938583/)
- [The fundamentals of understanding color theory](https://99designs.com/blog/tips/the-7-step-guide-to-understanding-color-theory/)

学习色彩理论目的是掌握色彩的应用，正确地使用色彩表达创作意图，以及色彩关系来影响或引导观众的注意力。

最简单的色彩应用就是文字的粗体，读者在看到一页满是文字的报纸，首先看到的就是大字标题。这就是色彩理论
最朴素的应用，而在商业中，色彩的应用远比这报纸的文字复杂的多。在现代社会，人类有限的时间里，有限的
注意力是一种极宝贵的资源。

体积感的表达和线条、颜色的使用密切相关。例如，在球体表面上平滑过度的暗部表达了这是平滑曲面，明暗变化
明显的位置就隐含了一条分界线。在暗部过度的区域填上一块特别暗的色块，就很容易给视觉造成一种深坑的感觉。
因为光线不能完全打在平滑的表面，更无法照进深凹的坑内。

美国美院基础教学法：五明度法，只需考虑形状，明度和形状之间的边缘，是一套适合初学者简单而规范的方法论。

颜色是眼睛能观察到的电磁波，波长越短能量越低，波长越短能量越高。按照红、澄、黄、绿、青、蓝、紫顺序排列，
绘画中主要是区分颜色对心理的冷暖感觉的影响。特定波长的能量可以被物体吸收，例如，火焰看起来越偏红、黄，
这些光是属于可以被人体吸收的热辐射光，这是暖色调。而能量更低的绿色、蓝色使心理感觉显得冷，如雪天的蓝，
又比如植物也会吸收能量而过滤掉非绿色的光线，反射出来的基本是绿色光。

早晨的天空多呈现蓝色，因为无云层,大气对太阳光主要起散射作用。紫光的波长最短，散射能力最大，在没有到
达地面之前就在外层大气中散射掉了，接近地面的紫光很少。而蓝光最多，所以我们在地面看天空是蓝色，而在
高空则逐渐变成紫色。

而傍晚天空多是火红色，因为日间太阳的能量使得空气上升造成云层密集，并且对短波长的蓝、绿光线有更强的
过滤作用，而红、黄光则更容易穿透云层。这些日积月累的自然现象已经是刻进 DNA 的信息，就如自然的条件
反射，即是冬天，眼睛看到红色就会有暖意。

眼睛看到的颜色不是光的颜色，而是光从物体表面反射的颜色。比如绿色植物，用来吸收光能的叶绿素对太阳光
有两个吸收高峰，分别是 440nm 附近的蓝区和 680nm 附近的红区，而对于处在 500 - 600 纳米之间的
绿光吸收的甚少，绿光就反射被眼睛接收到。

《色彩互动学》 Interaction of Color 本书记录了如何用实验的方法学习和教授颜色知识。从物理和生理上讲，
视觉感知到的颜色并不真实。这一事实让颜色在艺术创作中富有弹性。高效使用颜色，有必要逐步识认颜色如何欺人。
为此，本书以互动的方式来研究颜色系统。


用来绘画的颜料就是利用其对光线的反射形状，红黄蓝三种原色，使用这三种颜色可以混合得到任意的其它颜色。
所谓原色 Primary，正是指不能透过其他颜色混合调配而得出的基本色，在不同领域使用不同的原色，例如，
显示器光学三原色 RGB，是叠加色模型，色值越高就越亮。三原色相加为白色，属于无色系（黑白灰）。

![Additive color mixing](https://99designs-blog.imgix.net/blog/wp-content/uploads/2017/02/RBG-2-column.png?auto=format&q=60&fit=max&w=930)

原色两两混合就可以得到三种间接色：

    红+绿=黄     红+黄=橙
    绿+蓝=青     蓝+黄=绿
    蓝+红=紫     蓝+红=紫

颜料三原色（CMYK）：品红、黄、青(天蓝)，属于减色法，颜料用得越少，吸收的光线就越少，颜色越浅。三原色
可以混合出所有颜料的颜色，同时相加为黑色，黑白灰属于无色系。

![Subtractive color mixing](https://99designs-blog.imgix.net/blog/wp-content/uploads/2017/02/CMYK-915x915px.png?auto=format&q=60&fit=max&w=930)

传统美术色彩三原色：红，黄，蓝，属于减色法原理。为人们加入了感觉实际，是实际上的三原色。

绘画中更常用的是 HSV 色调模型：

- Hue：色相/色调，就是我们所说的颜色的含义。
- Saturation：饱和度，是指纯色的强度，换句话说，颜色是否显得更隐晦、暗淡或者更有活力。
- Value：亮度，色值与颜色的深浅相关。

色相、色调是同义词，但色调更加强调画面统一的色彩感受和色彩倾向，是画面给人的整体色彩印象。色调不统一，
画面中的色彩就是一盘散沙，画面中的每一块颜色都应该服从于整体的色调，在统一的色调下形成丰富的变化。

马赫带效应（Mach band effect）是一种主观的边缘对比效应。观察亮度不同的两块区域，边界处亮度对比加强，
使轮廓表现得特别明显。生理学对马赫带效应的解释是：人类的视觉系统有增强边缘对比度的机制。

![Mach band effect](https://pic4.zhimg.com/80/v2-dd31b2d7e50e5a6ecab13b2a89c719ff_1440w.webp)

在自然环境中，植物的花朵、果实通常是高饱和度的颜色，纯红、纯黄、纯黑等等。

绘画软件中常使用一个色环表示色彩模型，Hue 的取值 0° ~ 360° 循环表示 红、澄、黄、绿、青、蓝、紫、红，
再搭配一个矩形色块表示饱和度和亮度。

除了原色混合得到的间接色 Secondary Colors，第三类颜色就是复色，或称为三次色 Tertiary Colors。
它们是由色环中邻近的原色和间色混合而来，六种基本的复色分别是黄绿色、蓝绿色、蓝紫色、紫红色、红橙色、黄橙色。

![Pigment colours](https://public-media.interaction-design.org/images/uploads/user-content/1445/S9qTpVld44SchHmpmYf7mYgCmcOhXwGdb5eD56t8.jpeg)

可以注意到，绿色部分占据的位置是最多的，同时绿色也是可见光中分布最广的部分，相应地眼睛感光区中分布的
感知绿色的视锥细胞数量也最多。从能量集中角度看，不利于植物的光合作用采用，所以叶绿素采用能量更集中的光。
由于眼睛的绿色感光细胞分布更多，所以在晚上，绿色光更容易被感知，也就是说同样的强度的光，绿色会更明显。

阴影是可以主观取舍形状的，并不是每一个地方都要面面俱到；阴影是可以色彩倾向很强的，也要和画厚涂时候
一样注意冷暖；同一块阴影可能因为位置不同，颜色也会有变化。

在厚涂绘画过程中，通常会先上大块的底色，这和油画的前期铺色操作一样。先判断物体的纹理走向，在绘制纹理
前预先将大块的底色铺到画布上，然后再慢慢添加纹理细节。在铺底色时要大胆，不要考虑细节，只需要在保证轮
廓或明暗分界线正确的前提下无拘无束地绘画。

颜色理论中的搭配公式 Color Schemes：

1. *Monochromatic*：单色搭配，并使用饱和度和色值的知识来创造变化。该方案的好处是色彩能够保证匹配。
2. *Analogous*：相似色搭配，使用色轮中彼此相邻的色彩进行搭配，比如红色和橙色。
3. *Complementary*：互补色搭配，互补色在色轮中彼此相对，如蓝色和橙色，使用不同饱和度避免互补色方案呆板。
4. *Split Complementary*：分裂互补配色，使用相对颜色的两侧相邻颜色进行搭配。可以提升对比也更有趣。
5. *Triadic*：三元色搭配，采用三种均匀分布的颜色，在色轮上形成一个完美的三角形。
6. *Tetradic*：四元色搭配，使用的颜色在色轮上形成了一个矩形。可以将其中一个颜色用于主色，其余用于辅色。

![Complementary colors](https://99designs-blog.imgix.net/blog/wp-content/uploads/2017/02/Complementary-3-column.png?auto=format&q=60&fit=max&w=930)
![Analogous colors](https://99designs-blog.imgix.net/blog/wp-content/uploads/2017/02/Analogous-3-column.png?auto=format&q=60&fit=max&w=930)
![Triadic colors](https://99designs-blog.imgix.net/blog/wp-content/uploads/2017/02/Triadic-3-column.png?auto=format&q=60&fit=max&w=930)

经典的颜色行为准则：

1. 遇到扎眼的色彩搭配时，最简单的一个办法就是想办法确定色调。选择其中一种颜色，调整明暗度或饱和度。
2. 可读性 Readability 是任何设计的必备要素。清晰易读 Legible，避免繁杂，多用中性颜色平衡画面。
3. 每种颜色都会发出一个信息。重要的是要考虑到项目的色调，并选择合理的配色方案。
4. 你可以在各种有趣的地方找到配色方案，比如广告、配色网站以及一些有名的艺术作品。

色彩的七种对比即色相对比、明度对比、冷暖对比、补色对比、同色对比、色度对比和面积对比：

- *明度对比*：明度对比指黑、白、灰之间的关系，也是常说的素描明暗关系。黑、白两极之间的色阶非常明确，
            容易分辨。依明度关系分画面有高调、中调、低调之分。明度对比是构成色彩中层次感、体积感、
            空间感、重量感的重要因素，从画面层次感、空间感受的角度理解，明度关系使前景亮、远景暗；
            受光近的亮、受光远的暗。从体积感和重量感理解，越深的色调越重，越亮的色调越轻；层次越
            丰富的色调，体积感受越强，层次越简单的色调体积感越弱。
- *同色对比*：同色对比是色彩美学的核心。没有同色对比就没有色彩的互补规律，也没有色彩的和谐。同色对比
            中因纯度的强弱不同而形成对比，属“同类色对比”的色调。在观察和区别这类色彩时必须进行比较，
            区别出其色相的细微差别，而且注意其明度和纯度。不然，容易画得色彩雷同。一般说，不同色性
            和色相距离大的容易区别，而同类色接近的区分较难，通过这类训练，可以提高观察力和表现力。
- *色度对比*： 色度对比也称纯度对比，即强烈和暗淡色彩之间的对比。纯度较高的色彩以原色为最纯，加入相
            近的同类色彩也有较高的纯度。暗淡的色彩是加入了黑、白、灰或对比色使色彩减低了纯度。由不同
            色相、色性、明度、纯度等色彩组成的画面，它们之间产生不同程度的对比，形成画面的整体效果，
            一般较为常见。但此类对比，应该把一种色相作为主导色，把一种对比作为主要对比来统一全局，
            防止过于分散和杂乱。由于色彩和各种复杂关系，需要特别加强整体观念，从整个画面效果出发，
            有比较地表现出不同层次和主次关系。
- *色相对比*：色相对比是因色与色之间的差别而形成的对比。对比越强烈，色彩效果越鲜明，对感官刺激越大。
            红、黄、蓝三原色是最原始、最典型的色相对比。用冷暖来表示色彩的感觉和心理，主要源于人们
            的经验。“暖”色给人以热烈的气氛和温馨的感觉，“冷”色给人有凉爽和严肃的感觉。
- *冷暖对比*：色彩有冷暖之分。冷色泛指蓝绿色系，暖色指红黄色系，然而冷暖对比不是绝对的，关键取决于
            它同更冷的还是更暖的色相来比较。冷暖对比在色彩运用当中极为重要，是色彩的研究的关键所在。
            从色彩自身的功能来看，红、橙黄色使观者心跳加、血压升高，所以产生热的感觉。蓝、蓝绿、蓝紫色
            能使观者血压低、心跳慢，产生冷的感觉。色彩在冷暖感觉是色彩的物理、生理、心理及色彩本身
            综合性因素决定的。
- *补色对比*：在色相对比中，色彩互相联系衬托、互相补充，所以也叫互补色。补色对比 最强的是红与绿、黄
            与紫、蓝与橙，其它次之。所谓补色的对比是指看到任何一种特定颜色，眼睛都会同时产生对其
            补色的需要。如一张白纸单独看是白纸，在红纸上会感觉含绿、放在绿色纸上会感觉含红。补色对比
            搭配可构成互补色调，互补色相色调的色相感比对比色相色调效果要更强烈、更丰富、更完美、
            更有刺激性。互补色相色调能满足视觉色相的要求，取得视觉悟生理上的平衡，既对立又互补。
            互补色相如与明度、纯度相配合可构成审美价值很高的色彩效果。
- *面积对比*：面积对比是大与小之间对比。便面积对比不能单纯从体量上进行比较，要注意色彩视觉效果的均
            衡问题，而均衡度又随色彩明度的变化而变化。面积对比实质上是一幅作品中所含的色彩数量的
            比例对比。画面色彩面积的分布会产生不同程度的强弱对比，调节大小可以取得的色彩对比强弱、
            色彩的韵律节奏以及视觉上力的平衡。因此面积对比是具有结构性的，它是整个画面“明暗结构”
            和色彩结构“的重要组成部分。由于面积对比所起的重要作用，因此在构思构图时需要优先考虑。


视觉上的色彩错觉或误差是人们在感知外部世界时经常体验到的一种知觉状态。其具体表现在眼睛感知的色彩效果
（心理上的真实）与客观存在的色彩实体（物理上的真实）之间存在着一定的差距。色彩视错现象的产生除以生理
特征为前提条件外，还与物理因素、心理作用密切关联，并且各具特点。大体上分，色彩视错主要包括物理性视错与
心理性视错。

从生理学角度讲，物体对视觉的刺激作用突然停止后，人的视觉感应并非立刻全部消失，而是映像仍然暂时存留，
这种现象也称作“视觉残像”。视觉残像形成原理是，因为神经兴奋所留下的痕迹而引发，是眼睛连续注视的结果，
所以称之为“连续对比”。视觉残像又分为为正残像和负残像两类。

眼球中的视锥细胞包含能感应红色、绿色和蓝色的光化学物质。凝视某物体超过数秒之后，这些物质就会开始损耗，
然后视锥细胞开始向我们的大脑发送错误的信息，大脑依然会收到影像，这叫做*残影*。

所谓的正残像，又称“正后像”，是连续对比中的一种色觉现象。它是指在停止物体的视觉刺激后，视觉仍然暂时
保留原有物色映像的状态，也是神经兴奋有余的产物。如凝注红色，当将其移开后，眼前还会感到有红色浮现。
通常，残像暂留时间在 0.1 秒左右。影视艺术就是根据这一视觉生理特性的创作，如把每秒 24 个静止画面
连续放映时，眼睛就可体验到与生活中的运动节奏相对应的印象，因而使人感到栩栩如生。
 
所谓的负残像，又称“负后像”，是连续对比中的又一种色觉现象。它是指在停止物体的视觉刺激后，视觉依旧暂时
保留与原有物色成补色映像的视觉状态。通常，负残像地反映强度同凝视物色的时间长短有关，即持续时间越长，
负残像的转换效果越鲜明。例如，当久视红色后，视觉迅速移向白色时，看到的并非白色而是红色的补色——绿色。
如久视红色后，在转向绿色时，则会觉得绿色更绿。而凝注红色后，再移视橙色时，则会感到该色呈暗。


要观察这种现象，只需要在全黑的背景中用白色线画出格子，然后就可以观察到白色线条的交叉点会出现黑点残像现象。

![棋盘视错觉](https://picx.zhimg.com/80/bfa8d0ad15cf0ac735b9df38a5948411_1440w.webp)

先注视左侧的狐狸 30 秒时间，然后再注视右侧的狐狸，会在右侧的狐狸上发现一个红色的闪影。

![Fox](https://img3.jiemian.com/jiemian/original/20151011/144454807244297500_a700xH.jpg)

这张 19 世纪的紫罗兰雕刻画背后藏着拿破仑·波拿巴和他的第二任妻子玛丽·露易丝以及他们的儿子。观看这种
模糊的画像时，你的大脑被迫选择或是看画或是看脸，要同时看到这两样东西是很难的。提示：你可以找到拿破仑的帽子。

![NP](https://img1.jiemian.com/jiemian/original/20151011/14445479452906300_a700xH.jpg)

在大面积的背景色中，一个灰色点会自然地出现背景色的补色的倾向。

眼睛的观察力总会被大块的背景色影响，背景效应每天无时无刻不在发挥着作用，我们甚至都不会觉察到。比如，
在艺校中用来训练的灰度级色块，不同背景色下会表现出不同的效果。在全白的背景色下，黑色块会显得特别黑，
而其它浅灰色会显得模糊。而如果在全黑色背景下，白色就会显得特别光亮。所以，眼睛会分辨不了在不同背景色
中的两个相同的色块。

背景效应几乎时刻在欺骗眼睛，一个简单的列子就是使用黑白棋盘格，一半放在阴影下，另一半放在阳光下。由于
视觉经验，大脑会自动识别阳光下的黑色格子为黑色，但其实在阳光下的黑格子和阴影下的白色格子色值是相同的。

![棋盘视错觉](https://pic1.zhimg.com/80/v2-ea71587ad249dfec6a460e7815e112d6_1440w.webp)

Victo Ngai 倪传婧在其 Mastering Color 网课上举例：
在 HSV(309, 28, 40) 和 HSV(104, 30, 68) 两个背景色块中，分别放置饱和度、亮度都更低的两个色块
HSV(311, 17, 42) 和 HSV(104, 15, 62)，在背景效应下，这会让它们看下来是一样的颜色。

因为，降低了饱和度，颜色更难以区分色相，同时降低亮度又加强了这一变化。白色背景会让其它颜色看起来更暗，
而黑色背景则会让其它颜色看起来更亮。

所以，大脑通过眼睛看到的似乎一样的颜色，或者是不一样的颜色，都不一定是正确的，答案就在数字化图像中。
大脑只需要一个合理的颜色关系，眼睛自然需要降低颜色的高对比度，在绘画时，需要考虑这种特性。


参考 Color and Light by James Gurney - Separation of Light and Shadow。书中还比较了
直接观察与参考照片的绘画方式的区别，指出了参考照片进行绘画的不足。因为由于设备光线动态范围能力有限，
有些区域会出现纯白或纯黑，丢失大量细节。

Victo Ngai 倪传婧在其 Mastering Color 网课上指出几条最重要的色彩原理：

- **相对性原理** Relativity：色彩之间具有关联性，不可将色彩单独看待。眼睛的观察是感性的，背景效应解释了眼睛对颜色的观察并不完全准确。
- **一致性原理** Consistency：同一件作品中的颜色应该存在于同一个世界中，在作品中传达颜色一致性很重要。
  比如在一紫色水池中，水中的物体也应该是在紫色这个色调，否则，没有和紫色产生关系，物体看起来就像是游离在另一个空间。
- **色值对比原理** Value Contrast：使用明暗对比区域来引导观众的视线。在一幅暗调的画面中的亮色，或者一幅明亮色调画面中的暗色，会具有聚集作用。
- **强调色原理** Accent Color：适当的强调颜色可以突出画面重点，并具聚集目光。列如，冰天雪地中的红色，在蓝色调画面中的红就是最吸引目光的。
- **比例原理** Ratio：使用更强的饱和度选出一种颜色作为主导，特别是使用互补色配色方案时尤其是，否则其它颜色就会打架。

课程中，还演示了如何从参考作品或者图片中获取配色方案，并将其转化为自己的工作中使用的调色板，并加入自己的个性化元素。


素描的诀窍提到光的效果要点：

* 把亮的部分和暗的部分区域标记出来。开始时，把阴影部分的边界明确定出来，后续可以淡化、修改边界。 
* 用光影图案定造型。找出光影图案的四个基本要素:亮面、 暗面、投影和反射光。精心地勾画出这四个要素就可以产生很强的三维感。 
* 处理好硬边缘和软边缘。前者要有力度，后者要有柔度。两种边缘处理得好的话，可以产生非常逼真的效果。 
* 通过渲染光源和光的性质分析光。 
* 渲染氛围。要想让画更吸引人、更打动人，就要使用特殊效果的光，勾画特殊的投影，或是在重要部分的暗处投上光。 
* 比较色调，从而构建色调关系。色调是在彼此对比中才显出深浅。 
* 合并阴影形状。阴影是伟大的统一者，它可以把画中的不同部分连接起来。用一个阴影形状就可以把一群小的形状拉到一起，细节不再是最重要，而整体的效果却明显增强。 
* 用光来制作图案。当你开始把光和影作为形状看待的时候，它们就成为了制图的工具，勾画出各种图案。


《画家之眼》这本书的主题就是美的十二项基本要素：

- *统一*（unity）：这种一体性将画面的所有特质结合成单一表现或整体表现，意即将设计、色彩、线条、明暗、
        质感和主题巧妙安排，结合为一种全面性的表现。
- *简洁*（simplicity or clarity）：把跟主要构想无关的所有素材和细节变成次要，将主题简化为最
        基本的设计、形式与图案。
- *设计*（design）：意指块面、形式与色彩的整体关系。画面就是由设计创造出来的。
- *比例*（proportion）：意指画面中各个主题与各个部分的协调关系。比例失真（distortion）就不协调，
        不过某些失真或许是合理的，因为画家可能想要强调某个构想或情感。
- *色彩*（color）：这是美的要素中最有影响力的要素之一，而且在使用这项要素时，画家不能只以品位和
        好恶为准则，还必须了解色彩与明度的关系，以及创造写实与协调效果的基本调色原理。
- *韵律*（rhythm）：也可称为节奏，虽然这项要素常被轻视或误解，却对画作美感有极大的贡献。所有生物和
        非生物都有韵律，从最微小的形体到宇宙的循环无一例外。没有韵律，形体就静止不动，也毫无生气。
        如同自然界的运作，相近色或线条的重复，或是形状渐进扩大或缩小，都能为画作创造韵律。举例来说，
        树木本身枝丫和树叶的重复线条韵律，斑马背上的线条，或花瓣和花朵纹路的线条也能发现韵律。
- *形体*（form）：形体结构与整体的关系是一项基本艺术原理。万物存在的样态，不外乎形体或空间的实与虚，
        solid vs. void，而且两者不可或缺，无法独自存在。当画作中的物体形状经过巧妙的描绘和组合，
        并与开放区域形成适当的对比，譬如树与天空形成的对比，就会让画作具有“形体”。
- *质感*（texture）：意指对于表面的描绘。所有形体都有其表面特征，这一点就跟本身形体结构一样重要。
        以同样的表面特征描绘所有形体，就是千篇一律的毛病，当然不可能画出真正的美，是平庸之作常态。
- *明度*（value）：明度和色彩，两者密不可分。要画出美，两者缺一不可。适当的明度关系能为画面创造光感
        并增添统合感。不正确的明度关系就会对画面美感造成最大的破坏。
- *光感*（quality of light）：这项要素最重要不过，画作中的光感跟实际照射于画面上的光线融合，成为
        整张画作的一部分。光有许多种，室内光、室外光、阳光、漫射光和反射光。光源必须跟形体的塑造、色彩
        的性质与明度以及质感有关。如果画家没有真正理解光的原理，画作就可能只是颜料在画布（画纸）上
        的平面描绘，无法创造出画面的空间感。
- *主题*（subject）：这项要素提供给画家大好机会，充分发挥个人品位。画家可以从生活和大自然中，找到
        数不清的主题，从中挑选、设计和创造出自己专注的主题，展现画家本身对美的鉴赏力。
- *技法*（technique）：意指表现的方式而非表现本身。技法包括对于物体表面和质感的理解，以及对媒材
        及媒材应用之诸多方法的认识。技法是结合其他美的要素所做的个人表现。




## 🟡 Environment & Lighting 环境与光照
- [Lights and shadow](https://docs.godotengine.org/en/3.5/tutorials/3d/lights_and_shadows.html)
- [Reflection probes](https://docs.godotengine.org/en/3.5/tutorials/3d/reflection_probes.html)
- [Global illumination probes](https://docs.godotengine.org/en/3.5/tutorials/3d/gi_probes.html)
- [Baked lightmaps](https://docs.godotengine.org/en/3.5/tutorials/3d/baked_lightmaps.html)
- [GAMES104-现代游戏引擎：从入门到实践-王希](https://www.bilibili.com/video/BV1J3411n7WT/)
- [GAMES202：《高质量实时渲染》闫令琪](https://www.bilibili.com/video/BV1YK4y1T7yY/)
- [实时阴影技术 Real-time Shadows](https://www.cnblogs.com/KillerAery/p/15201310.html)
- [Introduction to 3D](https://docs.godotengine.org/en/latest/tutorials/3d/introduction_to_3d.html)
- [开放世界环境光照 Godot 3D 教程](https://www.bilibili.com/video/BV1bM4y1c74E/)
- [Introduction to global illumination](https://docs.godotengine.org/en/latest/tutorials/3d/introduction_to_global_illumination.html)
- [Volumetric fog and fog volumes](https://docs.godotengine.org/en/latest/tutorials/3d/volumetric_fog.html)

Godot 中使用米制单位系统，即属性面板中的 1 单位代表 1 米，物理或其它面积按此伸缩。

坐标系统使用 Y 轴作为 "up" 的指向，而水平轴为 X/Z。使用右手坐标系统，保持食指、中指、拇指相系垂直：

- 并且食指指向上，对应 Y 轴指向；
- 中指垂直屏幕指向自己，对应 Z 轴指向；
- 拇指平衡屏幕水平向右，对应 X 轴指向；

场景中默认的相机镜头指向 Z 轴负向，物体的指向 Z 轴方向为前向，简而言之：

- X 轴是两边： right/left
- Y 轴是上下： up/down
- Z 轴是前后： front/back

以下是 Freya Holmér 制作的各种软件使用的坐标系统 UP 方向轴的差别对照参考：

![Image by Freya Holmér](https://docs.godotengine.org/en/latest/_images/introduction_to_3d_coordinate_systems.webp)

在 3D 场景视图中，可以使用以下快捷键：

- 按下 Ctrl 配合鼠标操作可以将 moving, scaling or rotating 操作吸附到参考线。
- 使用 F 可以将视图中选中的对象居中到屏幕。


不同于电影行业为了追求高质量的离线渲染 off-line rendering，游戏行业中是实时渲染，这就为硬件提出
了高度的性能要求，在一定的硬件性能条件下，实时渲染并不能一味为了做最佳图像质量，而是在质量与流畅体验
之间的权衡。

为了实现图像质量又好，游戏操作体验又流畅的双平衡，渲染中通过引用一些代运算成本的技术，例如引入法线
贴图替代高精度高面数的模型。光照系统中，引入各种探针来设置需要细致处理的光照空间，避免将有限的算力
用到性价比不高的区域上。


Godot 引入了以下光照探针、后期处理或其它相关技术：

- Real-time global illumination (GI) probe 全局照明探针，只处理指定区域的全局光。
- Reflection probes 反射光探针，只处理指定区域的反射光。
- Baked lightmaps 光照烘培，将光照效果以图片形式保存下来，运行时直接贴图还原光照效果。
- Screen-Space Reflections (SSR) 屏幕空间反射最有意义的场景在物体彼此接触时，如物体在地板上的倒影。
- Screen-Space Ambient Occlusion (SSAO) 屏幕空间环境光遮蔽，模拟环境光遮挡（阴影）。
- Screen-space indirect lighting (SSIL) 屏幕空间间接光照处理。
- Signed distance field global illumination (SDFGI) 有向距离场全局光照，通过环境节点启用。

![SSR](https://docs.godotengine.org/en/3.5/_images/environment_ssr.png)

Godot 目前来看，光照效果相当弱，与 Blender 完全不在同一水平，不适合制作写实类型作器，风格化更适合。
Godot 4.0 引入了多种实时、半实时的光效提升技术，3D 光照技术比旧版本有了不小进步。

不考虑粒子节点，以下是新旧版本中关于光效处理的节点类型变化：

|      Godot 3.5       |          Godot 4.0           |
|----------------------|------------------------------|
| VisualInstance       | VisualInstance3D             |
| - BakedLightmap      | - Decal                      |
| - GIProbe            | - FogVolume                  |
| - Light              | - Light3D                    |
| - - DirectionalLight | - - DirectionalLight3D       |
| - - OmniLight        | - - OmniLight3D              |
| - - SpotLight        | - - SpotLight3D              |
| - ReflectionProbe    | - LightmapGI                 |
|                      | - ReflectionProbe            |
|                      | - VisibleOnScreenNotifier3D  |
|                      | - - VisibleOnScreenEnabler3D |
|                      | - VoxelGI                    |
|                      | Lightmapper                  |
|                      | - LightmapperRD              |

旧版本可以使用 GIProbe 全局光探针，新版本移除此节点，增加了多个视效节点，使用它们应该权衡：

- **Performance** 实时光照比半实时、烘焙技术更消耗算力；
- **Visuals** 实时技术不能提供最顶级的视觉效果。 
- **Real-time ability** 半实时技术有实时技术中不存在的约束，如移动的物体光照处理问题。
- **User work needed** GI 技术有完全自动的，也有需要用户仔细规划和调整的，根据工作需要使用。

新版本的光照技术应用场合概要：

|          GI          |        Perference        |      RT ability      |
|----------------------|--------------------------|----------------------|
| **ReflectionProbe:** | Update Mode: Always/Once | Optionally real-time |
| **LightmapGI:**      | Baked                    | not real-time        |
| **VoxelGI:**         | Forward+ Projects        | Fully real-time      |
| **SSIL:**            | Forward+ Projects        | Fully real-time      |
| **SDFGI:**           | Forward+ Proejcts        | Semi real-time       |

此外，通过打光技术辅助，可以模拟全局光的效果。要点是在主光源确定后，添加额外的补光光源，重要的是关掉
补光的阴影属性，Shadow = Off，并且适当减弱强度避免影响主光源。最后关掉高亮 Specular = 0，并调整
补光的打光方向。三灯布光法是一种经典打光技术，通过不同方位组合，通过主光、辅光、轮廓光展示不同的效果。

多数光效设置需要在素材导入时设置：

    Project Settings > Rendering > Global Illumination 

    Meshes > Light Baking > Static Lightmaps (VoxelGI/SDFGI/LightmapGI)
    Meshes > Lightmap Texel Size

    MeshInstance > Global Illumination > Mode > Static


### 🟠🔵 2D lights 二维灯光
- [2D lights and shadows](https://docs.godotengine.org/en/3.5/tutorials/2d/2d_lights_and_shadows.html)
- [2D lights and shadows demo](https://github.com/godotengine/godot-demo-projects/tree/master/2d/lights_and_shadows)
- [Trace Bitmap In Inkscape](https://inkscape.org/doc/tutorials/tracing/tutorial-tracing.html)
- [GPU Gems 1 - 11. Shadow Map Antialiasing](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-11-shadow-map-antialiasing)

除了环境设置，在 2D 场景中，可以使用 **CanvasModulate** 对整个画布进行颜色调整，可以批量改变
场景中的 CanvasItem 的颜色，但是对 CanvasLayer 或子类 ParallaxBackground 无效，因为它们
是独立的画布对象，具有不同 layer 绘画顺序。同样，配合 Light2D 节点，又可以添加二维光照，使得场景
中与光照节点的纹理重叠的区域不被调制影响。

- **CanvasModulate** 通过颜色调制使场景变暗，或者调制成任何希望的色调。
- **Sprite** 设置纹理显示灯光斑点、背景和阴影投射器，其纹理本身不会能参与光线的计算。
- **Light2D** 照亮场景，二维灯光通常的工作方式是，在场景的其余部分添加选定的纹理以模拟照明。但它也可以以其他方式使用，例如掩盖场景的某些部分。
- **LightOccluder2D** 用于告诉着色器场景的哪些部分投射阴影。阴影仅显示在 Light2D 覆盖的区域上，其方向基于灯光的中心。

![2D lights and shadows demo](https://docs.godotengine.org/en/3.5/_images/light_shadow_main.png)

Sprite 本身不会投身阴影，只用于设置场景需要的纹理，但会受到 CanvasModulate 的调制。阴影本身需要
通过 LightOccluder2D 节点设置 OccluderPolygon2D 多边形来决定 Light2D 覆盖范围内的阴影投射。
LightOccluder2D 提供了一个 Show Behind Parent 选项，所以可以作为 Sprite 子节点以显示在父
节点纹理的底层，避免用于投射阴影的多边形遮挡内容。

阴影投射区多边需要手动绘制，不能结合 Inkscape 这类工具提供的 Trace Bitmap 功能自动生成的矢量图。
或者没提供像 Blender 那样的画笔绘制曲线的编辑器。

Light2D 通过纹理来建立光源的各种属性，主要是光源的颜色、辐射范围。纹理尺寸越大，或者 Scale 越大，
光线照射到的范围越广。可以使用图像纹理作，或者使用 AnimatedTexture 这样的动画纹理，以产生交替的
灯光效果。光源纹理的一般制作，使用中心放射过渡的纯色，中心透明度低表示光照强，周边透明度高表示弱光照。
通过纹理制作，可以模拟散光灯、射灯或者聚光灯，光源也提供 Color、Energy、Mode、Height 等调制属性。

虽然，光源可以设置 Height 来与 Sprite 中的法线贴图进行光线的交互，但 LightOccluder2D 却没有
提供高度属性，所以光源始终被多边形分隔为内外两个区，在多边形外面、内面的光线不会穿透多边形。

2D 光源可以使用 20 个灯光分层管理光线交互、阴影投射，只有光源中 Range、Shadow 设置的 **Item Cull**
遮罩层与 CanvasItem、LightOccluder2D 中的 **Light Mask** 使用了一致的分层，它们才会与相应的
光源、阴影产生交互效果。Light Mask 遮罩属性在编程技术上，使用的是 bit 位记录分层信息。光源与物体在
同一个比特位置 1 表示它们是同层交互关系，应该产生光线交互效果。

Godot 支持 Percentage Closer Filtering (PCF)，这是一种阴影贴图的抗锯齿优化算法技术。

阴影贴图 shadow mapping 是一种用于影片图像的高端渲染技术，但是在实时的视频游戏中，会出现严重的
锯齿化问题。并且，当光线几乎平行于阴影表面传播时，使用透视阴影贴图技术和增加阴影贴图分辨率并不能解决
锯齿问题，因为放大率接近无穷大。高端渲染软件通过使用一种称为 PCF 百分比渐进滤波的技术来解决混叠问题。

与法线纹理不同，阴影贴图不能预过滤去消除锯齿。相反，每个像素都要进行多个阴影贴图的比较，求平均值。
这种技术被称为 PCF，因为它计算的是更接近光线的曲面的百分比，而不是在阴影中。

![Figure 11-1 Percentage-Closer Filtering](https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/elementLinks/fig11-01.jpg)

原始 PCF 算法要求将要着色的区域映射到阴影贴图空间，并随机采样该区域。该算法首先由 REYES 渲染引擎
实现，因此要着色的区域意味着四边的微多边形。

一般点光源会生成硬阴影，而面光源则会生成软阴影。当遮挡物越接近光线接受物体，会趋向于生成更硬的阴影，
远离的时候，会趋向于生成更软的阴影。调整 filter, filter smooth, gradient length 等属性改变
阴影的软硬程度。




### 🟠🔵 3D SpatialMaterial 空间材质
- [Material Maker by R0dZill4](https://godotengine.org/showcase/material-maker/)
- [Standard Material 3D and ORM Material 3D](https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html)
- [Godot 4 Alpha 森林制作](https://www.bilibili.com/video/BV1p54y1f7Lf/)
- [Vertex displacement with shaders](https://docs.godotengine.org/en/3.0/tutorials/3d/vertex_displacement_with_shaders.html)
- [Your 1st 3D shader](https://docs.godotengine.org/en/latest/tutorials/shaders/your_first_shader/your_first_3d_shader.html)

Godot 3D 几何节点提供了两个设置材质的属性：

- Material Override - The material override for the whole geometry.
- Material Overlay - The material overlay for the whole geometry.

Override 和 Overlay 两种方式的差别是，前者会覆盖整个几何体，替代所有 matereial slot 中的材质，
后者则是叠加在一起，在所有曲面的任何其他活动材质之上渲染该材质。例如，在 Sprite3D 上使用 Texture
可能会覆盖掉 Overlay 的材质，如果纹理图完全不透明。反过来对于 Override，纹理图则可被覆盖掉。


Godot 3.x 材质对象不多，只有 4 个类别：

- CanvasItemMaterial
- ParticlesMaterial
- ShaderMaterial
- SpatialMaterial

Godot 4.x 和旧版本的材质对象有些差别，包含名称上的变化和新增的材质。

材质基类 `Material` 下有两套子类型，一套是经由 BaseMaterial3D 衍生的空间材质，包括：

- `ORMMaterial3D` 和标准空间材质基本相同，但是遮挡、粗糙度和金属等通道只使用同一个 ORM 纹理；
- `StandardMaterial3D` 标准空间材质对应旧版本的 `SpatialMaterial`；

Godot 4 材质新增 `ORMMaterial3D` 材质，它几乎和标准 BaseMaterial3D 材质完全相同，但有一点不同。
没有为遮挡、粗糙度和金属设置单独的设置和纹理，而使用一个 ORM 纹理，该纹理的不同颜色通道用于每个参数。
诸如 Substance Painter 和 Armor Paint 之类的程序提供了这种格式导出的选项，这两个程序具有用于
虚幻引擎的导出预设，该引擎也使用 ORM 纹理。通过 Physically based rendering (PBR) 材质可以将
ORM 纹理应用于 3D 对象，这也就是 `ORMMaterial3D` 材质对象的功能。

另一套是继承 `Material` 的专用材质：

- `CanvasItemMaterial` 画布对象材质，是应用于 CanvasItem 对象的二维材质，可以使用着色器材质深入自定义。
- `FogMaterial` 体积雾材质，配合 `FogVolume` 节点使用。
- `PanoramaSkyMaterial` 对应旧版的 PanoramaSky 资源类型。
- `ParticleProcessMaterial` 为 GPU 粒子系统处理粒子属性，`GPUParticles3D` 和 `GPUParticles2D`。
- `PhysicalSkyMaterial` 新增的基于物理的天空材质，光源属性来自场景树中第一个 `DirectionalLight3D` 节点。
- `PlaceholderMaterial` 材质占位符，并非是真正的材质，而是用于解决材质加载的工具。
- `ProceduralSkyMaterial` 对应旧版的 ProceduralSky 资源类型。
- `ShaderMaterial` 着色器材质，可以进行着色器编程开发。

其中，`ShaderMaterial` 着色器材质是比较特殊的一种，它可以进行着色器编程开发，可以定制各种特效。

注意，天空材质中的太阳角度，需要通过 `DirectionalLight3D` 节点的旋转调整太阳高度角。

部分新增的材质对象，在旧版本也有相应的类型，只不过不是材质类型，例如 PanoramaSky 和 ProceduralSky，
它用于为 `WorldEnvironment` 环境节点提供天空环境材质设置，通过 `Environment` 资源创建天空环境。

当使用 `Material` 子类的项目出现以下两种加载条件时，就可以使用材质占位符：

- 在专用服务器模式下运行导出的项目时，仅保留纹理的尺寸，可用于游戏目的或其他元素的定位，并显著压缩导出的 PCK 文件。
- 当该子类由于使用不同的引擎版本或构建而丢失时（例如模块禁用）。


Material Maker 是基于 Godot 开发的一款程序化材质编辑器，它支持为 Godot、Unity、Unreal 等引擎
导出编辑好的程序化材质，也可以为 Blender 导出 EXR 格式材质。EXR 是一种多层的富信息图像格式，非常
方便用于合成、后期处理。EXR 能够存储高动态范围，常规图像文件格式如 JPEG 或 PNG 保存的是低动态范围。
这意味着 EXR 可以使用高动态范围，从图像的完全白色或完全黑色区域检索信息。

Material Maker 1.2 导出 Godot 材质格式为 `.tres`，是一个配置好的 SpatialMaterial 材质，可以直接
给 MeshInstance 节点使用。根据 Godot 版本，有三种导出方式：

- Godot 3 Spatial 三维空间材质；
- Godot 4 ORM 
- Godot 4 Standard Spatial 标准三维空间材质；

EXR 也是 Blender 默认支持导入、导出的一种图像格式，可以通过 Blender 输出属性面板，设置输出格式为
OpenEXR 或者 OpenEXR MultiLayer，即可以渲染得到 EXR 图像文件。可以将 EXR 文件拖放到 Shading
着色器编辑器中，Image Texture 节点会自动生成，Material Maker 导出的三个 EXR 可以做以下连接，
以自带的 beehive 蜂巢这个程序化材质导出的文件为例：

- beehive_metal.exr 主材质图像，连接到 Principle BSDF 材质节点的 BaseColor 端口；
- beehive_rough.exr 粗糙度图像，连接到 Principle BSDF 材质节点的 Roughness 端口；
- beehive_displace.exr 置换贴图，连接到 Material Output 材质输出节点的 Displacement 端口；

使用 Irfanview 工具，安装相应的 Exr.dll 插件即可以查看 EXR 材质图像。


材质中 Height 用于启用视差高度贴图，和 Normal Mapping 类似，是用于改变表面光线细节的贴图。
Godot 3.5 中使用 Depth 属性表示视差贴图。

另一种用于地形制作的置换贴图，Displacement Mapping，Godot 没有直接在材质中提供设置，而只能
通过着色器来实现，即需要创建着色器材质，对几何体的顶点进行直接处理。




### 🟠🔵 Procedural geometry 几何体处理
- [Procedural geometry](https://docs.godotengine.org/en/latest/tutorials/3d/procedural_geometry/index.html)
- [3D Voxel Demo](https://godotengine.org/asset-library/asset/676)
- https://docs.godotengine.org/en/latest/tutorials/3d/procedural_geometry/arraymesh.html

几何 Geometry 是一个数学概念，在 Godot 中使用 Mesh 来表达几何，也就屏幕上看到的各种三维对象。
几何体包含一系列的顶点 vertices 数据，顶点可以构建成三角面，进而形成 Mesh 网格体并表现几何体。

概括来说，Mesh 包含一组由顶点数据定义的曲面 Surfaces，而每个曲面由一个多维数组定义，组合了顶点坐标、
法线、UV坐标等等信息。

Godot 提供了多种类型来处理几何体，通过修改几何体的数据可以得到任意结构的几何对象，这些工具包括：

- `ArrayMesh` 资源类型提供顶点数据访问，并通过脚本构建 Mesh 曲面的能力，是最基础的几何处理工具。
- `MeshDataTool` 引用类型提供将 Mesh 转换为 vertices, faces, edges 并在运行时编辑的能力；
- `SurfaceTool` 引用类型提供 OpenGL 1.x 立即模式风格的 API 构造网格的能力，类似 `ImmediateMesh` 节点；
- `ImmediateMesh` 节点类型提供以立即模式风格绘制网格的能力，但只用于原型中，因为每一帧其几何体都会重建；

SurfaceTool 和 ArrayMesh 可以构造不需要每一帧都需要改变的静态网格，后者速度更快，前者 API 更易用，
MeshDataTool 也不快，但是可以提供边面相关的 API。

SurfaceTool 可以通过直接添加顶点或者使用顶点索引来构造几何体，最后通过 commit() 返回 ArrayMesh：

```py
    void begin(primitive: PrimitiveType)

    void set_bones(bones: PackedInt32Array)
    void set_color(color: Color)
    void set_uv(uv: Vector2)

    void add_index(index: int)
    void add_vertex(vertex: Vector3)
    
    ArrayMesh commit(existing: ArrayMesh = null, flags: int = 0)
```

Godot 4.x 目前只支持在 CPU 上修改几何体，而不支持 GPU 上的几何修改。

Godot 系统中 Mesh 是资源类型，可以提供几何体的数据，而将数据表达为几何体则通过 MeshInstance3D
或者 MultiMeshInstance3D 这些节点来实现。

 the Mesh, the ArrayMesh, the MeshInstance3D, the MultiMesh, and the MultiMeshInstance3D. 
 While they are all related, they have slightly different uses.

- `ArrayMesh` 顶点数组资源，提供顶点级别的几何表面操作。
- `ImmediateMesh` 对应旧版本的 ImmediateGeometry 节点。
- `PlaceholderMesh` Godot 4.x 新增的 Mesh 占位节点。
- `PrimitiveMesh` 常用的基本几何体的网格对象，定义在源代码 scene\resources\primitive_meshes.cpp。
    - BoxMesh 矩形盒子；
    - CapsuleMesh 胶囊体；
    - CylinderMesh 圆柱体；
    - PlaneMesh 平面；
    - PointMesh 单个顶点基本体；
    - PrismMesh 棱镜；
    - RibbonTrailMesh 带状轨迹；
    - SphereMesh 球体；
    - TextMesh 文本网格；
    - TorusMesh 圆环；
    - TubeTrailMesh 管道轨迹；

PointMesh 是只有单个顶点的基本体，它甚至都不能叫做 Mesh，但是光栅化时它就是一个固定大小的方块，
Rectangle，注意不是有四个顶点的那种矩形，它可以用于粒子系统。


另外，`MultiMesh` 是一种使用 GPU 批量实例化以提供网格的高性能绘图的资源类型。

`ArrayMesh` 中顶点使用的数据类型定义在 Mesh.ArrayType 枚举类型中，对应的数据类型如下：

| Index | Mesh.ArrayType Enum |                               Array type                              |
|-------|---------------------|-----------------------------------------------------------------------|
|     0 | ARRAY_VERTEX        | PackedVector3Array or PackedVector2Array                              |
|     1 | ARRAY_NORMAL        | PackedVector3Array                                                    |
|     2 | ARRAY_TANGENT       | PackedFloat32Array of groups of 4 floats.                             |
|     3 | ARRAY_COLOR         | PackedColorArray                                                      |
|     4 | ARRAY_TEX_UV        | PackedVector2Array or PackedVector3Array                              |
|     5 | ARRAY_TEX_UV2       | PackedVector2Array or PackedVector3Array                              |
|    10 | ARRAY_BONES         | PackedFloat32Array or PackedInt32Array of groups of 4 floats or ints. |
|    11 | ARRAY_WEIGHTS       | PackedFloat32Array of groups of 4 floats.                             |
|    12 | ARRAY_INDEX         | PackedInt32Array                                                      |

``ARRAY_TANGENT`` 使用 `PackedFloat32Array` 数据类型，每组共 4 个浮点数，前面 3 个浮点值
决定切换向量，最后一个浮点值为副法线方向，值为 -1 或 1。

``ARRAY_BONES`` 使用 `PackedFloat32Array` 或 `PackedInt32Array` 数据类型，也是 4 个值
一组，每组包含影响指定顶点的 4 个骨骼的索引。

``ARRAY_WEIGHTS``使用 `PackedFloat32Array` 数据类型，也是 4 个值一组，每个浮点值包含权重，
对应了``ARRAY_BONES``中与顶点关联的骨骼。


例如，通过基本的圆柱体实例的顶点数据，结合 ArrayMesh 重构出另一个圆柱体：

```py
var c = CylinderMesh.new()
var arr_mesh = ArrayMesh.new()
arr_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, c.get_mesh_arrays())
```

例如，以下代码通过 ArrayMesh 构造几何体，是一个三角形，并添加到场景树中：

```py
var vertices = PackedVector3Array()
vertices.push_back(Vector3(0, 1, 0))
vertices.push_back(Vector3(1, 0, 0))
vertices.push_back(Vector3(0, 0, 1))

# Initialize the ArrayMesh.
var arr_mesh = ArrayMesh.new()
var arrays = []
arrays.resize(Mesh.ARRAY_MAX)
arrays[Mesh.ARRAY_VERTEX] = vertices

# Create the Mesh.
arr_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
var m = MeshInstance3D.new()
m.mesh = arr_mesh
```


例如，以下使用 SurfaceTool 构造只有一个顶点的三角形，注意事项：

- 顶点属性需要在 add_vertex() 方法执行前添加；
- 使用 add_uv() 和 add_color() 给后续的顶点设置 UV 坐标和颜色属性；
- 第一个顶点添加前设置的属性决定了网格数据格式，例如，只添加了 UV 坐标，那么添加顶点后就不能再设置顶点颜色属性了。

```py
var st = SurfaceTool.new()
st.begin(Mesh.PRIMITIVE_TRIANGLES)
st.add_color(Color(1, 0, 0))
st.add_uv(Vector2(0, 0))
st.add_vertex(Vector3(0, 0, 0))
# Commit to a mesh.
var arr_mesh = st.commit()
```

Below is an example of how MeshDataTool may be used.

```py
var mesh = ArrayMesh.new()
mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, CubeMesh.new().get_mesh_arrays())
var mdt = MeshDataTool.new()
mdt.create_from_surface(mesh, 0)
for i in range(mdt.get_vertex_count()):
    var vertex = mdt.get_vertex(i)
    # In this example we extend the mesh by one unit, which results in separated faces as it is flat shaded.
    vertex += mdt.get_vertex_normal(i)
    # Save your change.
    mdt.set_vertex(i, vertex)
mesh.surface_remove(0)
mdt.commit_to_surface(mesh)
var mi = MeshInstance.new()
mi.mesh = mesh
add_child(mi)
```



### 🟠🔵 Texture Map 纹理贴图
- [Texture Mapping - GAMES101-现代计算机图形学入门-闫令琪](https://www.bilibili.com/video/BV1X7411F744?p=9)
- [GAMES101 随堂笔记-Lecture 09 Shading 3 Texture Mapping](https://blog.csdn.net/weixin_44848751/article/details/127887098)
- [Physically Based Rendering 3rd - 10 Texture](https://www.pbr-book.org/3ed-2018/Texture)
- [OpenGL Programming Guide > Chapter 9 Texture Mapping](http://www.glprogramming.com/red/chapter09.html)
- Fundamentals Of Computer Graphics - 11. Texture Mapping
- [OGLDev Tutorial 16: Basic Texture Mapping](https://ogldev.org/www/tutorial16/tutorial16.html)
- [LearnOpenGL - Textures](https://learnopengl.com/Getting-started/Textures)
- OpenGL 4.6 (Core Profile) 8.14 Texture Minification & 8.15 Texture Magnification
- [GPU Gems II - 28. Mipmap-Level Measurement](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-28-mipmap-level-measurement)

纹理贴图是图形着色中的一种基本方法，贴图就是一张贴在图形上的图像。要将一张图片映射到一个图形，比如
三角形或者正方形上，这就需要一种确定映射关系的方法。图形学中，将渲染得到的图像中的每一个点称为像素，
相似地，对于纹理图像上的每个点称为纹素，pixel vs. texel。

当然，纹理不一定局限于图像文件，也可以是程序贴图纹理 Procedural Texturing，通过噪声函数算法生成，
Noise Function 旨在创建可以模拟自然元素的纹理，例如木材，大理石，花岗岩，金属，石头等。噪声函数
包括分形 fractal noise，湍流扰动函数 turbulence functions，Perlin noise，Voroni 等等。
在过去，由于过程纹理计算量很大，在实时绘制中很少使用，而 GPU 促进了噪声纹理在实时渲染中的广泛应用。


在 2D 纹理处理中需要使用 UV 坐标，3D 纹理则使用 UVW 坐标，因为表示位置的坐标使用 XYZ 表示，为了
区别开来，所以使用 UVW 三个量表示三个轴向，以和位置坐标区分。

Godot 中的纹理坐标以左上角为原点，右下角为正方向 ，与 OpenGL 有点差别，就是将 V 轴上下反转。

![UV Mapping](https://docs.godotengine.org/en/3.5/_images/iconuv.png)

以下是 OpenGL 的 UV 坐标，纹理是一张砖墙图像，将它映射到一个三角形图形上，只使用了纹理中间的部分：

![https://learnopengl.com/Getting-started/Textures](https://learnopengl.com/img/getting-started/tex_coords.png)

UV 坐标取值范围在 [0,1] 区间，在屏幕空间看起来就是 U 对应从左到右的方向，V 对应从上到下的方向。
在给 GPU 传递顶点数据时，一般包含位置坐标及顶点对应的 UV 坐标，这样就可以按 UV 坐标给表面贴纹理。
通过设置 UV Mapping 映射关系，可以将纹理图按坐标对应贴紧模式表面，可以原点、大小一一对齐，也可以
不对齐，例如，将图片原点对应到模型 UV 最大值指向的位置，而将图片的最大尺寸位置对应到模型原点，就
将纹理图反转。


在纹理映射处理的过程中，会遇到这样的两种问题，即纹理缩放问题：

- 纹理太小，图形太大，需要对纹理进行放大处理；
- 纹理太大，图形大小，需要对纹理重采样，让它变小；

这两种问题就是 Point Query vs. (Avg.) Range Query，纹理处理中的平均范围查询只是一种具体操作，
并不是范围查询的一般形式。

为了放大纹理适用图形，简单复制纹素会导致严重的锯齿问题，例如以下图左侧显示的这样：

![GL_NEAREST vs. GL_LINEAR](https://learnopengl.com/img/getting-started/texture_filtering.png)

而右侧，则使用了线性插值重采样，看起来效果明显好多了。线性插值是最简单的纹理放大方法，通过在纹素间
增加平滑变化值创造出更的纹素，纹理尺寸也相应变大，这些纹理重采样方法也叫做 Texture filtering。

高分辨率的像素坐标经纹理映射，只有大小一致的情况下才会落在纹素中心，通常不会落在纹素中心，即映射坐标
非整数值，如何计算红点处的纹理值？就是插值需要考虑的问题。

一个方法是基于三角形重心坐标的插值算法，Interpolation Across Triangles: Barycentric Coordinates。
三角形是二维环境下的单形，即可以通过三角形拼接铺满整个 2D 空间。三角形内的任意一点，可以表示为三角形
三个顶点坐标的线性组合：

    (x, y) = αA + βB + γC
         1 = α + β + γ      (α, β, γ non-negative)

三角形所在平面上任意一个点（x，y）都可以用三个顶点 A、B、C 坐标的线性组合来表示。当线性组合的系数非负，
且 α、β、γ 之和等于 1，则表示这个点在三角形内部，而三个系数则会用于计算插值。

对于一个已知面积的小三角型，可以求角任意点 αβγ 三个系数。假定某点（x，y）与三个顶点连接，将三角形
划分成三个小三角形，各自的面积为 Aᴬ Aᴮ Aᶜ，那么利用面积比可以求出系数 α、β、γ。

    α = Aᴬ ÷ (Aᴬ + Aᴮ + Aᶜ)
    β = Aᴮ ÷ (Aᴬ + Aᴮ + Aᶜ)
    γ = Aᶜ ÷ (Aᴬ + Aᴮ + Aᶜ)

![Geometric viewpoint — proportional areas](https://img-blog.csdnimg.cn/bcd7595c4bc64587a08351dd029f47ec.png)

三角形的重心（质心）标对应的系数就是（1/3, 1/3, 1/3），一般情况下，等密度的物体在均衡的重力场下，
重心和质心是重合的，这个点会将三角形分割成三个面积相等的小三角形。所以，相比于通过面积求系数，更快的
是直接通过顶点坐标来计算，通过向量叉乘可以推导以下式子。式子不重要，关键是理解通过重心坐标来插值。

    α = ((x - Ax)(By - Cy) + (y - By)(Cx - Bx))÷((Ax - Bx)(By - Cy) + (Ay - By)(Cx - Bx))
    β = ((x - Cx)(Cy - Ay) + (y - Cy)(Ax - Cx))÷((Bx - Cx)(Cy - Ay) + (By - Cy)(Ax - Cx))
    γ = 1 - α - β

![Barycentric Coordinates: Formulas](https://img-blog.csdnimg.cn/596fb2e34799442fa59e1f123493220a.png)

当一个点的重心坐标（α，β，γ）求出来以后，就可以求解任意属性 V 在此点的插值，只需要将三个顶点所定义
的属性和系数做乘法再相加，即可求出插值出来的属性值。属性可以是位置，纹理坐标，颜色，法线，深度等等。

但是要注意，在三维空间中，应该考虑投影产生的变形影响，尤其对于在三维空间中的属性，比如深度信息，应该
用三维空间坐标找到对应位置，然后在三维空间中对 A、B、C 的深度属性插值，然后再投影回来，这个过程需要
做一次逆变换就可以。

最简单的插值就是一维线性插值，Linear Interpolation，函数简写为 lerp。更复杂的插值可以有二次曲线、
三次曲线等插值方法。对纹理的插值缩放尺寸，这种操作就是超采样 supersampling。

假定在一个小三角形顶点上，刚好对应到相邻的纹素，那么这个小三角形中间区域的渲染得到的像素就需要在各
个顶点对应的纹素取值之间，进行线性的平滑插值。比如，两顶点之间只多渲染一个像素，而两个顶点的值分别为，
0.5 和 0.7，那么插值点就可以按两点的平均值计算得到 0.6。

对于二维图像，需要进行二线性插值，Bilinear interpolation，分别对应水平方向、竖直方向插值。三维
中还有三线性插值 Trilinear Interpolation。注意，这里的二、三不是指二次曲线或三次曲线，而是一次
的直线做了几回插值操作。

![Bilinear interpolation](https://img-blog.csdnimg.cn/5f070c0acce34afa8562c076fe289fd4.png)

超采样抗锯齿 Super-Sampling Anti-aliasing (SSAA) 是早期抗锯齿方法，比较消耗资源。一般按整数
倍放大，x2、x4、x8 等倍数。 超级采样抗锯齿中使用的采样法一般有两种：

- 顺序栅格超级采样 Ordered Grid Super-Sampling (OGSS)，采样时选取 2 个邻近像素。
- 旋转栅格超级采样 Rotated Grid Super-Sampling (RGSS)，采样时选取 4 个邻近像素。


对于高质量的纹理，比如 4K 纹理在给小图形着色时，就会面临完全不同的问题，一大块的纹素要如何适配一个
像素。这就是块查询问题。当然，不能直接用一个平均值去代表一整块的纹素，会造成严重的失真。

一个经典的解决方法是 Mipmap，它通过为高质量的纹理生成不同精细层级的缩小版纹理，很好地解决了纹理
适配问题，并且速度很快，但是它只能做正方形的处理，比如 1x1、64x64、512x512 这样的纹理尺寸。一般
每层重采样按 1/2 的大小缩小，Level 0 为原图，Level 1 为原图的 1/4 大小，依次类推，所以增加的
存储空间最大为原纹理大小的 1/3。

![Figure 9-4 : Mipmaps](http://www.glprogramming.com/red/images/Image114.gif)

Mipmap 重采样纹理可以预先生成，得到 Mipmap 层级纹理后，贴纹理时就需要有一个映射方法，根据图形的
大小来选择所需要的精细度层级，Computing Mipmap Level D。

![Computing Mipmap Level D](https://img-blog.csdnimg.cn/cbc21cd30b7f4e129dfd141783d1aa0e.png)

计算 Mipmap 层级需要用到偏微分，图上的式中看起来很复杂，但其实就是求解像素与纹素变化率的比值问题。
将像相邻素点投影到对应的纹素，图中的红点代表投射坐标，四个相邻像素构成的矩形就会在纹理上投射出一个
四边形。已知相邻两个像素中心的距离是 1，对应到右边纹理上有的距离 L 也就可以求出，只需要用变化大的
一边的值就可以计算出目标的 Mipmap Level。如果 L 同样为 1 就表示应该使用原纹理，如果 L 为 2 则
应该使用 Level 1 纹理，查询结果总会对应 D  = log2L 层纹理上的一个纹素。

因此，只需要算出 D，即在第几层正方形的区域对应一个像素，就可以得出这个区域内平均值是多少。


Mipmap 并不能处理一切纹理适配问题，当图形需要纹理在两个层级之间过渡需要时，如果直接在现有的两个层
级之间转换，这就会导致纹理从一个精细纹理直接改变为另一张精度只有一半的纹理，图像会出现不连续的现象。
这就需要对 Mipmap 进行三线性插值：先查询出两个层级的纹理各自的二线性插值，再在这两个值之间做一次
额外的层到层之间的插值。

三线性插值提供了一种类似可以提供任意层的 Mipmap 的效果，出来的效果就是一个很漂亮的连续渐变的层级。

![Mipmap Trilinear Interpolation](https://img-blog.csdnimg.cn/cc252947b2f1434cbc10db1dbf1cffb5.png)


很显然，非正方形的变换也不能用 Mipmap 处理，这种情况下应用 Mipmap 就会产生不良效果。

![Mipmap 锯齿及摩尔纹](https://img-blog.csdnimg.cn/f187e0f6755749c5a68961c80d8405a5.png)

这种现象产生的原因是变形方向与采样不适配，Mipmap 都是正方形区域缩放，只能做正方形的 Range Query。
然而真实情况并不是如此，见下图，不同 Screen space 的像素所对应的纹素延展方向不同，有方块，有长条，
方向也不一样，甚至是不规则图形。下图来源 Fundamentals Of Computer Graphics - 11. Texture Mapping

![Screen space to texture space](https://pic2.zhimg.com/80/v2-1003f344d0ffc9d683b66167e45c0359_1440w.webp)

Figure 11.18. The footprints in texture space of identically sized square areas 
in the image vary in size and shape across the image.

为了解决 Mipmap 不能解决非正方形变换的问题，又引入了各向异性过滤 Anisotropic Filtering 以解决
三线性插值弊端，在不同的方向上表现各不相同（考虑方向性）：

![Anisotropic Filtering](https://img-blog.csdnimg.cn/4b84789bb6074c46b9baff3903fa8deb.png)

Mipmap 操作的相当于是上图的对角线图片，每次长宽各缩小一半，而各向异性可以用不同的长宽比进行缩小，
包含上图除了对角线以外的图片，就可以应对非矩形区域做范围查询，额外存储开销是原来的三倍。


但是，对于一些斜着的图形，依然没有很好的方法去查询。为了解决任意变形纹理映射问题，又引入了更复杂的
纹理过滤方法，如 Elliptically Weighted Average (EWA) 椭圆加权平均过滤。效果上，比三线性滤波 
Trilinear Filter 要好了一大截。

对于任何一个形状，EWA 都可以将其拆成很多不同的圆形去覆盖这个形状。比如，查询一个椭圆，可将其拆成多个
圆形，每次去查询一个圆形，多次查询自然就可以得到一个区域，但是代价是“多次查询”。可见质量越高的效果，
性能开销越大。

![EWA filtering](https://img-blog.csdnimg.cn/ea8e695554e04d74bf530569f6d7c04a.png)



### 🟠🔵 IBL & Skybox 纹理贴图光照
- [Poly Haven - The Public 3D Asset Library](https://polyhaven.com/all)
- [LearnOpenGL - Cubemaps skybox](https://learnopengl.com/Advanced-OpenGL/Cubemaps)
- [OGLDev Tutorial 25: SkyBox](https://ogldev.org/www/tutorial25/tutorial25.html)
- [GAMES101 现代计算机图形学入门 - 闫令琪](https://www.bilibili.com/video/BV1X7411F744/?p=10)
- [详解球面环境映射 - Spherical Environment Mapping](https://zhuanlan.zhihu.com/p/84494845)
- [GPU Gems I - 19. Image-Based Lighting](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-19-image-based-lighting)
- [Programming with OpenGL: Advanced Rendering - 9.3.2 Sphere Mapping](https://www.opengl.org/archives/resources/code/samples/advanced/advanced97/notes/node93.html)
- Real-Time Rendering - 10.4 Environment Mapping
- [Real-Time Rendering 3rd 纹理贴图及相关技术提炼总结](https://zhuanlan.zhihu.com/p/27551369)
- [Real-Time Rendering 3rd 基于图像的渲染技术提炼总结](https://zhuanlan.zhihu.com/p/30345339)
- [Real-Time Rendering 3rd 全局光照 GI 技术进化编年史](https://zhuanlan.zhihu.com/p/29418992)
- [Procedural geometry](https://docs.godotengine.org/en/latest/tutorials/3d/procedural_geometry/index.html)
- [Using the ArrayMesh](https://docs.godotengine.org/en/3.5/tutorials/3d/procedural_geometry/arraymesh.html)

纹理贴图不仅可以用来给图形着色，它还有各式各样的用法，如下，按技术出现先后序：

- Bump Mapping 凹凸贴图，使用纹理变化来影响法线方向，增加图形表面的凹凸细节；
- Displacement Mapping 转换贴图，使用纹理来改变顶点的位置；
- Normal Mapping 法线贴图，是凹凸贴图的一种应用，使用纹理记录法线向量；
- Parallax Mapping 视差贴图，又称为 Offset Mapping，是凹凸贴图改进版，纹理将有更明显的深度。
- Relief Mapping 浮雕贴图，有人把它誉为凹凸贴图的极致。

视差贴图是针对 Normal Mapping 的改进，利用 Height Map 进行了近似的 Texture Offset。
而 Relief Mapping 是精确的 Texture Offset，所以在表现力上比较完美。



用纹理图像来模拟光照就是常见用法，纹理当作环境光使用，那么纹理中记录的就是光照信息。或者直接将纹理
当作 Environment Map 渲染到图形上。

Skybox 就是将环境光纹理保存在一个 Cube 上用来模拟天空大气的环境，原理就是假设一个无限远的盒子，
以玩家为中心，无论玩家移动了多远，天空盒都不会变近，这样就产生一种四周的环境真的非常大的假象。

![Cubemaps skybox](https://learnopengl.com/img/advanced/cubemaps_skybox.png)

使用了环境立方体贴图的技术叫做环境贴图技术，让物体有反射(reflection)和折射(refraction)属性。

更早期的做法是使用一个球体来保存环境光，Spherical enviroment map，它采用单张贴图表示整个环境，
缺点是球形贴图的周边精确度急剧下降。这种模型中，摄像机位于无穷远，而球体无穷小，同时假设相机的分辨率
可以任意高。相当于把一个擦得锃亮的完美球体放在环境的中央，然后在无穷远处用长焦镜头对它进行拍照。照片
就是中覆盖整个圆形区域的部分，它与纹理图像的顶、底、左、右边缘相切。这个圆形区域之外的区域不重要，因为
它们不会在环境纹理中使用。

![Sphere Mapping](https://pic3.zhimg.com/80/v2-1528a601b4105d6e1b4c935444ac75e2_1440w.webp)
![Sphere Mapping](https://www.opengl.org/archives/resources/code/samples/advanced/advanced97/notes/img130.gif)

假设反射球表面法线为 n，视角方向 v，反射向量 r，采样公式表达如下，通过反射向量求采样坐标：

    m = 2 √(r𝑥² + r𝑦² + (r𝑧 + 1)²)
    𝑢 = r𝑥/m + 1/2
    𝑣 = r𝑦/m + 1/2

反射球体仅在球体的正面显示整个环境，产生的圆形图像也称为光照探针（light probe），因为它捕获了球体
位置处的照明情况，拍摄球形探针是捕获基于图像的照明的有效方法。将球形贴图可以展开为一张矩形的经纬贴图，
但是，这种方式的图像会出现上下两端的畸变，而赤道部分则相对过度采样。

1986 年，Greene 推出了立方环境映射（cubic environment map），这种是当今最流行的方法，它的投影
直接在现代 GPU 的硬件中实现。Cubemaps 方式使用 6 张纹理图，则不会有球体贴图的畸变问题。天空盒也要以
球体的方式呈现环境贴图，所以是将一个盒子包裹着一个球体，在计算上不及直接使用球体方便。与球形映射不同，
立方体环境映射独立于视图，与经纬映射相比，它还具有更加统一的采样特性。


以下使用 Blender + Godot 创建一个 Cubemap。先在 Blender 创建一个 Cube，进入编辑模式：

- 激活 Face selection mode，并选择所有面；
- 执行 Mesh - Normals - Flip 将六个面的法线反转，指向立方体内部；
- 设置 Viewport Overlays - Normals 可以显示法线，以确认法线朝向；
- 执行 UV - Cube Projection 使各面的 UV 坐标铺满整个纹理空间；
- 执行 Mesh - Split - Faces by Edges 分离六个面；
- 执行 Mesh - Separate - By Loose Parts 将六个分离面独立为 Mesh 对象；
- 操持各个面选择状态，执行菜单导出 Export - Wavefront (.obj)，导出选项设置：
    - Limit to: Selected Only 只导出已选择的六个面；
    - Foward Axis: -Z
    - Up Axis: Y

右手系 (right-hand system)，使大拇指、食指、中指互成直角，大拇指、食指、中指分别指向 x、y、z 轴
正方向，并且中指指向自己。而左手系 (left-hand system)则是中指指向 z 轴负方向，并且中指指向前方。

Godot 坐标系统中，按以下向量确定方向，x 轴指向 RIGHT，y 轴指向 UP，z 轴指向 BACK(backward)：

    Vector3.UP (0, 1, 0)
    Vector3.RIGHT (1, 0, 0)
    Vector3.FORWARD (0, 0, -1)

Blender 虽然也使用右手系，但是它是 z 轴向上的，这点与 Godot 不同。通过以上的导出设置可以适配 Godot
正常使用的右手系，会自动将 Blender 的 -Z 对应到 Godot 的 -Y，即对齐底部，Blender 中显示的底部，
在 Godot 中依然是底部。

导出后，各个面的顺序可以直接打开 obj 文件查看，在 Blender 场景中修改 Mesh 名称会改变显示顺序，
但导出的顺序可能还按原来的数据顺序，可以按需要的顺序重新将 Mesh 添加到 Collection 集体中再导出。

Cube 与摄像机前进方向相同的一面为 Back，相反方向的一面为 Front，同样，左右两面也与摄像机的左右
对换。在贴纹理图时，按前面展示的 Skybox 的图像命名，对应 Cube 的面进行贴图。因为，摄像机需要透过
Cube 的内表面成像，有三个面的 UV 坐标需要对 U 轴反转，分别是 Top、Front、Right，另外 Buttom
需要 UV 同时反转。

这种简单通过 Cube 模拟的 Skybox 有缺点，就是摄像机向顶、底方向时，成像会有较明显的矩形边界。更正确
的做法是使用 ArrayMesh 修改几何结构，并将 Box 表面映射到球体。

```py
var vertices = PoolVector3Array()
vertices.push_back(Vector3(0, 1, 0))
vertices.push_back(Vector3(1, 0, 0))
vertices.push_back(Vector3(0, 0, 1))
# Initialize the ArrayMesh.
var arr_mesh = ArrayMesh.new()
var arrays = []
arrays.resize(ArrayMesh.ARRAY_MAX)
arrays[ArrayMesh.ARRAY_VERTEX] = vertices
# Create the Mesh.
arr_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
var m = MeshInstance.new()
m.mesh = arr_mesh
```


然后，通过 GDScript 加载导出的 Mesh 并设置纹理：

```py
tool
extends Spatial
class_name SkyBox

onready var sky_mesh = load("res://assets/skybox/skybox.obj")

export(StreamTexture) var TextureLeft = null setget set_TextureLeft
func set_TextureLeft(value):
    TextureLeft = value
    set_mat()

export(StreamTexture) var TextureRight = null setget set_TextureRight
func set_TextureRight(value):
    TextureRight = value
    set_mat()

export(StreamTexture) var TextureFront = null setget set_TextureFront
func set_TextureFront(value):
    TextureFront = value
    set_mat()

export(StreamTexture) var TextureBack = null setget set_TextureBack
func set_TextureBack(value):
    TextureBack = value
    set_mat()

export(StreamTexture) var TextureBottom = null setget set_TextureBottom
func set_TextureBottom(value):
    TextureBottom = value
    set_mat()

export(StreamTexture) var TextureUp = null setget set_TextureUp
func set_TextureUp(value):
    TextureUp = value
    set_mat()

onready var _mesh:MeshInstance = $SkyMeshInstance

func create_mat(texture):
    var m = SpatialMaterial.new()
    m.flags_unshaded = true
    m.albedo_texture = texture
    return m

func set_mat():
    if _mesh:
        _mesh.queue_free()
    
    _mesh = MeshInstance.new()
    _mesh.name = "SkyMeshInstance"
    _mesh.mesh = sky_mesh
    add_child(_mesh)
    _mesh.owner = self
    print(_mesh.owner, sky_mesh)
    _mesh.set_surface_material(0, create_mat(TextureRight))
    _mesh.set_surface_material(1, create_mat(TextureLeft))
    _mesh.set_surface_material(2, create_mat(TextureFront))
    _mesh.set_surface_material(3, create_mat(TextureBack))
    _mesh.set_surface_material(4, create_mat(TextureBottom))
    _mesh.set_surface_material(5, create_mat(TextureUp))


func _ready():
    set_mat()
```



### 🟠🔵 Blinn-Phong 基础光照着色模型
- [GAMES101-现代计算机图形学入门-闫令琪](https://www.bilibili.com/video/BV1X7411F744?p=7)
- [GAMES202 作业 0: WebGL 框架的使用与 Blinn-Phong 着色模型 闫令琪](https://sites.cs.ucsb.edu/~lingqi/teaching/games202.html)
- [Learn OpenGL - Basic Lighting](https://learnopengl.com/Lighting/Basic-Lighting)
- [Learn OpenGL - Advanced Lighting](https://learnopengl.com/Advanced-Lighting/Advanced-Lighting)
- [Phong shading - HandWiki](https://handwiki.org/wiki/Phong_shading)
- [Blinn–Phong reflection model From HandWiki](https://handwiki.org/wiki/Blinn–Phong_reflection_model)
- [CS-116A: Introduction to Computer Graphics - Light and Color - Rob Bruce](http://www.cs.sjsu.edu/~bruce/fall_2016_cs_116a_lecture_light_and_color_part_1_of_2.html)

闫令琪的网课 GAMES202: 高质量实时渲染，作业零是 Blinn-Phong 着色模型编程的实验。这种着色器又叫
反射模型、修正模型，Blinn–Phong reflection model 或者 modified Phong reflection model，
是由 Jim Blinn于 1977 年在文章中对传统 phong 光照模型基础上进行修改提出的。它是一个经验模型，
并不完全符合真实世界中的光照现象，但由于实现起来简单方便，并且计算速度和得到的效果都还不错，因此在
早期被广泛的使用。

原模型作者是 Bùi Tường Phong (1942 – 1975)，他于 1973 年在犹他大学取得计算机科学博士学位，
并发明了 Phong 反射模型及 Phong Shading 着色算法，并广为 CG 界采用，作者 1975 死于白血病。

同样的模型，使用不同的着色算法会产生不同的效果，以下是三种最基础的不同着色频率的模型：

- Flat shding 按三角面着色，per-face，低频着色方法；
- Gouraud shading 按顶点着色，per-vertex，属于中频着色方法；
- Phong shding 按和像素着色，per-pixel，属于高频着色方法；

![Flat shading (left) versus Phong shading (right)](https://handwiki.org/wiki/images/8/84/Phong-shading-sample.jpg)


Blinn-Phong 光照模型将进入摄像机的光线分为三个部分，Ambient、Diffuse、Specular，即环境光、漫反射
和高光反射，每个部分使用一种方法来计算它的贡献度。就是说，只要将这三种光计算出来，就可以实现布林冯
光照模型效果。整个 Blinn-Phong 光照模型的结果就是 L𝑎 + L𝑑 + L𝑠 三者求和，以下逐个解析。

![Blinn-Phong reflection model](https://handwiki.org/wiki/images/6/6b/Phong_components_version_4.png)


计算中需要先定义一些单位向量用于表示方向，更高效果要求的着色模型还会需要其它参数：

- **Viewer direction**，观察方向，使用 𝑣 表示，由着色点指向摄像机；
- **Surface normal**，表面法线方向，使用 𝑛 表示；
- **Light direction**，光线入射方向，使用 𝑙 表示，由着色点指向光源；

![Lights reflection](https://pic1.zhimg.com/80/v2-62c91756b8b182383578c6708db35da4_1440w.webp)

环境光也称间接光，光线经过周围环境表面多次反射后会在物体表面形成均匀统一的光照效果，利用它可以描述
物体基本外观亮度，在光照模型中，通常用一个常量来表示。公式表达如下，k𝑎、I𝑎 分别为环境光系数、光强度。

    L𝑎 = k𝑎 ⨉ I𝑎

一般上，对于个具有一定粗糙度的非光滑物体，当光线照射到物体时，光线会被均匀的反射到各个方向，这种反射光
称为漫反射。从微观角度看，模型分析每一点光照都设定这一点有无数方向完全随机的法线，也就是说，在漫反射中，
视角的位置是不重要的，因此可以认为漫反射光在任何反射方向上的分布都是一样的。而整体上，物体的一个面上，
大多数法线都与这个面垂直，光线反射遵循整体规律。

反射光与反射系数有关系，reflection coefficient，物体表面反射光线的能力，就是反射光强度与入射光
的强度之比值，取值 [0, 1]，受入射光的投射角度、强度、波长、物体表面材料的性质，以及反射光的观察角度
等因素影响。

漫射光的强度与**入射角度**，入射光线与法线的夹角，以及入射光线强度相关。Lambert Consine Law
兰伯特余弦定律指出，入射光角度越大，漫反射分量越小，当夹角接近 90°，认为漫反射几乎为零，全部都是
反射光。夹角大于 90° 时的余弦值小于 0，没有实际意义，取 0 值。

    f(Θ) = max(0, cosΘ) = max(0, 𝑙·𝑛)

点积 𝑙·𝑛 就是求向量 𝑙 在 𝑛 上的投影，即反射光线强度，Θ 为入射角。

光线强度会随着距离的增加而衰减，假设一个光源，在距离它单位圆上每一个点接收到光的强度是 I。那么根据
能量守恒定律，且不考虑衰减，在距离光源 r 位置的圆上每个点接收到光的强度就是 I/r²。所以，漫射光强
L𝑑 可以表达为以下公式，其中 k𝑑 为反射系数：

    L𝑑 = k𝑑 ⨉ (I/r²) ⨉ max(0, 𝑙·𝑛)

这个公式说的是，漫射光等于着色点处接收到的光能在反射系数、光线传播距离约束下的反射形成二次传播的光能。

![Diffuse and Specular](https://learnopengl.com/img/lighting/basic_lighting_specular_theory.png)

高光反射也称为镜面反射，当然并不说说只有镜面才有高光反射，只是说体表面越光滑，镜面反射越明显，理想
条件下，完全的镜面是没有漫射光的。当平行入射的光线射到这个物体表面时，仍会平行地向一个方向反射出来。
入射光线 𝑙 照射在光滑的平面上，会沿着 R 方向反射，当观察角度正好与 R 方向对齐时，这时的镜面反射光
最强，最明显。非完全光滑的表面上，高光反射的方向并非只有 R 一个方向，而是 R 周边的一小块区域，角度
越接近就越明显。可以得出一条结论：高光反射和表面光滑度、观察角度有关。

布林冯模型中认为，高光反射的强度与反射光线 R 和观察角度 𝑣 之间夹角的余弦值成正比。它的强度，相当于
求向量 𝑣 在 R 上的投影，即 𝑣·R。

但是，对于一个现成的场景，一般已知量是摄像机代表的观察方向，物体表面法线方向，以及光线入射方向。而
反射方向 R 是个未知量，虽然可以通过余弦定理求解，但是运算比较麻烦。

![Halfway vector](https://learnopengl.com/img/advanced-lighting/advanced_lighting_halfway_vector.png)

Blinn-Phong 对冯氏光照模型的一个改进，就是观察到了半程向量 half-angle vector 和法线方向接近，
就表明高光越明显，这一发现就避免了直接计算 R 值，而是计算更容易得到的半程向量 ℎ，计算方法如下：

    ℎ = (𝑙 + 𝑣)/|𝑙 + 𝑣|

也就是半程向量等于，入射方向与观察方向的向量和，除于两向量的模，相当于做 normalize 归一化处理。
最后，高光反射光可以表达为以下公式：

    L𝑠 = k𝑠 ⨉ (I/r²) ⨉ max(0, 𝑛·ℎ)ᵖ

高光反射与镜面程度有一些明显的视觉效果，镜面程度越高，高光越高并且面积会越小，明暗分界越清晰，通过
设置指数就可以实现这一些效果，一般指数项 p 取值 64 次方的情况下，高光范围的角度大概对应 35° 左右。
虽然，反射光这是使用的是幂运算，但是因为向量都是单位向量，点积最大值不会超过 1.0，所以指数值越大，
光斑反而会越小。

![basic lighting specular shininess](https://learnopengl.com/img/lighting/basic_lighting_specular_shininess.png)



### 🟠🔵 Shadow Map 阴影贴图
- [GAMES101 现代计算机图形学入门  Geometry - 闫令琪](https://www.bilibili.com/video/BV1X7411F744/?p=12)
- [GAMES202 高质量实时渲染 - 闫令琪](https://www.bilibili.com/video/BV1YK4y1T7yY)
- [Optimized StencilShadow Volumes Cass Everitt & Mark J. Kilgard](https://slidetodoc.com/optimized-stencil-shadow-volumes-cass-everitt-mark-j/)
- [GPU Gems 1 - Part II: Lighting and Shadows](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows)
- [GPU Gems 3 - Part II: Light and Shadows](https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows)
- [RTR4 图形学基础 - 阴影 - ShadowMap及其延伸 - 杨鼎超](https://zhuanlan.zhihu.com/p/384446688)
- [Planar Shadow 方向光 - Jeffrey Zhuang](https://zhuanlan.zhihu.com/p/94491734)
- [Planar Shadow 点光源 - Jeffrey Zhuang](https://zhuanlan.zhihu.com/p/94555744)
- [OGLDev Tutorial 40: Stencil Shadow Volume](https://ogldev.org/www/tutorial40/tutorial40.html)
- [游戏中的阴影基础 - 洛城](https://zhuanlan.zhihu.com/p/27572129)
- [GAMES202 L3&L4&L5：实时阴影（Real-time Shadows） - 戴子玲](https://zhuanlan.zhihu.com/p/471190375)
- Real-Time Rendering, Fourth Edition - Chapter 7 Shadows
- [阴影体(shadow volume)](https://blog.csdn.net/zhao_92221/article/details/46756645)
- [实时阴影技术 Real-time Shadows](https://www.cnblogs.com/KillerAery/p/15201310.html)
- [华中科技大学 计算机图形学 实时阴影 - 万琳](https://www.bilibili.com/video/BV1V7411k74z?p=72)

Planar Shadow 是一种直接通过几何变换，将图形作为阴影的一种低运算得的低效果的阴影模拟技术，相当于
将图形拍平到投射平面上，优缺点很明显：

- 优点：阴影边界可以很清晰，节省 RenderTexture (RT)，相比 shadow map 就需要 RT。
- 缺点：不适用于曲面，最好的应用环境是平坦地形。

阴影映射 Shadow Mapping 是 Williams 于 1978 年发明的一种流行的阴影算法，同 Frank Crow 于
1977 发明的体积阴影 Shadow volumes 相比，具有几个重要优势，特别是，阴影贴图可以在任意位置查询，
并且对几何复杂性不太敏感。

Shadow Volume 最大的优点是没有阴影锯齿问题，但它基于几何方法，有可能每帧都要构造和渲染阴影锥，
而且有些工作必须由 CPU 完成，并且，无法处理具有透明材质物体的阴影投射，如公告板，粒子系统，树叶等。
使得它在效率上没有 Shadow Map 高，因为后者计算都在 GPU 完成。

Shadow Volume 根据光源和遮蔽物的位置关系计算出场景中会产生阴影的区域，然后对所有物体进行检测，
以确定其会不会受阴影的影响。下图的绿色物体是遮蔽物，而灰色的区域就是 shadow volume，阴影区域内的
物体才会受阴影的影响。假如一个物体遮住了光源投射出阴影，就称物体为 Shadow Caster (SC)。而阴影投射
到另一个物体上形成阴影，另一个物体就称为 Shadow Receiver (SR)。

![Optimized StencilShadow Volumes Cass Everitt & Mark J. Kilgard](https://img-blog.csdn.net/20150704160224644)

图片来源：Optimized StencilShadow Volumes Cass Everitt & Mark J. Kilgard

![Z-pass vs. Z-fail](https://images0.cnblogs.com/i/292994/201408/042015297253279.png)

Shadow Volume 的一种实现是 Z-pass 算法，它可以在任何支持 stencil buffer 功能的 GPU 上运行。
基本原理如下，分为三个步骤：

- Pass1：enable z-buffer write 条件下渲染整个场景，得到所有物体的 depth map。
- Pass2：disable z-buffer write & enable stencil buffer write 条件下渲染所有 shadow volume。
    对视线穿越阴影区域边界进行计数，在深度测试结果为 pass 的前提下，穿越 front face 和 back face
    分别 +1 和 -1，正面即面对视点的这一面，计数结果即为 stencil 值。
- Pass3：根据每个象素的 stencil 值是否大于 0 判断其是否处于阴影当中，然后据此绘制阴影效果。

以上过程概括起来，Z-pass 算法就是从视点向物体引一条射线，当它可以穿越所有 shadow volume 区域，
即 stencil = 0，即表示视线可以看到物体，因为它不在 shadow volume 区域内。

Z-pass 算法遇到的问题是，摄像机本身是假定位于阴影体外，当本身出现在阴影区域内部时，算法就失效了。

Z-fail 算法是 John Carmack，Bill Bilodeau 和 Mike Songy 各自独立发明的，其目的就是解决
视点进入 shadow volume 后 Z-pass 算法失效的问题。它针对 Z-pass 第二步作了补充，在尝试测试结果
为 fail 的条件下，穿越 front face 和 back face 分别对 stencil 值 -1 和 +1，刚好是反向操作。


Shadow Map 是目前主流的阴影生成算法，这主要得益于它算法直观，并且能够充分利用现代硬件的光栅化能力。
这也是入门图形学的基础算法之一，算法思路是通过视点深度与光源尝试信息的比较，确定阴影区域。对于确定
光源来说，场景中某个点是否被其照亮，取决于从光源的视角看去，这个点是否可触及，以及从摄像视角来看，
这个点是否可见。当两者任意一方不可以触及一个位置，那么就可以确定一个阴影位置。

Shadow Map 算法被分成光源视角处理、摄像机视角处理两个阶段：

- 从光源视角出发，绘制整个场景，平行光用正交投影，点光用透视投影，Shadow Map 记录下物体表面的距离；
- 从摄像机视角出发，重新绘制场景，获取世界投影空间内的像素到光源的深度 d；
- 并根据光源投影矩阵的逆矩阵，将世界坐标空间变换回光源的投影空间，找出对应光源投影空间 UV 坐标；
- 利用光源投影空间的 UV 坐标采样 Shadow Map，得到光源视角下的深度信息 ；
- 比较两个深度值，若 d > z，则当前位置被遮挡，处于阴影内，否则未被遮挡；

![Shadow Map Projections](https://pic3.zhimg.com/80/v2-3f2c370b6b39cade31f8b3e4bf3d815e_1440w.webp)

回顾一下 z-buffer 算法，深度就是片元的到相机的距离信息，默认值 1.0 表示无限远，深度图就是一张
灰度图像。想象一下，如果把相机位置换成光源，那么“光看不到的地方就是阴影”，这就是阴影贴图的思想。
由于相机视角处理阶段，需要的数据只是深度值，所以可以把光照计算关掉，打开 z-test 和 z-write。

![Depth map in Shadow map](https://pic2.zhimg.com/80/v2-7fc6cceda943968a08e8ec83fa46fe41_1440w.webp)

注意，Shadow mapping 和 Shadow volume 里面使用的 depth map 是有区别的，前者以光源和视点、
后者以视点角度计算得到深度图。


阴影贴图是一种相对高效和直观的光照模拟技术，应用此技术有三大难点：

- 1） Omnidirectional Shadow Maps：全方向的阴影贴图
- 2） Depth Bias：比较深度时的偏差问题
- 3） Aliasing：阴影贴图的采样和重采样问题

由于纹理采样的离散性特点，以及浮点数的精度误差，不能直接比较相等值，等等因素都会导致阴影贴图走样，
产生所谓的“Shadow Acne”。特别是在灯光与投影平面夹角较大时，锯齿现象更严重。通常的解决方案是比较时
加上一个固定偏差值 bias，但是若偏差值选取过大，又会产生“Peter-Panning”问题，影子飞起来。自适应
方案是 Slope Scale Depth Bias，基于斜率计算当前深度要加的偏差。

![Slope Scale Depth Bias](https://pic2.zhimg.com/80/v2-713a366f76e8637c7b27efbc95027ccd_1440w.webp)

Shadow Map 产生锯齿的普遍原因在于，坐标变换是连续的，但光栅化后的像素位置则是离散的，不论阴影贴图
的精度有多高，都无法保证从屏幕空间的像素映射到光源空间时，能够找到一个位置完全匹配的像素。一个解决
访求是，百分比渐进滤波 Percentage-Closer Filtering (PCF)，当计算一个屏幕空间的像素是否处于
阴影当中时，需要考虑它投影到的 Shadow Map 位置附近的多个像素，使用阴影软化。


### 🟠🔵 Ray Trace 光线追踪
- [实时光线追踪技术：业界发展近况与未来挑战](https://zhuanlan.zhihu.com/p/102397700)
- [RTX Global Illumination (RTXGI)](https://developer.nvidia.com/rtx/ray-tracing/rtxgi)
- [DLSS 2.0 - 重新定义AI渲染 - 文刀秋二](https://zhuanlan.zhihu.com/p/116211994)
- [GAMES101 现代计算机图形学入门 Ray Tracing - 闫令琪](https://www.bilibili.com/video/BV1X7411F744?p=13)
- [GAMES202 高质量实时渲染 Real-Time Ray Tracing - 闫令琪](https://www.bilibili.com/video/BV1YK4y1T7yY?p=12)
- [GAMES101 L15：光线追踪 - 辐射度量学、渲染方程、全局光照](https://www.yuque.com/sugelameiyoudi-jadcc/okgm7e/eb2c162cc558657da2aea25b68a6c580)
- [CS190I: Introduction to Offline Rendering Fall 2020](https://sites.cs.ucsb.edu/~lingqi/teaching/cs190I.html)
- [CS291A: Real-Time High Quality Rendering Spring 2020](https://sites.cs.ucsb.edu/~lingqi/teaching/cs291a.html)
- [Physically Based Rendering: From Theory to Implementation", 3rd](http://www.pbr-book.org/3ed-2018/contents.html)
- [Peter Shirley, "Ray Tracing in One Weekend -- The Book Series"](https://raytracing.github.io/)
- [Computer Graphics Lecture Notes 17 - Photorealistic Effects](http://www.cs.kent.edu/~farrell/cg00/lectures/rendering/render.html)
- [The Cornell Box](http://www.graphics.cornell.edu/online/box/)
- [Introduction to Ray Tracing: a Simple Method for Creating 3D Images](https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-ray-tracing/how-does-it-work)
- [空间数据结构(四叉树/八叉树/BVH树/BSP树/k-d树)](https://www.cnblogs.com/KillerAery/p/10878367.html)

为了简化图像格式带来的问题，以将重心放到光线追踪的处理上，Ray Tracing in One Weekend 教程中
使用了 Portable PixMap (PPM) 便携像素图片格式保存图像。

PPM 是 Netpbm 项目定义的一系列的图片格式中的一个：

|       Type       |  Magic Number & Format  | Extension |        Colors       |
|------------------|-------------------------|-----------|---------------------|
| Portable BitMap  | P1 (ASCII)  P4 (binary) | .pbm      | 0–1 (black & white) |
| Portable GrayMap | P2 (ASCII)  P5 (binary) | .pgm      | 0–255 (gray scale)  |
| Portable PixMap  | P3 (ASCII)  P6 (binary) | .ppm      | 0–255 (RGB)         |

PPM 是其中一种支持彩色的格式，有字符串格式和 binary 两种保存格式，对应 P3、P6 两个魔术数字。例如，
以下为 ASCII 保存的 PPM 彩色图像，只有 3x2 个像素：

```sh
    P3
    # The magic number P3 means colors are in ASCII,
    # The magic number P6 means colors are in binary.
    3 2
    255
    # then 3 columns and 2 rows,
    # then 255 for max color,
    # then RGB triplets
    255 0   0   0   255   0   0 0 255
    255 255 0   255 255 255   0 0 0
```

图像数据部分，使用 ASCII 字符串表示 RGB 三个分量，并使用空格分隔，图像每一行像素对应文件的一行，
像素数据从左到右，从上到下，与图像对应。当然，完全可以不分行，只需要定义好 columns x rows 即可。

对于 binary 格式，直接使用字节数值表示 RGB，不需要使用空格分隔，使用 P6 格式就显得没那么可读，
可以用 GIMP、IrfanView 等工具生成：

    00000000:  5036 0a23 2043 7265 6174 6564 2062 7920  P6.# Created by 
    00000010:  4972 6661 6e56 6965 770a 3320 320a 3235  IrfanView.3 2.25
    00000020:  350a ff00 0000 ff00 0000 ffff ff00 ffff  5...............
    00000030:  ff00 0000                                ....

使用 ffmpeg 可以将图片合成为视频，或者 gif 动画，图片名称格式如 demo01.ppm：

    ffmpeg -f image2 -framerate 15 -i demo%02d.ppm -loop -0 animation.gif

图形渲染有两大典型应用场景：

- 离线渲染 offline，典型的是电影中应用 Ray tracing 等高端技术和大量的算力生产极高质量的图形。
- 实时光栅化渲染 real-time，典型的是游戏应用，需要权衡性能与体验，需要在保证流畅体验的前提下提高画质。

光线追踪的两种基本形式如下：

- Forward Tracing (light tracing) 向光线传播方向追踪；
- Backward Tracing (eye tracing) 向光线来路方向追踪；

眼睛观察到的世界，就是光线进入眼球，或者说眼球结构通过聚焦让感光细胞看到成像平面上的色彩。在成像平面
上，有无数多的点，每个点都会有光子被反射到眼睛的视网膜上：

![photons & eyes](https://www.scratchapixel.com/images/upload/introduction-to-ray-tracing/lighttoeyebounce.png)


抽象的光线要以代码的形式表达实在是抽象上抽象的工作，但是还是要回到数学工具上来，向量是必不少的工具。
Ray Tracing In One Weekend 教程将光线抽象地表达为一个射线类 ray class，这有助于直观地理解
光线追踪里的射线如何工作。

所有光线追踪器都会有 ray class 用于计算沿着光线前行的可以看到什么色彩。

![Figure 2: Linear interpolation](https://raytracing.github.io/images/fig-1.02-lerp.jpg)

先来假设一个函数 P(t) = A + t𝑏，这里 P 表示一个光子沿着光线上传播的 3D 坐标，A、𝑏 分别是光线的
传播起点和方向。光线参数 t 是一个实数，在代码中用 double 类型表示。使用不同的 t 可以使用光子 P(t) 
沿射线移动点。

使用负值 t 可以在 3D 空间上沿光线的向后的任何位置移动。对于正值 t，只得到起点 A 前面的部分，这就是
通常所说的半直线或射线。

    P(t) = origin + t∗direction

那么，函数 P(t) 可以表示光子的运动，用代码表示，就是 ray::at(t) 方法使原点发生变化，变化量就是
沿着前进方向的单位向量与参数 t 的乘积：

```c++,ignore
#ifndef RAY_H
#define RAY_H

#include "vec3.h"

class ray {
    public:
        ray() {}
        ray(const point3& origin, const vec3& direction)
            : orig(origin), dir(direction)
        {}

        point3 origin() const  { return orig; }
        vec3 direction() const { return dir; }

        point3 at(double t) const {
            return orig + t*dir;
        }

    public:
        point3 orig;
        vec3 dir;
};

#endif
// Listing 8: [ray.h] The ray class
```

有了这一层抽象后，接下来要做的事就是实现一个 ray tracer，最核心的是，假设它从相机位置发出射线，
穿过屏幕上的像素，并计算沿射线方向上可以看到的色彩。

当然，这里又引入了一层抽象，射线并非要真的穿透屏幕，而是 3D 空间抽象的相机成像平面，viewport，
这个平面记录的是所有可以看到的色彩，最终会渲染到 frame buffer 并输出到屏幕上。

所涉及的步骤是：

1. 计算从眼睛到像素的光线，
2. 确定光线与哪些对象相交，以及
3. 计算该交点的颜色。

![Ray trace diagram](http://suncio.me/images/RayTraceDiagram.svg)

所以，光线追踪问题又回到了数学工具的使用上，几何图形的处理问题上。 

例如下图，往成像平面每个像素打一道射线，并计算它会与什么光源接触，并将结果记录下来：

![Lighting shadow](https://www.scratchapixel.com/images/upload/introduction-to-ray-tracing/lightingshadow.gif)
![Pixeld render](https://www.scratchapixel.com/images/upload/introduction-to-ray-tracing/pixelrender.gif)

尝试开发光线跟踪器时，可以用一个简单的相机来启动和运行代码，制作一个简单的 ray_color(ray) 函数，
它只需要返回背景的颜色，例如一个简单渐变色即可。

对于一个光线 r 和球体 p 求交运算，就是将光线方程代入球体方程中，这是解析几何问题：

    Ray: r(t) = origin + t∗direction, t >= 0

    Sphere: p: (p - c)² - R² = 0

    Intersection: (origin + t*direction - c)² - R² = 0

![GAMES101 Lecture 13 - Ray Intersection With Sphere](https://cdn.nlark.com/yuque/0/2021/png/12962324/1617257130807-a02c66ae-5d27-43d1-b53e-1e513f77d011.png)

就是求解二次方程：

    at² + bt + c = 0, where
    a = direction · direction
    b = 2(o - c) · direction
    c = (o - c) · (o - c) - R²

    t = (-b ± √(b² - 4ac)) / 2a

对于任意隐式几何曲面，要求解与光线方程的交点，只需要将光线方程代入几何方程，并求解实数、正数根：

    Ray: r(t) = origin + t∗direction, t >= 0

    General implicit surface: p: f(p) = 0

    Substitute ray equation: f(origin + t*direction) = 0
    
    Solve for real, positive roots

对于显式几何体，一般就是三角的运算，三角形也是图形学中最基础最常用的几何体，模型中包含大量的三角或
四边形，但能通常不会直接将光线与每个面进行运算，这个运算量极大。反而是平面的运算有非常大的用途，AABB
算法中就需要计算光线与平面的交点。一个三角形就可以当作一个平面看待，通常使用法线向量和一个点表达。

平面的隐式表达有代数方程方式 ax + by + cz + d = 0，也有点、法线定义方式：

    p : (p - p‘) · N = 0

上式意思是：所有 p 集合的点满足，与平面上一点 p‘ 的差值与法线的叉积为 0。要与光线相交，只需要将
光线方程代入 p 参数，设 p = r(t) 并求解 t：

    t = (p‘ - origin)·N /(d·N) = 0, 0<=t


![GAMES101 Lecture 13 - Ray Intersection With Plane](https://cdn.nlark.com/yuque/0/2021/png/12962324/1617257167963-81fb43a2-ece1-4db3-8079-013020ed0b77.png)

Möller Trumbore Algorithm 算法可以判断一个点是否在三角形内部。

![GAMES101 Lecture 13 - Möller Trumbore Algorithm](https://cdn.nlark.com/yuque/0/2021/png/12962324/1617257174848-5dc69262-34b0-47ff-998f-9fb7c9415d5f.png)


真实应用场景下的光线追踪面对的是一个复杂的环境，可能有多光源，多物体，有无数的运算需要处理，算法是
必然需要做优化。Axis aligned bounding box (AABB) 轴对齐边界盒就是一个常用的空间求交简化算法。 
AABB 基本思想是，用一个盒子的三对面，上下、左右、前后各面假设为无限延申的平面，盒子自身是它们的交集。
然后，物体包裹在这个盒子内部，根据光线与三对面的关系来判断是否真正相交：

- 显然，如果光线没有击中盒子，即没有同时穿过三对面，则不可能与物体相交；
- 光线与三对面都相交，则光线可能与物体相关；

并且 2D、3D 同样适用，只需要计算光线进入、穿透位置，光线进入、穿透一对面的位置记为 tmin 和 tmax，
那么，光线进入、穿透盒子的位置(时间)就为：

    tₗ = max(tmin)
    tₒ = min(tmax)

只要满足 tₗ < tₒ 即表示光线在盒子有停留，也就是同时穿透了三对面。如果 tₒ < 0 表示物体在光线后方，
即没有相交。如果，tₗ < 0 并且 tₒ >= 0，即表示光源位于盒子内部。

一般，tₗ < tₒ && tₒ >= 0 就认为光线与 AABB 相交。

AABB 本质上是一种空间分割技术，Uniform Spatial Partitions (Grids)，也是树状数据结构算法。
在图形学上，基于树状数据结构的算法可以带来非常大的性能的提升，相关算法比较如下：

- BSP-tree 二叉树在游戏工业算是老功臣，是早期技术，将空间二等分，比较麻烦，如对象平面相交时。
- Quad-tree、Oct-tree 四叉树/八叉树均匀切分三维空间，对象分布均匀时插入和查询效率较高，时间复杂度 O(logN)。
- KD-tree 是定制的二叉树，K-Dimensional tree，节点记录一个 k 维坐标点。
- Bounding Volume Hierarchy (BVH) 层次包围盒是多叉树。

![GAMES101 Lecture 14 - Acceleration & Radiometry](https://cdn.nlark.com/yuque/0/2021/png/12962324/1617257855961-cd607ec6-e167-4ad9-aa80-6cd5ace37720.png)

BSP Trees 全称二维空间分割树 Binary Space Partioning trees，使用二叉树的叶节点保存空间中的
图元集合，主要用于 Z-depth 排序，实现背面剔除。因为在 90 年代初受硬件限制，只能使用 BSP 对空间中
的图元进行排序，以保证渲染图元的顺序是按照由后至前进行的，换句话说，Z 值最小的物体总是最后被渲染。

四叉树/八叉树这类紧密空间分割算法有一个问题是，物体有可能在边界处来回，从而导致物体总是在切换节点，
使得数据结构中频繁做节点的增删操作，影响性能。而松散四叉树/八叉树正是解决这种边界问题的一种方式，
它定义节点有出入口边界，inner boundary vs. outerboundary，边界区域作为一个缓冲地带避免频繁操作，
就像施密特触发器 Schmitt Trigger 工作原理一样。

KD 树的每层都是对应一个划分维度，取决于使用者如何定义各层使用哪个维度。树的每个节点代表一个超平面，
该超平面垂直于当前层划分维度的坐标轴，并在该维度上将空间划分为两部分，一部分在其左子树，另一部分在
其右子树每次只沿某一个轴划分。

例如，以下为一个 2D 平面的 KD-tree，第一层划分维度为 X 轴，过节点坐标竖直分割；第二层为 Y 轴，
过节点坐标水平分割；第三层又为 X 轴，过节点坐标竖直分割。

![KD-tree](https://img2018.cnblogs.com/blog/1409576/201905/1409576-20190524233211006-2118364092.png)

但是，这些节点树使用叶节点来记录空间中的物体，都存在一个问题：多个区域的分割线可能与同一物体有交集，
这会导致同一个物体记录在不同的节点中。并且，KD-tree 还有更严重的问题，很难处理三角形和盒子求交。
而直接对物体进行划分的 BVH 则可以解决这样的问题，子节点存包围盒，根节点代表大包围盒，叶节点记录物体，
并约束一个物体只在一个包围盒内，包围盒可能相交，但问题不大，只要合理规划降低包围盒重合区。例如，沿长
轴方向划分，平均地划分三角形数量。

![Spatial vs. Object Partitions](https://cdn.nlark.com/yuque/0/2021/png/12962324/1617257912908-d9c99f26-76ad-4bd2-8e1d-6e5cd9d82750.png)


在研究物理光照规律之前，需要了解一下辐射度量学理论的一些基础：

- **Solid angle** 立体角，球面上的投影面积与半径的平方之比，类似圆有 2𝜋 弧度，球体有 4𝜋 立体弧度。
- **Radiant Intensity** 辐射强度是单位立体角的辐射通量，不随半径变化，因为单位立体角对应面积占比恒定。
- **Irradiance** 辐照度，单位面积接收到的辐射通量，称为该处的辐照度，会随着光源半径增加而衰减。
- **Radiance** 辐射，单位投影面积或者单位立体角上的辐射通量，图形学中主要关心它代表的光线传播方向。
- **Incident Radiance** 入射辐射，指到达表面的单位立体角的辐照度。
- **Exiting Radiance** 出射辐射，离开表面的单位投影面积的辐射强度。

![Radiosity Concepts](https://cdn.nlark.com/yuque/0/2021/png/12962324/1617258508714-099b7136-5b79-470a-b69e-c7cead25bdd5.png)
![Differential solid angle](https://cdn.nlark.com/yuque/0/2021/png/12962324/1617258521227-d45f943e-ea8f-47d4-bb34-519b530998b3.png)

在图形学中，关心的是光源发射的能量、受光体接受到的能量、光线传播方向：

- Radiant Intensity - Light Emitted From A Source
- Irradiance - Light Falling On A Surface
- Radiance - Light Traveling Along A Ray

![Light Source vs. Surface vs. Ray](https://cdn.nlark.com/yuque/0/2021/png/12962324/1617257932482-f621be8d-d5ce-4b61-a0be-40544395199a.png)

光源上强调的是辐射强度越强，释放出来的能量越大，相对就越亮，光源一般只考虑对外的辐射，即 radiance。
受光物体接受到的能量为入射光 irradiance，对外辐射为 radiances 也称亮度 luminance，相当光源。


为了寻找一种能够更准确地渲染更具漫反射特征的环境的技术，20世纪80年代中期，Don Greenberg 和他在
康奈尔大学的合作者设计了图像合成的辐射度方法 radiosity method，这就是 The Cornell Box 中遵循
的渲染原理，这个盒子经常在图形学文章中看到。

![The Cornell Box](http://www.graphics.cornell.edu/online/box/box.jpg)

光能传递的基本原理如下：

    radiosity = ∑(emissions + reflections + transmissions)

- 在一个封闭系统环境中研究光能量的平衡；
- 封闭环境是指这样的一个环境：从给定表面发射、反射的所有能量都被其他表面反射和吸收；
- 可以定义曲面光能传递值：能量离开曲面的速率。

光能传递计算有两个步骤：

首先，根据环境中每个曲面的 path 与所有其他曲面面片之间的能量交互量（形状因子）计算其曲面光能传递。
这是一个独立于视图的过程；虽然相当耗时，但每个场景只需要执行一次（前提是能量平衡不变）。

然后，渲染场景时考虑 a）可见曲面 b）插值着色 (flat or Gouraud)。这是依赖于视图的过程，移动相机
位置意味着需要重新计算图像，但这几乎可以足够快地实现实时渲染。当然，通过适当的技巧，光能传递可以以
每秒 15-20 帧的速度动态生成渲染图像，可作为漫游的基础。

与光线追踪一样，光能传递理论也研究许多问题领域，以及积极研究的领域：

- 使用各种混合方法，结合镜面反射、真反射和透射效果是可能的；不幸的是，这些方法依赖于视图。
- 必须在允许交互式调整照明参数的系统中重新计算光能传递解决方案，如剧院和照明设计，灯光颜色修改。
- 光能传递解决方案（以及生成的图像）的质量在很大程度上取决于曲面面片的定义方式（曲面细分），以及在关键区域（尤其是阴影）中如何重新定义曲面面片。
- 与光线跟踪一样，该技术的计算效率可以通过各种方式提高，特别是通过动态重新定义形状因子（渐进细化）。



### 🟠🔵 Subsurface Scattering 次表面散射
- Real-Time Rendering - CH9 Physically Based Shading
- [The Last of Us 2 Wallpapers](https://wallpapercave.com/tlou2-wallpapers)
- [角色渲染技术——皮肤 - 洛城](https://zhuanlan.zhihu.com/p/27014447)
- [Real-Time Rendering 3rd 第七章 · 高级着色：BRDF及相关技术](https://zhuanlan.zhihu.com/p/28059221)
- [GPU Gems 3 真实感皮肤渲染技术总结](https://zhuanlan.zhihu.com/p/42433792)
- [GPU Gems 3 - 14. Advanced Techniques for Realistic Real-Time Skin Rendering](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin)

半透明材质与次表面散射（Translucent and Subsurface Scattering）在生活中无处不在：树叶、纸、
蜡烛、牛奶、布料、皮肤、贝壳、玛瑙等。非金属物体几乎都存在 Subsurface Light Transport (SSLT)
次表面光传输现象，生物皮肤犹为明显。

![Grapes](https://www.creativeshrimp.com/wp-content/uploads/2015/03/grapes_04.jpg)

动物皮肤是一个多层结构，其表面油脂层主要贡献了皮肤光照的反射部分，约占入射光中的 6%。而油脂层下的
表皮层、真皮层则主要贡献了次表面散射部分，约占入射光中的 94%。任何没有直接从皮肤表面反射出去的光，
都会直接进入次表面层。这种占主要主导因素的次表面散射属性，决定了皮肤半透明的特征以及柔软的视觉外观。

![Figure 14-3 A Multilayer Skin Model](https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig03.jpg)
![Figure 14-4 Scattering and Absorption in Multiple Tissue Layers](https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems3/elementLinks/14fig04.jpg)

入射光与皮肤进行交互的过程中，被部分吸收（获取颜色）并经过多次散射，返回并从进入点周围的 3D 邻域处
表面离开。而有时光线会完全穿过像耳朵这样的薄薄区域，形成透射（Transmittance）。


Jensen 在 2001 年的论文 A Practical Model for Subsurface Light Transport 推导了许多
重要的物理公式，计算模型，渲染时的参数转换，以及测量了许多生活中常见材质的散射系数等等。

模拟半透明物体的方法有很多，例如：

- Volumetric Path Tracing
- Volumetric Photon Mapping
- Bidirectional Scattering Distribution Function (BSDF)
    - Bidirectional Reflectance Distribution Function (BRDF)
    - Bidirectional Transmittance Distribution Function (BTDF)
    - Bidirectional Surface Scattering Reflectance Distribution Function (BSSRDF)

![BSDF BRDF BTDF BSSRDF关系演示](https://pic2.zhimg.com/80/v2-715d6ac94c5775ad60a1570703d9921d_1440w.webp)

光线从一种介质射向另外一种介质时，可以根据光线行进路线分为两个部分：一部分光线在介质交界处发生了反射，
并未进入另外一种介质；另外一部分光线则进入了另一种介质，可能发展为次表面反射或折射。

反射光和入射光的辐射照度，radiance vs. irradiance，其比例是一个和入射角度、出射角度相关的函数，
这个函数就被称之为**双向反射分布函数** BRDF。而穿越介质部分的光照比例就称之为**双向透射分布函数** BTDF。
反射光与透射光总和，与入射光的辐射照度的比例就叫做**双向散射分布函数**，从能量守恒角度来说：

    BSDF = BRDF + BTDF

双向表面散射反射分布函数 BSSRDF 是目前的主流技术，简单来说，传统的 BRDF 模型是一种简化表达。两者
不同之处在于，BSSRDF 可以指定不同的光线入射位置和出射的位置。

- BRDF 模型中，一次反射光照的计算是在光线交点的法线半球上的球面积分。
- BSSRDF 模型中，每一次反射在物体表面上每一个位置都要做一次半球面积分，是一个嵌套积分。






### 🟠🔵 Environment & post-processing 环境与后期处理
- [Environment and post-processing](https://docs.godotengine.org/en/latest/tutorials/3d/environment_and_post_processing.html)
- [Environment and post-processing](https://www.bilibili.com/video/BV1Km4y1X765/)
- [Godot 4.0 gets SDF based real-time global illumination](https://godotengine.org/article/godot-40-gets-sdf-based-real-time-global-illumination)
- [Volumetric fog and fog volumes](https://docs.godotengine.org/en/latest/tutorials/3d/volumetric_fog.html)

Godot 3.x 重新设计提供了 Environment 资源，这是一个后期效果系统，每个场景中可以设置一个世界环境
节点用来加载一个环境配置资源，WorldEnvironment 在场景树中只能有一个，但可以加载不同的环境配置。

![project environment setting](https://docs.godotengine.org/en/3.5/_images/environment_default.png)

环境配置资源包括 sky, ambient lighting, tone mapping, effects, adjustments 等配置选项，
可以对现有的场景效果进行改头换脸般的后期处理。在一个工程中创建的环境配置资源本身不会起作用，除非将它
通过世界环境节点加载到场景树中。或者通过摄像机的环境属性中指定一个环境配置，这种设置可以覆盖世界环境。
可以通过工程设置，为工程指定一个默认环境配置，Project Settings -> Rendering -> Environment。


环境配置中，提供了以下多种属性以产生相应的后期效果，只挑选重点内容说明：

|       属性      |                        说明                       |
|-----------------|---------------------------------------------------|
| Background      | 背景色填充                                        |
| Ambient         | Light 环境光                                      |
| Fog             | 雾化效果                                          |
| Tonemap         | 色调映射                                          |
| Auto Exposure   | 自动曝光                                          |
| SS Reflections  | 屏幕空间反射光 Screen-Space Reflections (SSR)     |
| SSAO            | Screen-Space Ambient Occlusion 屏幕空间环境光遮蔽 |
| DOF Far Blur    | 基于深度场的远景模糊，Depth of Field (DoF)        |
| DOF Near Blun   | 基于深度场的近景模糊                              |
| Glow            | 辉光效果                                          |
| Adjustments     | 整体调整                                          |
|-----------------|---------------------------------------------------|
| Reflected Light | 反射光                                            |
| SSIL            | Screen-Space Indirect Light                       |
| SDFGI           | Signed Distance Fields Global Illumination        |
| Volumetric Fog  | 体积雾                                            |

其中，屏幕空间反射光及以下的选项都属于中后期效果处理，最后四种为 Godot 4.x 增加功能。

SDFGI 近似于动态实时光照贴图（dynamic real-time lightmap），但不需要展 UV 也不需要使用贴图。
开启 SDFGI 它会自动工作，并对静态物体生成全局光照。它不需要光线追踪，可以在绝大多数最新的 GPU 上
甚至几年前的中档廉价 CPU 上运行。SDFGI 的开发和测试使用 Geforce 1060，一直保持着 60fps 帧率。
SDFGI 也支持反射，无论是漫反射还是镜面反射，所以全 PBR 场景将不成问题。


🟡**Background** 即用来指定场景中空白区域的背景色，可以使用图像、颜色，或者程序化背景，会影响物体的
环境光与反射光，有多种模式：

- **Clear Color** 使用工程默认的清屏色填充背景，rendering/environment/default_clear_color。
- **Custom Color** 类似以上，但是由用户指定颜色。
- **Sky** 使用程序化背景，提供一个 PanoramaSky 360° 天空球，或者 ProceduralSky 梯度渐变太阳，
    提供了多种太阳选项设置。物体可以反射或吸收天空纹理的环境光，创建天空球时需要指定纹理。
- **Color+Sky** 可定义天空，但使用纯颜色填充背景，天空球仅作用为反射光和环境光。
- **Canvas** 画面模式可以配置 CanvasLayer 的渲染顺序使用。
- **Keep** 保持残影。
- **Camera feed** 

![Environment Background](https://docs.godotengine.org/zh_CN/stable/_images/environment_background1.png)

🟡**Ambient Light** 环境光，即几何体上每一块的光照强度都一样的光，与场景中具体的光源无关。

所谓环境光 ambient 即经过无数折射后在空间上呈现极度均匀的柔和光，无论从什么角度看，物体的环境光
都是一致的。所谓漫反射光 diffuse 即光线折射次数不是很多，并且对下一个物体的受光面有较大影响。

![Ambient](https://docs.godotengine.org/en/latest/_images/environment_ambient2.png)

环境光有两种，一是材质中的 Albedo 的环境光颜色 Ambient Color，以及从天空球获取到的环境背景色。

当背景设置为天空(Sky)时，使用天空贡献度(Sky Contribution) 属性，设置环境颜色(ambient color)
和天空色之间的混合比例，默认值为 1.0，因此只有天空色会影响对象。

最后，能量(Energy) 属性是一个乘数，在使用 HDR 时非常有用。场景中设置的光源与环境光对物体的影响是
一个混合过程，具体效果不仅取决于能量的级别大小，还决定于着色器的实现，默认着色器是一个颜色叠加关系。

一般来说，环境光只用于简单场景、大型外景，或出于性能原因，因为环境光运算量少，不能提供最佳的照明质量。
通过 ReflectionProbe 或 GIProbe 生成环境光是更好的方案，这样可以更真实地模拟间接光的传播方式。


🟡**Fog** 雾，这是模拟真实感的一个重要因素，就像在现实生活中一样，使远处的物体逐渐消失在均匀的背景
颜色中。物理效果实际上非常复杂, Godot 提供很好的近似效果，有两种雾：

- **Depth Fog** 深度雾基于距相机的距离来应用雾化效果。
- **Height Fog** 高度雾应用于任何高度位于 Height Min/Max 之间的物体，无论距离相机的距离如何。

![Depth Fog vs. Height Fog](https://docs.godotengine.org/en/3.5/_images/environment_fog_depth_height.png)

雾的本体颜色是改变雾化效果的直接因素，这两种雾类型都可以调整它们的曲线, 使它们的过渡或多或少变得清晰。

可以调整两个属性以使雾效果更有趣:

- **Sun Amount**，它利用 **Sun Color** 颜色，在视角朝向平行光的入射方向时，模拟穿过雾的阳光。
- **Transmit Enabled** 模拟更逼真的透光率，在实践中，它使光线在雾中更加突出。

🟡**Tonemap** 色调映射选项仅在 GLES3 适用。

色调映射选择应用于场景的色调映射曲线，选项为电影和游戏工业中所使用的标准曲线。除线性模式外，色调映射
运算可以使亮部和暗部更均匀，同时防止高亮区域受到裁剪。

**Mode** 色调映射使用以下模式：

- **Linear** 线性模式是默认值，是最快也是最简单的色调映射运算，会导致高亮区域过曝，有可见的裁剪。
- **Reinhardt** 颜色影射为 color = color / (1 + color)，可以防止裁剪高亮区域，但可能会有些暗淡。
- **Filmic** 防止裁剪高亮区域，最终的图像通常比前者鲜艳。
- **ACES** 学院色彩编码系统色调映射器，Academy Color Encoding System。已废弃，Godot 4.0 中移除。
- **ACES Fitted** 更耗算力，但对于高亮区域的处理方式更真实，光线越亮饱和度越低，输出的图像对比度更高。

色调映射曝光 **Exposure** 模拟长时间获取的光照量，默认值 1.0。值越高，整体更亮。修改色调映射运算子
或白点后，如果场景看上去太暗，请尝试将这个值略微调高。

光照映射白点 **White** 模拟白色在整个尺度中所处的位置，默认值 1.0。推荐值 [6.0, 8.0]，以使得
光照更真实。值越高，高光区域更少过曝，但会让场景整体看起来更暗。


🟡**Auto Exposure (HDR)** 自动曝光选项仅在 GLES3 适用。

尽管，大多数情况下艺术家会严格控制照明和纹理，出于真实性效果，通过自动曝光机制可以简单地支持高动态
范围实现，如低光户内区域和高光户外相结合时的画面。自动曝光模拟相机或眼睛，适应明暗位置和不同光量。

使用自动曝光的最简单方法是，确保室外灯光或其他强光的能量超过 1.0，通过调整灯光的 Energy 乘数实现。
为了使其保持一致，Sky 通常也需要使用能量乘数，以配合平行光。通常情况下，数值在 3.0 到 6.0 之间，
就足以模拟室内室外条件。

通过将自动曝光与 Glow 后处理相结合，超过色调映射 White 的像素将会逸出至辉光缓冲区，从而在摄影中
创造典型的泛光效果。

自动曝光部分中的用户可控值具有合理的默认值, 但仍然可以调整它们：

- **Scale** 用于比例缩放照明，较大的比例值会产生较亮的图像，较小的值会产生较暗的图像。
- **Min Luma** 自动曝光调整的最小亮度，亮度是屏幕所有像素中光线的平均值。
- **Max Luma** 自动曝光调整的最大亮度。
- **Spped** 亮度校正的速度，值越高，校正效果出现速度越快。


🟡**Glow** 辉光是指超饱和的高光对周围颜色产生的影响，在摄影和胶片中，当光量超过介质支持的最大值时，
无论是模拟还是数字技术，这些高光通常会向图像周围较暗区域渗出。

默认情况下，即使启用了效果，可能也会变弱或不可见。实际辉光发生需要两个条件之一：HDR 阈值和 Bloom。

像素中的光线超过 HDR 阈值，其中 0 表示所有光线都超过该阈值，1.0 表示光线超过色调映射器白值即溢出。
通常情况下，这个值应该在 1.0，但它可以调低以允许更多的光线渗入。还有，额外的参数 HDR Scale 允许
对超过阈值的光线进行缩放，使其更亮或更暗。

泛光效果 Bloom effect 值设置大于 0。随着它的增加，它会以更高的数量将整个屏幕发送到辉光处理器。

以上两者都会导致光从较亮的区域开始逸出，一旦看到辉光，就可以通过一些额外的参数来控制它：

- **Intensity** 强度是效果的整体比例，可以将其增强或减弱，0.0 可以将其删除。
- **Strength** 调整高斯滤波器内核的处理强度，数值越大，滤波器越饱和并向外扩展。一般来说，修改 Levels 更有效地调整大小。

效果的混合模式如下：

- **Additive** 添加是最强的一种，因为它只在图像上添加辉光效果，不涉及混合。一般来说，它太强了，不能使用，但在低强度的泛光下可能看起来很好，会产生一种梦幻般的效果。
- **Screen** 确保辉光永远不会比自己更亮，它作为一个周围的方式将非常好。
- **Softlight** 是默认的，也是最弱的一种，只在物体周围产生细微的颜色扰动，在黑暗场景中效果最好。
- **Replace** 用来模糊整个屏幕或调试辉光效果，它只显示辉光的效果，没有后面的图像。

辉光等级 Levels 提供了 7 个用于改变辉光效果的大小和形状配置，较小的级别在物体周围出现较强的辉光，
而大的级别是覆盖整个屏幕的朦胧辉光。然而，这个系统的真正优势在于结合 Levels 来创造更有趣的辉光模式。

最后，随着最高的图层在对微小模糊图像的拉伸中被创建，可能会看到一些块状模糊。启用 Bicubic Upscaling
可以以最低的性能成本处理这种问题，注意这只在 GLES3 中有效。

![Bicubic Upscaling](https://docs.godotengine.org/zh_CN/stable/_images/environment_glow_bicubic.png)


🟡**Screen-Space Reflections (SSR)** 屏幕空间反射只在 GLES3 中有效。

![SSR effect](https://docs.godotengine.org/zh_CN/stable/_images/environment_ssr.png)

Godot 支持三种反射数据源，Sky、ReflectionProbe、GIProbe，但它们可能无法为所有情况提供足够的细节。
SSR 最有意义的场景是物体彼此接触，例如地板上的物体、桌子上的物体、漂浮在水面上的物体呈现的倒影等。

SSR 另一个优点是实时工作，而其他类型的反射是预先计算，实时运算的反射光可以用来生成人物、汽车等移动
物体的实时反射光到周围的物体表面上。

以下是一些用户可以细调的参数：

- **Max Steps** 确定反射的长度，最小为 1，这个数字越大，计算成本就越高，效果也越精细。
- **Fade In** 调整淡入曲线，这有助于使接触区域更柔和。
- **Fade Out** 调整淡出曲线，因此步长限制会轻微淡出。
- **Depth Tolerance** 屏幕空间射线对间隙的容差，容差值越大，忽略的间隙就越大。
- **Roughness** 勾选时 SSR 会考虑材质的粗糙度以产生接近的 screen-space blur 效果。

请记住, 屏幕空间反射仅适用于反射不透明几何体，透明对象无法反射光线。因为它们不会写入深度缓冲区，这也
适用于使用 SCREEN_TEXTURE 或 DEPTH_TEXTURE 的着色器。


🟡**Screen-Space Ambient Occlusion (SSAO)** 屏幕空间环境光遮蔽只在 GLES3 中有效。

环境光部分提到，光源节点的光线无法到达的区域，要么是阴影或是在光源半径之外，这些区域会被环境光照亮。
Godot 可以使用 GIProbe, ReflectionProbe, Sky 或恒定的环境色来模拟环境光，但问题是，之前提出
的所有方法都更多地作用于较大的尺度或大区域，而不是较小的几何体层面。

恒定环境色和 Sky 在任何地方都是一样的，而 GI 和反射探针的局部细节较多，但不足以模拟光线无法填充到
中空或凹面特征内部的情况。

这可以用屏幕空间环境遮挡来模拟，它的目的是确保几何体凹陷区域更暗，模拟光线进入的较窄路径。

启用此效果，打开灯光却无法欣赏到相应的效果是一个常见的错误，这是因为 SSAO 仅作用于 Ambient light
环境光，而不是直接光。这就是在使用直射光的条件下，效果不太明显的原因。如果想强制 SSAO 也在直射光下工作，
请使用 Light Affect 光线影响参数，尽管并这不好，但有些设计师喜欢。

当与真正的间接光源结合时，SSAO 效果看起来最好，比如 GIProbe。

可以使用以下几个参数调整 SSAO：

- **Radius/Intensity** 控制遮挡的半径或强度，半径是世界(公制)单位，从视口开始计算距离。
- **Radius2/Intensity2** 辅助半径和强度，通常结合大半径和小半径 AO 效果很好。
- **Bias** 偏置调整可以解决自遮挡问题，但通常默认情况下效果不错。
- **Light Affect** 设置对直射光线的影响量，而不仅仅对环境光作用，有些艺术家喜欢这种效果。
- **Ao Channel Affect** 零值表示仅将材质的 AO 纹理用于环境光遮挡，SSAO 不应用。大于 0 的值会
    在不同程度上将 AO 纹理与 SSAO 效果相乘，对没有 AO 纹理的材质无效。
- **Quality** SSAO 将根据质量针对每个像素对球体进行更多采样，仅适用于现代 GPU。
- **Blur** 模糊采样核的大小，1x1 kernel 是最粗糙的，3x3 模糊最细致，更柔化图像，但不保留局部细节。
- **Edge Sharpness** 用于保持边缘的清晰度，避免折痕处没有 AO 的区域。



🟡**Adjustments** 是在处理结束时阶段的标准图像调整功能，包含：

- Brightness 亮度调整；
- Contrast 对比度调整；
- Saturation 饱和度调整；
- Color Correction 颜色校正；

第一个调整功能是能够改变典型的亮度、对比度和饱和度：

![Brightness Contrast Saturation](https://docs.godotengine.org/en/3.5/_images/environment_adjustments_bcs.png)

第二种是通过提供颜色校正梯度映射来改变色彩，但是常规黑色到白色渐变将不起作用，这种映射就是保持原色。
创建自定义 **GradientTexture** 允许将每个通道映射到不同的颜色，在映射纹理图中，从左往右对应原图的
黑色到白色的变化。使用常规黑色到白色渐变，只可以调整两者的位置来改变原图的亮暗关系。通过改变映射色彩，
就可以实现调整个原图的色彩关系，原图像的 RGB 映射到新的 RGB 通道上。



## 🟡 Chaos World 混沌世界
- [Fast Portable Noise Library](https://github.com/Auburn/FastNoiseLite)
- [Painting with Maths by Inigo Quilez](https://www.bilibili.com/video/BV1fU4y1273S/)
- [Raymarching distance fields - 2008 by Inigo Quilez](https://iquilezles.org/articles/raymarchingdf/)
- [Ray Marching and Signed Distance Functions](https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/)
- [The Book of Shaders by Patricio Gonzalez Vivo & Jen Lowe](https://thebookofshaders.com/11/?lan=ch)
- [Voronoi diagrams – inventor, method, applications](https://www.researchgate.net/publication/329444868_Voronoi_diagrams_-_inventor_method_applications)
- [Value noise derivatives - 2008](https://iquilezles.org/articles/morenoise/)
- [网格噪声（Cellular Noise）](https://thebookofshaders.com/12/?lan=ch)
- [Generating Noise for applications](https://learn.microsoft.com/en-us/archive/blogs/hemipteran/generating-noise-for-applications)
- [Voronoi Noise Worley and Chebyshev](https://catlikecoding.com/unity/tutorials/pseudorandom-noise/voronoi-noise/)
- [Simplex Noise, keeping it simple](https://catlikecoding.com/unity/tutorials/simplex-noise/)
- [Voronoi Noise](https://iquilezles.org/articles/voronoise/)
- [Voronoi edges - 2012 by Inigo Quilez](https://iquilezles.org/articles/voronoilines/)
- [Distance functions - by Inigo Quilez](https://iquilezles.org/articles/distfunctions/)
- [A GPU Approach to Voronoi Diagrams](https://nullprogram.com/blog/2014/06/01/)
- https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-8-pixel-displacement-mapping-distance-functions
- [Voronoi and Worley (cellular) noise - Godot Shaders](https://godotshaders.com/snippet/voronoi/)
- [Voronoi Texture 体积着色器造云](https://www.bilibili.com/video/BV167411s7tt)
- An Image Synthesizer. Ken Perlin (1985)
- Texturing and Modeling, Third Edition: A Procedural Approach. David S. Ebert, F. Kenton Musgrave, Darwyn Peachey, Ken Perlin, Steve Worley (2002)
- The Science of Fractal Images, Heinz-Otto Peitgen (1988)
- Matlab Documentation - Symbolic Math Toolbox - Mathematics: Equation solving, formula simplification, calculus, linear algebra, and more
- [Random number generation](https://docs.godotengine.org/en/stable/tutorials/math/random_number_generation.html)

计算机图形学其中一个问题是噪声，世界随处都可见的噪声看似杂乱无章，其实有迹可循。最简单的白噪声 White Noise
是一些毫无关联的像素构成，这些像素都是一个独立随机的点，自然办大量存在。而一些有规律的噪声，如细胞结构、树皮
纹理、水波等等。理解这些现象更恰的观念是混沌系统，混沌不等于随机，随机表示完全无法预测，而混沌则是整体有规律，
具体无法测。就细胞结构来说，整体上植物的细胞开状都像一个长方形盒子，这是可以预测的，但是具体每个细胞的大小分布
这些具体的数值是不能预测的。

在研究噪声问题之前，建议观看 Inigo Quilez 作品演示 Raymarching distance fields - 2008，
以及可以打开你天灵盖的《用数学绘画》 Painting with Maths 系列教学视频。

将噪声与傅里叶级数、分形、布朗运动等等数学工具组合，可以创造一切可能，而不仅仅是游戏地形景观。一些成功
的噪声研究为软件工业提供了大量可产品化的算法，包括但不仅限于以下这些：

- Open Simplex 噪声算法，Godot 将其封装在 **OpenSimplexNoise** 类型；
- Voronoi 算法，维诺图（Voronoi Diagram）多边形结构可以很好地模拟生物细胞的随机特征；

Ken Perlin 在噪声算法有巨大贡献，Perlin Noise 柏林噪声是 Ken Perlin 1983 年提出，用于制作
迪士尼的动画电影 TRON 《电子世界争霸战》中制作光效的算法。他不满足于当时计算机产生的那种非常不自然的
纹理效果，因此提出了 Perlin 噪声。Prelin 由于出色的工作，获得了奥斯卡科技成果奖。

单形噪声 Simplex Value Noise 是 Ken Perlin 创造了佩林噪声之后发明的另一种噪声模式。这种类型的
噪声使用核求和而不是插值，kernel summation instead of interpolation，并且基于单纯形网格而
不是超立方体晶格。


程序噪声 Pseudorandom Noise 的生成方法大致可以分为两类：

- 基于晶格的方法（Lattice based）
    - 一种是值噪声（Value noise），是承上启下的一种算法，是白噪声与 Perlin Noise 的中间阶段。
    - 另一种是梯度噪声（Gradient noise），包括 Perlin，Simplex，Wavelet 噪声等等；
- 基于点的方法（Point based） Worley 噪声即 Voronoi 算法，用于模糊处理的高斯噪声（Gauss noise）；

白噪声的不平滑不协调是它的最大问题，要得到平滑的过渡最简单的方式就是模糊，或者说在不同点之间进行插值，
Value nosie 的基本算法特点就是基于晶格方法，所谓晶格就是形状规则的格子。

Value noise 噪声的基本原理如下：

- 想要在晶格中进行插值计算，首先需要定义在各晶格顶点上的值；
- 然后，根据输入点在晶格内的位置，进行二次线性插值得到最后的噪声图；

虽然在两个值之间进行线性插值的确可以获得很平滑的过渡效果，但是到三个值，乃至更多值的时候，晶格交界处
的过渡太生硬了，问题就出来了。

Perlin Noise 则将晶格梯度化，晶格的四顶点先定义随机的一个向量值，各顶点到内部点的位置对应又有 4
个向量值。噪声取值则根据顶点向量与顶点到内部点的向量点积（dot product; scalar product）得到。

Perlin Noise 算法的时间复杂度是 O(2^n)，生成噪声维度越高，计算复杂性增长越快，同时，在实现算法时
对排列组合表 Permutation 的操作也越复杂，插值运算也越多，代码操作时难度也越来越大。正因如此，2001 年，
Ken Perlin 对算法进行了改进，希望凭借新的数学基础理论，单形(Simplex)理论，以解决高维度的噪声生成
的计算量问题，所以最后的噪声就叫作 Simplex Noise。


单形是线段、三角形、四面体直至任意维度符号的一种概述，是 N-space 的一种细分。简单说，N 维单形就是能
铺满 N 维空间的最简单图形。对１D 空间来说，单形就是等长的线段，线段首尾相连平铺整个１D 空间，而对于
２D 空间来说，能平铺整个空间的最简单图形是等边三角形，对 3D 空间来说，能平铺整个空间的最简单图形是
四面体，依此类推度。单形有一个特性，N 维空间的单形有 N+１ 个顶点，N! 个单形能组成 N 维空间的超晶格体。


Worley noise 也叫 Cellular noise，算法是 Steven Worley 在 1996 年的论文提出的，
A Cellular Texture Basis Function，在这篇论文里，他描述了这种现在被广泛使用的程序化纹理技术。
Voronoi（Cellular Noise）网格噪声算法实质上是这样一个问题：距离场计算问题。在 UV 网格上随机选
一个点 P，如何判断它处在哪个多边开区块内？

算法可以表述为：每个特征点向外扩张生长，直到它碰到其它扩张的区域。这反映了自然界的生长规则。生命的形态
是由内部扩张、生长的力量和限制性的外部力量共同决定的。模拟这种行为的算法以 Georgy Voronoi 命名。

![Monokot root (Georgy Voronoi algorithm)](https://thebookofshaders.com/12/monokot_root.jpg)

Voronoi 图需要对平面划分，根据平面上设置的特征点（Site）把平面分成若干区域，同一个区域中的所有点
到某一点的距离最近，这些区域称为单元（Cell），相邻单元之间的分界线成为边（Edge），相邻两个或多个条
边的交点称为顶点（Vertice）。Voronoi 边上的点到两个 Site 的距离相等并小于到其它 Site 的距离，
而其顶点到多个（≥3）Site 的距离相等并小于到其它 Site 的距离。

这里距离场的距离是指，到一个特征点集最近的点的距离。比如说要写一个 4 个特征点的距离场，对每一个像素，
计算它到最近的特征点的距离。最粗暴的办法就是遍历所有共 4 个特征点，计算出与到当前像素点的距离，并
记录下最近的那个距离，这些记录下来的数据就表示一个距离场 Distance field。距离场早期在医疗行业的
放射设备成像上有应用，在物理引擎中，也会采用有向距离场来处理问题 Signed Distance Field。

Inigo Quilez 还用来作画，完全使用代码画一只有血有肉的蜗牛，展示在 Raymarching distance fields - 2008。

Voronoi 图生成时，需要先生成随机顶点作为特征点，并根据特征点生成多边形进行分区。沿两顶点画出平分线，
这条线即多边形的一个边，然后根据多边形对分区内的点进行插件处理。生成特征点越多计算复杂度越大，随后
Steven Worley 对算法进行了多次优化。


通过将空间分割成网格，并不需要计算每一个像素点到每一个特征点的距离，使用得计算得以简化。并且 GPU 中
每个像素点都在自己的线程中运行，把空间分割成网格（cells），每个网格对应一个特征点。另外，为避免网格
交界区域的偏差，需要计算像素点到相邻网格中的特征点的距离。这就是 Steven Worley 在论文中的主要思想。
最后，每个像素点只需要计算到九个特征点的距离：他所在的网格的特征点和相邻的八个网格的特征点。

所以，改进后的 Voronoi 算法不仅基于点又基于晶格。

在 2011 年, Stefan Gustavson 优化了 Steven Worley 的算法，提出 2x2 Worley 噪声优化，仅仅
对一个 2x2 的矩阵作遍历（而不是 3x3 的矩阵）。这显著地减少了工作量，但是会在网格边缘制造人工痕迹。
事实上这个问题在3x3上也存在，只是不明显。

Inigo Quile 也在 Voronoi edges - 2012 中提供了一个边线查找算法，算法提供了正确的距离度量。

Voronoi 噪声求解的函数中，显示到最近单元格点的距离的函数被命名为 F1，显示到第二个最近点的距离的
函数被命名为 F2，依此类推。不必限制自己只使用 F1 或 F2，也有可以使用以某种方式组合它们的函数。
最有趣的变体是 F2-F1 Voronoi。


在游戏工业上利用现代 GPU 硬件编程，即编写着色器是实现噪声程序普遍做法。现在，通过浏览器就可以编写
着色器语言程序，Shadertoy 就是这样的工具，作者 Inigo Quilez 也是计算机图形领域的大牛。

开源免费的动画工具 Blender 也不错，使用 OSL（Open Shading Language）着色器语言。Godot 上使用
OpenGL GLSL 2/3 着色器语言编程，只需要给对象创建一个 ShaderMaterial 材质即可。编写着色器涉及
数学方面的知识比较多，同时要求更高的艺术审美能力，才能制作出高质量的作品。

GLSL 本身没有提供随机函数，除了早期版本提供一系列噪声函数 noise1 ~ noise4，在新的 OpenGL 4.4
已经弃用，所以返回值总是为 0。要实现伪随机数，可以用取巧的方法，Shadertoy 上提供了一个实现方法，
利用 fract 函数截取小数部分：


```js
float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}
```

参考 [Noise - value - 3D by Inigo Quilez](https://www.shadertoy.com/view/4sfGzS)


着色器中有一个用于平滑插值的 smoothstep 曲线公式 y = 3x^2 - 2x^3，它可以由二次方程混合得到，
这件事确实让开始接触着色器编程的我觉得，数学上的函数这个概念真的和计算机结合非常密切。

假设有两条二次方程曲线：

    C: f(x) = x^2
    D: f(x) = 1 - (x-1)^2

并且有两个用于混合以上曲线的函数：

    E: f(x) = x
    F: f(x) = 1 - x

它们分别是正例、反比例函数。那么 smoothstep 曲线公式就可以按 CF + DE 混合，在 [0,1] 区间上混合
得到两条曲线的平滑过度，使得插值始终可以将输入 x 映射到 [0,1] 这个标准化区间内，并实现两端的平滑。

```c
    // Hermite interpolate between ``edge0`` and ``edge1`` by ``x``.
    // vec_type smoothstep (vec_type edge0, vec_type edge1, vec_type x)
    // vec_type smoothstep (float edge0, float edge1, vec_type x)

    genFType t;
    t = clamp ((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
```

平滑插值结果返回 0.0 如果 x ≤ edge0，或者返回 1.0 if x ≥ edge1，当 edge0 < x < edge1，使用
smooth Hermite interpolation 将结果平滑在 [0, 1] 区间。注意，edge0 ≥ edge1 时，无定义。


Ken Perlin 对 Simplex Noise 算法的一个优化是将三次 Hermite 函数即 smoothstep() 函数替换
成了四次 Hermite 函数。使得函数曲线两端更“平”，所以噪声图每个格的边缘更加优雅地与另一个衔接。

    Cubic Hermite Curve： f(x) = 3x^2-2x^3
    Quartic Hermite Curve： f(x) = 6x^5-15x^4+10x^3

而这种数学工具的应用远不只是在算法的效率提升上的应用，程序化建模的基本工具也是数学。例如，球和圆有
什么本质差别呢，一个是 x^2 + y^2 = r^2，一个是 x^2 + y^2 + z^2 = r^2，当进行比例运算后，
就可以将一个圆变换为椭圆，将一个球变成一个饼状态，这是不是太有趣了。

而 Inigo Quilez 展示在 Raymarching distance fields - 2008 上的数学作画能力绝对可以开拓
你对于数学的原有认识，它就真的像上帝！

计算机不能有产生真正的随机数，只能通过算法生成伪随机数序列来模拟随机性质，pseudorandom number generators (PRNGs)。
Godot 提供全局的随机函数，以及 RandomNumberGenerator 类型，在使用 rand 或 randi 获取伪随机
数值时，需要先在 ready 中调用 randomize() 初始化方法，以产生不同的伪随机数序列： 

```py
var _fruits = ["apple", "orange", "pear", "banana"]

func _ready():
    randomize()

    for i in range(100):
        # Pick 100 fruits randomly.
        print(get_fruit())


func get_fruit():
    var random_fruit = _fruits[randi() % _fruits.size()]
    # Returns "apple", "orange", "pear", or "banana" every time the code runs.
    # We may get the same fruit multiple times in a row.
    return random_fruit

```


Godot 3.x 提供 OpenSimplexNoise 类型作为噪声生成器，Godot 4.x 则使用 FastNoiseLite 类型
生成 1D, 2D, 3D, 4D 的噪声：

```py
# Godot 3.x
var _noise = OpenSimplexNoise.new()

func _ready():
    randomize()
    # Configure the OpenSimplexNoise instance.
    _noise.seed = randi()
    _noise.octaves = 4
    _noise.period = 20.0
    _noise.persistence = 0.8

    for i in 100:
        # Prints a slowly-changing series of floating-point numbers
        # between -1.0 and 1.0.
        print(_noise.get_noise_1d(i))

# Godot 4.x
var _noise = FastNoiseLite.new()

func _ready():
    randomize()
    # Configure the FastNoiseLite instance.
    _noise.seed = randi()
    _noise.fractal_octaves = 4
    _noise.frequency = 1.0 / 20.0

    for i in 100:
        # Prints a slowly-changing series of floating-point numbers
        # between -1.0 and 1.0.
        print(_noise.get_noise_1d(i))
```


## 🟡 Shader Programming 着色器 - GPU 编程
- [GAMES101-现代计算机图形学入门-闫令琪](https://www.bilibili.com/video/BV1X7411F744/)
- [龚大的上帝视角看GPU教程](https://www.bilibili.com/video/BV1P44y1V7bu/)
- [Real-Time Rendering 3rd 渲染管线优化提炼总结](https://zhuanlan.zhihu.com/p/32928016)
- [Real-Time Rendering 3rd 渲染加速算法提炼总结](https://zhuanlan.zhihu.com/p/32300891)
- [The Book of Shaders by Patricio Gonzalez Vivo & Jen Lowe](https://thebookofshaders.com/?lan=ch)
- [OpenGL Wiki](https://www.khronos.org/opengl/wiki/Main_Page)
- [Real-Time Rendering, Fourth Edition](http://www.realtimerendering.com/)
- Computer Graphics: Principles and Practice 3rd Edition 2014
- Fundamentals of Computer Graphics 4/5th Edition
- OpenGL SuperBible: comprehensive tutorial and reference OpenGL 4.3 6th Edition
- OpenGL SuperBible: comprehensive tutorial and reference OpenGL 4.5 7th Edition
- OpenGL Programming Guide: The Official Guide to Learning OpenGL 4.3 8th Edition
- OpenGL Programming Guide: The Official Guide to Learning OpenGL 4.5 with SPIR-V 9th Edition
- GLSL Essentials: Enrich your 3D scenes with the power of GLSL! by Jacobo Rodríguez
- [OpenGL Reference Cards](https://www.khronos.org/developers/reference-cards/)
- [Vulkan® Learning](https://vulkan.org/learn)
- [Vulkan® API Tutoria](https://vulkan-tutorial.com/Introduction)
- [Spine 动画制作及 SFML Framework 入门](https://github.com/jimboyeah/spine-sfml-demo/)
- [Vulkan: the essentials - NVIDIA by Tristan Lorach, March 17th 2016](https://developer.download.nvidia.cn/gameworks/events/GDC2016/Vulkan_Essentials_GDC16_tlorach.pdf)
- [The OpenGL Shading Language](https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language)
- [Rendering Pipeline Overview - Vertex Specification](https://www.khronos.org/opengl/wiki/Vertex_Specification)
- [Leanr OpenGL - Hello Traiangle](https://learnopengl.com/Getting-started/Hello-Triangle)
- [Leanr OpenGL zh_CN](https://github.com/LearnOpenGL-CN/LearnOpenGL-CN/)

说到计算机图形学，就不得不说从 OpenGL 到 Vulkan 规范的演化过程，以及从 CPU 到 GPU 绘图方式的转变。

早期计算机图形学还没有大量应用，大多只是实验室研究，一般绘图能力也是通过 CPU 实现的。随着市场和技术发展，
计算机新增了 GPU 这个主角，在计算机构架上，GPU 可以和 CPU 共享或者使用独立的内存，即存在两种架构：
**耦合式架构**与*分离式架构*。分离式构架通过 PCI-e 等总线通讯，而共享构架则不需要经过外部总线传递数据。
分离式构架的缺点在于 PCI-e 相对于两者具有低带宽和高延迟，数据的传输成了其中的性能瓶颈。但是优点也明显，
就是一旦数据准备好，就不需要 CPU 再提供数据，GPU 内部更高效地执行绘图流程，被移 PC、动设备大量采用。

共享式构架共享内存和缓存，AMD 的 APU 采用的就是这种结构，目前主要使用在 PS4 等游戏主机中。


说到 OpenGL 就离不开 SGI（美国硅图公司）这家公司，OpenGL 起源于 SGI，在 1992 年 7 月发布 
OpenGL 1.0 成为工业标准。受控于 1992 年成立的独立财团 OpenGL Architecture Review Board (ARB)。
SGI 等 ARB 成员以投票方式产生标准，并制成规范文档(Specification)公布，各软硬件厂商据此开发自己
硬件系统上的实现。只有通过了 ARB 规范全部测试的实现才能称为 OpenGL 规范。

2006 年 08 月 10 日，Khronos 集团宣布获得 OpenGL 的控制权，发展扩张后，Apple、Dell、Google 
和 S3 Graphics 等公司都已成为了其会员。

科纳斯组织（Khronos Group）是一个由成员资助，专注于制定开放标准（Open standard）的行业协会，
重点制定免费的 API，使在各种平台和设备上创作或播放的多媒体可以得到硬件加速。

目前，OpenGL Graphic API 还在进化之中，但是出于性能与构架优化，以及 Metal、DirectX 等对手竞争需要，
新的接棒者 Vulkan GPU API 已经开始普及应用。这个新的规范将开放更多的 GPU 能力给开发者，一方面
硬件性能可以得到最大化的发掘，但另一方面，对开发者的技术要求也提升几个级别。

我接触 GPU 渲染管线是从 OpenGL 开始的，而有个金主爸爸的 DirectX 多媒体接口只有一个模糊的认识。
在图形接口规范中，确实是非常混乱的一个市场，像是一个军阀混战的年代。Open Graphics Library 整体
上还是比较接近图形学的基础概念，选择 OpenGL 的理由很简单：通用跨平台。

如果想要更深入 GPU 的开发，khronos 组织最新制定的图形接口标准 Vulkan® API 可以更精细的开发能力。
Vulkan 虽然给开发者提供了更多的自由度，如果这个开发者本身不自由(非大牛)，那用回 OpenGL 就很好。
原因就在于如果开发者对内存管理机制，对程序运行机制没有十足的理解，那就可能会误用 Vulkan 
导致运行效率甚至 OpenGL 运行效率更低，那这样就得不偿失。

与使用 OpenGL 状态机提供的固定状态和操作集相比，Vulkan API 为程序员提供了对绘图过程的更多控制，
并且以更灵活、更简单的方式。借助这一额外的灵活性，着色器可用于创建过于复杂（如果不是不可能的话）的效果，
用常规 OpenGL 函数无法描述这些效果：每像素照明、阴影等。现代显卡和新的 OpenGL Core Profile 
图形接口已经完全基于着色器，称为固定管道的固定状态和函数集已被弃用，将来可能会被删除。

毕竟 Vulkan 细杂体现在，要实现图形学的 Hello World 程序绘制三角形绘制需要上千行代码，这对于熟悉
OpenGL 程序的开发人员来讲是不可想象的，甚至比自己用 CPU 实现一套软光栅器更为复杂！同时难度也体现在
它的 API 复杂难懂，对于入门图形学的新手来讲并不是太简单。所以，无论 OpenGL 或者 Vulkan 规范，其目标
用户一般是图形学高级玩家、或游戏引擎开发团队。

学习 OpenGL 着色器编程要搞清楚几个概念，OpenGL API 是一个提供图形接口的规范，而硬件厂商负责实现
这套规范，应用开发者则按规范进行游戏或引擎之类软件的开发，三方互相独立又有联系。OpenGL 这套接口下，
提供的 GPU 编程语言是 The OpenGL Shading Language，简称为 GLSL。

目前，三大主流规范使用的 Shader 语言是：

- HLSL - Direct3D High Level Shader Language
- GLSL - OpenGL Shader Language 
- CGSL - Nvidia C for Graphic

着色器 Shaders 就是在 GPU 上运行的程序，也就是对 GPU 编程的代码片断，所谓片断是指这种程序一般很小，
可能最多就是上几百行代码。出于 OpenGL 通用性考虑，GLSL (OpenGL Shading Language) 语法上类似 C/C++。

在早期，OpenGL 和 GLSL 的版本发行并不一致，直到 OpenGL 2.0 开始，才对应发行一个版本号。但版本号
并不总是一致，直到 OpenGL 3.3 开始才一致，所以 Godot 使用的 GLSL 2/3 对应 OpenGL 1.2 和 3.3：

|    时间    |     版本     | GLSL |                    主要特性增加                    |
|------------|--------------|------|----------------------------------------------------|
| 1992/01    | OpenGL 1.0   | -    |                                                    |
| 1997/01    | OpenGL 1.1   | -    | Vertex arrays                                      |
| 1998/03/16 | OpenGL 1.2   | -    | Imaging subset (optional)                          |
| 1998/10/14 | OpenGL 1.2.1 | -    | Define ARB extensions concept                      |
| 2001/08/14 | OpenGL 1.3   | -    | Compressed texture format                          |
| 2002/07/24 | OpenGL 1.4   | -    | Automatic mipmap generation                        |
| 2003/07/29 | OpenGL 1.5   | -    | Buffer object                                      |
| 2004/09/07 | OpenGL 2.0   | 1.10 | OpenGL Shading Language 1.00                       |
| 2006/07/02 | OpenGL 2.1   | 1.20 |                                                    |
| 2008/08/11 | OpenGL 3.0   | 1.30 | Deprecation Model                                  |
| 2009/03/24 | OpenGL 3.1   | 1.40 |                                                    |
| 2009/08/03 | OpenGL 3.2   | 1.50 | Geometry shaders, in/out interface block           |
| 2010/03/11 | OpenGL 3.3   | 3.30 |                                                    |
| 2010/03/11 | OpenGL 4.0   | 4.00 | Tessellation Shader                                |
| 2010/07/26 | OpenGL 4.1   | 4.10 |                                                    |
| 2011/08/08 | OpenGL 4.2   | 4.20 |                                                    |
| 2012/08/06 | OpenGL 4.3   | 4.30 | Arbitrary Compute Shaders                          |
| 2013/07/23 | OpenGL 4.4   | 4.40 |                                                    |
| 2014       | OpenGL 4.5   | 4.50 |                                                    |
| 2017       | OpenGL 4.6   | 4.60 | The SPIR-V language can be used to define shaders. |

关键的版本有：

- OpenGL 2.0 引入着色器语言，支持顶点着色器、片段着色器；
- OpenGL 3.0 增加了“弃用”概念：Deprecation Model，在以后的版本中将某些功能标记为删除状态。
- OpenGL 3.1 基于现有的弃用模型，和后续将要实现的 Core Profile 重大修改，删除了大多数不推荐的功能。
- OpenGL 3.2 引入几何着色器；创建了两个上下文概念：Core Profile 和 Compatibility Profile。
- OpenGL 4.0 引入细分着色器；
- OpenGL 4.3 引入计算着色器；
- OpenGL 4.6 正式引入 SPIR-V 标准可移植中间层语言；

OpenGL 为了适应现代的 GPU 开发，使用 Core Profile 上下文配置，使开发者也可以使用一些更底层的功能。
2008 年 8 月 11 日发布的 OpenGL 3.0 这个版本代号叫做 Longs Peak，大量改变原有工作方式，根本性
改变 API 调用方式。从此开始分 *Core Profile* 和 *Compatibility Profile* 两种上下文工作方式，
并且 Khronos Group 希望只支持 Core Profile。但这个革新性的规范被许多厂商明确表示拒绝，他们并表示
会继续支持许多被划入 Compatibility Profile 的扩展，所以改为可选项。

OpenGL 3.0 的出现改变了过去 OpenGL 向后兼容的特性，在一定程度上简化了原有 API 的臃肿增加灵活度。
但是，没有采用向后兼容方式，所以原有的开发流程被打破，许多开发者是不能接受的。

Core Profile 只包含最新的 Shader 相关的函数，程序必须使用 Shader 编写。而兼容配置则可以兼容原
OpenGL 固定管线的功能，也可以使用 Core Profile 中的内容。

新版本 OpenGL 后的基本参考文档也变为三个，例如 OpenGL 3.3 相应的文档包括：

- OpenGL 规范文档：GLSLangSpec.3.30.pdf
- GLSL 核心模式规范文档：glspec33.core.pdf
- GLSL 兼容模式规范文档：glspec33.compatibility.pdf

另外，还引入了一个 Forward compatibility 模式，即向未来兼容，按 Deprecation 过时标记的函数都不可用。

无论这些 API 规范如何打架，着色器始终就是高效绘图的代名词，通过可编程着色器语言 Shader Language
在 GPU 中执行高效的图形渲染代码。官方提供的 OpenGL Wiki 文档是最佳入门材料，上面有关于 Rendering pipeline，
OpenGL Shading Language 的基本介绍。另外，Shadertoy 网站也是一个膜拜大神着色器案例的好去处。


根据 OpenGL 文档，OpenGL Render Pipeline 渲染管线的工序如下：

- Vertex Specification
    - Vertex Rendering
    - Primitive
- Vertex Processing
    - Vertex Shader
    - Tessellation
    - Geometry Shader
- Vertex Post-Processing
    - Transform Feedback
    - Clipping
- Primitive Assembly
    - Face Culling
- Rasterization
- Fragment Shader
- Per-Sample Processing
    - Scissor Test
    - Stencil Test
    - Depth Test
    - Blending
    - Logical Operation
    - Write Mask

片段着色器阶段也基本就是渲染管线的最后流程，经过最后的处理就得到了屏幕上输出的图形。

Mastering SFML game development by Pupius, Raimondas 书中提供了一张可编程渲染管线示意图，
很简明地表达了渲染管线各个工序的作用：

![Programmable pipeline - Mastering SFML game development by Pupius, Raimondas](https://github.com/jimboyeah/spine-sfml-demo/raw/master/images/Programmable%20pipeline%20-%20Mastering%20SFML%20game%20development%20by%20Pupius,%20Raimondas.jpg)

以下是根据 OpenGL Programming Guide 第 9 版本制作的 GPU 渲染流程图：

```sh
+========+      +========+      +==============+    +==============+
| Vertex |      | Vertex |      | Tessellation |    | Tessellation |
| Data   |  ->  | Shader |  ->  | Control      | -> | Evaluation   |
+========+      +========+      | Shader       |    | Shader       |
                                +==============+    +==============+
  +==========+                                                |
  | Culling  |      +===========+      +==========+           |
  |   and    |      | Primitive |      | Geometry |           |
  | Clipping |  <-  | Setup     |  <-  | Shader   |  <--------+
  +==========+      +===========+      +==========+
       |  
       V                              +=============+
+===============+    +==========+     | █▀▀░█░█░▀█▀ |
| Rasterization | -> | Fragment | ->  | █▀▀░▄▀▄░░█░ |
+===============+    | Shader   |     | ▀▀▀░▀░▀░░▀░ |
                     +==========+     +=============+

        Figure 1.2 OpenGL pipeline
```

这里，有几个关键的阶段，其中*顶点着色器*和**片段着色器**是必需外部提供的，引擎一般提供默认的实现。
GPU 绘画需要知道图形的结构，图形结构依赖顶点数据，而这些数据不能凭空产生，应用由开发都提供：

- ✒ 从顶点数据输入到 *Geometry Shader* 几何着色器为止，这部分是整个渲染流程的前端部分。
- ✒ 其次，是固定功能部分，Primitive Assembly, Clipping, Rasterization 等阶段就是将代表
     场景的图元转化为像素，会应用 Viewport Transformation 这类操作以将虚拟 3D 场景映射到 2D 的屏幕空间上。主要是光栅化，几何空间上的顶点通过投射变换，确定了对应屏幕光栅的位置，也就是几何
     图形空间的点与像素坐标的对应关系确立。
- ✒ 最后，是以 *Fragment Shader* 为分界的渲染后期阶段，这个阶段最重要的工作就是在将数据发送到
     帧缓冲区前确定像素的颜色。

片段着色器阶段对于开发者来说相当重要，开发者可以决定这些片元该着上什么样的颜色，这个阶段也被称为像素
着色器，尽管这种称谓不是太恰当。当几何体装配为图元并送入光栅化阶段，这里将计算出窗口中哪些像素受到了
几何体的影响。当 OpenGL 确定当前需要生成一个独立的片元时，它将执行片元着色器的内容，然后就进入逐片元
的一系列操作，经过几个处理阶段，判断片元是否可以作为像素绘制到帧缓存中，以及控制绘制的方式。只有进入 
frame buffer 后才意味着相应的图像像素即将要生成。

举例来说，如果片元超出了帧缓存的矩形区域，或者它与当前帧缓存中同位置的像素相比，距离视点更远，那么
正在处理的过程都会停止，片元也不会被绘制这些用户在屏幕上看不见的区域。而另一个阶段当中，片元的颜色会
与当前帧缓存中的像素颜色进行混合。逐片元操作（Per-Fragment Operations）对每个片元进行操作，将
它们的颜色以某种形式合并，得到最终在屏幕上像素显示的颜色，主要工作是片元测试（Test）与合并（Merge）。

片元进入到帧缓存之前需要经过完整测试过程，片元写入 frame buffer 时可以执行一些高度可配置的操作。
这些测试和操作大部分都可以通过 glEnable() 和 gIDisable() 来启用或停用。引擎也会通过界面提供相应
功能配置选项，比如 Depth Test、Depth Write 等配置选项。深度写入是判断该材质是否会剔除后面的像素，
只要开启 Depth Write 不管是否为透明物体，都会根据 Z 来遮挡后面的物体。

如果一个片元在某个测试过程中丢弃，那么之后所有的测试或者操作都不会再执行，这些测试和操作的顺序如下：

1）剪切测试（scissor test)将所有绘制操作都限制在剪切盒区域内。
2）多重采样的片元操作（multisampling）几何图元边缘平滑技术，也叫反走样 antialiasing。
3）模板测试（stencil test)模板值与模板缓冲区的模板值进行比较，比较通过，片元才被继续处理。
4）深度测试（depth test)片元的深度值（Z坐标分量）与缓冲区的深度值进行比较，以确定物体的遮挡关系。
5）融混（blending）即根据图像的 alpha 及混合方程进行透明物的混合。
6）抖动（dithering）通过对颜色较单调的图像进行抖动来提升颜色的分辨率，与报纸印刷时候的半调方法有点类似。
7）逻辑操作，片元的最后一个操作，包括 OR、XOR、INVERT，处理当前输入片元数据（源）以及当前颜色缓存中的数据（目标)。

使用多重采样技术 multi-sampling，可以在一个 framebuffer 上为每个像素保存多个 depth, stencil
或者颜色值。Depth buffer 中保存的值通常是 [0, 1] 范围的值，0 表示距离最近，1 表示距离最远。已经
渲染的位置，OpenGL 可以比较片段的窗口空间坐标与深度缓冲区中已经存在的值。如果该值小于已经存在的值，
则片段可见。这种测试的意义也可以改变，例如，可以要求 OpenGL 允许具有大于、等于，或不等于深度缓冲区
内容的 z 坐标分量的片段通过。深度测试的结果也会影响 OpenGL 对 stencil 缓冲区的操作。


图形应用一般会涉及大量的数据，比如，绘制一个带纹理图的正方体，纹理文件的大小决定了图形的精细度，为了
高质量，一张纹理可能就有几 MB，甚至几十 MB。正方体本身模型结构简单，可能只有 8 个顶点，但是在项目中
一般使用的模型都是极精细的，并且还需要从高度精细的模型制作出低精度的模型，以提升 GPU 工作效率，避免
因为模型面数极大导致 GPU 过负而不能达到要求的帧率。

另外，顶点数据不仅仅是坐标数据，除了位置坐标信息，顶点还可以有颜色、纹理贴图坐标等等。为了提高数据使用
效率，OpenGL 中使用以下数据对象，参考 Rendering Pipeline Overview - Vertex Specification：

- `VBO` - Vertex Buffer object 在显卡存储空间中开辟出的一块内存缓存区用来储存顶点数据，增加
        顶点进入 GPU 效率的方法。它们是可以存储在显存中的缓冲区，以最快的 GPU 速度去访问数据。
- `VAO` - Vertex Arrary Object 顶点数组对象，定义了 VBO 顶点属性信息，和着色器变量起连接作用。
        虽然，VBO 实现了数据缓存的目的，但每次绘制模型之前需要绑定顶点的所有信息，当数据量很大时，
        重复这样的动作变得非常麻烦。VAO 可以把这些所有的配置都存储在一个对象中，每次绘制模型时，
        只需要绑定这个 VAO 对象就可以了。 缓存顶点的方式，比起零散的顶点传输效率要高。另外，通过 VAO
        定义的顶点属性信息，可以按不同的方式来组织数据，比如 VBO 中的数据每隔几个字节是坐标、
- `EBO` - Element Buffer Object 索引缓冲对象，或者称 `IBO` - Index Buffer Object，
        用于索引顶点数组的数据，解决顶点重用问题，可以减少内存空间浪费，提高执行效率。例如，立方体
        只要存储 8 个顶点信息，通过索引对象引用不同的点就可以用三角形绘制出整个模型。如果，直接使用
        三角形的顶点来绘图，则立方体 6 个面至少需要 12 个三角形共 36 个顶点。而通过索引对象，
        当需要使用重复的顶点时，就使用位置索引来调用顶点坐标信息，而不需要重复记录顶点坐标。

根据官方 Vertex Specification 文档描述，VBO 本身存储的是顶点数据，而 VAO 本身存储的是状态信息，
即指明 VBO 中存储的数据是什么。OpenGL 执行绘制命令时，需要知道顶点信息包括位置、颜色、法线等等，它们
可以在哪里取得（Slot），怎么取得（offset，stride），这些都是 VAO 可以提供的数据。VAO 出现以前，
调用 Draw Command 绘制之前需要调用 glVertexAttribPointer(…) 函数设置这些信息，并且每一次调用
绘制命令都需要重新设置顶点状态信息。VAO 出现之后，顶点状态信息集中存储起来，在执行绘制命令前，调用
**glBindBuffer(GL_ARRAY_BUFFER, VBO)** 绑定 VAO 对象即可。

OpenGL 绘图流程在不使用 VAO 只使用 VBO 的情况下，需要调用 `glVertexAttribPointer()` 设置
顶点属性，属性内容包括；

```c
    glVertexAttribPointer(
       0,                  // attribute 0. No particular reason for 0, but must match the layout in the shader.
       3,                  // size
       GL_FLOAT,           // type
       GL_FALSE,           // normalized?
       0,                  // stride
       (void*)0            // array buffer offset
    );
```

- `index` 参数指定从索引 0 开始取数据，与顶点着色器中 layout(location=0) 对应。
- `size` 参数指定顶点属性大小为 3 字节。
- `type` 参数指定数据类型。
- `normalized` 参数定义是否希望标准化数据，只表示方向不表示大小。
- `stride` 参数是步长，指定在连续的顶点属性之间的间隔。上面传 0 和传 3 效果相同，如果传 1 取值方式为 012、123、234……
- `offset` 参数表示顶点数据在缓冲区起始位置的偏移，是一个 GLvoid 指针。


以下是摘自 Learn OpenGL 教程中的 VBO、VAO 用法演示代码，单纯 VBO 方式每次绘图都需要设置属性：

```c
// 0. copy our vertices array in a buffer for OpenGL to use
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 1. then set the vertex attributes pointers
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);  
// 2. use our shader program when we want to render an object
glUseProgram(shaderProgram);
// 3. now draw the object 
someOpenGLFunctionThatDrawsOurTriangle();   
```

使用 VAO 保存顶点属性数据的优点就是在后续的绘制中，不需要再次处理属性数据，只需要先绑定 VAO 对象：

```c
// ..:: Initialization code (done once (unless your object frequently changes)) :: ..
// 1. bind Vertex Array Object
glBindVertexArray(VAO);
// 2. copy our vertices array in a buffer for OpenGL to use
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. then set our vertex attributes pointers
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);  

  
[...]

// ..:: Drawing code (in render loop) :: ..
// 4. draw the object
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
someOpenGLFunctionThatDrawsOurTriangle();  
```

当然，使用 Godot 编写 GLSL 代码时，并不需要自己处理这些逻辑，引擎已经处理好了。并且 Godot 4.x
开始，已经支持 Vulkan API，而 Godot 3.x 对 OpenGL 的支持还会持续。

以下是 NVIDIA 在 2016 年游戏开发者大会 GDC（Game Developers Conference）上报告文档中提供的
OpenGL 和 Vulkan 的构架对比：

![Vulkan: the essentials - NVIDIA](https://github.com/jimboyeah/spine-sfml-demo/raw/master/images/vulkan_component.png)

从架构图对比上可以直观看到，原本 OpenGL 驱动层开发的内容被移到 Vulkna 应用层开发了。也就是说，
一方面开发 Vulkan 应用的难度增加了，因为需要处理原本硬件厂商需要做的工作。另一方面，功能更强大了，
因为驱动层的部分功能可以由应用层进行配置开发。


## 🟡 ShaderMaterial Programming 着色器材质编程
- [Matlab Help - Mathematical Functions](https://ww2.mathworks.cn/help/symbolic/mathematical-functions.html)
- [The OpenGL Shading Language](https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language)
- [The Book of Shaders by Patricio Gonzalez Vivo & Jen Lowe](https://thebookofshaders.com/?lan=ch)
- [Shaders Programming](https://docs.godotengine.org/en/3.5/tutorials/shaders/index.html)
- [Shading language](https://docs.godotengine.org/en/3.5/tutorials/shaders/shader_reference/shading_language.html)
- [Godot Shaders](https://docs.godotengine.org/en/3.5/tutorials/shaders/index.html)
- [Particle shaders](https://docs.godotengine.org/en/3.5/tutorials/shaders/shader_reference/particle_shader.html)
- [Converting GLSL to Godot shaders](https://docs.godotengine.org/en/3.5/tutorials/shaders/converting_glsl_to_godot_shaders.html)
- [Sprite Shaders](https://github.com/godotengine/godot-demo-projects/tree/master/2d/sprite_shaders)
- [Screen Space Shaders](https://github.com/godotengine/godot-demo-projects/tree/master/2d/screen_space_shaders)
- [2.5D Demo Project with GDScript](https://godotengine.github.io/godot-demo-projects/misc/2.5d/)
- [Voronoi and Worley (cellular) noise - Godot Shaders](https://godotshaders.com/snippet/voronoi/)
- [smoothstep desmos](http://www.desmos.com/calculator/309w4rkmpe)
- [双曲函数基础知识 by Coston](https://zhuanlan.zhihu.com/p/363616604)
- [可能是最好的讲解双曲函数的文章 - 王希](https://zhuanlan.zhihu.com/p/20042215)
- [Painting with Maths by Inigo Quilez](https://www.bilibili.com/video/BV1fU4y1273S/)
- [Raymarching distance fields - 2008 by Inigo Quilez](https://iquilezles.org/articles/raymarchingdf/)
- [Inigo Quilez - 2D distance functions](https://iquilezles.org/articles/distfunctions2d/)
- [Inigo Quilez - 3D distance functions](https://iquilezles.org/articles/distfunctions)
- [Ray Marching and Signed Distance Functions](https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/)
- [傅里叶级数、傅里叶变换与频谱 by Eugene Khutoryansky](https://www.bilibili.com/video/BV1sS4y1G7WF)
- [什么是傅立叶级数呢？-从热流到画圈圈 by 3Blue1Brown](https://www.bilibili.com/video/BV1vt411N7Ti)
- [But what is the Fourier Transform? A visual introduction by 3Blue1Brown](https://www.bilibili.com/video/BV1pW411J7s8)
- [An Interactive Guide To The Fourier Transform](https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/)
- [Pitch Shifting Using The Fourier Transform](http://blogs.zynaptiq.com/bernsee/pitch-shifting-using-the-ft/)
- [Fourier Transform: maps image into spatial frequency domain](https://homepages.inf.ed.ac.uk/rbf/HIPR2/fourier.htm)
- [Fourier transforms of images by Rachel Thomas](https://plus.maths.org/content/fourier-transforms-images)
- [How to Use Blender's New Ultimate Shader - Principled BSDF](https://www.bilibili.com/video/av27998058/)
- [Spatial Material](https://docs.godotengine.org/en/3.5/tutorials/3d/spatial_material.html)
- [Principled BSDF](https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/principled.html)
- [Physically Based Rendering: From Theory to Implementation, Third Edition](http://www.pbr-book.org/3ed-2018/contents.html)
- [基于物理的渲染（PBR）白皮书 - 毛星云](https://zhuanlan.zhihu.com/p/53086060)

虽然，这小节内容是讲材质与着色器编程，但本质上，是在讲数学的应用。编程只是使用数学工具的手段，作品效果
就是最终产品。这中间要经历的内容很多，根据不同数学基础的人自然有不同的理解或不理解，或者难以理解。到目前
为止，傅里叶级数及其应用是给我最大触动的数学工具，3Blue1Brown 制作的一个图形化傅里叶级数教学视频
以一种难以想象的直观手段，将极度抽象的数学工具，用形象的动画形式展示在观众面前。这真的太棒了，尽管，
数学的意义远不止如此，但通过动画形象地说明了数学在音乐、图像、电子、通信等等领域的共通性。

Godot 材质有三类，它们都可以使用节点编辑界面方式、或者使用着色器方式进行编辑，与 4 个资源类型关联：

- **spatial**     - for 3D rendering.
- **canvas_item** - for 2D rendering.
- **particles**   - for particle systems.

|   Resource Type    |              Note             |
|--------------------|-------------------------------|
| SpatialMaterial    | for 3D rendering.             |
| CanvasItemMaterial | for 2D rendering.             |
| ParticlesMaterial  | for particle systems.         |
| ShaderMaterial     | uses a custom Shader program. |

Spatial Material 材质基于物理的渲染 PBR - Physically Based Rendering 技术，自迪士尼在 
SIGGRAPH 2012 上提出了著名的迪士尼原则的 BRDF（Disney Principled BRDF）之后，由于其高度的
易用性以及方便的工作流，已经被电影和游戏业界广泛使用。

与其他软件兼容，如皮克斯的 Renderman® 和虚幻引擎®。SubstancePainter® 等软件绘制或烘焙的图像
纹理可以直接链接到此着色器中的相应参数。

Blender 动画软件中也基于 PBR 提供原理化 BSDF 着色器节点 Principled BSDF，是默认基本材质。
参考 Blender Guru 的教程 How to Use Blender's New Ultimate Shader - Principled BSDF。

基于 PBR 可以创建各种各样的材质，基础层为漫反射，金属度，次表面散射和透射。除此之外，还有镜面层，
光泽层和透明涂层。Godot 官方示范中 Material Testers 展示了这种着色器各参数间的相互影响所呈现的
真实图形效果。注意，Albedo 就是材质的基本色。

PBR 模型将物体按表面光的反射、折射与吸收等物理特性分成电介质 Dielectrics、金属物质 Metals，对
光学特性影响上考虑了 Fresnel 菲涅尔效应、 粗糙度、 金属性。

![Disney Principled BSDF](https://docs.blender.org/manual/en/latest/_images/render_shader-nodes_shader_principled_example-1a.jpg)

Fresnel 效应解析光波通过不同介质的分界面时发生反射和折射，入射光分为反射光 Reflection 和折射光
Refraction 两部分。浅入射角获得的反射光更多，比如看湖面反射的景物倒影，远处比近处的倒影清晰明亮，
还有看一颗金属球，球体的圆周更明亮。物体的粗糙度对光反射有很大的影响，但是 Fresnel 效应一直存在，
即使是没有镜面反射的木球也会表现出周边更亮。

电介质对光的反射、折射和金属只对光线反射的特性是明显的差别，一般 Metallic 金属度设置为 0 或 1 
对应电介质和金属两类材料，不使用中间值，基本没有非金属和金属材料模型之间的混合材料。数值为 1.0 时，
表示使用基础色着色的完全镜面反射 Specular，且不含有漫反射 Diffusion 或透射 Transmission，
透射是入射光经过折射穿过物体。而对于金属表层的异物，如锈斑 Rust 的处理，就等价为电介质的覆盖。 

衍射（Diffraction），又称绕射，是指波遇到障碍物时偏离原来直线传播的物理现象。

次表面散射 Subsurface Scattering 相关属性与光路的折射有关，对于金属材料是没有效果的，同样透射
Transmission 相关属性也对金属无效。对于不透明的材料 Transmission = 0，那么 IOR - Index of Refraction 
折射率就是无效属性。

光泽 Sheen 属性适合 Fabric 织物类无镜面反射的材质。

清漆 Clearcoat 适合物体表层的光泽，如用于汽车油漆等材质的模拟。

各向异性 Anisotropic 通常搭配 Tangent 切向用于丝线、条纹的梳理，如布料的线条光影、煎锅底部的圆圈条纹。

通过法向的控制来控制不同观察角度的光影效果是很基础且重要的技术，Normal 法向控制基础图层的法线方向，
Tangent 切向控制各向异性图层的法线方向。

总结一下金属材质的 5 大要素：

- Base Color 基础色
- Metallic 金属度
- Roughness 糙度
- Clearcoat 清漆
- Normal 法向

玻璃材质的 4 大要素：

- Base Color 基础色
- Transmission 透射
- IOR 折射率
- Specular 高光
- Roughness 糙度
- Clearcoat 清漆

光滑白陶瓷材质，设定固有色为白，然后降低粗糙度参数，配合次表面 SSS 增加材质的半透明，就像皮肤。


着色器程序使用 **ShaderMaterial** 资源对象包装，要用着色器编程实现各种材质，就需要创建着色器材质。
然后，给颜色器材质的 Shader 属性设置一个着色器程序即可。在编辑着色器代码时，Godot 会自动编译着色器，
就像 Shadertoy 一样，编辑代码的过程就可以看到输出效果。不过，注意一点，着色器的 Uniform 变量是可以
在属性探测器面板中修改的，并且修改后的值会保留，下次运行时自动传入着色器。这种情况下，修改着色器中的值
会被覆盖，可以将材质对象清理干净再重新设置着色器即可以解除保留的数据。

正如上小节所说，OpenGL 和 GLSL 的版本发行并不一致，直到 OpenGL 2.0 开始，才对应发行一个版本号。
但版本号直到 OpenGL 3.3 开始才一致，所以 Godot 使用的 GLSL 2/3 对应 OpenGL 1.2 和 3.3。
而学习 Godot 着色器编程最基本的三个参考材料就是官方的规范手册，还有快速参考卡：

- The OpenGL® Graphics System: A Specification (Version 3.3 (Core Profile) - March 11, 2010)
- The OpenGL® Graphics System: A Specification (Version 3.3 (Compatibility Profile) - March 11, 2010)
- The OpenGL® Shading Language Language Version: 3.30 Document Revision: 6 11-Mar-2010
- OpenGL 3.2 API Quick Reference Card

前面两个着重于 OpenGL 规范本身，如果不是做引擎开发，可以不看，而且有更新的 Vulkan 规范可用。
而 GLSL 着色器语言规范参考手册则是必需的，里面有大量函数、变量定义等信息。

    git clone --depth=1 git@github.com:KhronosGroup/OpenGL-Registry

Godot 是基于 OpenGL 开发的游戏引擎，Godot 4.x 已经支持 Vulkan，所以其着色器程序的编写需要符合
基本 GLSL 着色器语言规范，而在着色器程序代码组织上有些许差别。GLSL 源代码中，顶点着色器和片段着色器
代码都有 **main()** 函数作为入口，Godot 则将着色器程序 Vertex & Fragment 二者合二为一，在同
一个代码文件定义 **vertex()** 和 **fragment()** 两个函数对应，外加一个光照函数 **light()**。
这些处理器函数，Processor functions，的使用取决于着色器的类型，对于 spatial 和 canvas_item
来说，它们都可以使用，而对于粒子着色器来说，只能使用 **vertex()**。

Godot 着色器编程与标准 GLSL 编程还有一个差别，就是不同的着色器需要设置渲染模式，引擎需要这些设置，
渲染模式决定了如何配置 OpenGL，也决定了渲染输出效果。使用图形界面时，通过材质属性控制器面板就可以
修改需要的各种渲染模式。而使用色器程序时，默认渲染模式为 **blend_mix**，启用 Alpha 透明：

```c
shader_type spatial;
render_mode skip_vertex_transform;
// render_mode blend_mix  Mix blend mode (alpha is transparency), default.
// render_mode depth_draw_alpha_prepass, cull_disabled, world_vertex_coords;

void vertex() {
    VERTEX = (MODELVIEW_MATRIX * vec4(VERTEX, 1.0)).xyz;
    NORMAL = normalize((MODELVIEW_MATRIX * vec4(NORMAL, 0.0)).xyz);
    // same as above for binormal and tangent, if normal mapping is used
}
```

其中，因为 Sptial 涉及光照处理，可配置的渲染模式最多，不涉及光照的 canvas_item 其次，particle
粒子着色器渲染模式最少。因为，粒子着色器本身不绘图，是 vertext shader 的一种特殊形式，在对象绘制
前运行以计算材质属性，如 color, position, rotation 等等。然后，再传递给 CanvasItem 或 Spatial
等着色器使用。粒子着色器之所以可以获得属性数据输出，是因为使用了一个特殊的着色器：转换反馈着色器，
transform feedback shader，根据 OpenGL 4.6 规范手册的封面，可以看到这种着色器经顶点着色阶段，
到几何着色阶段，再反馈回数据。在片段着色器运行之前就得到了数据，后续的片段着色器就可以利用这些数据。

转换反馈着色器是 Shader Model 4.0 带来的一个新特性，与其他特性不同，它改变了 OpenGL 渲染管线。
Transform Feedback 在 DirectX 中被称为 Stream-Output Stage。Godot 引擎内部实现中，执行
着色器编译后，创建一个着色程序并附加着色器之前，即在调用 glLinkProgram() 链接程序之前，先执行 
glTransformFeedbackVaryings() 告诉 OpenGL 要捕获到一个缓冲区中的输出属性。

另外，每种着色器还配置了不同的预定义变量，具体参考官方文档：

- shader_reference/shading_language.rst
- shader_reference/spatial_shader.rst
- shader_reference/canvas_item_shader.rst
- shader_reference/particle_shader.rst
- shaders/compute_shaders.rst
- shaders/converting_glsl_to_godot_shaders.rst
- shaders/using_viewport_as_texture.rst

Godot 提供了 VisualShader 可视节点编程，通过 Expression node 节点也可以编写着色器代码。
不像 VisualScript，它已经被 Godot 4.x 丢弃，而着色器的可视化编程还在使用中。

CanvasItem shaders render modes

+---------------------------+----------------------------------------------------------------------+
| Render mode               | Description                                                          |
+===========================+======================================================================+
| **blend_mix**             | Mix blend mode (alpha is transparency), default.                     |
| **blend_add**             | Additive blend mode.                                                 |
| **blend_sub**             | Subtractive blend mode.                                              |
| **blend_mul**             | Multiplicative blend mode.                                           |
| **unshaded**              | Result is just albedo. No lighting/shading happens in material.      |
| **skip_vertex_transform** | VERTEX/NORMAL/etc need to be transformed manually in vertex function.|
| **blend_premul_alpha**    | Pre-multiplied alpha blend mode.                                     |
| **blend_disabled**        | Disable blending, values (including alpha) are written as-is.        |
| **light_only**            | Only draw on light pass.                                             |
+---------------------------+----------------------------------------------------------------------+

前面 6 种模式和 Spatial 着色器通用，后面 3 种只对 CanvasItem 着色器有效果。


Particle shaders render modes

+-----------------------+----------------------------------------+
| Render mode           | Description                            |
+=======================+========================================+
| **keep_data**         | Do not clear previous data on restart. |
| **disable_force**     | Disable attractor force.               |
| **disable_velocity**  | Ignore **VELOCITY** value.             |
+-----------------------+----------------------------------------+


### 🟠🔵 OSL 着色器编程
- [Open Shading Language](https://docs.blender.org/manual/en/latest/render/shader_nodes/osl.html)
- https://github.com/AcademySoftwareFoundation/OpenShadingLanguage/blob/master/src/doc/osl-languagespec.pdf
- [Real-Time Rendering 3rd 非真实感渲染(NPR)相关技术提炼总结](https://zhuanlan.zhihu.com/p/31194204)

开放式着色语言 OSL 是一种小型但丰富的着色器语言，用于高级渲染器和其他应用程序中的可编程着色，非常
适合描述材质、灯光、置换和图案生成。最初由 Sony Pictures Imageworks 开发，用于其内部渲染器，
用于故事片动画和视觉效果，作为开源发布，以便其他视觉效果、动画工作室和渲染软件供应商使用。现在，它是
VFX 和动画功能的事实上的标准着色语言，在许多商业和工作室专有渲染器中广泛使用。

Blender 中支持在 Cycles 渲染引擎中进行 OGL 着色器编程，但只能在 CPU 模式下运行着色器。在属性面板
选择 Cycles 渲染器，以及 CPU 模式，勾选 Open Shading Language 选项。

在着色器编辑器中，添加 Script 节点，并为脚本节点指定着色器文本。右侧有按键可以重新编译着色器程序，
编译成功后会显示其输入和输出参数相应端口。若着色器为材质，则直接与材质输出节点的 Surface 输入连接，
即 Surface 输入体积或纹理。

执行菜单 Window -> Toggle System Console 打开系统控制台可以查看编译着色器产生的错误信息。在
脚本编辑器中，选择 Templates - Open Shading Language 可以打开示范代码。

OSL 是个没有光照能力的不完全着色器，光照依靠渲染引擎完成，OSL 只提供光照需要的 PBR 等信息。而且，
OSL 目前是个软件着色器，只能在 CPU 上运行，所以换到 GPU 模式就没用了，是个很鸡肋的功能。OSL 对于
3dmax 来说，意义还很大，因为 3dmax 传统 shader 的封闭性很难开发，OSL 完美的解决了这个问题。 

以下代码创建简单的卡通着色效果，会创建三个颜色输入，和一个光线入射方向：

```c
#include "stdosl.h"

// OLS Toon Shading
shader BaseToon(
    color Albedo = color(1, 1, 1),
    color LightColor = color(1, 1, 1),
    color ShadowColor = color(0, 0, 0),
    vector LightDirection = vector(0, 0, 0),
    output color Final = 0
)
{
    // get light direction use toon kit object info node 
    // or use vector node dirver.
    vector L = LightDirection;
    
    // lambert NdotL
    float NdotL = dot(N, L);
    
    // use round
    float Cel = round(NdotL);
    
    // mix shadow and light color
    color celShading = mix(ShadowColor, LightColor, Cel);
    
    Final = Albedo * celShading;
}
```



### 🟠🔵 from GLSL to Godot

由于 Shadertoy 这个基于 Web 开发的着色器程序编写、分享平台实在是好用，还有 The Book of Shaders
站点，所以在 Godot 实现着色器可以考虑它们的一些习惯的变量用法。只需要很小的代码变化，就可以从 GLSL 
编程转换到 Godot shaders 编程。

GLSL 内建的常用变量与等价 Godot 变量对照表如下，Variable 中为原变量名，Equivalent 为 Godot
中的等价定义。它们都不是用来向 GLSL 传递数据的 Uniform 变量，所以不能在主程序中编辑：

+----------------+---------+---------------+-----------------------------------------------------+
|Variable        |Type     |Equivalent     |Description                                          |
+================+=========+===============+=====================================================+
|gl_FragColor    |out vec4 |COLOR          |Output color for each pixel.                         |
|gl_FragCoord    |vec4     |FRAGCOORD      |For full screen quads. For smaller quads, use UV.    |
|gl_Position     |vec4     |VERTEX         |Position of Vertex, output from Vertex Shader.       |
|gl_PointSize    |float    |POINT_SIZE     |Size of Point primitive.                             |
|gl_PointCoord   |vec2     |POINT_COORD    |Position on point when drawing Point primitives.     |
|gl_FrontFacing  |bool     |FRONT_FACING   |True if front face of primitive.                     |
+----------------+---------+---------------+-----------------------------------------------------+

注意，`Uniform` 是从 CPU 向 GPU 中的着色器发送数据的一种方式，它定义的变量是全局的 Global，
意味着 uniform 变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器
在任意阶段访问。其次，无论 uniform 设置成什么值，都会一直保存着它们的数据，直到它们被重置或更新。
要向着色器传递数据，就需要使用 Uniform 变量，并通过 **set_shader_param()** 设置数据，Godot
引擎内部会调用 OpenGL API，例如用 `glGetUniformLocation` 查询，调用 `glUniform4f` 设置。
参考 Godot 3.x 源代码的 ShaderGLES2 或 ShaderGLES3 的实现。

Godot 着色器中还有些特殊的变量，用于访问屏幕图像的 **SCREEN_TEXTURE**，以及存储 3D 场景深度
信息的 **DEPTH_TEXTURE**，使用当前片段着色器中的 **SCREEN_UV** 坐标获取对应的像素颜色值，这
是一个 RGB 颜色值。更多的自定义符号，可以参考源代码 GLES3 驱动模块的 **ShaderCompilerGLES3**
类型中定义的映射关系。

```c
shader_type canvas_item;

// GLSL: you can assign a default value to uniforms
uniform float blue = 1.0; 

void fragment() {
    COLOR = textureLod(SCREEN_TEXTURE, SCREEN_UV, 0.0);
    COLOR.b = blue;
}

// GDScript:
// var blue_value = 1.0
// material.set_shader_param("blue", blue_value)
```

Godot 着色器编程也提供了 GDScript 中使用属性提示辅助功能，在着色器定义变量时，可以设置属性提示，
以方便使用者或开发者在面板中随时了解属性的取值。例如，hint_range 提示取值范围，hint_albedo 提示
纹理输入：

```c
shader_type spatial;

uniform vec4 color : source_color;
uniform float amount : hint_range(0, 1);
uniform vec4 other_color : source_color = vec4(1.0);
```

+----------------------+------------------------------------------------+-----------------------------------------------------------------------------+
| Type                 | Hint                                           | Description                                                                 |
+======================+================================================+=============================================================================+
| **vec3, vec4**       | source_color                                   | Used as color.                                                              |
| **int, float**       | hint_range(min, max[, step])                   | Restricted to values in a range (with min/max/step).                        |
| **sampler2D**        | source_color                                   | Used as albedo color.                                                       |
| **sampler2D**        | hint_normal                                    | Used as normalmap.                                                          |
| **sampler2D**        | hint_default_white                             | As value or albedo color, default to opaque white.                          |
| **sampler2D**        | hint_default_black                             | As value or albedo color, default to opaque black.                          |
| **sampler2D**        | hint_default_transparent                       | As value or albedo color, default to transparent black.                     |
| **sampler2D**        | hint_anisotropy                                | As flowmap, default to right.                                               |
| **sampler2D**        |`hint_roughness[_r, _g, _b, _a, _normal, _gray]`| Used for roughness limiter on import (attempts reducing specular aliasing). |
| **sampler2D**        |`filter[_nearest, _linear][_mipmap][_aniso]`    | Enabled specified texture filtering.                                        |
| **sampler2D**        |`repeat[_enable, _disable]`                     | Enabled texture repeating.                                                  |
+----------------------+------------------------------------------------+-----------------------------------------------------------------------------+


Godot 4.x 开始使用 Vulkan，着色器加载流程完全不同，VkShaderModule 是着色器的组织模块对象，
加载流程还会使用到 VkPipelineShaderStageCreateInfo 一类对象。并且，Vulkan 引入了一种中间
代码语言 SPIR-V 来处理着色器，加载的着色器是字节码。

```py
# Load GLSL shader
var shader_file := load("res://compute_example.glsl")
var shader_spirv: RDShaderSPIRV = shader_file.get_spirv()
var shader := rd.shader_create_from_spirv(shader_spirv)
```

为了使编写片段着色器简单明了，Shadertoy 会处理从主程序向片段着色器传递大量有用信息：

- iChannelTime[4] 对应 Shadertoy 提供的四个外部媒体播放时间信息；
- iChannelResolution[4] 对应 Shadertoy 四个外部媒体分辨率；
- iChanneli 对应 Shadertoy 四个外部媒体当前的图像纹理，i 值为 [0, 3]；
- iMouse 对应浏览器中获取到的鼠标落在 Canvas 像素位置信息；

Godot 默认只当前节点纹理传入着色器，**CanvasItem** 类型对象可以使用 2D 材质，可以设置一个纹理。

其中有一些在 Godot 中没有等价表达，因此 Godot 选择了默认情况下不提供它们，为了方便用户在 Godot 
中按同样方式处理它们，下面这张表给出 Shadertoy 这些变量 定义与 GLSL 的等价关系。以下变量标明为 
“Provide with Uniform”，表示用户负责自己创建 uniform 从外部传递数据到着色器程序。

+---------------------+---------+------------------------+-----------------------------------------------------+
|Variable             |Type     |Equivalent              |Description                                          |
+=====================+=========+========================+=====================================================+
|fragColor            |out vec4 |COLOR                   |Output color for each pixel.                         |
|fragCoord            |vec2     |FRAGCOORD.xy            |For full screen quads. For smaller quads, use UV.    |
|iResolution          |vec3     |1.0 / SCREEN_PIXEL_SIZE |Can also pass in manually.                           |
|iTime                |float    |TIME                    |Time since shader started.                           |
|iTimeDelta           |float    |Provide with Uniform    |Time to render previous frame.                       |
|iFrame               |float    |Provide with Uniform    |Frame number.                                        |
|iChannelTime[4]      |float    |Provide with Uniform    |Time since that particular texture started.          |
|iMouse               |vec4     |Provide with Uniform    |Mouse position in pixel coordinates.                 |
|iDate                |vec4     |Provide with Uniform    |Current date, expressed in seconds.                  |
|iChannelResolution[4]|vec3     |1.0 / TEXTURE_PIXEL_SIZE|Resolution of particular texture.                    |
|iChanneli            |Sampler2D|TEXTURE                 |Godot provides only one built-in; user can make more.|
+---------------------+---------+------------------------+-----------------------------------------------------+

The Book of Shaders 中使用的着色器程序几乎是严格按 GLSL 编写的，只实现少量 uniforms 变量：

+---------------------+---------+------------------------+-----------------------------------------------------+
|Variable             |Type     |Equivalent              |Description                                          |
+=====================+=========+========================+=====================================================+
|gl_FragColor         |out vec4 |COLOR                   |Output color for each pixel.                         |
|gl_FragCoord         |vec4     |FRAGCOORD               |For full screen quads. For smaller quads, use UV.    |
|u_resolution         |vec2     |1.0 / SCREEN_PIXEL_SIZE |Can also pass in manually.                           |
|u_time               |float    |TIME                    |Time since shader started.                           |
|u_mouse              |vec2     |Provide with Uniform    |Mouse position in pixel coordinates.                 |
+---------------------+---------+------------------------+-----------------------------------------------------+


OpenGL 使用的坐标是笛卡尔坐标系统，即屏幕向右、向上分别为 X、Y 轴正方向 ，顶点的值直接反映在屏幕。

始终需要明确的一点是 OpenGL 世界坐标系是`右手坐标系` right-hand system ，在二维屏幕上，屏幕
水平方向是 X 轴方向，向右为正，屏幕竖起方向是 Y 轴方向，向上为正，垂直于屏幕的方向是 Z 轴方向，
从屏幕里往外为正。即右手中指向自己表示 Z 轴、食指竖起向上表示 Y 轴、母指向右表示 X 轴。即使手腕怎么
转动，右手系统这种轴向关系是主要的参考。下图中，Camera 成像的角度就如眼睛看屏的幕图像一样：

Perspective Projection vs. orthographic Projection:

![https://stackoverflow.com/questions/36573283/from-perspective-picture-to-orthographic-picture](https://github.com/jimboyeah/spine-sfml-demo/raw/master/images/From_perspective_picture_to_orthographic_picture.png)

第一个着色器，在编写代码前，需要了解以下函数及内置变量：

- gl_Position 顶点着色器输出的顶点坐标，这是顶点着色器输出的最主要的数据。
- gl_FragColor 片段着色器输出的颜色，经过顶点着色器处理后的纹理、顶点等数据会进入片段着色器继续处理。
- texture() 函数用来读取纹理输入，GLSL 内置函数，纹理则 Godot 引擎输入，给 Node2D 设置纹理图即可。

```c
// Perform a texture read. 
gvec4_type texture (gsampler2D s, vec2 p [, float bias])
```

GLSL 的函数多数都有重载，参数可以是 1D、2D、3D、4D 的形式。纹理读取函数会使用纹理坐标 P 在当前绑定
到采样器的纹理中进行纹理查找 texture lookup。GLSL 中的纹理相关函数会根据 OpenGL API 设置的
纹理组合采样器，texture-combined samplers，对纹理进行访问。纹理属性，如大小、像素格式、维度数、
过滤方法、mipmap 级别数、深度比较等，也由 OpenGL API 调用定义，这些信息都会影响 GLSL 纹理函数。
Sampler 通常是在片元着色器内定义的，这是一个 uniform 类型变量，即处理不同的片元时这个变量不变。
一个 sampler 对应一个 texture，类型也是对应的，比如 sampler2D 采样器就对应 GL_TEXTURE_2D 
类型的纹理对象。

例如，绘制一个三角形，只要传递三个纹理坐标给顶点着色器，片元着色器会为每个像素生成纹理坐标的插值，
根据纹理坐标就得到了每一个像素的颜色值。Godot 使用 **draw_circle()** 方法在 Node2D 绘图，
由于只有一个坐标，对应的 UV 为 (0.0, 0.0)，尽管圆周是多条线段绘制模拟出圆形，但顶点却只有一个。
而像 **draw_polygon()** 这样的方法则需要指定，因为它需要指定多个顶点。

纹理坐标通常的范围是从(0, 0)到(1, 1)，当纹理坐标设置为范围以外，OpenGL 默认的行为是折回重复这个
纹理图像，Texture Wrapping，即忽略纹理坐标浮点值的整数部分，即小数部分，OpenGL 还有其它选择，
具体参考规范手册。

以下是一个 Node2D 节点的扩展类，可以绘制圆形、矩形及背景纹理填充，可以作为 Sprite 使用，并且可以
设置着色器材质进行着色器编程：

```py
tool
extends Node2D

class_name Circle
signal circle_hit(event)

export(Color, RGBA) var color = Color(.2,.2,.2,.5) setget _set_color
export(float, 0, 100, .1) var radius = 20.0 setget _set_radius
export(float) var detectionRadius = 20.0 setget _set_detectionRadius
export(bool) var rectangular = false setget _set_rectangular
export(Texture) var texture setget _set_texture

func _set_color(value):
    color = value
    update()

func _set_radius(value):
    radius = value
    update()

func _set_detectionRadius(value):
    detectionRadius = value
    update()

func _set_rectangular(value):
    rectangular = value
    update()

func _set_texture(value):
    texture = value
    update()


func _draw():
    var w = 1.4142135623730 * radius
    if rectangular:
        draw_rect(Rect2(-Vector2.ONE*w/2, Vector2(w, w)), color)
    else:
        draw_circle(Vector2.ZERO, radius, color)
    if texture:
        draw_texture_rect(texture, Rect2(Vector2.ONE*w/-2, Vector2(w, w)), false)

func _input(event):
    if event.is_pressed() and event is InputEventMouseButton:
        var mouse = event as InputEventMouseButton
        var distance = self.position.distance_to(event.position)
        var sd = self.position.distance_squared_to(event.position)
        if distance > detectionRadius:
            return
        print("detection distance %s - %s" % [distance, sd])
        emit_signal("circle_hit", mouse)
```

数学在着色器是最基础也是最重要的工具，所有算法都离不开基础的函数，而其中又以线性代数的向量、变换矩阵
等内容为主，三角函数也是最为常用的函数，以下是三角其中三个的曲线，在着色器中绘图、变换数值等等操作
经常使用到，熟悉它们非常必要。Matlab 提供的符号数学工具箱文档是不错的参考材料：

[Symbolic Math Toolbox](https://ww2.mathworks.cn/help/symbolic/)

| Cosine Plot | Sine | Arctangent |
|-------------|------|------------|
| ![Cosine Plot](https://ww2.mathworks.cn/help/examples/symbolic/win64/CosPlotTheCosineFunctionExample_01.png) | ![Sine Plot](https://ww2.mathworks.cn/help/examples/symbolic/win64/SinPlotTheSineFunctionExample_01.png) | ![ArcTangent Plot](https://ww2.mathworks.cn/help/examples/symbolic/win64/AtanPlotTheInverseTangentFunction1Example_01.png)

- Sine 和 Cosine 的值域都是 [-1, 1]，周期都是 2π。
- Sine 在 -π/2 到 π/2 区间是递增，而 Cosine 在 -π 到 0 区间是递增。
- atan 反正切函数，即正切函数的反函数，inverse tangent (arctangent)，值域为 [-π/2, π/2]。

Tangent 正切函数是根据角度 α 求解对边与邻边的比值，而反向三角函数则反过来根据比值求角度，如下图所示。

    sin(α) = opposite side / hypotenuse    = a / h
    cos(α) = adjacent side / hypotenuse    = a / h
    tan(α) = opposite side / adjacent side = a / b

![Trigonometric Functions](https://ww2.mathworks.cn/help/symbolic/definition_sine.png)

反正切函数是递增函数，并且在两边呈现平滑的变化，这个特性可以用在平滑过渡上。

- For real values of Z, atan(Z) returns values in the interval [-pi/2, pi/2].
- For complex values of Z, atan(Z) returns complex values with the real parts in the interval [-pi/2, pi/2].


颜色使用 RGBA 四分量结构，使用 vec4 四维向量表示，着色中创建向量非常便利，例如，以下两个色彩图案
相应的代码，第一条使用字面常量设置图案为统一的色值。第二条使用 UV 坐标作为颜色的 RG 前两个分量，
Blue 蓝色分量为 0.5，Alpha 分量为 1.0 不透明状态，所以第二图左上角应该是淡蓝，到右下角蓝色相对
变弱，以红绿混合色为主，显示为偏黄色。而右上角以红色为主，搭配半分蓝，显示为紫色，而左下角以绿为主，
搭配蓝色后，显示青绿色。因为绿色比较显眼，人类眼睛的绿色感光器即视锥细胞较多，所以绿色较显著 ：

![Blue Box](https://docs.godotengine.org/en/3.5/_images/blue-box.png)
![UV Box](https://docs.godotengine.org/en/3.5/_images/UV.png)

```c
void fragment() {
    COLOR = vec4(0.4, 0.6, 0.9, 1.0);
    COLOR = vec4(UV, 0.5, 1.0);
}
```

向量提供了各种分量的访问，并且可以按坐标形式、或颜色分量的形式访问，如 COLOR.rgb 等价 COLOR.xyz，
但最好按语议使用。颜色各分量值会通过 clamp 函数约束在 [0.0, 1.0] 范围，超出的值会被固定转换到正常
区间，负值截断变成 0.0，正数则不超过 1.0。

对于 Alpha 分量，则特殊点，根据图像数据无符号数、有符号数格式差别，Alpha 对应归一化为两种区间表达
[0,1] 或者 [−1,1]。但 Alpha 值超出这个范围时，并不会你 RGB 分量一样被 clamp 约束在正常值区间，
在 OpenGL 对纹理进行混合处理时，Alph 值就会按混合方程式进行处理。

Godot 在绘制透明图像时，透明会区也会一并处理，这对于大尺寸的图像来说并不是很好的做法，通过转换带
透明纹理的 Sprite 为 MeshInatance2D，可以路过大量透明区的渲染。例如，以下这棵带透明区的树，
在场景中选中 Sprite，在视图中的工具栏执行 "Convert to 2D Mesh" 即可以进行转换，另一种生成 2D 
网格的方法是通过 OBJ 导入。

![2D meshes - Sprite to Mesh](https://docs.godotengine.org/en/3.5/_images/mesh2d1.png)


在 Godot 默认着色器混合模式下，负值的 Alpha 影响最终混合结果，如下两组的颜色，分别是等效的：

    COLOR = vec4(1.0, 1.0, 0.0, -1.0); // blue
    COLOR = vec4(0.0, 0.0, 0.72, 1.0); // blue

    COLOR = vec4(0.0, 1.0, 0.0, -1.0); // purple
    COLOR = vec4(0.72, 0.0, 0.72, 1.0);// purple

根据手册内容 The OpenGL Graphics System: A Specification (Version 4.6 (Core Profile)
17.3 Per-Fragment Operations - Blending - Table 17.1: RGB and alpha blend equations
混合方程式可以表达为以下方式，混合涉及像素来源方以及目标输出方的两个参数，混合因子和像素颜色，分别前缀
f 和 C 表示，op 为操作，即运算方式，运算中的参数以分量形式进行：

    C_final = f_source * C_source op f_destination * C_destination

混合运算可以是以下几种，另外 GL_MIN、GL_MAX 两种比较简单:

- **GL_FUNC_ADD** 前后两项相加
- **GL_FUNC_SUBTRACT** 前后两项相减
- **GL_FUNC_REVERSE_SUBTRACT** 前后两项反顺序相减

混合函数 Blend Functions 可以设置两个分量系数，RGB Blend Factors 和 Alpha Blend Factor，
这些系数的传入方式不同，会大大改变，输出结果。通过以下 OpenGL 命令启用、设置混合模式：

```c
    glEnable(GL_BLEND);
    glBlendEquation(GL_FUNC_ADD);
    glBlendEquation(GL_FUNC_REVERSE_SUBTRACT);

    glBlendFunc(GL_SRC_ALPHA, GL_ONE);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glBlendFunc(GL_ONE, GL_ONE); //use additive to accumulate one over the other
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ZERO, GL_ONE);
```

混合函数设置的混合权重系数有四个来源，是通过 BlendColor 命令设置的 RGBA 颜色分量，包括第一来源
和第二来源的颜色，以及 darw buffer 中的目标颜色。另外，还有特殊的常量权重 GL_ZERO 和 GL_ONE，
分别是 (0,0,0,0) 和 (1,1,1,1) 两个四维矢量。

例如，glBlendFunc(GL_SRC_ALPHA, GL_ONE) 方式传入的系数，搭配 GL_FUNC_ADD 运算，假设源像素
vec4(1.0, 1.0, 0.0, -1.0)，Alpha 负值分量就会和源像素的 RGB 相乘，再与后面的常量运算结果相加，
最后归一化，将 RGB 负值归 0.0，将 Alpha 归 1.0，得到 vec4(0.0, 0.0, 0.3, 1.0)。

    C_final = (-1.0,-1.0,-1.0,-1.0) * (1.0, 1.0, 0.0, -1.0) 
            + (1.0,1.0,1.0,1.0) * (0.3, 0.3, 0.3, 1.0)
            = (-0.7,-0.7,0.3,2.0)

以上相乘是和分量的运算，并不是向量之间的运算，不是向量点积也不是叉积，所以没使用向量表示。另外，默认
Godot 工程环境背景色 Default Clear Color 设置为 77 的灰度值，即各分量约为 0.3。

最后，官方文档推荐以下顺序编写着色器代码：

```c
01. shader type declaration
02. render mode declaration
03. // docstring

04. uniforms
05. constants
06. varyings

07. other functions
08. vertex() function
09. fragment() function
10. light() function
```


### 🟠🔵 3D SpatialShader 空间材质着色器
- [LenarOpenGL - Coordinate Systems](https://learnopengl.com/Getting-started/Coordinate-Systems)
- [Spatial shaders](https://docs.godotengine.org/en/3.5/tutorials/shaders/shader_reference/spatial_shader.html)
- [Your 1st 3D shader](https://docs.godotengine.org/en/latest/tutorials/shaders/your_first_shader/your_first_3d_shader.html)
- [Your 2nd 3D shader](https://docs.godotengine.org/en/latest/tutorials/shaders/your_first_shader/your_second_3d_shader.html)

3D 着色器与 2D 的着色器差别较多，例如 COLOR 全局变量不能修改，因为此模式下它不是 uniform 变量，
这些差别主要是因为 Godot 中的提供的材质支持，即通过 3D 着色器可以访问到默认的 3D 材质接口，如
ALBEDO、NORMALMAP 等全局符号可以修改材质表面色(vec3)、法线贴图等设置。

注意，Godot 3.x 与 4.x 的版本变化较大，很多对象及符号都做了调，NORMALMAP 就变更为 NORMAL_MAP。

```py
# called from the MeshInstance3D
mesh.material.set_shader_param("height_scale", 0.5)
mesh.material.set_shader_param("normalmap", sometexture)
```

要给 3D 着色器传递数据，可以使用材质类的方法接口，也可以使用着色器中定义 uniform 变量等形式传递数据。
注意，如果要在 fragment 中使用 VERTEX 中包含的当前顶点坐标信息，需要通过 varying 变量传递数据。
尽管，在片段着色器中还可以访问 VERTEX 这个全局变量，但其本身已经不是顶点着色器处理过程中的那个顶点
坐标，而渲染流水线上的其它参考坐标，即 OpenGL 视图坐标系统，以屏幕中心为原点，右上角为正方向。这个坐标
会随着视图位置的移动而变化，而不管物体本身的坐标是不是还在原位。

因为，vertex 着色器是为每个顶点设置属性使用的，会为每个顶点调用，而 fragment 着色器则为每个像素调用。


以下着色器实现波浪特效，在场景中创建一个 `MeshInstance3D` 节点，再给它赋予一个 PlaneMesh 网格，
这是 Godot 内置的一些最简单的模型，给 Plane 设置细分到 100 格左右的方阵即可。通过 3D 视图的菜单
切换为 Display wireframe 显示线框，可以看到网格中包含了许多三角形，这些都 PrimitiveMeshes，
也是 OpenGL 绘图中最基本的图元，就像点、线、多边形一样，都是最简单的图形结构。

给材质创建一个 NoiseTexture 纹理，并给它指定噪声来源 OpenSimplexNoise 或 FastNoiseLite 
以生成平滑噪声纹理，常用来生成地形。然后，通过着色器将噪声用于改变 Plane 的随机高度，为了更真实，
可以添加不同频率的随机噪声。就像傅里叶变换中那样，使用不同的同期的正弦函数组合来模拟其它信号。

虽然，通过噪声纹理可以创建地形或水波，但是此时光照处理中还是将它当作 Plane 网格来处理，法线没有改变，
光照也就明显看着不对。

法线存储在网格中，但着色器会不断更改网格的形状，因此法线总不正确。要解决此问题，可以重新计算着色器中
的法线或使用与噪波相对应的法线纹理。Godot 中很容易实现，可以在 vertex 着色器中手动计算法向量，也
可以直接使用 NoiseTexture 创建法线噪声纹理，只需要勾选 As Normalmap，生成的纹理就是法线贴图。
然后，将 uniform 输入的法线贴图赋值到 NORMALMAP 输出变量中。根据需要设置凹凸强度 Bump strenth，
如果纹理接缝太明显，可以勾选 Seamless 减少影响。

注意，法线贴图需要使用 XZ 分量作为采样坐标，因为 Godot 的 Y 轴是竖起向上的。还有 Plane 对象的
坐标原点在中心，坐标范围为 [-1, 1]，需要根据实际使用进行转换。

环境设置上，需要创建一个 WorldEnvironment，并设置背景模式为 Sky，然后，创建一个程序化天空盒，
使用 ProceduralSkyMaterial 程序材质。

菲涅尔效应表现比较好理解，视线与表面夹角越小，效应就越明显，反射光看起来也越强，所以需要视角向量和
物体表面法向量进行点积运算，dot(NORMAL, VIEW)。当两者垂直时点积结果最小，为 0，但是菲涅尔效应是
最强的，所以是反比例关系。


```c,ignore
shader_type spatial;
//render_mode unshaded;
render_mode diffuse_toon, specular_toon;

// Constants in Godot 4.x
//const float PI  = 3.14159265358979323846;
//const float TAU = 6.28318530717958647692;

uniform sampler2D normalmap;
uniform sampler2D noise;

varying vec3 tex_position;

float wave(vec2 position)
{
    position += texture(noise, position / 10.0).x * 2.0 - 1.0;
    vec2 wv = 1.0 - abs(sin(position));
//  return length(wv);
    return pow(1.0 - pow(wv.x * wv.y, 0.65), 4.0);
}

float height(vec2 position, float time)
{
    return wave((position - time) * 0.4 ) * 0.3 + 
           wave((position - time) * 0.3 ) * 0.3 +
           wave((position + time) * 0.5 ) * 0.2 +
           wave((position - time) * 0.6 ) * 0.2;
}

void vertex() {
    // save position for fragment, conver Plane coordinate from [-1, 1] to [0, 1]
    tex_position = (VERTEX.xyz + 1.0) / 2.0;
    
    float edge = 1.0 - smoothstep(0.0, 1.2, length(VERTEX.xz));
    VERTEX.y += height(VERTEX.xz, TIME) ;//* edge;
}

void fragment()  
{
    float fresnel = sqrt(1.0 - dot(NORMAL, VIEW));
    RIM = 0.2;
    METALLIC = 1.0;
    ROUGHNESS = 0.01 * (1.0 - fresnel);
    ALBEDO = vec3(0.1, 0.3, 0.5) + (0.8 * fresnel);
    NORMALMAP = texture(normalmap, tex_position.xz).xyz;
    
//  ALBEDO = vec3(VERTEX); // View space coordinate
}
```

概括地看，Godot 所做的是为用户提供一组可以选择设置的参数，AO、SSS_Strength、RIM 等等对应各种复杂效果，
环境光遮挡 Ambient Occlusion, 亚表面散射 SubSurface Scattering, 边缘照明 Rim Lighting。
当脚本不使用这些功能代码时，着色器不会产生额外功能的开销。这使得用户可以轻松地使用复杂且正确的 PBR 着色，
而无需编写复杂的着色器。

当然，Godot 还允许忽略所有这些参数并完全自定义着色器。例如 unshaded 渲染模式就可以关闭光照系统。

    render_mode diffuse_toon, specular_toon;

多个渲染模式可堆叠使用，例如，使用卡通着色而非 PBR 着色，就将漫反射模式和镜面反射模式设置为卡通。

Godot 4.x 中，给 3D 着色器引入了多个常量，除了原有的 TIME，还有圆周率等 Global built-ins:

+-------------------+----------------------------------------------------------------------------------------+
| Built-in          | Description                                                                            |
+===================+========================================================================================+
| in float **TIME** | Global time, in seconds.                                                               |
| in float **PI**   | A ``PI`` constant (``3.141592``).                                                      |
|                   | A ration of circle's circumference to its diameter and amount of radians in half turn. |
| in float **TAU**  | A ``TAU`` constant (``6.283185``).                                                     |
|                   | An equivalent of ``PI * 2`` and amount of radians in full turn.                        |
| in float **E**    | A ``E`` constant (``2.718281``). Euler's number and a base of the natural logarithm.   |
+-------------------+----------------------------------------------------------------------------------------+


另外，3D 着色器除了 vertex() 和 fragment()，还多了一个 light() 着色处理函数，在这个处理函数中，
可以使用以下内置变量 Light built-ins：

+-----------------------------------+----------------------------------------------------+
| Built-in                          | Description                                        |
+===================================+====================================================+
| in vec2 **VIEWPORT_SIZE**         | Size of viewport (in pixels).                      |
| in vec4 **FRAGCOORD**             | Coordinate of pixel center in screen space.        |
| in mat4 **MODEL_MATRIX**          | Model space to world space transform.              |
| in mat4 **INV_VIEW_MATRIX**       | View space to world space transform.               |
| in mat4 **VIEW_MATRIX**           | World space to view space transform.               |
| in mat4 **PROJECTION_MATRIX**     | View space to clip space transform.                |
| in mat4 **INV_PROJECTION_MATRIX** | Clip space to view space transform.                |
| in vec3 **NORMAL**                | Normal vector, in view space.                      |
| in vec2 **UV**                    | UV that comes from vertex function.                |
| in vec2 **UV2**                   | UV2 that comes from vertex function.               |
| in vec3 **VIEW**                  | View vector, in view space.                        |
| in vec3 **LIGHT**                 | Light Vector, in view space.                       |
| in vec3 **LIGHT_COLOR**           | Color of light multiplied by energy.               |
| in float **ATTENUATION**          | Attenuation based on distance or shadow.           |
| in vec3 **ALBEDO**                | Base albedo.                                       |
| in vec3 **BACKLIGHT**             |                                                    |
| in float **METALLIC**             | Metallic.                                          |
| in float **ROUGHNESS**            | Roughness.                                         |
| in bool **OUTPUT_IS_SRGB**        | ``true`` when calculations happen in sRGB color    |
| out vec3 **DIFFUSE_LIGHT**        | Diffuse light result.                              |
| out vec3 **SPECULAR_LIGHT**       | Specular light result.                             |
| out float **ALPHA**               | Alpha (0..1); if written to, the material will go  |
+-----------------------------------+----------------------------------------------------+


### 🟠🔵 Orbit Shader

以下是一个轨道环绕着色器，只是简单地使用三角函数产生圆形、椭圆形轨道，并将轨道上的点的位置设置到顶点
着色器的顶点坐标上，使用顶点位置坐标按轨道移动。然后，再根据顶点的坐标变化，以使用顶点坐标在 y 轴方向
上产生扰动，扰动来源于坐标的 XY 两轴的变化值。所以，顶点无论在其中任意一轴上的移动，扰动都会所反映。
然后输出给后续的着色器处理，如片段着色器。

```c,ignore
shader_type canvas_item;
// Here are the available types:
//shader_type spatial;     // - for 3D rendering.
//shader_type canvas_item; // - for 2D rendering.
//shader_type particles;   // - for particle systems.

uniform vec2 orbit = vec2(1.0, 1.0);

void vertex() {
  // Animate Sprite moving in a orbit around its location
  VERTEX += vec2(cos(TIME)*orbit.x, sin(TIME)*orbit.y);
  VERTEX.y += 3.0*cos(VERTEX.x) * sin(VERTEX.y);
}

void fragment(){
  COLOR = texture(TEXTURE, UV); //read from texture
}
```

### 🟠🔵 Pixlate Shader

以是一个具有实用功能的着色器 Pixelate Shader，功能说明如下：

Uniform 定义了外部传入参数 amount，它指定了一个像素重采样量。根据 p 坐标计算表达式，amount 先
会对 UV 进行缩放再取整后除以自身，参数值越大，UV 坐标相对就显得小，即 UV 变化就更精细，输出像素
就越接近原图。当 amount 等于原图大小时，就等于没有像素化效果。当 amount 越小，UV 的变化影响就显得
强烈，也就是每扫描下一个像素时，UV 坐标的变化就可以导致更多的原像素被忽略了，并且使用一些重复的像素，
最后，图像效果出来的就是粗糙的像素化效果。

```c
shader_type canvas_item;

uniform int amount = 9;

void fragment()
{
    vec2 p = round(UV * float(amount)) / float(amount);
    
    vec4 text = texture(TEXTURE, p);
    
    COLOR = text;
}
```

### 🟠🔵 Circle Art Shader

以下是一个通过圆点绘画图形的着色器，通过调整风格参数 grid 将整个图形分成方块，再设置圆点半径，使
图形中位置处理圆内的部分绘画出来，就像一个圆形图章在打点绘画。

分割图形后，使用 **mod()** 函数对 UV 坐标进行分段处理，分段后 UV 坐标重新映射到 [0.0, 1.0]
这个区间上，以方便后续的计算。圆点半径 radius 是相对于分块中心的位置，所以在求当前 UV 坐标到圆心
距离时，先减去 0.5 偏移常量。

为了添加镂空效果，定义为布尔值 stencil 变量，通过类型转换可以将 bool 转换为整数，true false 值
分别对应 1 和 0。这里取巧的点在于，通过乘数 -2 和加数 1 将布尔值转换为用作符号的值，1 和 -1。

最后，利用距离函数的数据设置 Alpha 通道，隐藏掉不需要显示的部分，即得到类似 Dot Plot 的圆点图。

```c
shader_type canvas_item;
render_mode blend_mix;

uniform float radius:hint_range(0.0, 1.0, 0.01) = 0.4;
uniform float grid:hint_range(0.0, 100.0) = 10.0;
uniform float sharp:hint_range(0.0, 1.0, 0.01) = 0.50;
uniform bool stencil = false;
 
void fragment()
{
    COLOR = texture(TEXTURE, UV);
    // cast bool to 1.0 or -1.0
    float sign = float(int(stencil) * - 2 + 1);
    float circles = length(mod(UV, 1.0 / grid) * grid - 0.5) - radius;
    COLOR.a = 1.0 - float(stencil) - sign * clamp(sharp * 100.0 * circles, 0.0, 1.0);
}
```

注意 clamp 函数的参数顺序，和 smoothstep 的不同，它将范围值 [min, max] 放在后面：

```c
// Clamp ``x`` between ``min`` and ``max`` (inclusive).
vec_type clamp (vec_type x, vec_type min, vec_type max)
```


### 🟠🔵 Circle SDF Shader
- https://iquilezles.org/articles/distfunctions/
- https://iquilezles.org/articles/distfunctions2d/

Shadertoy 作者 Inigo Quilez 对有向距离场很有深入的研究，使用 Raymarching distance fields
程序化建模利害得不行，作者主页上有一句话：“learning computer graphics since 1994”。

RayMarching 看起来跟 RayTracing 光线追踪很像，本质是通过数学方法模拟光线的传播。这种技术也是
有向距离场 SDF(Signed Distance Functions) 的应用，使用距离方程来表示几何体的方式，配合算法
直接以像素渲染方式 pixel shader 产生最终的建模效果画面，而不需要 3D 模型数据输入。这也就是 
Shadertoy 网站上大部分建模作品使用的方法。

然而 RayMarching 有一个硬伤，即像素渲染要对每一个像素点做运算，当画布较大时，其计算量就会很大。
这也是 Shadertoy 演示的很多作品打开时很卡顿，甚至很多案例还没打开，浏览器就会崩溃。

RayMarching 译作光线步进，或者射线推进，也称为球体追踪(Sphere Tracing), 以球体作为检测单元。
其意思就是让射线的起点沿着射线方向逐步推进，每次推进的距离就是射线起点到 SDF 模型的作为半径的距离。
光线追踪有前向、后向两种方式，Foreward/Backward Tracing，RayMarching 采用后向方式，由相机
位置投射光线，模拟眼睛的视线路径。


下图摘自 GPU Gems 2 Chapter 8. Per-Pixel Displacement Mapping with Distance Functions

![Figure 8-5 Sphere Tracing - from GPU Gems 2](https://jamie-wong.com/images/16-07-11/spheretrace.jpg)

RayMarching 将整个场景定义为一个有向距离场，为了找到视线和场景之间物体的交点，从相机开始，即沿着 P₀
视线一点一点地扩展，通过距离块提供的距离信息，可以检测到扩展半径是否触及场景物体，或者说，此时 SDF 的
计算结果是否为负数？。一般，有向距离场用负值表示物体内部，0 值表示物体表面，正值表示外部。如果 SDF 返回
正值，就继续沿着射线前进到最大步数。由于第一个触点不在视线方向上，所以继续探测，直到触及 P₄ 这点。
然后，根据表面的法线向量，以及光源位置和光的直线传播、透射、折射、反射原理，对物体进行着色。


作为一个入门启示练习，以下实现一个带有一点光属性地绘制圆形的着色器，场景中只有一个圆形，使用 SDF 
有向距离场来定义它，这是一种用距离方程来表示几何体的方式。空间中到圆心的距离等于半径的点，就是圆形表面。
圆形内部，距离值为负，外部距离值为正。

绘画时，只需要在圆形内上色，而圆形外不需要颜色，通过 Alpha 置零，使其透明化。

利用 **min()** 和 **max()** 函数可以过滤数据，将符合条件的值，按大、或小的规则过滤出来，使用钳制
函数 **clamp()** 可以实现将输入值约束在指定区间。

这些函数有时可以换着使用，可以达到相似的效果，例如，以下使用 clamp 和平滑插值函数 smoothstep 将
Alpha 通道的值约束在 [0.0, 1.0] 区间。当然，它们有所差别，clamp 会将超出范围的值复位到有效区间。

而三次平滑插值函数 smoothstep，结果返回 0.0 if x ≤ edge0，或者返回 1.0 if x ≥ edge1，而当
edge0 < x < edge1，使用 smooth Hermite interpolation 将结果平滑在 [0.0, 1.0] 区间。

平滑插值是与 clamp 最大的差别所在，插值会按比例改变输入数据，使其平滑分布到 [0.0, 1.0] 区间。
而 clamp 则不会，它只将超出范围的值分别归位为区间两端的值。

注意，edge0 ≥ edge1 时，无定义。

```c
    // Hermite interpolate between ``edge0`` and ``edge1`` by ``x``.
    // vec_type smoothstep (vec_type edge0, vec_type edge1, vec_type x)
    // vec_type smoothstep (float edge0, float edge1, vec_type x)

    genFType t;
    t = clamp ((x - edge0) / (edge1 - edge0), 0, 1);
    return t * t * (3 - 2 * t);
```

着色器中，根据半径设置，距离场中最大的距离的 ±0.5，将值作为 RGBA 直接赋值到片段着色器的输出，并没有
达到 RGBA 的最大动态范围。通过 clamp 或 smoothstep 可以重新将 [0.0, 0.5] 的值映射到 [0.0, 1.0]。

这个着色器中引入了点光源（Point Light）的概念，原理很像一个灯泡，从灯泡的钨丝向四面八方发出光。
然而，为了性能考虑，点光源被简化为从空间中的一个点均匀地向各个方向发射光。尽管这里有太多的缺陷，比如，
没有处理好光的传播路径与光强的关系，没有考虑衰减半径（Attenuation Radius），也没有考虑物体呈现
的颜色受光源和物体本身材质的影响等等，也没有考虑受光物体是平面或者是球面。只是简单地根据光源的距离，
线性计算颜色的亮度值，然后再叠加光源颜色。

更高级的光照效果还有，皮肤上的次表面散射（Subsurface scattering)，到处可见的 Fresnel 菲涅尔效应。

但是，这一切都不影响这个简单的着色器作为一个初学者的最直观的学习材料。

```c
shader_type canvas_item;

uniform float radius = 0.5;
uniform vec2  center = vec2(0.5, 0.5);
uniform vec2  light_position  = vec2(0.5, 0.0);
uniform vec3  light_color  = vec3(0.9, 0.2, 0.2);
uniform float light_energy  = 0.85;

float sdf_circle(vec2 p, float r)
{
    return length(p - center) - r;
}

void fragment()
{
    float dis = sdf_circle(UV, radius);
    float circle = max(0.0, -min(0.0, dis));
    COLOR = vec4(0.0) + circle;
    COLOR.a = clamp(0.0, 1.0, COLOR.a * 100.0);
    //COLOR.a = smoothstep(0, 0.1, COLOR.a);
    
    float lsdf = 1.0 - length(light_position - UV);
    float light = smoothstep(0, 1.0, lsdf * light_energy);
    COLOR.rgb = light_color * light;
}
```

注意：Godot 中着色器的 uniform 变量是可以在属性探测器面板中设置值的，并且会将值保留在工程文件中，
再次加载是会直接读取工程中的保留值，而不能通过修改代码来改变取值。这时可能需要将着色器材质清理掉，再
重新关联着色器，这样才能使着色器中的 uniform 初始化赋值生效。




### 🟠🔵 Convolution Shader 卷积边缘检测算法
- [从图(Graph)到图卷积(Graph Convolution)：漫谈图神经网络模型](https://www.cnblogs.com/SivilTaram/p/graph_neural_network_2.html)
- [卷积变体](https://zhuanlan.zhihu.com/p/393200454)
- [什么是卷积？But what is a convolution?](https://www.bilibili.com/video/BV1Vd4y1e7pj/)

卷积是一种积分变换的数学方法，与傅立叶变换有着密切的联系。在数字信号处理、通信系统、光学系统、神经网络
计算许多方面得到了广泛应用。卷积算法可以应用于许多场景，轻松实现模糊、边缘检测、浮雕等滤镜效果。

可以用卷积来演示 314x159 两个数的乘法运算，将各个数字分拆计算卷积，再按对角线求和再算权重：

      | 3    1    4
    --|-------------
    1 | 3    1    4
      |
    5 | 15   5    20     ==> 36 + (20+9)x10 + (4+5+27)x100 + (1+15)x1000 + 3x10000
      |
    9 | 27   9    36       = 49926

使用 Python numpy 模块计算卷积，如果是计算巨大的数据，使用 scipy 模块效率更高：

```py
    # pip install scipy numpy
    import numpy
    import scipy.signal

    res = numpy.convolve((3,1,4), (1,5,9))
    print(res) # [ 3 16 36 29 36]

    a1 = numpy.random.random(10000)
    a2 = numpy.random.random(10000)
    res = scipy.signal.fftconvolve(a1, a2)
    print(res)
```

图像处理中，边缘检测是最基本的技术，图像可以通过边缘的分区后，再根据不同区域进行差异化的处理。边缘
可以被检测出来，并突出显示，是因为它与四周存在明显的差异，关键就是图像的像素差异。

判断边缘的依据可以是颜色、亮度、纹理等变化差异的大小，或者说强度，就是判断相邻像素之间的梯度 gradient。
算法中，出于性能考虑也可以使用绝对值来替代开根号运算。

根据应用场合不同，围绕差异的边缘检测的方法有多种：

- 2D 图像边缘检测技术可以使用卷积（convolution）；
- 3D 物体的边缘检测，可以使用 3D 场景中的深度信息，或者使用表面法线向量；

在教科书上，卷积的定义通常是用函数的乘积组合定义的，而在图形处理上，可以用意图形象直观地展示：

![Visual 2D Convolution](https://images.cnblogs.com/cnblogs_com/SivilTaram/1510485/o_image-13-conv-cnn.gif)

图中左侧可以看作是图像的像素值，中间是一个计算方法中设置的权重值，右侧是计算结果。中间是一个采样矩阵，
也叫卷积核 kernel，通常是一个 NxN 的矩阵，并且 N 一般为奇数，矩阵中的每个值就是权重**weight**。
进行卷积处理的过程就是，将每个输入值都卷积核相乘，并得到一对应的输出值。

因为，这种卷积运算的结果相当对原图像重新采样，作用像电路中的滤波器一样，可以实现图像的模糊、锐化效果，
即分别过滤掉了高频、低频的数值变化，所以也叫做 filter。图像的高低频表现在视觉上，就是颜色变化差别大
即为高频，锐化的图像即为典型高频。变化差别小即为低频，看起来平滑，模糊就是典型的低频。

从信号角度理解，卷积可以定义为一个函数（蓝色单位响应方波）在一个输入信号（红色方波）上的加权输出，
即将输入信号从方波转变为三角波，卷积结果就是将方波边缘（高频）转换为三角波的缓慢变化（低频）。

![Square to triangle](https://pic3.zhimg.com/v2-a5b5870ab0a4030684c7f5796e3b83a6_b.webp)

例如，采用 3x3 的平滑过滤卷积核可以实现一定的模糊效果，输出值为采样区域的平均值，效果类似高斯模糊。
卷积核中心格子对应当前的像素，其它周边的每个格式都对应偏移到输入像素的周边，并根据卷积核中设置的权重
与输入值相乘，再求和获取到的值即为新图像像素值。

使用卷积进行边缘检测时，卷积核设置的权重值也称边缘检测算子。卷积虽然名字中有“卷”的含义，但是它的内涵
主要在于连续、积的层面上。


在 3D 场景中，物体的每个坐标都会有一个特殊的值 Z，也就是深度。深度信息可以用来区分物体位置前后关系，
即相互之间的遮盖关系。引擎一般都有提供深度信息，当然也可以通过物体表面的坐标计算到相对某点的距离得到。
如果一个位置的深度值和它四周的深度值产生了差异，那说明这个位置可能就是我们想要找的边缘。


法线就是垂直于物体表面的单位向量，通过它可以判断表面是否发生较大的变化，如果两点法线的点积为 0 就
表示两点所在的表面是互相垂直的，之间相差较大，相反，值越大表明越平坦，向量点积的结果可以判断边缘。
还可以有另一种思路：法线与视角间的夹角。视线与其法线的夹角更接近于垂直，就更可能被认定为边缘的部分。


### 🟠🔵 Displacemnet & Terrain 转换贴图与地形
- [Your 1st 3D shader](https://docs.godotengine.org/en/latest/tutorials/shaders/your_first_shader/your_first_3d_shader.html)
- [Your 2nd 3D shader](https://docs.godotengine.org/en/latest/tutorials/shaders/your_first_shader/your_second_3d_shader.html)
- [Spatial shader](https://docs.godotengine.org/en/latest/tutorials/shaders/shader_reference/spatial_shader.html)
- [Multiple resolutions](https://docs.godotengine.org/en/latest/tutorials/rendering/multiple_resolutions.html)
- [Setting up the game area](https://docs.godotengine.org/en/stable/getting_started/first_3d_game/01.game_setup.html)
- [The OpenGL® Shading Language, v4.60.7](https://github.com/KhronosGroup/OpenGL-Registry/tree/main/specs/gl/GLSLangSpec.4.60.html)
- [【Godot教程】顶点动画纹理](https://www.bilibili.com/video/BV14A411Z7gb/)
- [Houdini - Vertex Animation Textures (VAT)](https://www.vfxforce.cn/archives/16033)
- [Using VisualShaders](https://docs.godotengine.org/en/latest/tutorials/shaders/visual_shaders.html)
- [Using compute shaders](https://docs.godotengine.org/en/latest/tutorials/shaders/compute_shaders.html)

置换贴图是地形制作的基本工具，在 GPU 渲染管线上，顶点着色器是处理几何体原始信息的工具，通过修改顶点
坐标，使用原先的平面几何体产生任何希望的效果。结合噪声纹理，根据其像素的灰度值来修改顶点的高度坐标，
就可以使用平面按照噪声纹理隆起，或者凹陷，形成逼真的地形。

顶点动画纹理也是这种直接控制顶点的开发技术，Vertex Animation Textures (VAT) 就是将曲面顶点
的运动数据：坐标、法线保存到图像文件中，如果使用法线贴图格式则还需要切线向量，在引擎中通过着色器
将制作好的动画纹理重现为模型动画。


Godot 材质中 Height 用于启用视差高度贴图，类似 Normal Mapping 都是用于改变表面光线细节的贴图。
Godot 3.5 中使用 Depth 属性表示视差贴图。

另一种用于地形制作的置换贴图，Displacement Mapping，Godot 没有直接在材质中提供设置，而只能
通过着色器来实现，即需要创建着色器材质，对几何体的顶点进行直接处理。

给场景添加 MeshInstance3D 节点，并为其创建一个 PlaneMesh 平面几何体，然后为其创建着色器材质，
点击 ShaderMaterial 打开着色器设置，在 Shader 属性中创建一个 `Shader` 即着色器程序。或者，
可以使用 `VisualShader` 进行可视化着色器编程。

Godot 提供了 GLSL 编程接口，与源始的 OpenGL 着色器编程不同的是，直接在单个着色器程序中编写：

- Vertex Shader 顶点着色器：`void vertex() { ... }`
- Fragment Shader 片段着色器：`void fragment() { ... }`
- Lighting 光照处理函数；：`void light() { ... }`

使用可视化着色器编程的一个好处是更直观，直接通过图形界面就可以生成着色器代码，通过节点连接实现和各种
着色器数据的赋值。通过选择要编写的着色器，所有可用的输出变量就直接显示在 Output 节点中。

节点化编程和代码编辑方式有思路层面的差异，比如代码中使用 uniform 来定义全局变量来输出纹理资源，
在可视编程中，只需要放置一个 Texture 节点，就会自动创建相应的 uniform 变量。但是资源数据的使用
方式是有很大差别的。可以使用 `Expression` 或者 `GlobalExpression` 节点编写 GLSL 代码，它们
分别会在着色器全局作用域、函数作用域中生成相应的代码。

最新推出的 compute shaders 则需要使用底层的 `RenderingDevice` 访问 Vulkan API 来实现。


在创建材质时，有两个选择，可以给 MeshInstance3D 几何节点或者 Mesh 资源附加材质，两者都通用。

然后点击着色器打开它，在其属性面板中，可以通过工具菜单 Save 将着色器保存到文件中进行编辑。

为了让 PlaneMesh 可以表现凹凸曲面，需要对平面进行细分，让它拥有更多的顶点，而不是只有 4 个顶点。
Subdivision Width/Depth 设置合适的值，比如 256。为何查看细分的效果，可以打开线框视图功能，
Perspective -> Display Wireframe，这样就会将细分的边线显示出来。

以下要实现这个简单的地形着色器包含内容：

- 一个噪声纹理，通过 NoiseTexture 加载 OpenSimplexNoise 或者新版本的 FastNoiseLite；
- 一个顶点着色器处理函数 `void vertex()`；
- 使用一个 GLSL `texture()` 纹理采样函数；
- 定义一些全局的着色器变量，用于地形的海拔高度偏移、地形纹理缩放，高度差放大等等；

着色器中需要使用 GLSL `texture()` 纹理采样函数，其返回值包含指定坐标上的像素值 RGBA。对于灰度
纹理来说，RGB 三分量是等值的，而透明度分量 Alpha = 1。

需要注意：

- 新创建的 PlaneMesh 顶点坐标值为 [-1,1] 范围，平面中心为零点，大小为 2x2，而 UV 坐标范围总是是 [0,1]。
- Godot 中的 XYZ 三轴，红绿蓝三色对应，Y 是垂直方向，XZ 才是地平面。

3D 环境中，平移、Size 等使用米制单位，1 表示 1 米，创建噪声纹理使用的是像素。可以使用三角函数去观测
PlaneMesh 细分后的顶点坐标变化。三角函数的周期是 2PI，对于一个 20x20 大小的平面，它在两个维度上
就有 3 个多的三角函数周期的变化。

在着色器中定义的 uniform 全局变量，Godot 会进行处理，并且在 ShaderMaterial 面板中提供设置操作，
分组在 Shader Params。注意，如果着色器程序有语法错误时，参数就不会显示在发展面板中。

```c
shader_type spatial;

uniform sampler2D height_map;
uniform float scale = 1.0;
uniform float multiply = 1.0;
uniform float offset = -0.5;
uniform vec2 translation = vec2(0,0);

float height(vec2 pos) {
    //return sin(pos.x) + cos(pos.y);
    return (length(texture(height_map, pos / scale + translation)) + offset) * multiply;
}

void vertex() {
    VERTEX.y += height(VERTEX.xz);
}
```

经过以上操作得到的地形还只是停留在曲面的阶段，对于一个能在项目中使用的地形，还会需要更多的功能。
绿植装饰、光照效果等等基础材质属性，还要提供碰撞检测等等功能。

光照处理涉及到法线，中学的物理定义，光线是直线传播的，反射光则与表面法线向量形成和入射角相等的夹角。
当前的地形虽然经过基本的顶点置换处理，得到了与地面一样起伏的曲面。但是，其法线还是和原来新创建的
PlaneMesh 一样，即所有细分出来的片面都拥有一样的法线。当光线照射到这个曲面时，光照效果和照在平面上
没有两样的！

在场景上添加一个灯光节点，散光灯或直射光都可以，DirectionalLight，OmniLight。然后打开法线视图
Perspective -> Display Normal，就可以看到这个问题，面没有明暗差异。如果添加散光灯，曲面的明暗
变化只跟光源的距离有关，而与曲面的朝向无关。

法线数据保存在 Mesh 资源中，前面的着色器只是修改了顶点坐标，而没有处理法线信息，使得法线错误。
修复法线朝向有两个方法：

- 修改着色器内置的 `NORMAL` 或者 `NORMAL_MAP` 向量；
- 使用向量贴图修正法线；

在噪声程序纹理工具中，可以按同样的方式生成法线贴图，即和纹理贴图一致的法线信息，Noise Texture
面板中勾选 As Normal Map 选项即生成法线贴图。

在渲染流水线上，顶点处理和法线处理使用不同的着色器，顶点着色器一般专用于顶点处理。法线处理可以在片段
着色器中处理。如果使用 OpenGL API，则需要加载两个着色器程序。在 Godot 中已经处理好着色器的加载，
只需要在同一相着色器程序中编写 `void fragment()` 函数即可。

OpenGL Shading Language 手册简化 GPU 渲染流水线如下，开发者主参与两个阶段：

1. **Vertex Processor**
2. Tessellation Control Processor
3. Tessellation Evaluation Processor
4. Geometry Processor
5. **Fragment Processor**
6. Compute Processor

GLSL 着色器语言从语法上讲，和 C 语言无异，基本数据类似也一样。但是作为 GPU 着色器，它提供了大量
向量、矩阵、纹理等数据类型，并且基于它们提供了丰富的 API。GLSL 实际上是几种密切相关的语言，这些语言
用于为 API 处理管道中包含的每个可编程处理器创建着色器。因此，编程模型完全与 C 语言编程不一样。官方
文档仓库中包含一个单页面的语言手册 GLSLangSpec.4.60.html。

另一个问题是，**顶点着色器**与**片断着色器**是两个 GPU 程序，虽然在 Godot 中使用同一个着色器
代码文件。这两个着色器会在 GPU 渲染流水线上依工序执行处理，为了将顶点着色器的数据传递给片断着色器，
GPU 编程中提供了 varying 变量，

GLSL 的一大特色就是有各种修饰符号来决定变量的使用规则，参考修饰符说明。uniform 与 varying 很
大不同在于，前者在处理一个基本体的过程中是不会改变的，用来链接 CPU 运行的程序与 GPU 运行的着色器。
后者则更像是一般的 C 语言变量，可以在着色器程序中改变它的值，并实现不同着色阶段中的数据传递。

存储修饰符 Storage Qualifiers [4.3]

- `none` (Default) local read/write memory, or input parameter.
- `const` Compile-time constant, or read-only function parameter.
- `attribute` Linkage between a vertex shader and OpenGL ES for per-vertex data.
- `uniform` Value does not change across the primitive being processed, uniforms form the linkage between a shader, OpenGL ES, and the application.
- `varying` Linkage between a vertex shader and fragment shader for interpolated data.

参数修饰符 Parameter Qualifiers [4.4]

- `none` (Default) same as `in`.
- `in` For function parameters passed into a function.
- `out` For function parameters passed back out of a function, but not initialized for use when passed in.
- `inout` For function parameters passed both into and out of a function.

输入参数在调用函数时复制传入，输出参数在函数返回时复制输出值。其它修饰符参考官方手册。

朗伯照明理想镜面散射光模型，表面不吸收任何入射光，Lambertian lighting model 实现如下，Godot
着色器中提供了光照函数定义，通过修改这个函数可以实现自己的光照效果：

```C++
void light() {
    DIFFUSE_LIGHT += clamp(dot(NORMAL, LIGHT), 0.0, 1.0) * ATTENUATION * ALBEDO;
}
```

在主光源光强度为 1.0 的条件下，ALBEDO 纹理会按以上算法与法线、入射光方向，衰减系数等因素下生成
模型表面的漫射光效果，通过调整基本色输入来调整最终效果。




## 🟡 2D Animation 平面动画
- [Animation Retargeting in Godot 4.0](https://godotengine.org/article/animation-retargeting-in-godot-4-0)
- [Movie Maker mode arrives in Godot 4.0](https://godotengine.org/article/movie-maker-mode-arrives-in-godot-4)
- [Creating movies](https://docs.godotengine.org/en/latest/tutorials/animation/creating_movies.html)
- [How to make your bullets look awesome in Godot - Advanced Trails](https://www.bilibili.com/video/BV1iA411A7gz/)


### 🟠🔵 TileMap 瓦片地图
- [Abstract Platformer](https://kenney.nl/assets/abstract-platformer)
- [Godot Advanced Trails Examples](https://github.com/RPicster/Godot-Advanced-Trails-Examples)
- [Using TileMaps](https://docs.godotengine.org/en/3.6/tutorials/2d/using_tilemaps.html)
- [Using GridMaps](https://docs.godotengine.org/en/latest/tutorials/3d/using_gridmaps.html)

官方文档推荐了一个动画资源 Abstract Platformer，这组资源可以用来做 TileMap、AnimatedSprite
之类的动画演示。或者，使用官文展示的一组青蛙 Sprites：

![Frog Spritesheet](https://docs.godotengine.org/en/3.5/_images/2d_animation_frog_spritesheet.png)

TileMap 瓦片地图是 2D 游戏常见的技术，通过定义瓦片图集 TileSet，就是将图片按区域划分最小的区块，
然后，再用类似绘画的方式一样，将瓦片图绘制到 TileMap 上，最后得到的一个游戏关卡地图。技术上来讲，
TileMap 就是一个按格子分割的区域，用格子的形式来记录什么位置的格子要绘制什么图像。

TileMap 中的图像常采用斜角地图的形式，即 Isometric View，即等距视角下的地图，和透视相对，是指
视野内的物体，无论远近都用同一大小来表现，而绘画中常用的透视 Perspective 却是远小近大。

使用多个 TileMap 可以在同一块位置添加多张图像，以得到合适的场景。

![TileMap Tool](https://docs.godotengine.org/en/3.6/_images/tilemap_tool.png)

点击打开编辑界面，为 TileMap 创建新的瓦片集，在 TileSet 中导致图像等资源，并将其分割成瓦片图。
可以每次一张图像作为一个瓦片导入，也可以将一张图片分割成多个瓦片，方格化批量方式称为 Atlas tiles。

先将源图片导入瓦片集中，然后点击 New Single Tile 创建第一个瓦片，通过拖动出一个矩形区 Region
定义好这个瓦片所使用的图像区域。要编辑已有的瓦片，点击 Edit 进行编辑状态，点击需要编辑的瓦片，然后
拖动鼠标重新定义瓦片区域。瓦片的其它属性，如名称等，可以在属性探测器面板中设置。

有了第一块瓦片，就可以将它绘制到 TileMap 中的网格上了。

对于代表玩家不能穿越的区域，可以给瓦片设置碰撞检测区，在瓦片编辑状态下，点击 Collision 定义一个
矩形，或者多边形作为碰撞检测时的参考区。

遮挡、导航形状区域定义用于 AI 寻路导航使用。

CanvasItem 节点通过 y_sort_enabled 可以启用渲染排序，正确解决物体的前后遮挡关系。旧版本中使用
TileMap.cell_y_sort 属性。


除了以上 Single Tile 方式单个地创建瓦片，还可以使用以下两种方式定义瓦片：

Atlas tiles：可以为图集一次定义一组瓦片，而不是一次添加一个，并且这种方式可以在绘画到 TileMap
时打开 Enabled Priority 以随机生成瓦片。并且，可以为其中任意的瓦片定义碰撞检测区。这种模式下，
可以在 Icon Mode 下选择一个图案作为在 TileMap 绘图列表的图标显示。而 Z-Index 模式则用来定义
各个瓦片的绘图时的 Z 深度值。还有优先级模式 Priority Mode 用来设置瓦片出现的随机概率值。

Autotiles 用于地形编辑，允许一次定义一组平铺，然后根据相邻单元格的内容添加规则来控制用于绘图的平铺，
瓦片选择由位掩码控制。单击 Bitmask 设置位掩码，然后单击要添加或删除掩码的瓦片进行设置：

- 左键单击瓦片的某个区域可添加 “on” 标记位，显示为红色；
- 右键点击设置 “off” 标记位，正常状态；
- Shift + 左键单击可设置 “ignore” 标记位，显示为蓝色；

每个瓦片可设置的 Bitmask 数量通过属性面板 Autotile bitmask mode 设置，允许设置为：

- “2x2” 模式包含 4 个标记位，对应瓦片的四个角；
- “3x3 (minimal)” 模式包含 9 个标记位，四个角标记位功能同上；
- “3x3”。

必须满足所有 “open” 和 “off” 的标记位，才能匹配位掩码，但忽略 “ignore” 标记位。

Godot 使用 Autotiles 更新单元格时，首先会根据已设置的相邻单元格创建图案。它在 Autotiles 中搜索
具有与创建的图案匹配的位掩码的瓦片，如果找不到匹配的位掩码，将改用 “Icon” 瓦片。如果找到多个匹配，
将根据优先级设置随机选择其中一个。

以最简单的 2x2 模式为例，瓦片的四个角都有一个 bitmask：

- "on"（图中红色）状态下的边角要与同相状态的瓦片相连接；
- "off"（图中白色）状态下的边角要与至少有一个 "off" 状态设置的瓦片相连；

![2x2 bistmask](https://docs.godotengine.org/en/3.6/_images/autotile_template_2x2.png)

另外，通过编程，可以批量修改 TileMap 的内容，TileSet 提供了方法根据 tile 名称获取 ID，然后可以
在 TileMap 中定位到全部使用了 ID 对应的图像的格子坐标，这个坐标是格子的行列坐标，和世界坐标之间
可以相互转换。给 set_cell() 传递 -1 作为 tile ID 则可以清空格子内容。编辑 Tile 时，会自动设置
ID，并显示在瓦片名称前。

通过这些方法，可以使用 TileMap 绘制各种对象的占位符号，然后编程替换成需要的节点对象。Godot 4.x
版本中，直接可以在 TileMap 中将场景当作 tile 使用。 

```py
# TileSet
int find_tile_by_name(name: String) const

# TileMap
Array get_used_cells_by_id(id: int) const
Vector2 world_to_map(world_position: Vector2) const
Vector2 map_to_world(map_position: Vector2, ignore_half_ofs: bool = false) const

# Node2D
Vector2 to_global(local_point: Vector2) const
Vector2 to_local(global_point: Vector2) const
```

通过 get_used_cells 返回的一系列坐标指示了，TileMap 哪个格子上已经绘制了瓦片图，坐标对应左上角
为原点，右下角为正方向。

Godot 4.x 使用了全新的 TileMap 界面，并且引入场景的支持，可以将场景作为瓦片图使用。并且，底部工具
面板中相应显示为 TileSet、TileMap 两个面板。旧版本中，在 2D 场景面板工具栏中的功能移到了 TileMap
面板中，并且新增了 Line、Rect 两种绘制工具。部分属性面板内容也移动到 TileSet 面板中，包括以下属性组：

- Animation
- Rendering
- Terrains

新增了 Atlas Merging Tool 用于合并瓦片图，在 TileSet 面板中的弹出菜找到。

引入图层管理瓦片，在属性面板 Layers 添加图层，绘制时在 TileMap 面板右上角选择所在图层，绘制在同
一图层上的瓦片图使用相同的层设置，如色彩调制。新旧版本的 API 上也有差别：

    void set_cell ( int x, int y, int tile, ...)
    void set_cellv ( Vector2 position, int tile, ... )

    void set_cell ( int layer, Vector2i coords, int source_id=-1, Vector2i atlas_coords=Vector2i(-1, -1), int alternative_tile=0 )
    void set_cells_terrain_connect ( int layer, Vector2i[] cells, int terrain_set, int terrain, bool ignore_empty_terrains=true )
    void set_cells_terrain_path ( int layer, Vector2i[] path, int terrain_set, int terrain, bool ignore_empty_terrains=true )

 和旧版本的瓦片 ID 不同，新版本引入了 source_id 作为瓦片集来源，并且需要通过 atlas_coords 指定
 瓦片图的坐标所在。所以，官方示范工程 2d navigation_astar 需要按以下代码迁移升级：

    #set_cell(point_start.x, point_start.y, 1)
    #set_cell(point_end.x, point_end.y, 2)

    set_cell(0, point_start, 1, Vector2i(0, 0))
    set_cell(0, point_end, 2, Vector2i(0, 0))


要将场景作为瓦片使用，则在 TileSet 中添加一个 Scenes Collection，并且将场景资源添加进来。

将图像导入 TileSet 中，会自动提示是否需要使用自动创建瓦片集，可以激活 Eraser 工具，通过点击擦除瓦片区。
如果手动创建瓦片定义，就需要取消 Eraser 工具，并点击图片进行定义，默认为 Tile Size 设置的格子像素大小。
可以在 Select 面板中修改瓦片的大小，只需要周边保留有足够的空白区。创建瓦片时，按下 Shift 拖动创建任意
格子大小的瓦片。

要将瓦片绘制到场景时，就切换到 TileMap 面板，并选择已经定义好的瓦片进行绘制，有 4 种绘制工具：

- Paint (D)
- Line (L)
- Rect (R)
- Bucket (B)

选择多个瓦片，还可以配合 Place Random Tile 进行随机绘制，投掷图标按键打开此功能。

地形是瓦片图集需要提供的基本功能，比如，绘制一片草地，在未绘制的区域显示为水塘，这就是地形的基本表现。
不同于旧版的 bitmask 设置方式，Godot 4.x 将面板拆分到属性探测器面板，以及 TileSet 面板两部分。
TileMap 节点的属性页面板中，弹开 Tile Set 面板，可以在 Terain Set 中创建地形集定义，并设置模式
和添加多个地形名称定义，每个地形可以一个名字和一个颜色进行标记，模式有对应有 3 种：

- Match Corners and Sides (3x3)
- Match Corners (2x2)
- Match Sides

然后，在主界面底部的 TileSet 面板中，激活 Paint 绘制属性，选择属性 Rendering - Terrains，
然后，通过 Painting 列表中选择的项目进行 bitmask 数据绘制：

- Terrain Set 设置瓦片归属于某个地形集，-1 表示不属于任何地形图集。
- Terrain 设置瓦片归属于这个地形集的某个地形，比如，一个地形集可能定义有草地、森林两种地形。

绘制地形时，就切换到 TileMap 面板，并选择 Terrains 栏目中列出的地形定义。


### 🟠🔵 Tween & AnimationPlayer 缓动曲线动画
- [SceneTreeTween](https://docs.godotengine.org/en/stable/classes/class_scenetreetween.html)
- [Tween](https://docs.godotengine.org/en/stable/classes/class_tween.html)
- [Canvas layers](https://docs.godotengine.org/en/3.6/tutorials/2d/canvas_layers.html)
- [2D Sprite animation](https://docs.godotengine.org/en/3.5/tutorials/2d/2d_sprite_animation.html)

缓动曲线是用数学公式计算一个时间段内某一个变量的平滑变化产生动画的技术，例如，在 1s 时间内将节点
的 x 位置坐标从 0 慢慢增加到 100，这种平滑的变化有不同的公式产生不同的动画效果，曲线参考图如下：

![Tween easing and transition types cheatsheet](https://raw.githubusercontent.com/godotengine/godot-docs/master/img/tween_cheatsheet.png)

使用 SceneTreeTween 和旧式的 Tween 对象创建缓动曲线动画变换效果，这是最基本的 2D 动画技术。

2D 动画涉及到的节点类型除了缓动程序，还包括但不仅限如下这些：

|     Objects      |         Base Type          |
|------------------|----------------------------|
| SpriteFrames     | Resource                   |
| AnimatedTexture  | Texture < Resource         |
| Animation        | Resource                   |
| Sprite           | Node2D < CanvasItem < Node |
| AnimatedSprite   | Node2D < CanvasItem < Node |
| AnimatedSprite3D | Spatial < Node             |
| AnimationPlayer  | Node                       |
| AnimationTree    | Node                       |

前两个资源类型用于包装动画图像资源，而 Animation 动画资源则作为动画轨道记录动画帧属性。

SpriteFrames 包装动画帧图像资源，可以包含多个动画配置。

AnimatedTexture 是动态纹理资源，本身就具有动画播放能力。作为一个资源类型，类似使用图片纹理对象。
但可以设置多个帧，而不是一张静态图片，然后可以提供给 AnimatedSprite、TileMap 等需要图像资源的
节点使用。用户可以对帧率 FPS、每帧延时，或者暂停、单次播放 Oneshot 等进行设置。Godot 引擎架构中
负责视觉处理的 VisualServer 以动态纹理规定的速率按顺序绘制区域。好消息是，这不涉及引擎的额外逻辑。
坏消息是，用户几乎没有控制权。

例如，AnimatedTexture + AnimatedSprite 组合，这就有了双重动画，一边 AnimatedTexture 按自己
的动画节凑播放各帧图像，每一帧的图像输出又被 AnimatedSprite 重新制作的动画进行播放。也就是前者负责
变换图片，后者负责制作动画，二者组合得到最终效果。用在大量的自动动画背景中，单个批处理绘制调用就可完成渲染。


AnimatedSprite + SpriteFrames 组合制作图片帧动画，可以创建多个动画。对比单独使用 Sprite 节点，
它加载一张 Spritesheet 图像，则只能创建一个动画，但如果用好 **AnimationPlayer** 来控制其属性，
也可以创建多个动画资源。AnimatedSprite3D 则是在 3D 场景下创建的一个能展示帧动画的 2D 平面。

动画资源类型 **Animation** 保存的是动画相关数据，在 AnimationPlayer 编辑界面中以轨道的形式展示，
也可以通过编程方式设置动画轨道及关键帧数据：

```py
# This creates an animation that makes the node "Enemy" move to the right by
# 100 pixels in 0.5 seconds.
var animation = Animation.new()
var track_index = animation.add_track(Animation.TYPE_VALUE)
animation.track_set_path(track_index, "Enemy:position:x")
animation.track_insert_key(track_index, 0.0, 0)
animation.track_insert_key(track_index, 0.5, 100)
```

AnimationPlayer 节点作为关键帧动画，通过 Animation 资源类型记录场景内其它节点的属性变化来生产动画，
可以创建多个动画，以对象属性轨道的方式编辑，它还可以用于各种动画 2D 动画：

- Cut-Out animations: 剪影动画，如皮影戏的效果；
- 2D Mesh animations: 绑定骨骼控制图像的变形；

Animation 可以记录 6 种轨道数据，TrackType 定义的值如下：

● **TYPE_VALUE** 属性轨道，只记录可以插值的属性。
● **TYPE_TRANSFORM** 变换矩阵轨道，用于改变节点局部变换、骨骼姿态。
● **TYPE_METHOD** 方法调用轨道，设置要在动画播放时触发的函数，可以带参数。
● **TYPE_BEZIER** 贝塞尔曲线自定义插值轨道，可以对向量、颜色等属性的分量做动画。
● **TYPE_AUDIO** 音频轨道，使用 AudioStreamPlayer 播放音频流，可以在动画中修剪和预览该流。
● **TYPE_ANIMATION** 动画轨道，用于播放其它 AnimationPlayer 节点的动画。

动画播放器可以配合 Path2D、Path3D 以及 PathFollw 可以制作运动路径跟随，内嵌 RemoteTransform
作为子节点，它可以将自身的位置等状态，包含路径运动的产生的运动信息，发送给其它对象以实现路径跟随运动，
例如用路径控制运动学刚体 KinematicBody。


视差，即远慢近快的视觉现象，是常被 2D 采用的一种动画技术，游戏、动画片中非常多应用，使用视差背景图节点
ParallaxBackground，就可以实现，继承自 CanvasLayer。将视差图层节点 ParallaxLayer 放置到视差
背影节点内，设置视差图层的 Motion 属性以确定视差效果。

最主要的 Scale 参数，决定了视差图层与相机运动的速度比例，0 表示固定不动，类似 CanvasLayer 图层
下的节点一样固定位置。设置 [0, 1] 表示比相机运动速度慢，通常就是远景的设置，大于 1 就是近景的设置。

场景中总是存在 Viewport，至少场景树的顶级有一个不可见的 Viewport，它设置了 canvas_transform，
允许对它所包含的 CanvasItem 施加一个自定义的 Transform2D 变换. Camera2D 的主要工作方式就是
改变这个 Transform2D 变换实现画布内容的变换控制。

![CanvasLayers](https://docs.godotengine.org/en/3.6/_images/canvaslayers.png)

在 3D 场景中也可以使用 **CanvasLayer** 来显示 2D 节点内容，避免受到画布因相机视角变换的影响，
可以实现的功能不仅以下功能：

- Parallax Backgrounds 视差效果，配合 ParallaxLayer 节点设置背景图片，可以设置镜像延伸。
- UI: 游戏中的用户界面，或者 head-up display (HUD) ，它们应该固定在屏幕中，不随游戏世界变换。
- Transitions: 视觉变换，如渐变、混合效果，这些内容也固定位置。

类似的，CanvasItem 提供了一个方法，**set_as_toplevel()** 可以将 2D 节点添加顶级状态，以避免
受到父级的变换影响，同时绘图时会覆盖在其它未标记为 Top Level 的基点。

场景中可以使用一个 **WorldEnvironment** 节点，同时只能有一个，包括继承的场景在内。然后为环境节点
创建一个 **Environment** 资源，用于配置环境，如设置背景属性：

- Background Mode 设置为 Canvas 模式；
- Canvas Max Layer 设置一个序数，层序小于这个值的 CanvasLayer 就会当作背景层；

Layer 序号越大，绘图顺序越靠后，就可以覆盖其它 Layer 更小的节点。2D 场景默认图层绘画顺序为 0，如果
CanvasLayer 序号设置为更小的值，如 -1 则会先行绘制，作为背景。CanvasLayers 拥有独立的绘图顺序，
由 Layer 序号决定，它们独立于场景树的节点顺序，可以在需要时调整。


场景中相机运动可以使用以下代码片段，使用鼠标移动来决定相机位置：

```py
exetends Node2D

onready var camera_2d = $Camera2D

func _input(event):
    if event is InputEventMouseMotion:
        #camera_2d.anchor_mode = Camera2D.ANCHOR_MODE_FIXED_TOP_LEFT
        camera_2d.position = (event.position - get_viewport().size/2) / 2
```


动画的基本原理就是连续的相似图像在人眼的视觉暂留产生的运动感觉，2D Sprite animation 就是将一组
相似的但又有关键区别的图像按指定时间间隔播放的动画效果，在场景中使用 **AnimatedSprite** 节点，
在属性探测器中设置节点的 Frames 属性，它关联一个 **SpriteFrames** 动画帧资源，包含多个动画配置，
可供 AnimatedSprite 或 AnimatedSprite3D 播放。


打开动画帧资源，在动画帧编辑面板中有一个默认的 default 动画，根据需要创建更多的动画，如行走、跳动
等等，然后为每个动画导入相关图片，可以是单张单个动作的图像，或者一张包含所有动作的 Sprites 图像，
即 Sprites Sheet 图像，要求各个动作图像大小相等，导入后需要通过画网格来定位。

然后，设置帧动画的播放速度 Speed，默认为 5 FPS，即每秒 5 帧，还可以勾选 Loop 表示循环播放不终止。
AnimatedSprite 播放完每一个动画时，会发布一个 **animation_finished** 信号，可以利用它来做
动画转换以完成动画组合。

```py
onready var animated_sprite = $ColorRect/AnimatedSprite


func _on_AnimatedSprite_animation_finished():
    print("AnimatedSprite finished ", animated_sprite.animation)


func _on_ColorRect_gui_input(event):
    if event is InputEventMouseButton and event.is_pressed():
        var ans = animated_sprite.frames.get_animation_names()
        var idx = ans.find(animated_sprite.animation)
        idx = (idx + 1) % ans.size()
        animated_sprite.play(ans[idx])
```

以下是定制 Sprite 实现的 MyAnimatedSprite 动画节点：

```py
extends Sprite
class_name MyAnimatedSprite

signal animation_finished

var timer:Timer = Timer.new()

export(int, 0, 120, 1) var FPS = 4
export(bool) var pause = false setget set_pause
export(bool) var loop = false
export(bool) var TextureMovtion = true setget set_TextureMovtion

func _enter_tree():
    timer.connect("timeout", self, "_on_Timer_timeout")
    add_child(timer)

func _ready():
    connect("animation_finished", self, "_on_animation_finished")
    set_animation()
    
func _input(event):
    if event.is_pressed() and event is InputEventMouseButton:
        var mouse = event as InputEventMouseButton
        var distance = position.distance_to(mouse.position)
        if distance > 32:
            return
        if mouse.button_index == BUTTON_LEFT:
            set_TextureMovtion(!TextureMovtion)
        else:
            set_pause(!pause)
    
    
func _on_Timer_timeout():
    var frames = hframes * vframes
    frame = (frame + 1) % frames 
    if frame == frames - 1:
        yield(get_tree(), "idle_frame") # wait next idle frame
        emit_signal("animation_finished")

func _on_animation_finished():
    if not loop:
        timer.stop()
    

func set_pause(state):
    pause = state
    set_animation()

func set_animation():
    if not pause and texture:
        timer.start(1.0 / FPS)
    else:
        timer.stop()

func set_TextureMovtion(state):
    TextureMovtion = state
    var at = texture as AnimatedTexture
    at.pause = !state
    property_list_changed_notify()
```


使用 **Sprite** 和 **AnimationPlayer** 搭配也可以实现 AnimatedSprite 一样的帧动画，只不过
AnimationPlayr 是记录节点的属性作为关键帧，一个动画包含多个关键帧。首先，给 Sprite 节点的纹理属性
指定一张 Spritesheet 图像，然后通过 Hframes 和 Vframes 两个属性将图像拆分作多个帧。然后，打开
底部 Animation 动画播放节点设置面板，创建一个动画，为 Sprite 节点的 Frames 属性添加一条轨道，
并在轨道中添加关键帧。可以通过右键菜单，也可以通过 Sprite 的属性面板的 Key 图标设置。

注意，AnimationPlayer 中的动画轨道是和属性的路径字符串关联的，如果对应的节点位置有变量，轨道中的
属性路径可能也需要更新，否则可能因找不到节点而导致原有的动画设置不能生效。

```py
extends Sprite

onready var player:AnimationPlayer = $AnimationPlayer
onready var timer = $Timer
onready var sprite = $"."

enum Direction { Left = -1, Right = 1 }
export(Direction) var direction = Direction.Left

func _on_Timer_timeout():
    player.current_animation = "fog jump"
    #player.play("fog jump")


func _on_AnimationPlayer_animation_started(anim_name):
    var tween = get_tree().create_tween().set_trans(Tween.TRANS_QUART)
    var up = Vector2(direction * 50.0, -30.0)
    var dn = Vector2(direction * 40.0, 30.0)
    tween.tween_property(sprite, "position", up, 0.3).as_relative().set_ease(Tween.EASE_OUT)
    tween.tween_property(sprite, "position", dn, 0.15).as_relative().set_ease(Tween.EASE_IN)


func _on_AnimationPlayer_animation_finished(anim_name):
    var vs = get_viewport().size
    if sprite.position.x > vs.x:
        sprite.scale.x = direction
        direction *= -1
    elif sprite.position.x < 0:
        sprite.scale.x = direction
        direction *= -1
```

2D/3D 动画最重要的一个节点是 **AnimationTree**，旧的 AnimationTreePlayer 由于太复杂已经丢弃。
动画树实现的功能是动画混合技术 Animation Blending，作为独立一小节讲解。


## 🟡 Animation Blending 动画混合
- [Using AnimationTree](https://docs.godotengine.org/en/3.5/tutorials/animation/animation_tree.html)
- [Adobe Mixamo](https://www.mixamo.com)
- [Third Person Shooter demo](https://github.com/godotengine/tps-demo)
- [Retargeting 3D Skeletons](https://docs.godotengine.org/en/latest/tutorials/assets_pipeline/retargeting_3d_skeletons.html)
- [Animation Retargeting in Godot 4.0](https://godotengine.org/article/animation-retargeting-in-godot-4-0)
- [Better collada plugin for Blender](https://github.com/HungryProton/collada-exporter-2.8)
- [09.高级动画技术：动画树、IK和表情动画 | GAMES104-现代游戏引擎：从入门到实践](https://www.bilibili.com/video/BV1pY411F7pA)
- https://threejs.org/examples/#webgl_animation_skinning_additive_blending
- [spine-godot Runtime](http://esotericsoftware.com/spine-godot)
- [Spine Runtimes - spine-godot](https://github.com/EsotericSoftware/spine-runtimes)

官方文档提供的第三人称射击游戏示范项目 Third Person Shooter demo 是学习动画混合的好例子。

Adobe Mixamo 是学习 3D 动画的一个资源网站，它用许多现成的模型和动画预设，可以实现自动化的骨骼
绑定及动画制作，只要上传自己的角色模型稍作校正就可以完成动画制作，现有的动画素材也是很好的学习资源。

动画混合是一种重要的计算机动画技术，基本的动画技术在使用上存在难以使用的的问题。例如，游戏中玩家角色
同时可以不同的动作，也就是不同的动画融合在一起。比如，简单的动画可能有步行、跳跃、攻击行为等，在简单
播放动画的技术中，它们都是独立的，一个播放完就进行下一个动画。

典型的动画混合例子，就是将 3D 人物模型从走路动画过滤过渡到奔跑动画。但是，在游戏交互中要求远不止如此，
可能玩家在做跳跃动作时还突然想做出攻击动作，那么传统的动画就无法很好适应这种中间转播其它动画的操作。


游戏、动画工业对动画有大量的需求，动画制作完成后还有复用的需要，即将同一套动画应用于骨骼结构相似的
模型上。这里就存在动画重定向的问题，Animation Retargeting。基于骨骼绑定制作的动画，有一个特点，
就是模型不同的部分绑定不同的骨骼，通过调整骨骼姿态使用模型产生相应的姿态，记录到关键帧后就得到动画。
所以，动画重定向就需要将动画来源的骨骼与目标模型的骨骼做校对，以使用原动画的数据适用于新的模型上。

同样，2D 动画也有类似的动画复用问题，在 Godot 中使用 AnimationPlayer 节点制作的关键帧动画，其
目标节点是通过节点路径表示的，就是一个字符串，通过改变这个节点路径，就可以将动画应用于不同的节点上。

Godot 动画节点中最重要的一个节点是 **AnimationTree**，旧版本的 AnimationTreePlayer 由于太
复杂已经丢弃。动画树实现的功能是动画混合技术 Animation Blending，它的功能涉及内容较多，也是比较
复杂的一个节点。一般它和 AnimationPlayer 搭配使用，用于管理不同动画的切换播放。

AnimationTree 动画混合使用到三大类型节点：

- **Animation** 动画资源类型，动画树引用通过 anim_player 属性连接到 AnimationTree 上的动画。
- **AnimationRootNode** 根节点用来混合子节点，最常用的是 Blend Tree 混合树。
- **Blend Nodes** 混合节点用于 Blend Tree 混合树，多个输入端口接入的混合节点，最终混合成单个图。

动画树需要指定一个动画播放节点的路径以调用其动画配置，还需要设置一个顶层资源动画节点，以下 5 个继承自
AnimationRootNode < AnimationNode 的类型对应了 5 种不同的动画混合方法：

- **AnimationNodeAnimation**: 动画节点，只是简单地从已经连接的动画中选择要播放的动画。
- **AnimationNodeBlendTree**: 混合树可以混合不同的根节点，常常用它作为动画树的根节点使用。
- **AnimationNodeStateMachine**: 状态机可以包含多个根节点，它们都是状态，使用转换方法切换状态。
- **AnimationNodeBlendSpace2D**: 2D 混合空间，混合点可以在二维平面运动，可以混合多个动画。
- **AnimationNodeBlendSpace1D**: 1D 混合空间，简化版本，混合点只能一维方向变化，混合两个动画。

根运动技术 **Root Motion** 是指，即因角色动作导致需要移到模型位置，拼接两个动画，就需要处理前后
两个动画中的模型位置，使其前后连接流畅。假设，现成的模型动画基于原点定位，当一个使用 Root Motion 
的动画播放到结束时，模型已经偏移原点。所以，当下一个动画跟着播放时，又瞬时回到了原点，这里就有位移差
要处理好才能将两个动画无缝拼接起来。3D 动画技术中，模型网格的骨架用于为角色提供推动力，动画师常用的
技术是使用根骨骼为其余骨骼提供运动。这允许角色的步行可以稳贴地板，产生真实的角色动画，而不会出现摩擦
地板的脚掌拖动现象。

对于一个动画而言，只是角色运动中的一个周期而已，当动画播放完一个周期，它又需要让图像恢复原位，再从头
来过，这样周而复始地播放。在实际使用中，动画循环播放应该产生连续的位移，而不是来回跳动。


Godot 中播放动画时，亦可以使用根骨骼作为根运动轨迹 Root Motion Track，这样将在视觉上取消骨骼变换，
动画将保持位置不变。根运动轨迹可以通过 get_root_motion_track() 获取再传递给 KinematicBody 的
**move_and_slide()** 方法以控制角色运动。

RootMotionView 是一个工具节点，放置在场景中当作地板，为角色动画提供参照，在游戏中时默认是禁用的。

使用官文展示的一组青蛙 Sprites 为例，它可以制作为一个跳跃动画，这个跳跃动作会产生位移：

![Frog Spritesheet](https://docs.godotengine.org/en/3.5/_images/2d_animation_frog_spritesheet.png)

假定制作了 jump_left 和 jump_right 两个跳跃动画，因为图像的青蛙是向左的，如果在 Sprte 显示
图像，可以通过设置 scale.x 为 -1 进行左右反转，从而得到向右的图像。使用 AnimationPlayer 制作
动画时，是可以知道角色移动距离的，那么在动画播放完成时，通过接收 animation_finished 信号，并在
信号触发时主动移动相应的距离，然后再开始下一轮的动画播放，这样移动就可以衔接起来。注意 Loop 方式开启
AnimationPlayer 就不会发出 animation_finished 信号。另外，通过 AnimationTree 触发的动画
播放行为也不会生产 AnimationPlayer 的这些动画播放的相关信号，因为它们属于不同的对象。


以最简单的 1D 混合空间为例，给 AnimationTree 添加上 **AnimationNodeBlendSpace1D** 根节点，
打开 Bottom Panel 中的动画树面板，可以看到混合编辑器中只是一维的时间坐标轴，可以往不同的位置添加
动画节点，或者嵌套地添加其它 Animation Root 根节点用来混合更多的子节点。

直接通过 Create Points -> Add Animation 将两个青蛙跳跃动画添加到轴线上，然后设置 Blending 
Position，在两个动画定位点之间移动，即混合两个动画的数据。在正中中间时，因为动画使用的 scale.x
分别为 1 和反转时的 -1，所以结果会将青蛙的图形的 scale.x 混合为 0，使用得图像不可见。将混合点
移动到任意一侧，则结果就是完全输出最靠近的这个动画，另一个动画对结果完全没有影响。

2D 混合空间则可以在二维空间中设置混合点，在二维空间中至少放置 3 个动画点，以形成一个 2D 图形区域，
当混合点与动画点越接近时就得到这个动画点的更多混合量，直到完全输出这个动画点的动画：

![BlendSpace2D](https://docs.godotengine.org/en/3.5/_images/animtree8.gif)

2D 混合模式有三种选择，默认情况下，Blend Mode 为线性模式，通过在最近的三角形内插入点进行混合。
处理 2D 动画（逐帧）时，可能需要切换到离散模式 Discrete mode，下拉菜单中显示为 3 个点。或者，
如果希望在离散动画之间切换时保持当前播放位置，则使用有进位模式 Carry mode。

同样使用青蛙的跳跃动画来演示状态机的使用，给动画树添加 StateMachine 根节点，然后在底面板的动画树
编辑器中，点击状态机管理界面中的 + 号增加动画节点，分别添加 jump_left、jump_right，还有动画树
默认提供的 RESET，即休息节点，没有动画的静止状态。然后，点击穿线箭头图标，看起来像飞机，给三个状态
添加连接线，使用 RESET 与其它两个动画实现双向连接，而两个跳跃动画相互不连接。

例如，当前处于 jump_left 状态中，播放的就是向左跳跃动画。然后，再点击 jump_right 状态的播放图标，
如果 Play Mode 设置为遍历模式 Travel，表示状态不会直接从 jump_left 切换到 jump_rigth 状态，
而是按连接线，先切换到 RESET 状态，再切换到 jump_right 动画状态。

状态机中每个节点都是一个状态，对应的一个动画，点击状态节点上的播放图标就可以切换到这个状态。节点上
显示的文字就是状态名称，调用 **start()** 等方法做状态转换时，需要使用这个名称，不因为有空格导致
状态名称不匹配而不能播放动画。节点状态会一直保持播放状态，除非调用 **stop()** 方法停止。

注意，默认的 **RESET** 动画用于最初加载对象时的姿态，只有一个帧，并且不期待被用于时间轴的回放。
为了动画混合结果可以重播保持一致，要混合的属性需要设置初始值。所以，在状态机中执行了 RESET 动画
状态时，它可能会影响到其它和 RESET 相关的动画。

对于 Skeleton3D 骨骼使用位置/旋转/缩放 3D 轨迹时，初始值为复位骨骼 Bone Rest。对于其他属性，
初始值是 0，如果轨迹出现在 **RESET** 动画中，则使用其第一个关键帧的值。

2D 或者 3D 的旋转轨道设置的插值方式为线性角或者立方体角度时，Linear Angle or Cubic Angle，
可以用来限制旋转角度保持在与初始角度到 180 度的范围，这可以用来避免角色肢体发生违反生理现象的旋转。
可以在混合动画时防止骨骼穿透身体，因此，Skeleton3D 的 Bone Rest 值应尽可能接近可移动范围的中点。
这意味着，对于人形模型，最好以 T 形姿势导入。像上面的角色演示动画这样，可以看到动画按 Bone Rests
位置优化最短的旋转路径，而不是两个动画之间的最短旋转路径。

需要通过混合动画旋转 Skeleton3D 超过 180 度的情况，可以考虑使用 Root Motion 功能。通过动画树
获取到的 Root Motion 是一个变换矩阵对象，它包含了根骨骼的实时运动，可以将这个变换信息传递给角色
控制类型的运动处理方法就可以让动画前后流畅地拼接起来：

```py
func _process(delta):
    var motion:Transform = animation_tree.get_root_motion_transform()
    # This can be fed to functions to control the character movement, such as 
    # KinematicBody.move_and_slide (Godot 3.x)
    # CharacterBody3D.move_and_slide (Godot 4.x) 
```

状态转换模式设置决定了状态机如何切换动画，有 3 个切换模式：

- Immediate：立即模式，将立即切换到下一状态，当前状态将结束并融入新状态的开始。
- Sync：同步模式，将立即切换到下一个状态，但会 seek 寻找到新状态到与旧状态一致的回放位置。
- At End：结束时模式，将等待当前状态播放结束，然后切换到下一个状态动画的开始。


A* 算法实现的遍历功能是 Godot 的 StateMachine 实现中的一个很好的特性，可以指示从当前状态转到
另一个状态图，同时访问所有中间状态。要使用状态遍历功能或进行状态转换，首先，从动画树节点检索出状态机
回放对象 **AnimationNodeStateMachinePlayback**。注意，它通过导出的属性引用，属性导出路径可以
在动画树的属性面板中找 Parameters -> Playback，拖动属性到脚本编辑器中即可，然后使用 Object 
**get()** 方法获取。调用 **get_travel_path()** 可以获取遍历的路径：

```py
# AnimationNodeStateMachinePlayback
var playback_path = "parameters/playback" # or parameters/StateMachine/playback
var state_machine = $AnimationTree.get(playback_path)
state_machine.travel("jump_left")
state_machine.start("jump_right")
```

对于已对配置好的动画树根节点，可以在动画树的属性探测器面板中点击 Tree Root 属性右侧的下拉菜单保存
到动画树资源文件中，以便后续再使用。Blend Tree 编辑器也可以保存节点资源配置，操作麻烦点：

- 点击 Blend Tree 属性探测器面板上下拉菜单，竖直的三个点图标，执行 Make Resource Built-in；
- 点击磁盘图标弹出菜单的 Save 执行关联式保存，这种方式会将节点关联到一个资源文件，保存项目时也会写入；
- 或者，直接点击 Save As... 另存资源文件，这种方式不会执行关联操作，保存项目时也不会主动写入这个文件；
- 对于已经关联保存的节点资源文件，可以再次执行 Make Resource Built-in 将资源数据内置，不再使用文件；

为了方便复用已经配置好的动画节点资源，根据需要选择这两种资源保存方式，关联式保存可以在修改节点后自动在
保存项目时更新资源文件，非关联式保存则可以避免这种自动更新，对于不需要或很少更新资源，就不需要关联。


**Blend Tree** 混合树可以混合不同的根节点，它总是有一个默认输出节点，AnimationNodeOutput，
可以将各种混合节点连接到输出节点，也可添加不同类型的混合节点，以混合多个动画：

- **AnimationNodeAdd2** 2 端口叠加混合，Add Amount 指定叠加比例，0.0 表示不叠加 add 端口。
- **AnimationNodeAdd3** 3 端口叠加混合，Add Amount 指定叠加比例，0.0 表示不叠加 ±add 端口。
- **AnimationNodeBlend2** 2 端口混合，Blend Amount 指定混合比例，0.0 表示不混合 bledn 端口。
- **AnimationNodeBlend3** 3 端口混合，Blend Amount 指定混合比例，0.0 表示不混合 ±bledn 端口。
- **AnimationNodeOneShot** 单次触发，Active 打开时，表示触发 shot 输入端口的动画。
- **AnimationNodeTimeScale** 时间缩放，对输入端的动画进行速度缩放，0 表示动画停止。
- **AnimationNodeTimeSeek** 动画时间定位，用于改变动画回放时间点。
- **AnimationNodeTransition** 是一个简单状态机，适用于不需要更高级的状态机的情况。

其中 NodeAdd2、NodeAdd3、NodeBlend2、OneShot 这三种混合方式都可以设置过滤器动画轨道，即可以
单独控制哪些轨迹通过混合功能，这对于将动画层叠在一起非常有用。点击 Edit Filters，勾选激活选项，
并设置需要作为过滤器的动画轨道，以混合使用这些轨道控制动画。

叠加与混合两种方式的差别在于，叠加方式是加法器，Add Mount 为 1.0 时 add 端口的动画会完全叠加在
in 端口输入的动画上，所以可以用来组织多个角色的动画，一个 Blend Tree 就可以安排多个角色的动画。
而混合方式 Blend 表示 Mixture 的意思，搅拌在一起，Blend Amount 设置为 1.0 表示混合的结果只
有 Blend 端口的动画，in 端口的动画完全没有。反之，0.0 表示只会播放 in 端口的动画，Blend 端口的
动画完全不考虑。其它值则表示在输入动画之间的混合状态。Blend3 的混合比例在 [-1.0, 1.0]，-1 和 1
分别表示只输出 -blend 和 +blend 端口输入的动画，设置为 0.0 表示只输出 in 端口的动画。

以下是 Blend2 混合节点的效果演示：

![Blend2](https://docs.godotengine.org/en/latest/_images/blending5.webp)

所有混合节点都作为导出属性，属性访问路径通过动画树的属性探测器面板获取，Parameters 包含所有已添加节点。

OneShot 混合根据动画是否启用 Loop 循环播放有不同表现，shot 端口输入的动画在不启动循环播放状态下，
播放完成时就会返回到 in 端口的动画状态。通常用来给角色添加开火的动作，所以叫做单次射击。

Transition 做简单的状态转换，可以添加多个状态，状态之间转换时间可以在 Xfade Time 属性中设置，
设置 Input Count 确定好输入端口数量，即状态数量，然后将动画连接到输入端口。然后通过导出的 current
属性设置当前状态，状态机就会从上一个状态转换到新的状态。此功能在 Godot 3.x 中还不完善，在属性面板中
添加输入端口后，会提示状态端口没有连接，编辑界面也没有及时更新，可以在添加端口后将 Transition 连接
到其它端口再断开试试，不行就可能需要重新加载动画树或场景。

Transition 提供了一个自动推进选项 Auto Advance，激活它，当前状态转换完成后，即动画播放完成后，
自动推进到下一个状态。如果所有状都激活了自动推进，就会像 Loop 模式一样循环播放各个状态的动画。

TimeSeek 做动画回放时间定位时，在设置好 seek_position 时间点后，会自动在下一处理帧进入睡眠模式，
通过设置 seek_position 值为 -1.0 使其不再有作用。

```py
# Play child animation from the start.
animation_tree.set("parameters/Seek/seek_position", 0.0)
# Alternative syntax (same result as above).
animation_tree["parameters/Seek/seek_position"] = 0.0

# Play child animation from 12 second timestamp.
animation_tree.set("parameters/Seek/seek_position", 12.0)
# Alternative syntax (same result as above).
animation_tree["parameters/Seek/seek_position"] = 12.0
```

混合树的可视化节点编辑目前操作上还不流畅，而且所有连接到 Output 节点，所有输入端口必需有连接，否则
不能正常播放动画。节点连接操作也不是很便利，必需先断开原有连接，才能连接新的节点。



## 🟡 Physics 物理系统
- https://docs.godotengine.org/en/latest/tutorials/physics/physics_introduction.html
- [GAMES201-高级物理引擎实战指南 - 胡渊鸣](https://www.bilibili.com/video/BV1ZK411H7Hc)
- [Godot 平台跳跃游戏教程 - 如何实现攻击判定](https://www.bilibili.com/video/BV1Nt4y1e7yd?p=9)
- [2D Physics Tests](https://github.com/godotengine/godot-demo-projects/tree/master/2d/physics_tests)
- [3D Physics Tests](https://github.com/godotengine/godot-demo-projects/tree/master/3d/physics_tests)

物理系统是游戏引擎中的一个大系统，图形学专门开设有物理引擎课程来讲解它。物理系统实现真实世界的物理原理，
会涉及以下基本物理对象概念，主要内容是 4 种碰撞体的碰撞检测与响应处理：

- Area2D/3D 物理探测区，可以检测进入、离开等行为，也可用于覆盖定义区域中的物理属性，例如重力或阻尼。
- RigidBody2D/3D 刚体，不会变形的物体，用户不直接控制，而是应用力（gravity, impulses）改变其行为。
- StaticBody2D/3D 静态物理体，具有物理性质，参与碰撞，但物理引擎不会移动它们；
- CharacterBody2D/3D 角色运动学形体，旧版为 KinematicBody。只提供碰撞检测，但用户要实现碰撞响应，包含重力、阻力等等。

除了物理探测区，其它三种物理对象都继承自 PhysicsBody2D/3D，而物理体又继承自 CollisionObject。

此外，还有其它一些物理模型：

- SoftBody 软体
- Ray-casting 射线投射
- Ragdoll system 碎布玩偶系统

Godot 4.x 添加了新功能，与旧版本有差别。

注意，不要改变缩放属性，Scale 必需保持为 (1, 1)，物理引擎并不使用缩放尺寸。另外，物理引擎为了提供
运算效率，会使用多线程，物体位置或者线性速度等属性在当前帧中可能不精确，为了使用精确值，就需要使用
`Node._physics_process()` 回调。

Godot 使用的物理引擎可在项目配置中修改，默认集成了 Bullet 和内置的物理引擎：

```py
enum PhysicsEngine {
    BULLET,
    GODOT_PHYSICS,
    OTHER,
}

var _engine = PhysicsEngine.OTHER


func _enter_tree():
    pause_mode = Node.PAUSE_MODE_PROCESS

    get_tree().debug_collisions_hint = true

    var engine_string = ProjectSettings.get_setting("physics/3d/physics_engine")
    match engine_string:
        "DEFAULT":
            _engine = PhysicsEngine.BULLET
        "Bullet":
            _engine = PhysicsEngine.BULLET
        "GodotPhysics":
            _engine = PhysicsEngine.GODOT_PHYSICS
        _:
            _engine = PhysicsEngine.OTHER
```


在游戏中，NPC 或敌人之类的运动可以通过 VisibilityEnabler 来控制，它会在进入玩家视野后才会运动，
通过控制 RigidBody 或 AnimationPlayer 等父节点的 disabled 状态来实现这一效果，或者冻结状态，
通过监听 screen_enterd 或 viewport_enterd 等信号，可以改变其本身的行为。

**VisibilityEnabler** 只能在场景初始化之前添加才会生效，并且保对同一个场景下的节点有影响。如果，只
需要处理相关通知，可以使用父类型 **VisibilityNotifier** 替代。



### 🟠🔵 Collision & Shape
- https://docs.godotengine.org/en/latest/tutorials/physics/collision_shapes_2d.html
- https://docs.godotengine.org/en/latest/tutorials/physics/collision_shapes_3d.html
- godot-docs\classes\class_collisionshape2d.rst
- godot-docs\classes\class_collisionpolygon2d.rst
- godot-docs\classes\class_shape2d.rst


碰撞对象可以分层管理，它与被遮罩的层中的对象才相互发生碰撞，碰撞对象可以扫描多达 32 个碰撞层，通过
遮罩属性设置遮罩层，以下两个是分层碰撞系统中使用属性：

- collision_layer 设置物理对象所在层，默认为 layer 1。
- collision_mask  设置物体需要扫描哪些层以进行碰撞检测，如果对象不在其中遮罩层中，将忽略它。

层的名称可以通过 Project Settings -> Layer Names 修改。

PhysicsBody2D/3D 碰撞对象本身只提供碰撞检测逻辑，需要在子级节点中给出一个碰撞检测边界范围定义。
有两种方式定义碰撞形状：

- CollisionPolygon 此直接在编辑器绘画多边形，提供图形用于确定碰撞检测的边界范围。
- CollisionShape 碰撞图形方式可以使用以下基础碰撞形状，也可以通过 Mesh 来生成 Shape。

碰撞形状的具体定义保存在 Shape2D/3D 资源中，碰撞形状可以设置多个，在碰撞检测时逐个进行比较。例如，
在 Area2D/3D 信号事件中可以获取到相应的 Shape 节点序号。

以下是 Godot 4 提供的各种基本碰撞形状类型，所有物理碰撞中都可用，Debug - Visible Collision Shapes
选项打开后，可以在调用运行过程中显示碰撞形状：

|        Shape2D        |        Shape3D        |
|-----------------------|-----------------------|
| CapsuleShape2D        | BoxShape3D            |
| CircleShape2D         | CapsuleShape3D        |
| ConcavePolygonShape2D | ConcavePolygonShape3D |
| ConvexPolygonShape2D  | ConvexPolygonShape3D  |
| RectangleShape2D      | CylinderShape3D       |
| SegmentShape2D        | HeightMapShape3D      |
| SeparationRayShape2D  | SeparationRayShape3D  |
| WorldBoundaryShape2D  | SphereShape3D         |
|                       | WorldBoundaryShape3D  |

不同 Godot 版本之间的碰撞形状对象关系：

|  Godot 3.x  |      Godot 4.x       |
|-------------|----------------------|
| LineShape2D | SegmentShape2D       |
| RayShape2D  | SeparationRayShape2D |
|             | CylinderShape3D      |
|             | HeightMapShape3D     |
|             | WorldBoundaryShape3D |

其中，Concave 凹面的和 Convex 凸面的两种多边形需要设置 2 的整数倍的顶点来定义多边形。
凸碰撞形状是基本碰撞形状和凹碰撞形状之间的折衷，如名字所提示，它无法表达有凹陷的形状的碰撞。

虽然可以通过设置基点数据来定义形状，但可以通过 Sprite 或 MeshInstance3D 网格自动生成。

选择 Sprite 节点，可以在主视图的 Sprite - Create CollisionPolygon2D Sibling 菜单执行
碰撞形状的生成，执行它会弹出一个对话框，包含以下设置：

- Simplification: 简化级别，值越大忽略越多细节；
- Shrink (Pixels): 收缩级别，值越大相对于精灵的边收缩生成的碰撞多边形。
- Grow (Pixels): 生长级别，值越大值生成的碰撞多边形相对于精灵的边增长。

请注意，将“增长”和“收缩”设置为相等的值可能会产生不同的结果，而不是将两者都设置为 0。还可以将 Sprite
转换为 Polygon2D 节点，这个功能相当于简化的位图转矢量图功能，它可以检测图像的透明区。还不能用它来
生成导航风格中使用的 NavigationPolygon，只能生成外轮廓图形用于碰撞检测。


选择 MeshInstance3D 节点后，在主视图的 Mesh 菜单中提供多种生成模式：

- Create Single Convex Collision Sibling - 使用 Quickhull 算法生成单个凸形；
- Create Multiple Convex Collision Siblings - 使用 V-HACD 算法生成多个凸形，比凹面速度更快；

对于特别复杂的碰撞体，就需要使用凹面或三角面构造的碰撞体，Mesh 菜单对应有：

- Create Trimesh Static Body
- Create Trimesh Collision Sibling

其它形状介绍，这些都是简单形状，非常方便于碰撞算法处理：

- RectangleShape 矩形碰撞检测；
- CircleShape 圆形碰撞检测；
- CapsuleShape 胶囊形碰撞检测；
- SegmentShape 线段形碰撞检测；
- SeparationRayShape (designed for characters)
- WorldBoundaryShape (infinite plane)

https://docs.godotengine.org/en/latest/classes/class_worldboundaryshape3d.html
`WorldBoundaryShape` 是一个无尽的平面，可以阻挡物理体进入负向空间，其法向的反方向部分为负向空间。
在 PhysicsBody 中使用它，会导致放置在它“下方”的碰撞物体传送到“上方”平面。

WorldBoundaryShape3D 不支持静态模式以外的 RigidBody3D

分离射线并不是一个真正的碰撞形状，它是尝试用射线来分离射线碰撞到的端点位置，用在角色控制中。

碰撞检测只是碰撞处理的一部分，碰撞算是有三个主要部分：

- 碰撞检测 (collision detection)
- 碰撞判定 (collision determination)
- 碰撞响应 (collision response)

而算法消耗主要在前两个部分，所以设置碰撞形状时应该尽量简单，尽管 PhysicsBody 没限制碰撞形状的数量，
但尽量不多用碰撞形状，避免出现性能问题。同时，避免对碰撞形状做线程变换操作，translating, rotating, 
或者 scaling 都应该避免，以尽可能利用物理引擎的优化。

碰撞检测算法一般分 2 个阶段，需要使用空间分割算法来加速物体的检测过程：

- broad phase 粗筛阶段快速找出潜在的碰撞物体对列表，不在这个列表里的是绝对没可能碰撞的。
- narrow phase 细筛阶段准确找出发生碰撞的物体对列表，并进行碰撞判定。

对于只有单个碰撞形状的 StaticBody，碰撞算法的 broad phase 就可以忽略非活动的 PhysicsBody 对象。
但是使用多个碰撞形状的情况下，则不能这样优化。碰撞算法 narrow phase 需要对每个碰撞形状逐个进行检测。



### 🟠🔵 Area2D/3D
- https://docs.godotengine.org/en/latest/tutorials/physics/using_area_2d.html
- [2D Dodge The Creeps Demo](https://godotengine.org/asset-library/asset/515)
- [2D Pong Demo](https://godotengine.org/asset-library/asset/121)
- [2D Platformer Demo](https://godotengine.org/asset-library/asset/120)
- [3D Platformer Demo](https://godotengine.org/asset-library/asset/125)
- [GUI in 3D Demo](https://godotengine.org/asset-library/asset/127)
- [2D Pong Demo](https://godotengine.org/asset-library/asset/121)
- [2D Kinematic Character Demo](https://godotengine.org/asset-library/asset/113)
- godot-docs\tutorials\physics\using_area_2d.rst
- godot-docs\classes\class_area2d.rst
- godot-docs\classes\class_area3d.rst

There are three main uses for Area2D/3D:

- Overriding physics parameters (such as gravity) in a given region.
- Detecting when other bodies enter or exit a region or what bodies are currently in a region.
- Checking other areas for overlap.

Area2D/3D 继承自 CollisionObject2D/3D，和 PhysicsBody2D/3D 是同级的具有碰撞功能的对象。

Area2D/3D 的一大功能是监视其它 Area，物理体 Body 或碰撞 Shape 进入与离开当前区域，通过
信号返回相关参数：

- area_entered (`Area2D` area )
- area_exited (`Area2D` area )
- area_sape_entered (`RID` area_rid, `Area2D` area, `int` area_shape_index, `int` local_shape_index )
- area_sape_exited (`RID` area_rid, `Area2D` area, `int` area_shape_index, `int` local_shape_index )
- body_entered (`Node2D` body )
- body_exited (`Node2D` body )
- body_sape_entered (`RID` body_rid, `Node2D` body, `int` body_shape_index, `int` local_shape_index )
- body_sape_exited (`RID` body_rid, `Node2D` body, `int` body_shape_index, `int` local_shape_index )

Shape 碰撞触发的信号要在 Area 的信号后面，即先发生 Area 交叠行为，其它碰撞对象也一样：

- 先触发 area_entered 再 area_shape_entered。
- 先触发 area_exited 再 area_shape_exited。

设置以下两个属性控制 Area 是否处理监控、或可以被监控状态：

- Monitoring 启用即监控其它形状的碰撞事件，才会触发以上各个信号；
- Monitorable 启用可以被监控；

Area 本身只提供碰撞检测逻辑，需要在子级节点中给出一个碰撞检测边界范围定义，有两种方式：

- CollisionPolygon 此直接在编辑器绘画多边形，提供图形用于确定碰撞检测的边界范围。
- CollisionShape 碰撞图形方式可以使用以下基础碰撞形状，也可以通过 Mesh 来生成 Shape。

碰撞形状可以设置多个，在碰撞检测时逐个进行比较，在信号事件中可以获取到相应的 Shape 节点序号。

Area2D/3D 的第二个主要功能是通过参数覆盖修改物理引擎的默认行为，需要开启 Space Override：

- Combine - The area adds its values to what has been calculated so far.
- Replace - The area replaces physics properties, and lower priority areas are ignored.
- Combine-Replace - The area adds its gravity/damping values to whatever has been calculated so far (in priority order), ignoring any lower priority areas.
- Replace-Combine - The area replaces any gravity/damping calculated so far, but keeps calculating the rest of the areas.

覆盖将根据 Priority 指定的优先级、覆盖模式来决定哪些值被覆盖，高优先级的会先处理。

可以覆盖的物理属性包括：

- Gravity - Gravity's strength inside the area.
- Gravity Vec - Gravity's direction. This vector does not need to be normalized.
- Linear Damp - How quickly objects stop moving - linear velocity lost per second.
- Angular Damp - How quickly objects stop spinning - angular velocity lost per second.
- Point gravity - The Gravity Point property allows you to create an "attractor".

Point gravity 点重力场允许创建“吸附器”，启用后 Area 区域的重力将根据重力矢量属性计算出一个点，
值是相对于 Area2D 的，例如，使用（0，0）会将对象吸引到区域的中心。

![Area2D Override](https://docs.godotengine.org/en/latest/_images/area2d_override.gif)



### 🟠🔵 RigidBody & StaticBody
- https://docs.godotengine.org/en/latest/tutorials/physics/rigid_body.html
- https://kidscancode.org/godot_recipes/3.x/kyn/rigidbody2d/

刚体和静态物体是相似的两类，它们都由物理引擎直接控制，只是后者不需要移动，只参考碰撞计算。

Example uses for StaticBody2D/3D:

- Platforms (including moving platforms)
- Conveyor belts
- Walls and other obstacles

对于刚体，用户不能直接控制它，物理引擎需要通过不断的计算，实时反映刚体在虚拟世界中的行为。需要通过施加力，
使用 apply_impulse() 方法，来间接控制：

```py
void _integrate_forces(state: PhysicsDirectBodyState3D)
virtual void apply_central_impulse(impulse: Vector3)
void apply_impulse(impulse: Vector3, position: Vector3 = Vector3(0, 0, 0) ) 
int get_bone_id()
const bool get_simulate_physics()
bool is_simulating_physics()
```

还可以通过 `_integrate_forces()` 回调，它会在物理处理期间调用。使用 `custom_integrator` 属性
设置自定义的积分器，允许禁用默认行为，并为实体执行完全自定义的力积分。在力积分回调方法这里，可以通过 
PhysicsDirectBodyState 安全地修改物理相关的属性，它会处理好物理引擎的多线程计算同步问题：

```py
extends RigidBody2D

var thrust = Vector2(0, -250)
var torque = 20000

func _integrate_forces(state):
    if Input.is_action_pressed("ui_up"):
        state.apply_force(thrust.rotated(rotation))
    else:
        state.apply_force(Vector2())
    var rotation_direction = 0
    if Input.is_action_pressed("ui_right"):
        rotation_direction += 1
    if Input.is_action_pressed("ui_left"):
        rotation_direction -= 1
    state.apply_torque(rotation_direction * torque)
```

像 Node3D 中的 ``set_global_transform()`` 或者 ``look_at()`` 都不能直接在刚体中使用，
以下是一个刚体的 ”look_at" 方法实现，间接通过刚体 ``angular_velocity`` 旋转角速度来实现：

```py
extends RigidBody

func look_follow(state, current_transform, target_position):
    var up_dir = Vector3(0, 1, 0)
    var cur_dir = current_transform.basis * Vector3(0, 0, 1)
    var target_dir = (target_position - current_transform.origin).normalized()
    var rotation_angle = acos(cur_dir.x) - acos(target_dir.x)

    state.angular_velocity = up_dir * (rotation_angle / state.step)

func _integrate_forces(state):
    var target_position = $my_target_node3d_node.global_transform.origin
    look_follow(state, global_transform, target_position)
```


### 🟠🔵 CharacterBody 运动角角色
- https://docs.godotengine.org/en/latest/tutorials/physics/kinematic_character_2d.html
- [Physics Platformer](https://github.com/godotengine/godot-demo-projects/tree/master/2d/physics_platformer)
- [Platformer 3D](https://github.com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character)
- [Kinematic Character 3D](https://github.com/godotengine/godot-demo-projects/tree/master/3d/kinematic_character)
- [RigidBody Character 3D](https://github.com/godotengine/godot-demo-projects/tree/master/3d/rigidbody_character)

物理引擎有两类角色控制方法：

- **dynamic character controller** 
- **kinematic character controller**

一些物理引擎，如 Havok，将动态角色控制器视为最佳选项，而其他物理引擎（PhysX）则更倾向于推广运动学引擎。

动态角色控制器使用具有无限惯性张量的刚体，它是一个不能旋转的刚体。物理引擎总是让物体移动和碰撞，然后
一起解决它们的碰撞。这使得动态角色控制器能够与其他物理对象无缝交互，如平台演示中所示。然而，这些互动
并不总是可预测的。碰撞可能需要一帧以上的时间才能解决，因此几次碰撞可能会产生微小的位移。这些问题可以解决，
但需要一定的技能。

运动学角色控制器始终假设以非碰撞状态开始，并始终移动到非碰撞状态。如果它开始时处于碰撞状态，它会像
刚体一样试图释进入自由态，但这是例外，而不是规则。这使得它们的控制和运动更加可预测，更易于编程。然而，
作为一个缺点，它们不能直接与其他物理对象交互，除非通过手工编写代码完成。

使用运动学角色节点时，建议使用 physics process 回调，因为它会在物理引擎开始一轮计算之前调用，在
些进行的属性修改会被同步到物理引用服务器上，并且以固定的周期调用，即传入的 `delta` 值始终恒定。这也
使得物理、运动计算工作更可预测。

运动角角色本身支持碰撞，但是需要使用 CollisionShapes 提供检测边界定义，所以 KinematicBody2D
经常将 CollisionShapes 作为子节点添加到场景中。碰撞中使用到的数据由 KinematicCollision2D/3D
类型中保存。

![KinematicBody2D](https://docs.godotengine.org/en/latest/_images/kbscene.png)


CharacterBody 是 KinematicBody 的新版本称谓，有两个方法用于执行移动和碰撞的响应：

- move_and_collide() 移动并在碰撞时停止，返回一个包含碰撞信息的 KinematicCollision 对象；
- move_and_slide() 移动并以滑动方式响应碰撞，返回滑动速度，通过 get_slide_collision() 获取碰撞信息。

```py
extends PhysicsBody2D

var velocity = Vector2(250, 250)

# Get the gravity from the project settings to be synced with RigidDynamicBody nodes.
var gravity = ProjectSettings.get_setting("physics/2d/default_gravity")

func _physics_process(delta):

    velocity = move_and_slide(velocity, Vector2(0, -1))
    
    var collision_info = move_and_collide(velocity * delta)
    if collision_info:
        var collision_point = collision_info.position
        velocity = velocity.bounce(collision_info.normal)
```

运动学角色通常是由玩家直接控制的，除了碰撞检测，不能像刚体那样更真实地模拟自然环境中物体的力学表现。
比如，刚体在落到斜坡时，会旋转心使用其表面紧贴斜坡，而运动角角色就没有这样的物理模拟效果。


### 🟠🔵 SoftBody 软件
- https://docs.godotengine.org/en/latest/tutorials/physics/soft_body.html


### 🟠🔵 Skeleton 骨架动画
- [Godot 4 IK程序化骨骼动画](https://www.bilibili.com/video/BV1Me411L7vN/)


### 🟠🔵 Particles 粒子特效
- https://docs.godotengine.org/en/latest/tutorials/performance/vertex_animation/controlling_thousands_of_fish.html
- https://docs.godotengine.org/en/latest/tutorials/shaders/shader_reference/particle_shader.html
- https://docs.godotengine.org/en/latest/classes/class_particleprocessmaterial.html
- https://docs.godotengine.org/en/latest/classes/class_renderingserver.html
- [New improvements for GPUParticles in Godot 4.0](https://godotengine.org/article/improvements-gpuparticles-godot-40/)
- [Mesh level of detail (LOD)](https://docs.godotengine.org/en/latest/tutorials/3d/mesh_lod.html)
- [Particle systems (2D)](https://docs.godotengine.org/en/latest/tutorials/2d/particle_systems_2d.html)
- [Godot 3's renderer design explained](https://godotengine.org/article/godot-3-renderer-design-explained/)
- [Turbulence/Noise for ParticleMaterial (2D / 3D)](https://github.com/godotengine/godot/pull/55387)
- [Godot 4.x - 2D+3D 粒子扰动预览](https://www.bilibili.com/video/BV1zS4y117g9/)
- godot\servers\rendering\renderer_rd\shaders\particles.glsl

按坐标维度，Godot 粒子特效可以分为 2D 和 3D 两类。按运算方式不同分为 CPU 和 GPU 两类，后者能
利用多流水线并行计算的 GPU 资源，创建项目时选择 GLES3 就可以使用更高级的 GUP API，Godot 提供
默认的粒子着色器为 particles.glsl，粒子节点的几乎所有属性都是按此着色程序来进行设置的。另外，
使用 GLES2 后端的项目则会使用 CPU 粒子特效。

粒子是计算机图形处理中用于大量物体的一处计算处理方式，像爆破、烟火、烟雾等等，这些难以用单独网格模型
实现的效果都是粒子系统的用武之地。

粒子系统基本的工作模型是，围绕粒子发射器，大量的粒子由发射器按参数释放出来。为了系统高效，粒子被设计
成有生命周期的物体，超过时间就可以回收占用的资源。粒子参根据具体实现模型不同，基本上有随机性属性、颜色、
大小、位置、速度、旋转、发散等等。二维粒子可以指定形状，用于发射粒子。

三维空间下可以设置粒子碰撞形状还有扰动节点 GPUParticlesAttractor3D，调整其位置、强度等参数，就
可以对粒子系统产生扰动效果，增加随机性。

3D 粒子材质有 Draw Passes，每个 Pass 可以指定一个 Mesh 资源进行渲染，相当于 2D 粒子中设置纹理。
每个网格体都可以指定材质，比如创建一个四边面 **QuadMesh**，这是没有厚度的几何体，当相机位在其侧面时，
就会看不到这个面，可以在材质参数中打开 **Billboard** 公告板功能，这个功能就是用来将一个时刻朝向相机，
以避免侧面看不见的情况。

所有物理系统参数都可以随机化：

    initial_value = param_value + param_value * randomness

制作粒子特效时，可以打开 Emitting 和关闭 One Shot，这样只可以重复播放效果方便实时监测。

导入外部时，可以生成 mesh LOD，通过 MultiMesh 和粒子系统，可以实现丰富的特效。

|     Godot 3.5     |               Godot 4.0               |
|-------------------|---------------------------------------|
| CPUParticles2D    | CPUParticles2D                        |
| GPUParticles2D    | GPUParticles2D                        |
| CPUParticles      | CPUParticles3D                        |
| GPUParticles      | GPUParticles3D                        |
| ParticlesMaterial | ParticleProcessMaterial               |
|                   | GPUParticlesAttractor3D               |
|                   | -->GPUParticlesAttractorBox3D         |
|                   | -->GPUParticlesAttractorSphere3D      |
|                   | -->GPUParticlesAttractorVectorField3D |
|                   | GPUParticlesCollision3D               |
|                   | -->GPUParticlesCollisionBox3D         |
|                   | -->GPUParticlesCollisionHeightField3D |
|                   | -->GPUParticlesCollisionSDF3D         |
|                   | -->GPUParticlesCollisionSphere3D      |

ParticleProcessMaterial 和旧版本的 ParticlesMaterial 材质是用来处理 GPU 粒子属性的资源对象。
可以使用着色器的方式实现粒子材质，定义粒子属性与行为。例如，可以设置碰撞模式，COLLISION_RIGID 模式
与刚体可以碰撞。HIDE_ON_CONTACT 模式在碰撞时隐藏粒子。

材质中 Next Pass 设置要用于下一个过程的材质，将使用不同的材质再次渲染对象。但是这个属性指定的材质
只适用于 Spatial 节点，以及使用 SpatialMaterials 和 ShaderMaterials 着色器。

注意粒子碰撞使用 GPUParticlesCollision3D 节点，而不是 PhysicsBody3D 节点，但粒子作为子节点。
对于 2D 粒子，只使用 LightOccluder2D 节点进行碰撞。这个节点用于遮挡 Light2D 投射的光，投射阴影。


Godot 4.0 的粒子系统按 `RenderingServer` 接口实现，这是所有可视元素的底层处理服务器。作为最
常用的接口，引擎为它定义了一个全局符号 `RS` 来引用它的 singleton。这个接口提供了直接创建着色器
资源的 API，也提供了给几何体设置着色器，或给着色器全局变量赋值的 API。此外，还定义了一个全局符号
`RSG` 引用 `RenderingServerGlobals`，这个类型对象只包含全局静态成员，引用各种底层服务器对象，
包括线程启用标志 threaded。

其中，有一个重要的全局类 `RendererSceneCull`，它代表了全局场景处理器，里面包含了大量图形学概念。
是渲染方法接口 `RenderingMethod` 的具体实现。具体还有 `RendererSceneRender` 接口，待深究。

```C++,ignore
// godot\servers\rendering\renderer_scene_cull.h
// godot\servers\rendering\renderer_scene_render.h
void RendererSceneCull::update() {
    //optimize bvhs

    uint32_t rid_count = scenario_owner.get_rid_count();
    RID *rids = (RID *)alloca(sizeof(RID) * rid_count);
    scenario_owner.fill_owned_buffer(rids);
    for (uint32_t i = 0; i < rid_count; i++) {
        Scenario *s = scenario_owner.get_or_null(rids[i]);
        s->indexers[Scenario::INDEXER_GEOMETRY].optimize_incremental(indexer_update_iterations);
        s->indexers[Scenario::INDEXER_VOLUMES].optimize_incremental(indexer_update_iterations);
    }
    scene_render->update();
    update_dirty_instances();
    render_particle_colliders();
}
```

渲染服务器的默认实现为`RenderingServerDefault`，其构造器中会初始化 RSG 引用的各种全局服务器。

```C++,ignore
// godot\servers\rendering_server.h
    Dictionary[]    get_shader_parameter_list ( RID shader ) const
    void            global_shader_parameter_add ( StringName name, GlobalShaderParameterType type, Variant default_value )
    Variant         global_shader_parameter_get ( StringName name ) const
    PackedStringArray   global_shader_parameter_get_list ( ) const
    GlobalShaderParameterType   global_shader_parameter_get_type ( StringName name ) const
    void    global_shader_parameter_remove ( StringName name )
    void    global_shader_parameter_set ( StringName name, Variant value )
    void    global_shader_parameter_set_override ( StringName name, Variant value )

    Variant instance_geometry_get_shader_parameter ( RID instance, StringName parameter ) const
    Variant instance_geometry_get_shader_parameter_default_value ( RID instance, StringName parameter ) const
    Dictionary[] instance_geometry_get_shader_parameter_list ( RID instance ) const
    void    instance_geometry_set_shader_parameter ( RID instance, StringName parameter, Variant value )

    void material_set_shader ( RID shader_material, RID shader )

    RID     shader_create ( )
    String  shader_get_code ( RID shader ) const
    RID     shader_get_default_texture_parameter ( RID shader, StringName name, int index=0 ) const
    Variant shader_get_parameter_default ( RID shader, StringName name ) const
    void    shader_set_code ( RID shader, String code )
    void    shader_set_default_texture_parameter ( RID shader, StringName name, RID texture, int index=0 )
    void    shader_set_path_hint ( RID shader, String path )
```

底层系统中使用大量宏编程，比如 `PhysicsServer3D` 经过宏编程包装成 `PhysicsServer3DWrapMT`，
源代码阅读器可能难以直接定位相关 API。

宏编程中使用了 `FUNC$VER` 这样的格式，版本号代表要定义的方法使用的参数个数。另外，后缀 R 表示所
定义方法的返回类型，C 表示 const override，S 代表使用 SYNC_DEBUG。宏函数最大版本为 FUNC15，
即定义一个使用 15 个参数的方法。

比如，以下使用 `FUNC1RC` 定义一个方法用于获取着色器的全局参数，方法返回值类型为 Variant，而唯一
的一个参数是 const StringName &，函数签名后缀为 const override。

```C++,ignore
// FUNC1RC(Variant, global_shader_parameter_get, const StringName &)
// virtual Variant global_shader_parameter_get( const String& p1) const override

// godot\core\templates\command_queue_mt.h
// godot\servers\server_wrap_mt_common.h
#define FUNC1RC(m_r, m_type, m_arg1)                                                \
    virtual m_r m_type(m_arg1 p1) const override {                                  \
        if (Thread::get_caller_id() != server_thread) {                             \
            m_r ret;                                                                \
            command_queue.push_and_ret(server_name, &ServerName::m_type, p1, &ret); \
            SYNC_DEBUG                                                              \
            return ret;                                                             \
        } else {                                                                    \
            command_queue.flush_if_pending();                                       \
            return server_name->m_type(p1);                                         \
        }                                                                           \
    }
```

底层服务器经常会使用到 ServerName 或者 server_name，它们是一个全局符号，可以引用不同的服务系统。
物理系统中，引用的是物理服务器；在渲染服务器中，如以上使用命令队列的宏定义中，就是粒子渲染材质存储服务：

```C++,ignore
// godot\servers\rendering\rendering_server_default.h
#define ServerName RendererMaterialStorage
#define server_name RSG::material_storage

    FUNC3(global_shader_parameter_add, const StringName &, GlobalShaderParameterType, const Variant &)
    FUNC1(global_shader_parameter_remove, const StringName &)
    FUNC0RC(Vector<StringName>, global_shader_parameter_get_list)
    FUNC2(global_shader_parameter_set, const StringName &, const Variant &)
    FUNC2(global_shader_parameter_set_override, const StringName &, const Variant &)
    FUNC1RC(GlobalShaderParameterType, global_shader_parameter_get_type, const StringName &)
    FUNC1RC(Variant, global_shader_parameter_get, const StringName &)

    FUNC1(global_shader_parameters_load_settings, bool)
    FUNC0(global_shader_parameters_clear)

// godot\servers\physics_server_2d_wrap_mt.h
   #define ServerName PhysicsServer2D
   #define ServerNameWrapMT PhysicsServer2DWrapMT
   #define server_name physics_server_2d

// godot\servers\physics_server_3d_wrap_mt.h
// godot\ervers/physics_server_3d.h
   #define ServerName PhysicsServer3D
   #define ServerNameWrapMT PhysicsServer3DWrapMT
   #define server_name physics_server_3d
```

底层服务器使用多线程命令队列来管理各种操作，每个服务器对象都有命令队列 `CommandQueueMT`，所有
命令都通过入栈的形式执行操作，如 push、 push_and_ret、 push_and_sync 分别代表无反回值的命令、
有返回值的命令，和同步命令操作等等，再另外作深入探索。


粒子渲染材质存储服务定义在 `RendererParticlesStorage` 接口，`ParticlesStorage` 提供实现，
负责引擎的渲染服务与着色器的数据交流。

```C++
// godot\servers\rendering\storage\particles_storage.h
// godot\servers\rendering\renderer_rd\storage_rd\particles_storage.h
// godot\drivers\gles3\storage\texture_storage.h
// godot\drivers\gles3\storage\material_storage.h
// godot\drivers\gles3\storage\particles_storage.h
// godot\servers\rendering\rendering_device.h
// godot\servers\rendering\renderer_rd\shaders\particles.glsl
```

以下是默认的渲染服务器的 draw() 方法简要流程，其中包含了更新粒子系统，最主要的是调用粒子处理方法：

    +=================================+    +=================================+
    | RenderingServerDefault          |    | ParticlesStorage                |
    |---------------------------------|    |---------------------------------|
    | ======================== draw() |    | ========== _particles_process() |
    | ---------------v--------------  |    | TextureStorage ...              |
    | command_queue:                  |    | MaterialStorage ...             |
    |            ->push(_thread_draw) |    | ParticlesStorage ...            |
    | ---------------v--------------  |    | RenderingDevice ...             |
    | ======================= _draw() |    | ->compute_list_begin()          |
    |   emit_signal("frame_pre_draw") |    | ->compute_list_bind_compute_pipeline() |
    | ---------------v--------------  |    | ->compute_list_bind_uniform_set()  |
    | RendererCompositor:             |    | ->compute_list_set_push_constant() |
    |                 ->begin_frame() |    | ->compute_list_add_barrier()    |
    | RendererSceneRender:            |    | ->compute_list_end()            |
    |                      ->update() |    |                                 |
    | RendererParticlesStorage:       |    |                                 |
    |            ->update_particles() | -> |                                 |
    | RenderingMethod:                |    +=================================+
    |               ->render_probes() |
    | RendererViewport:               |
    |              ->draw_viewports() |
    | RendererCanvasRender:           |
    |                      ->update() |
    | RendererCompositor:             |
    |                   ->end_frame() |
    | RenderingMethod:                |
    | ->update_visibility_notifiers() |
    | RendererCanvasRender:           |
    | ->update_visibility_notifiers() |
    | ---------------v--------------  |
    |  emit_signal("frame_post_draw") |
    +=================================+


粒子属性面板内容参考：

- Texture 在粒子上显示的纹理。
- Time 生存周期参数。
    - Lifetime 生命周期，粒子在场景中存活的时间。
    - One Shot 单次触发粒子释放，不会循环进行。
    - Preprocess 预计算可以让粒子计算直接进入计算过程，而不是等到加载粒子到场景后从初始状态开始。
    - Speed Scale 粒子运动速度缩放。
    - Explosiveness 爆发度，1 表示完全暴发，0 为平均发射粒子。
    - Randomness 设置生存周期的随机性。
    - Fixed FPS 设置粒子渲染帧率，但不影响粒子系统的运算帧率。
    - Fract Delta 是否启用分数增量，粒子着色器变换矩阵可以增值 PARTICLE.velocity * local_delta。
- Drawing 绘图参数
    - Visibility Rect 可视矩形区，需要超出屏幕时保持粒子时，设置大一点的可视区。
    - Local Coords 粒子是否使用父节点的局部坐标空间。false 表示使用全局坐标。
    - Draw Order 粒子绘制顺序，缺省值：DRAW_ORDER_INDEX，可以按生成序，或者反序。

ParticleProcessMaterial 粒子材质参数参考：

- Direction 设置一个矢量指示粒子速度方向，与初始速度决定运动速度。
    - Spread 散射角度，粒子发射方向范围从 +spread 到 -spread。
    - Flatness 平滑度设置为 1 相当于没有散射。
- Gravity 设置一个矢量指示重力大小的方向。
- Initial Velocity 初始速度，准确地讲是速率 speed，而非 velocity。
- Angular Velocity 粒子自转角速度，Spin Velocity，可使用曲线控制，曲线左侧控制最开始发射的粒子。
- Orbit Velocity 轨道速度，会经过发射点形成圆形运动轨道，速度是每秒绕行周数，曲线水平轴表示生存时间。
- Linear Acceleration 线性加速度。
- Radial Acceleration 径向加速度，正值按原方向加速。生存时间够长，负值可以实现反向运动。
- Tangential Acceleration 切向加速度，与当前速度垂直的加速度。曲线方式下，水平轴表示粒子生存时间。
- Damping 速度阻尼，对角度、轨道等旋转运动无效。曲线控制时，水平轴表示粒子生存时间。
- Angle 粒子旋转角度，使用曲线控制时，水平轴表示粒子生存时间。
- Scale 粒子缩放，可以用曲线控制，曲线从左到右表示粒子的发射时间，倍数取曲线值与 scale 乘积。
- Color 颜色调制，白色无效果。
    - Color 或 Color Ramp 渐变左侧表示每个粒子的初始颜色。颜色会和 Particle2D 的纹理相乘。
    - Color Random 指定渐变，粒子的颜色将按发射顺序沿着 GradientTexture 变化。
- Hue variation 粒子色调。
    - Variation 粒子的初始色调，可以结合随机性使用。
    - Variation Curve 粒子沿着 CurveTexture 改变色调。

除了以上基本的粒子属性，以下是几个重要的粒子效果设置，包括：

- Trail 尾迹、残影效果
- Particles Animation 粒子动画
- Emission Shapes & Emission Mask 发射形状与遮挡功能


Flags 标志位设置，轨道运动只在 Disable Z 激活时有效，如果不禁止 Z 轴移动，方向 spread 有副作用。
其他 particle_flags 参考 `ParticleProcessMaterial::_update_shader()` 的着色器配置流程。


Animation 粒子动画，如果直接设置此属性，点击粒子材质切换面板时，可能会在节点显示提示信息：粒子动画
需要和 `CanvasItemMaterial` 中的动画选项结合使用。也就是要为 2D 节点创建材质，并且设置粒子动画为
激活状态，Particles Animation 勾选状态。即将 CanvasItem 当作 Sprite Animation 来使用，对其
进行矩形切割成格子，就像 `AnimatedSprite` 节点那样。

此时，材质面板出现相应的三个选项，分别用于指定格子列数、行数和循环：

- Particles Anim H Frames
- Particles Anim V Frames
- Particles Anim loop

回到粒子材质面板，可以指定粒子动画播放帧率，速度为 0 就是静态帧。设置粒子动画偏移，Offset 指定的
是所有 Sprites 的百分比偏移位置。使用曲线设置 Speed 或 Offset，曲线水平轴为粒子生存时间。



2D 粒子可以在 **Emission Shapes** 指定一个形状，点、矩形、圆形等，用来确实粒子发射的起始点、区域。
ParticlesMaterial 提供了 Emission Mask 发射遮挡功能，它可以按纹理资源来生成粒子发射区域、方向。
创建粒子节点后，在工具栏中应显示 "Particles" 粒子菜单，选择 Load Emission Mask。

![Load Emission Mask](https://docs.godotengine.org/zh_CN/latest/_images/emission_shapes2.png)

Emission Mask 对话框提供三种发射遮挡类型以及一个取色选项，纹理图像中的色彩、透明区都会影响结果:

- Solid Pixels 实心像素：纹理任何区域都可以产生粒子，透明区域除外。
- Border Pixels 边界像素：从图像中检测边缘，粒子将从纹理的外边缘产生。
- Directed Border Pixels 有向边界像素：类似于边界像素，但按初始速度从边界向外发射粒子。
- Capture from Pixel 发射色彩，会使粒子在其产生点处继承遮挡材质的颜色.

确定生成遮挡后，程序就会为粒子设置好材质，可以回到粒子属性面板 Emission Shape 中查看。需要注意，
不应该直接在属性面板中添加图像 Point Texture 或 Color Texture，程序需要通过 Load Emisson Mask
菜单执行数据处理工作，才能正确使用 Emisson Mask。


Trail 尾迹、残影效果，粒子数量与除数 Divisor 相除取 ceiling 值为发射的粒子数量，余下全部粒子
将作为尾迹效果粒子。

比如，粒子发射数量 Amount = 10，而 Divisor = 7，即发射 2 个粒子，其余粒子将作为发迹效果使用。
尾迹也受到爆发属性的影响，如果 Explosiveness = 1，那么尾迹也会随其它粒子一起发射。

- **Size Modifile** 指定 CurveTexture 设置控制轨迹粒子的大小变化的曲线。
- **Color Modifile** 指定 GradientTexture 控制轨迹粒子的颜色变化。

以上是 Godot 3.5 的操作，Godot 4.0 版本中的 2D 粒子尾迹使用网格蒙皮的方式。新版本中，通过设置
Section 来控制尾迹的精细度，另外细分 Subdivisions 数值越大也越精细。通过 Lifetime 控制尾迹的
长度，时间越长，尾迹越长，这与旧版本单独绘制一连串的尾迹粒子的方式有很大的不同。

另外，Godot 4.0 还增加多个粒子材质功能，同时支持 `emit_particle()` 手动发射：

- Turbulence 湍流扰动
- Sub Emitter 子发射器系统，指定一个子发射器在着色器中发射粒子。
- Collision 碰撞，Rigid 或 Hide on Contact 两种碰撞响应，前者碰撞后反弹，后者会隐藏粒子。
- Attrator Interaction 吸收器交互，使物体向 Sphere 或 Box 中心移动。

子发射器有三种触发方式：At Constant、At End、At Collision。以后者为例，在粒子碰撞时触发子发射器。
在粒子材质中，给 Sub Emitter 属性指定一个发射器，在粒子碰撞事，就会触发它发射粒子。比如，机枪扫射
的子打中玻璃瓶，瓶的碎片四射，这种情况是一级发射器加子发射器的效果。


Baked SDF Collision
Still, for complex interiors, creating all the collisions with boxes and spheres can be a hassle. Additionally, you may want collider objects with more complex shapes to interact with particles.

To solve this, the SDF collider was added. It bakes an area of a custom resolution as a signed distance field. This allows approximate complex collisions with geometry (without having to test the actual geometry, which is expensive).
烘焙SDF碰撞

尽管如此，对于复杂的内部，用盒子和球体制造所有的碰撞可能会很麻烦。此外，您可能希望具有更复杂形状的碰撞器对象与粒子交互。
为了解决这个问题，添加了SDF对撞机。它将自定义分辨率的区域烘焙为带符号的距离字段。这允许与几何体发生近似复杂的碰撞（无需测试实际几何体，这很昂贵）。

Heightfield Collision
While SDF collision works great for certain objects and interiors, it would require too much memory to be used in exteriors. For this, heightfield collision has more advantages.

作为粒子的基本中有几个特别的资源类型 primitive_meshes.h ：

- **ArrayMesh** 这是 Godot 网格资源处理类，本身不是基本体，常用于几何体的代码处理方式。
- **TextMesh** 文字网格，只支持从 DynamicFont 矢量字体的轮廓生成，需要设置 Text 属性及字体；
- **QuadMesh** 四边面基本体，没有厚度、细分，适合于布告板材质，新版本中作为 PlaneMesh 子类形；
- **PointMesh** 单顶点基本体；

PointMesh 是只有单个顶点的基本体，它可以用于粒子系统。它甚至都不能叫做 Mesh，但是光栅化时它就是
一个固定大小的方块，即不论远近地看，它在屏幕上的大小是恒定的，按 Point Size 指定大小显示。这种方块
不是四个顶点的那种矩形。它更涉及的功能少，更节省资源。要使用粒子着色器的颜色，就要在粒子材质中勾选
Vertex Color - Use As Albedo，即表示使用粒子着色器 Color 属性。

PointMeshe 作为粒子使用时，必需激活 SpatialMaterial 材质的 `flags_use_point_size` 标志。
同时设置材质参数中的 `params_point_size`，粒子尺寸可以使用着色器的 `POINT_SIZE` 符号访问。
此外，一些顶点操作的常规功能会失效，包括布告牌模式、增殖和剔除面，billboard, grow, cull face。

QuadMesh 基本体一般同需要启用 Parameters - Billboard Mode，否则在背面是看不见的，从其构造器
可以了解到，默认的面朝向是 `set_orientation(FACE_Z)`，启用布告板模式后，就一直朝向镜头。另外，
设置 Flip Faces 会反转绘制三角形的顶点顺序，会影响 Cull Back。

虽然可以给粒子材质设置发光 Emission，但这只是一种颜色，非光照模拟，所以不会给周围环境带来光效。


### 🟠🔵 Ray-casting 射线投射工具
- https://docs.godotengine.org/en/latest/tutorials/physics/ray-casting.html
- https://docs.godotengine.org/en/latest/classes/class_physicsserver2d.html
- https://docs.godotengine.org/en/latest/classes/class_physicsserver3d.html
- https://docs.godotengine.org/en/stable/classes/class_physics2dserver.html
- https://docs.godotengine.org/en/stable/classes/class_physicsserver.html
- https://kidscancode.org/godot_recipes/3.x/kyn/raycast2d/

射线投射是游戏开发的一个常用工具，通过投射进行碰撞检测，可以获取到碰撞物体的信息，包括碰撞点坐标。
Godot 系统架构中，通过底层的 PhysicsServer 管理物理空间，这个空间记录了所有底层的信息，而场景树
只是前端可视部分。简单的投射工具 `RayCast2D` 或者 `RayCast3D` 节点，需要查询这个空间提供的底层
数据来实现碰撞检测，并在每一帧都返回检测结果。

此外，Godot 4 还新增了 ShapeCast2D/3D 形状投射工具。

物理系统的模拟计算是每一帧都在持续进行的，碰撞检测中要使用最新的碰撞信息，可以强制执行更新方法：

- force_raycast_update()
- force_shapecast_update()

两类投射工具都有强制更新碰撞信息的方法，执行它们就可以在当前帧获取到最新碰撞检测数据，而不必等待
下一个 physics process 调用。比如，射线的父节点改变了状态，就可以及时获取到这么变化。

物理引擎的运算周期可以在工程配置中设置，Physics Common，指定 Physics FPS。

物理空间对象归属于一个 World 对象，通过节点的 get_world 方法可以获取到世界对象，世界对象都有物理
空间资源的 RID 引用在 space 属性中，可以直接通过 Physics2DServer 或者 PhysicsServer3D 这些
底层服务器对象的 space_get_direct_state ( RID space ) 方法直接使用物理空间资源。

```py
    func _physics_process(delta):
        var space_rid = get_world_2d().space

        var space_state = PhysicsServer.space_get_direct_state(space_rid)
        var space_state = Physics2DServer.space_get_direct_state(space_rid)

        var space_state = PhysicsServer2D.space_get_direct_state(space_rid)
        var space_state = PhysicsServer3D.space_get_direct_state(space_rid)

        var space_state = get_world_2d().direct_space_state
        var space_state = get_world_3d().direct_space_state
```

Space 对象和射线求交相关的方法是 `intersect_ray()`，射线按线段的方式给出传播方向上的两点坐标，
通过 QueryParameters 传入查询服务 API，射线在这段行程中碰撞到的对象信息，作为查询结果保存在
字典对象中返回。

Godot 3.5 中只定义了两个 QueryParameters 类型，射线碰撞检测不需要使用查询参数对象：

- Physics2DShapeQueryParameters
- PhysicsShapeQueryParameters

Godot 4.x 新增 NavigationPath 和 Point、Ray 三类查询参数类型，射线碰撞需要使用查询参数类型：

- NavigationPathQueryParameters2D
- NavigationPathQueryParameters3D
- PhysicsPointQueryParameters2D
- PhysicsPointQueryParameters3D
- PhysicsRayQueryParameters2D
- PhysicsRayQueryParameters3D
- PhysicsShapeQueryParameters2D
- PhysicsShapeQueryParameters3D 

物理空间对象根据这些查询参数来执行相应的碰撞测试，并返回相应的数据，它们共通的属性如下，包括碰撞
对象的区域面积、物体，还有遮罩层。被测试对象的 collision_layer 和正在碰撞检测的对象遮罩层一致时，
碰撞才可能发生。此外，可以在 exclude 数组中显式指定一个列表，不需进行碰撞测试的对象都可以加入：

```py
    bool collide_with_areas = false
    bool collide_with_bodies = true
    int collision_mask = 0xFFFFFFFF
    Array[RID] exclude = []
```

其中，导航路径查询参数比较特别，在导航相关教程中说明。

除了这些共通的属性，根据不同物理类型的碰撞，具体的查询参数还包括一些专用的参数。比如，最简单的点查询
PhysicsPointQueryParameters2D 只包含一个二维坐标 `position` 参数用于 `intersect_point()
`进行二维空间的碰撞检测。检测结果返回的字典数据中包含以下内容：

- **collider**: The colliding object.
- **collider_id**: The colliding object's ID.
- **rid**: The intersecting object's RID.
- **shape**: The shape index of the colliding shape.

对于射线碰撞检测，`intersect_ray()` 需要给出 `from` 和 `to` 两个坐标表示线段，在这区间进行
碰撞检测，另外，还可以指定 hit_from_inside 来检测物体内部的碰撞，这种情况下，返回字典中的法向量
为零值，表示没有方向。没有发生碰撞时，返回一个空值字典。

- **collider**: The colliding object.
- **collider_id**: The colliding object's ID.
- **normal**: The object's surface normal at the intersection point.
- **position**: The intersection point.
- **rid**: The intersecting object's RID.
- **shape**: The shape index of the colliding shape.

用于形状碰撞检测的 PhysicsShapeQueryParameters 是所有查询参数中最多专用参数的类型，这也是最
常用的碰撞检测查询参数：

```py
    float margin = 0.0
    Vector3 motion = Vector2(0, 0)]
    Resource shape
    RID shape_rid
    Transform3D transform = Transform2D(1, 0, 0, 1, 0, 0)
```

形状碰撞检测返回的是一个字典数组，intersect_shape() 方法的参数 max_results 控制求交结果数量：

- **collider**: The colliding object.
- **collider_id**: The colliding object's ID.
- **rid**: The intersecting object's RID.
- **shape**: The shape index of the colliding shape.


物理空间提供碰撞检测方法如下，PhysicsDirectSpaceState2D/3D 定义了类似的 API。其中，前缀为
intersect 的是碰撞检测方法，大部分方法都与形状碰撞检测或求交相关。

而 `cast_motion()` 检查 Shape3D 在不发生碰撞的情况下可以移动多远。返回的数组表示运动的安全和
不安全比例，数组元素值介于 0 和 1 之间。安全比例是在没有碰撞的情况下可以进行的运动的最大比例。
不安全比例是碰撞时必须移动的距离的最小比例。如果未检测到碰撞，返回 [1.0，1.0]。

注意：检测开始前，已经与之发生碰撞的任何 Shape 都将被忽略，例如在内部的碰撞。使用 `collide_shape()`
方法可以确定已经与之碰撞形状。

`collide_shape()` 方法检查给定的形状与空间的交点，结果数组包含形状与另一形状相交的点列表。返回
的点是一对接触点的列表。每一对的第一个位于 PhysicsShapeQueryParameters3D 对象中传递的形状中，
第二个位于物理空间中的碰撞形状中。

`get_rest_info()` 检查指定形状与空间中形状的交点，如果它与多个形状碰撞，将选择最近的一个。返回
的字典对象包含以下字段：

- **collider_id**: The colliding object's ID.
- **linear_velocity**: The colliding object's velocity Vector3. If the object is an Area3D, the result is (0, 0, 0).
- **normal**: The object's surface normal at the intersection point.
- **point**: The intersection point.
- **rid**: The intersecting object's RID.
- **shape**: The shape index of the colliding shape.

注意：`collide_shape()` 和 `get_rest_info()` 两个方法不考虑对象的运动特性。


Space 与投射相关 API 参考：

```py
# Godot 3.5 stable

    # godot-docs\stable\classes\class_canvasitem.rst
    World2D get_world_2d ( ) const

    # godot-docs\stable\classes\class_spatial.rst
    World get_world( )  const

    # godot-docs\stable\classes\class_world2d.rst
    Physics2DDirectSpaceState direct_space_state

    # godot-docs\stable\classes\class_world.rst
    PhysicsDirectSpaceState direct_space_state

# Godot 4.x beta

    # godot-docs\docs\classes\class_node3d.rst
    World3D get_world_3d ( ) const

    # godot-docs\docs\classes\class_world2d.rst
    PhysicsDirectSpaceState2D direct_space_state

    # godot-docs\docs\classes\class_world3d.rst
    PhysicsDirectSpaceState3D direct_space_state

# Space objects 

    # godot-docs\stable\classes\class_physics2ddirectspacestate.rst
         Array  cast_motion ( Physics2DShapeQueryParameters shape )
         Array  collide_shape ( Physics2DShapeQueryParameters shape, int max_results=32 )
    Dictionary  get_rest_info ( Physics2DShapeQueryParameters shape )
         Array  intersect_point ( Vector2 point, int max_results=32, Array exclude=[  ], int collision_layer=2147483647, bool collide_with_bodies=true, bool collide_with_areas=false )
         Array  intersect_point_on_canvas ( Vector2 point, int canvas_instance_id, int max_results=32, Array exclude=[  ], int collision_layer=2147483647, bool collide_with_bodies=true, bool collide_with_areas=false )
    Dictionary  intersect_ray ( Vector2 from, Vector2 to, Array exclude=[  ], int collision_layer=2147483647, bool collide_with_bodies=true, bool collide_with_areas=false )
         Array  intersect_shape ( Physics2DShapeQueryParameters shape, int max_results=32 )

    # godot-docs\stable\classes\class_physicsdirectspacestate.rst
         Array  cast_motion ( PhysicsShapeQueryParameters shape, Vector3 motion )
         Array  collide_shape ( PhysicsShapeQueryParameters shape, int max_results=32 )
    Dictionary  get_rest_info ( PhysicsShapeQueryParameters shape )
         Array  intersect_point ( Vector3 point, int max_results=32, Array exclude=[  ], int collision_layer=2147483647, bool collide_with_bodies=true, bool collide_with_areas=false )
    Dictionary  intersect_ray ( Vector3 from, Vector3 to, Array exclude=[  ], int collision_mask=2147483647, bool collide_with_bodies=true, bool collide_with_areas=false )
         Array  intersect_shape ( PhysicsShapeQueryParameters shape, int max_results=32 )

    # godot-docs\docs\classes\class_physicsdirectspacestate2d.rst
    PackedFloat32Array      cast_motion ( PhysicsShapeQueryParameters2D parameters )
    PackedVector2Array[]    collide_shape ( PhysicsShapeQueryParameters2D parameters, int max_results=32 )
            Dictionary      get_rest_info ( PhysicsShapeQueryParameters2D parameters )
            Dictionary[]    intersect_point ( PhysicsPointQueryParameters2D parameters, int max_results=32 )
            Dictionary      intersect_ray ( PhysicsRayQueryParameters2D parameters )
            Dictionary[]    intersect_shape ( PhysicsShapeQueryParameters2D parameters, int max_results=32 )

    # godot-docs\docs\classes\class_physicsdirectspacestate3d.rst
    PackedFloat32Array      cast_motion ( PhysicsShapeQueryParameters3D parameters )
    PackedVector2Array[]    collide_shape ( PhysicsShapeQueryParameters3Dint max_results=32 )
            Dictionary      get_rest_info ( PhysicsShapeQueryParameters3 parameters )
            Dictionary[]    intersect_point ( PhysicsPointQueryParameters3D parameters, int max_results=32 )
            Dictionary      intersect_ray ( PhysicsRayQueryParameters3D parameters )
            Dictionary[]    intersect_shape ( PhysicsShapeQueryParameters3D parameters, int max_results=32 )
```




## 🟡 Godot AI 有思想的精灵
- [17.游戏引擎Gameplay玩法系统：高级AI | GAMES104-现代游戏引擎：从入门到实践](https://www.bilibili.com/video/BV1iG4y1i78Q/)
- [Godot Recipes 3.x AI/Behavior](https://kidscancode.org/godot_recipes/3.x/ai/)

![Steering behavior](https://kidscancode.org/godot_recipes/3.x/img/ai_context_10.gif)


### 🟠🔵 GridMap 网格关卡地图
- [Using GridMaps](https://docs.godotengine.org/en/latest/tutorials/3d/using_gridmaps.html)
- [3D Platformer Demo](https://godotengine.org/asset-library/asset/125)
- [3D Kinematic Character Demo](https://godotengine.org/asset-library/asset/126)
- https://docs.godotengine.org/en/latest/classes/class_gridmap.html
- https://docs.godotengine.org/en/latest/tutorials/physics/collision_shapes_3d.html
- https://docs.godotengine.org/en/latest/tutorials/navigation/navigation_using_navigationmeshes.html

Gridmaps 是用于创建 3D 关卡的节点，相当于 2D 关卡中使用 TileMap，先用定义好一组 3D 网格，用于
生成 MeshLibrary，后续用于关卡地图的绘制。

执行菜单 Scene - Convert To - MeshLibrary... 将当前场景转换为 MeshLibrary 资源。

用于生成 MeshLibrary 的场景可以按这样的节点结构组织：

- 顶点使用一个 Node3D 节点；
- 子节点可以添加多个 MeshInstance3D 作为模型网格，这些子节点相当于 3D 地图的瓦片；

如果需要使用物理系统，还可以添加碰撞体，手动给风格添加 `StaticBody3D` 和 `CollisionShape3D`。
可以通过网格生成碰撞体，使用菜单 Mesh 生成单个 "Convex" 凸壳包围需要碰撞检测物体即可。应付复杂形状
的碰撞可以使用 "Trimesh Static Body"，它会生成紧贴模型各个部分的碰撞体。

生成 MeshLibrary 后，就可以在场景中通过 GridMap 使用它来绘制 3D 关卡地图。使用主视图中 GridMap
菜单，还可以旋转瓦片的模型，或者绘制平面所在的轴向或楼层。按下 `Shift` 拖动选区，使用菜单进行区域
操作，复制、清除等等。



### 🟠🔵 Navigation 多边形导航寻路算法
- https://docs.godotengine.org/en/latest/tutorials/navigation/navigation_introduction_2d.html
- https://docs.godotengine.org/en/latest/tutorials/navigation/navigation_using_navigationservers.html
- https://docs.godotengine.org/en/latest/tutorials/navigation/navigation_using_navigationagents.htm
- https://docs.godotengine.org/en/latest/tutorials/navigation/navigation_using_agent_avoidance.html
- https://docs.godotengine.org/en/stable/tutorials/physics/ray-casting.html
- [Real Time Navigation (3D)](https://docs.godotengine.org/en/3.6/tutorials/navigation/real_time_navigation_3d.html)
- [Navigation Polygon 2D](https://github.com/godotengine/godot-demo-projects/tree/master/2d/navigation)
- [3D Navigation Mesh](https://github.com/godotengine/godot-demo-projects/tree/master/3d/navmesh/)
- [Real Time Navigation (3D)](https://docs.godotengine.org/en/3.6/tutorials/navigation/real_time_navigation_3d.html)
- [Godot导航系统详解:导航基础](https://www.bilibili.com/video/BV1CG411g7P9/)

Godot 中的 AI 寻路方案大概有以下几种：

- AStar 寻路算法，对于自动生成的网格地图非常有用，结合多线程效率也高；
- Navigation2D 导航类，基于多边形，比较方便且实用，但是有较大的局限；
- RayCast2D 射线检测，对路径进行判断，有比较好的解决方案，但是算法复杂；
- 使用大量的 Area2D 对地图可行路径进行判断；

|           2D           |           3D           |   Type   |
|------------------------|------------------------|----------|
| Astar2D                | Astar3D                | Object   |
| NavigationServer2D     | NavigationServer3D     | Node     |
| NavigationRegion2D     | NavigationRegion3D     | Node     |
| - NavigationAgent2D    | - NavigationAgent3D    | Node     |
| - NavigationObstacle2D | - NavigationObstacle3D | Node     |
| NavigationPolygon      | NavigationMesh         | Resource |

Godot 4.x 版本后节点及对象名称的版本变化：

+------------------------------+-----------------------------+
| Old name (Godot 3.x)         | New name (Godot 4)          |
+==============================+=============================+
| NavigationMeshInstance       | NavigationRegion3D          |
| NavigationPolygonInstance    | NavigationRegion2D          |
| Navigation2DServer           | NavigationServer2D          |
| Navigation2D                 | Node2D                      |
| Navigation3D                 | Node3D                      |

新版本下的各种导航相关对象用途介绍：

- NavigationServer 导航服务实现寻路算法，用于计算导航路径；
- NavigationMap 为导航服务提供数据，将导航网格信息转换为用于路径查找的组合导航地图；
- NavigationRegion2D 二维导航网格，通过 NavigationPolygon 绘制多边形为地图提供 2D 可通行区域定义；
- NavigationRegion3D 三维导航网格，通过 NavigationMesh 为 3D 导航中使用的多边形区域定义；
- NavigationPathQueryObject 导航路径查询对象可以配合 NavigationPathQueryParameters 来定制导航；  
- NavigationAgent 导航代理使用导航服务计算出来的路径，为用户提供服务，例如按导航路径移动、避障；
- NavigationObstacle 由于障碍物不断移动而无法有效烘焙到导航网格，此节点用于给运动障碍物设置回避半径。
- NavigationLink 用于在导航不连通的两点之间创建路径链接，而不仅仅是沿着导航网格的表面行进，比如跨越间隙，zip-lines, teleporters。


在 Godot 3.x 中，Navigation2D 节点下需要设置一个 NavigationPolygonInstance 节点作为导航
网格的数据来源，其属性 navpoly 保存的是 **NavigationPolygon** 资源，即导航用的网格数据，这些数据
会被导航节点读取。新版本直接使用 map_get_path() 即可以计算出网格两点之间的路径，返回的是坐标数量由路径
的曲折度决定。两点之间没有障碍物，就只有一个点坐标。

Navigation2D 节点的 get_simple_path() 方法替代为 Navigation2DServer.map_get_path()。

```py
# Navigation2D node
PoolVector2Array get_simple_path(start: Vector2, end: Vector2, optimize: bool = true) const
# Navigation2DServer.map_get_path()
PoolVector2Array map_get_path(map: RID, origin: Vector2, destination: Vector2, optimize: bool, navigation_layers: int = 1) const

# NavigationServer2D.map_get_path()
PackedVector2Array map_get_path(map: RID, origin: Vector2, destination: Vector2, optimize: bool, navigation_layers: int = 1) const
```

在 3D 环境下也类似，Navigation3D 节点下需要设置一个 NavigationMeshInstance 节点作为导航
网格的数据来源，保存在 navmesh 属性中的 **NavigationMesh** 资源中。导航网格节点下可以设置
MeshInstance 作为道路模型的网格，这与导航无关，但可以用它来烘焙出导航网格数据。


2D 多边导航网格不像 NavigationMesh 可以烘焙生成，需要手动绘制多边形将通道包含在多边形内部。先绘制
最外部的多边形以包含所有路径区域，然后再绘制内部的多边形，将障碍区域包裹起来。并且目前 Godot 4 Beta
版本中图形操作界面还有不少问题：

- NavigationRegion2D 节点绘制多边形操作命令不能完全正确执行。
- 绘制好多边形后，导航网格地图数据没有相应更新，并且可能在同一点位置绘制重叠的多个顶点。
- 点击导航网格节点时，属性面板可能会隐藏不显示，需要将父节点隐藏后才能显示属性面板。
- 目前还不能对多边形进行更丰富的操作，例如多个基点的选择、复制、粘贴等。

为了利用多边形数据，可以将多边形顶点数据保存到独立的 NavigationPolygon 资源文件中。这个文件是文本
格式，所有顶点坐标会无序地记录到 vertices = PackedVector2Array() 列表中。定义在 polygons 属性
中的多边形由这些坐标序号表示，但这部分的多边形是计算出来的，并不是绘制的多边形。

用户绘制的最外层的多边形则保存在 outlines 属性中第一个 PackedVector2Array，它包含外层多边形的
顶点坐标，数据可能存在重复，并且也没有引用 vertices 定义的坐标序号。后续的 PackedVector2Array 顶点
表示其它内部的多边形。

用户绘制的多边形轮廓后续会转换成 NavigationMesh 资源，即和 3D 导航网格一样的处理流程，作为定义
NavigationServer 地图的区域使用。绘制轮廓多边形不能有交叠，否则不能正确计算出导航网格。推荐使用
3D 导航网格，Godot 提供了 NavigationMeshGenerator 可以直接将模型网格烘焙得到导航网格。

在绘制多边形时，顶点会显示相应的序号，如果序号不连续则可能有顶点重合，序号从 0 开始。多个顶点重叠，
结果看起来像一个顶点，这也可能是导致顶点移动等绘制命令不正常、地图数据不更新、NavigationPolygon
资源文件数据重复的原因。

为了搞清楚这些问题，可以使用标尺绘制一个多边形，并分析保存到资源文件中顶点数据。判断顶点是否重叠，
可以直接检查 polygons 中同一个 PackedInt32Array 引用的顶点序号是否有重复即可。如果顶点重叠，
那么同一个多边形就会有多人顶点引用相同坐标。


选择导航节点后，在 3D 视图中会出现 Bake NavMesh 按钮，它可以将子级的网格烘焙成导航网格。也可以
调用 bake_navigation_mesh 方法进行动态烘焙。注意，NavigationMesh 要设置 Source Geometry Mode：

- NaviMesh Children 此模式可以将子级 MeshInstance 网格烘焙成导航网格。
- Group with Children
- Group Explicit

后两种模式配合 Node - Groups 面板使用，需要显式指定一个节点组名称，不同的是后者直接将节点组名称关联
的节点作为几何网格数据来源，而 Group with Children 则将节点组的子级作为几何网格来源。

NavigationMesh 的一些属性说明：

- Cell size/height 设置导航网格的占用空间大小、偏移高度；
- Agents 代理设置：
    - agent_height 代理对象可以通过的的地板到天花板的高度，烘焙时按 cell_height 倍数取值；
    - agent_radius 代理使用的碰撞检测半径，值越大导航区被占用空间越多，烘焙时按 cell_size 倍数取值；
    - agent_max_climb 代理对象可以爬的最大台阶高度，烘焙时按 cell_height 倍数取值；
    - agent_max_slope 代理对象可以爬坡的最大角度，角度单位；

NavigationAgent 节点可以替代导航节点使用，它用于导航以避免碰撞。用于导航以到达某个位置，同时避免
静态、动态障物。使用往复速度障碍物 Reciprocal Velocity Obstacles (RVO) 来避免动态障碍物。
代理需要导航数据才能正常工作，默认情况下，此节点将注册到默认的世界导航地图。如果此节点是导航节点的
子节点，它将注册到导航节点的导航地图，可以使用 set_navigation() 设置导航节点。

通过 get_world() 方法取得 World2D/3D 对象，其 navigation_map 属性就是当前世界的默认导航地图。

注意：默认情况下，用于避免碰撞的昂贵计算是在线程中完成的。在没有线程支持的 HTML5 导出中，它们将在
主线程上完成，这可能会导致性能问题。

NavigationAgent 节点的属性说明：

- path_desired_distance 物体到目标位的距离小于这个值就认为已经到达路径中的位置，可以继承到导航路径的下一个位置；
- agent_height_offset 用于修正 NavigationMesh 中 agent_height 设置产生的地板高度偏移；
- path_max_distance 允许代理离开理想导航路径的最大距离，因为要试图避免碰撞，超过这个值将重新计算理想路径；
- target_desired_distance 导航到达此距离值就可以认为已经到达最终目标区域，而不必精确到达位置；
- navigation_layers 导航层设置，和导航节点的 Navigation Layers 设置配合使用；

NavigationAgent 方法简要说明：

- set_navigation_map(navigation_map: RID) 手动指定导航网格地图；
- set_velocity(velocity: Vector3) 给导航运动避障算法传入一个速度；
- set_target_location(location: Vector3) 设置导航目标位置；
- is_navigation_finished() 判断导航是否已经到达位置；
- get_next_location() 获取导航路径中的下一个位置，新版本中使用 get_next_path_position()；

设置避障速度后，在启用避障功能后会相应产生 velocity_computed(safe_velocity: Vector3) 信号，
由避障算法计算合适的运动速度，并通过信号的方式传递给用户。


在 Godot 4.x 中，使用 NavigationServer 对象来计算网格路径，这是抽象类，不能实例化，使用其提供
的静态方法来获取导航路径数据。

2D 与 3D 网格导航原理是相同的，NavigationServer2D 是一个前端，用于帮助将 Vector2(x，y) 转换
Vector3(x，0.0，z)，然后返回 NavigationServer3D API。

```py
func _unhandled_input(event: InputEvent):
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
        var map := get_world_3d().navigation_map
        var from := camera.project_ray_origin(event.position)
        var to := from + camera.project_ray_normal(event.position) * 1000
        var target_point := NavigationServer3D.map_get_closest_point_to_segment(map, from, to)

        # Set the path between the robot's current location and our target.
        path = NavigationServer3D.map_get_path(map, robot.position, target_point, true)
```

导航服务器中可以使用多个导航地图，通过 map_set_active() 方法激活并使用其中一个。地图对象可以关联
多个导航网格 NavigationRegion，导航网格又可以设置图层，图层是一个 32-bit bitmask。例如，设置
为图层 1 遮罩值就为 1，设置为图层 4，第四个比特的值对应为 8。图层可以模拟一把钥匙，拥有钥匙的玩家
可以通过一扇门，只需要在 map_get_path 查询导航路径时传入一个可以通过的网格图层。

注意，同时存在多个交叠的导航网格可能导致寻路出现“穿透”障碍的现象，并且导航网络是否显示都有效：

```py
    var map := get_world_2d().navigation_map
    var regions := NavigationServer2D.map_get_regions(map)
    var layer := NavigationServer2D.region_get_navigation_layers(regions[0])
    print("Navigation region layer: ", layer, regions)
```

摄像机对象提供几个光线投射方法，Ray-casting，可以获取射线方向上的目标位置坐标，游戏开发者可以用
光线投射来做瞄准、确定视线、测量距离之类的功能。这些方法都需要提供一个屏幕像素坐标作为射线的投射起点：

```py
Vector3 project_local_ray_normal(screen_point: Vector2) const
# Returns a normal vector from the screen point location directed along the camera.
# Orthogonal cameras are normalized. Perspective cameras account for perspective, 
# screen width/height, etc.
Vector3 project_position(screen_point: Vector2, z_depth: float) const
# Returns the 3D point in world space that maps to the given 2D coordinate in the 
# Viewport rectangle on a plane that is the given z_depth distance into the scene 
# away from the camera.
Vector3 project_ray_normal(screen_point: Vector2) const
# Returns a normal vector in world space, that is the result of projecting a point 
# on the Viewport rectangle by the inverse camera projection. This is useful for 
# casting rays in the form of (origin, normal) for object intersection or picking.
Vector3 project_ray_origin(screen_point: Vector2) const
# Returns a 3D position in world space, that is the result of projecting a point 
# on the Viewport rectangle by the inverse camera projection. This is useful for 
# casting rays in the form of (origin, normal) for object intersection or picking.
```

例如，在输入事件中，将鼠标点击的二维坐标位置映射为三维的投射起点 from，然后给定一个投射距离作为射线
的有效范围，以摄像机朝向即法向为投射方向，在射线的有效范围 from - to 两个坐标连线之内检测导航地图中
的最近点。project_ray_normal 返回世界空间中的法向量，是通过摄影机反向投影在视口矩形上投影点的结果，
这对于以（原点、法线）形式投射光线以进行对象相交或拾取非常有用。亦可直接使用世界空间 intersect_ray
方法来探测物理刚体碰撞点：

```py
extends Spatial

onready var camera = $"../CameraBase/Camera"
onready var navigation_agent = $NavigationAgent
onready var robot = $"../RobotBase2"

var SPEED = 10

func _physics_process(delta):
    if not navigation_agent.is_navigation_finished():
        var step_size = delta * SPEED
        var nextpoint = navigation_agent.get_next_location()
        var direction = nextpoint - robot.translation
        robot.translation += direction.normalized() * step_size

func _unhandled_input(event):
    if event is InputEventMouseButton and event.button_index == BUTTON_LEFT and event.pressed:
        var from = camera.project_ray_origin(event.position)
        var to = from + camera.project_ray_normal(event.position) * 100
        #var target_point = get_closest_point_to_segment(from, to)
        var collision = get_world().direct_space_state.intersect_ray(from, to)
        print({"from":from, "to":to, "collision":collision, "robot":robot.translation})
        if collision:
            navigation_agent.set_target_location(collision.position)
            print("next ", navigation_agent.get_nav_path(), navigation_agent.get_next_location(), collision.position)
```

可以使用 ImmediateGeometry 节点将导航路径绘制出来，Godot 4.x 使用 ImmediateMesh 替代，
PRIMITIVE_LINE_STRIP 绘图方式表示点与点之间进行连线，和 OpenGL 的图元定义一致：

```py
func draw_path(path_array):
    var im = get_node("ImmediateGeometry")
    # im.set_material_override(spatialmaterial)
    im.clear()

    im.begin(Mesh.PRIMITIVE_POINTS, null)
    im.add_vertex(path_array[0])
    im.add_vertex(path_array[path_array.size() - 1])
    im.end()
    
    im.begin(Mesh.PRIMITIVE_LINE_STRIP, null)
    for x in path:
        im.add_vertex(x)
    im.end()
```

### 🟠🔵 Astart 导航寻路算法
- https://docs.godotengine.org/en/latest/classes/class_astar3d.html
- [Grid-based Navigation with Astar](https://github.com/godotengine/godot-demo-projects/tree/master/2d/navigation_astar)
- [Amit 讲 A* 寻路算法](https://blog.csdn.net/denghecsdn/article/details/78778769)
- [Amit’s A* Pages](http://theory.stanford.edu/~amitp/GameProgramming/)
- godot-docs\tutorials\navigation\navigation_introduction_2d.rst
- godot-docs\tutorials\navigation\navigation_introduction_3d.rst

寻路是基础的游戏算法，是 AI 模拟人类导航探索能力的方式。

提到游戏 AI 就不得不说 Pacman 经典吃豆人游戏，作为经典游戏，其最有特色的部分就是带有 AI 原型的四个幽灵对手：

- 红色的幽灵 Blinky 代表执着，它会一直跟着玩家走，并且随着玩家吃的豆越多移动速度会变的越快。
- 粉色的幽灵 Clyde 代表预知，它会以玩家路径的前方为目的地，经常会围堵玩家，官方的名称叫做“埋伏者”。
- 青色的幽灵 Linky 代表变化，它有时候会追着玩家走，有时候又会提前堵在玩家必经的路上，善于变化。
- 黄色的幽灵 Pinky 代表随意，它的行动路线完全随机，甚至大多数时间它会完全不理会玩家，一个人自己在地图上漫游。

- [Play Pacman Online](https://jimboyeah.github.io/pacman/)

经典寻路算法是 `Dijkstra` 算法，是算法名称也是作者名称。算法基于格子 Grid，格子有八个移动方向，
但是效率低下，真正在项目中实用的是经过优化的 `A*` 寻路算法。相对于迪杰斯特拉的算法，不同点在于，
加了一个启发系数，极大降低了搜索空间，提高算法效率，没有这个算法估计很多游戏的 NPC 寻路都跑不动。

戴克斯特拉算法 Dijkstra’s algorithm 是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出的最短寻路算法，
使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。

在一些情况下，如果可以预先计算出每个节点到终点的直线距离，则可以利用这个信息更快的到达终点。虽然，
给定一张带有阻碍物的格子地图，人脑可以瞬间就通过眼睛观察到的图像得到起点到目标点的最佳路径。但是
程序需要数据，要得到这个最佳数据，就需要对全部输入的格子进行处理，优化算法来提高工作效率。

与 Dijkstra 算法类似，也使用一个优先队列，但此时以每个节点到达终点的距离作为优先级，每次始终选取
到终点移动代价最小（离终点最近）的节点作为下一个遍历的节点，这种算法称之为 `Best First` BFS 
最佳优先算法，也可以看作是一种深度优先或贪心策略的寻路算法。

Dijkstra 算法是一种广度优先遍历的算法，在没有障碍的情况下就像波浪扩散一样去搜索目标。而改良的 
Best First 的速度很快，以最靠近目标点的优先去找到达目标点的路径。

但是，当遇到障碍时，最佳优先算法不一定可以获取最佳结果，它大体趋势会沿着起点到终点的直线为对称轴，
左右来回寻点。就如知道前面有一条桥可以过河，结果直到桥头发现当...当...当...在施工，封桥不给过了，
最后还得回到码头搭船过渡。

假设，在起点和目标点之间有一个巨大的凹口形阻碍物，且开口向着起点，那么以上两种寻路算法的结果可能是：

-  `Dijkstra` 算法摸索了大面积区域，即经过大量运算，并最终找到一个避开了凹口内部的最佳路径；
-  `Best First` 则快速找到一条直接往凹口内部走，并且遇到阻碍后再折回的一条比较长的路径；

所以，这里就有一个算法性能和路径最优的平衡性问题，找到一种既有效率，又能找到捷径的算法是最佳答案。

在 `Dijkstra` 算法和 `Best First` 算法的基础上，`A*` 算法提供的解决方法是根据起点到参考点的
距离 + 参考点到目标点的距离之和来寻路。

可以用 f(n)=g(n)+h(n) 表达，其中：

- f(n) 是节点 n 的综合优先级。选择下一个要遍历的节点时，总会选取综合优先级最高（值最小）的节点。
- g(n) 是节点 n 距离起点的代价。
- h(n) 是节点 n 距离终点的预计代价，这也就是 `A*` 算法的启发函数 Heuristic Function。

这是迪杰斯特拉算法和最佳优先算法的结合体，可以加个权重参数 K 来调节这两种算法的影响程度

    f(n)= k * g(n) + (1-k) * h(n) ； k 取值 为 [0,1]

- 当 k=0 时，f(n)= h(n) ，就变成了最佳优先算法；
- 当 k=1 时，f(n)= g(n) ，就变成了迪杰斯特拉算法；
- 当 k=0.5 时，f(n)=g(n)+h(n) ，就变成 `A*` 算法；

AI 系统的引入，可以解决 Steering Behaviors 行为控制需求，这是使用动力学的数据结构，加速度和
角速度参数等模拟真实有生命的活动，如：

- 敌人的游走行为 wandering behavior；
- Seeking 地图探索；
- Arriving 到达指定点；
- Pursuit 包抄对手；
- Evade 规避对手；
- Flee 跳跑；
- Separate 分散行为；
- Align 队列行为； F
- Patrol 巡逻行为，可以适当设置巡逻点 PatrolPoint。

AStar2D 或 AStar3D 实现了 A* 寻路，需要为它添加具有连接属性的空间点，算法会计算出两个指定点的
最近路径所包含的点：

    PackedInt64Array   get_id_path(from_id: int, to_id: int)
    PackedVector2Array get_point_path(from_id: int, to_id: int)

    void add_point(id: int, position: Vector3, weight_scale: float = 1.0)
    bool are_points_connected(id: int, to_id: int, bidirectional: bool = true) 
    void connect_points(id: int, to_id: int, bidirectional: bool = true)
    bool has_point(id: int) const
    void set_point_disabled(id: int, disabled: bool = true)

方法介绍：

- add_point() 添加数据点，将一个 ID 与坐标数据关联；
- are_points_connected() 查询两点是否有通路；
- connect_points() 两点之间添加连接属性；
- has_point() 判断指定 ID 是否有对应的点；
- set_point_disabled() 禁用某个点，相当于设置一个障碍点；

```py
    var astar = AStar2D.new()
    astar.add_point(1, Vector2(0, 0))
    astar.add_point(2, Vector2(0, 1))
    astar.add_point(3, Vector2(1, 1))
    astar.add_point(4, Vector2(2, 0))

    astar.connect_points(1, 2, true)
    astar.connect_points(1, 3, true)

    var neighbors = astar.get_point_connections(1) # Returns [2, 3]


    var astar = AStar3D.new()
    astar.add_point(1, Vector3(0, 0, 0))
    astar.add_point(2, Vector3(0, 1, 0), 1) # Default weight is 1
    astar.add_point(3, Vector3(1, 1, 0))
    astar.add_point(4, Vector3(2, 0, 0))

    astar.connect_points(1, 2, false)
    astar.connect_points(2, 3, false)
    astar.connect_points(4, 3, false)
    astar.connect_points(1, 4, false)

    var res = astar.get_id_path(1, 3) # Returns [1, 2, 3]
```

Godot 中的 TileMap 节点可以为 AStart 提供网格数据，注意 TileMap API 获取的网格坐标数据类型
有变化，在做判断时可能会误用导致逻辑问题，不能正确判断障碍物所在的网格位置。

Godot 4.x 返回的是整形坐标值，而 AStart 添加数据点时使用的浮点坐标值：

```py
# Godot 3.x
Array[Vector2] get_used_cells() const

# Godot 4.x
Array[Vector2i] get_used_cells(layer: int) const
```

以下是根据官方 2d/navigation_astar 示范工程更新到 Godot 4.x 的代码：

```py
extends TileMap

const BASE_LINE_WIDTH = 3.0
const DRAW_COLOR = Color.WHITE

# The Tilemap node doesn't have clear bounds so we're defining the map's limits here.
@export var map_size: Vector2 = Vector2.ONE * 16

# The path start and end variables use setter methods.
# You can find them at the bottom of the script.
var path_start_position = Vector2():
    set = _set_path_start_position
#   set(value):
#       # TODO: Manually copy the code from this method.
#       _set_path_start_position(value)

var path_end_position = Vector2():
    set = _set_path_end_position
#   set(value):
#       # TODO: Manually copy the code from this method.
#       _set_path_end_position(value)


var _point_path = []

# You can only create an AStar3D node from code, not from the Scene tab.
@onready var astar_node = AStar3D.new()
# get_used_cells is a method from the TileMap node.
# Here the id 0 corresponds to the grey tile, the obstacles.
@onready var obstacles = get_used_cells(0)
#@onready var _half_cell_size = cell_size / 2
#@onready var _half_cell_size = Vector2(tile_set.tile_size / 2)

func _ready():
    var walkable_cells_list = astar_add_walkable_cells(obstacles)
    astar_connect_walkable_cells(walkable_cells_list)

func _draw():
    #if not _point_path:
    if _point_path.size() == 0:
        return
    var point_start = _point_path[0]
    var point_end = _point_path[len(_point_path) - 1]

    #set_cell(point_start.x, point_start.y, 1)
    #set_cell(point_end.x, point_end.y, 2)
    set_cell(0, Vector2(point_start.x, point_start.y), 1, Vector2i(0, 0))
    set_cell(0, Vector2(point_end.x, point_end.y), 2, Vector2i(0, 0))
    
    var last_point = map_to_local(Vector2(point_start.x, point_start.y)) # + _half_cell_size
    for index in range(1, len(_point_path)):
        var current_point = map_to_local(Vector2(_point_path[index].x, _point_path[index].y)) # + _half_cell_size
        draw_line(last_point,current_point,DRAW_COLOR,BASE_LINE_WIDTH)
        draw_circle(current_point, BASE_LINE_WIDTH * 2.0, DRAW_COLOR)
        last_point = current_point


# Loops through all cells within the map's bounds and
# adds all points to the astar_node, except the obstacles.
func astar_add_walkable_cells(obstacle_list = []):
    var points_array = []
    for y in range(map_size.y):
        for x in range(map_size.x):
            var point = Vector2i(x, y)
            if point in obstacle_list:
                continue

            points_array.append(point)
            # The AStar3D class references points with indices.
            # Using a function to calculate the index from a point's coordinates
            # ensures we always get the same index with the same input point.
            var point_index = calculate_point_index(point)
            # AStar3D works for both 2d and 3d, so we have to convert the point
            # coordinates from and to Vector3s.
            astar_node.add_point(point_index, Vector3(point.x, point.y, 0.0))
    return points_array


# Once you added all points to the AStar3D node, you've got to connect them.
# The points don't have to be checked a grid: you can use this class
# to create walkable graphs however you'd like.
# It's a little harder to code at first, but works for 2d, 3d,
# orthogonal grids, hex grids, tower defense games...
func astar_connect_walkable_cells(points_array):
    for point in points_array:
        var point_index = calculate_point_index(point)
        # For every cell in the map, we check the one to the top, right.
        # left and bottom of it. If it's in the map and not an obstalce.
        # We connect the current point with it.
        var points_relative = PackedVector2Array([
            point + Vector2i.RIGHT,
            point + Vector2i.LEFT,
            point + Vector2i.DOWN,
            point + Vector2i.UP,
        ])
        for point_relative in points_relative:
            var point_relative_index = calculate_point_index(point_relative)
            if is_outside_map_bounds(point_relative):
                continue
            if not astar_node.has_point(point_relative_index):
                continue
            # Note the 3rd argument. It tells the astar_node that we want the
            # connection to be bilateral: from point A to B and B to A.
            # If you set this value to false, it becomes a one-way path.
            # As we loop through all points we can set it to false.
            astar_node.connect_points(point_index, point_relative_index, false)


# This is a variation of the method above.
# It connects cells horizontally, vertically AND diagonally.
func astar_connect_walkable_cells_diagonal(points_array):
    for point in points_array:
        var point_index = calculate_point_index(point)
        for local_y in range(3):
            for local_x in range(3):
                var point_relative = Vector2(point.x + local_x - 1, point.y + local_y - 1)
                var point_relative_index = calculate_point_index(point_relative)
                if point_relative == point or is_outside_map_bounds(point_relative):
                    continue
                if not astar_node.has_point(point_relative_index):
                    continue
                astar_node.connect_points(point_index, point_relative_index, true)


func calculate_point_index(point):
    return point.x + map_size.x * point.y


func clear_previous_path_drawing():
    #if not _point_path:
    if _point_path.size() == 0:
        return
    var point_start = _point_path[0]
    var point_end = _point_path[len(_point_path) - 1]
    #set_cell(point_start.x, point_start.y, -1)
    #set_cell(point_end.x, point_end.y, -1)
    set_cell(0, Vector2(point_start.x, point_start.y), -1)
    set_cell(0, Vector2(point_end.x, point_end.y), -1)


func is_outside_map_bounds(point):
    return point.x < 0 or point.y < 0 or point.x >= map_size.x or point.y >= map_size.y


func get_astar_path(world_start, world_end):
    self.path_start_position = local_to_map(world_start)
    self.path_end_position = local_to_map(world_end)
    _recalculate_path()
    var path_world = []
    for point in _point_path:
        var point_world = map_to_local(Vector2(point.x, point.y)) # + _half_cell_size
        path_world.append(point_world)
    return path_world


func _recalculate_path():
    clear_previous_path_drawing()
    var start_point_index = calculate_point_index(path_start_position)
    var end_point_index = calculate_point_index(path_end_position)
    # This method gives us an array of points. Note you need the start and
    # end points' indices as input.
    _point_path = astar_node.get_point_path(start_point_index, end_point_index)
    # Redraw the lines and circles from the start to the end point.
    queue_redraw()  # update()


# Setters for the start and end path values.
func _set_path_start_position(value):
    if value in obstacles:
        return
    if is_outside_map_bounds(value):
        return

    #set_cell(path_start_position.x, path_start_position.y, -1)
    #set_cell(value.x, value.y, 1)
    set_cell(0, path_start_position, -1)
    set_cell(0, value, 1)
    path_start_position = value
    if path_end_position and path_end_position != path_start_position:
        _recalculate_path()


func _set_path_end_position(value):
    if value in obstacles:
        return
    if is_outside_map_bounds(value):
        return

    #set_cell(path_start_position.x, path_start_position.y, -1)
    #set_cell(value.x, value.y, 2)
    set_cell(0, path_start_position, -1)
    set_cell(0, value, 2)
    path_end_position = value
    if path_start_position != value:
        _recalculate_path()
```

### 🟠🔵 Behavior Tree 行为树
- [Godot State Machine](https://gdscript.com/solutions/godot-state-machine/)
- [Godot Behavior Tree](https://gdscript.com/solutions/godot-behaviour-tree/)
- [Godot Behavior Tree](https://github.com/andrew-wilkes/godot-behaviour-tree)
- https://github.com/libgdx/gdx-ai/wiki/Behavior-Trees
- https://www.behaviortree.dev/docs/Intro
- https://docs.unrealengine.com/4.26/zh-CN/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/
- [Naive Behavior Tree by Raiix](https://github.com/rayxuln/Behavior-Tree-Syntax-Compiler)
- [Naive Behavior Tree 插件教程](https://www.bilibili.com/video/BV1gv411g7p4/)
- [Naive Behavior Tree 示范案例](https://github.com/rayxuln/MyDogIsACat)
- [Naive Behavior Tree 在线演示](http://github.raiix.com/gamelib/feed_it/)
- [Raiix State Machine](https://github.com/rayxuln/RaiixStateMachinePlugin)
- [Behavior Tree Editor](https://github.com/rayxuln/behavior_tree_plugin)
- [Behavior Tree Editor 教程](https://www.bilibili.com/video/BV1KV411k7t9/)
- [GDScript progress report: Writing a new parser](https://godotengine.org/article/gdscript-progress-report-writing-new-parser/)

行为树 Behaviour Tree 如其名，是一个树状数据结构，是一种流行的 AI (Artificial Intelligence)
编码组织方法，常用于游戏中的 NPC (Non Player Controlled) 角色执行不同的动作。

行为树是一种用来表示逻辑决策的方法，主要 Decision Making 方法有以下两种：

- State Machine
- Behavior Trees

行为树与有限状态机（FSM，Finite State Machine）、决策树（Decision Tree）等常被对比，绝大多数
情况下他们可以发挥同样的作用，并且可以相互转换。

当需要做决策时，先从行为树的根节点树开始查询，以树状方式向下层传播，直到叶节点，它包含最终要执行或者
实现的游戏功能。行为树的遍历操作在游戏中的每个 tick 中都会发生，游戏中的每一帧都可能有行为决策。

![Behavior Trees](https://docs.unrealengine.com/4.26/Images/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/BehaviorTreesOverview/BT_Overview_Intro.png)

假设，为一个角色定义的一颗行为树，大体上为这个角色设计了三套行为，分别是：

- 巡逻（Patrol）
- 攻击（Attack）
- 逃跑（Retreat）

而这些行为又可以细化，比如狼狈地跑，狠狠地攻击，优哉游哉地巡逻，新增加的这些细化的行为又可以挂到行为树
的子层，具体节点数据可以根据需要来决定。当游戏中需要决策当前这个角色要执行什么行为时，就需要自顶向下，
并结合一些条件来搜索这颗树，最终匹配到叶节点，即确定下来要执行的行为，并且执行它，这就是行为树的基本原理。
叶节点上一般包含行为，称之为行为节点（Action Node），其余节点一般称之为控制节点（Control Node）。
控制节点其实是行为树的精髓所在，决策过程受控制节点约束。

组织起这些行为可以使用不同的方式，有些行为可以组合，比如出拳与扭腰，有些行为是单一的，这就要为行为树
设计不同类型的节点来表达相应的行为性质，并且又可以按不同的方式执行，这就需要合成节点（Composite）
来组织它们：

1. Sequenece：各种行为一个接着一个进行。
2. Parallel：多个行为同时进行。
3. Selector：从多个候选行为中选择一个执行。

行为节点可能有多种运行状态：

- Executing 运行中：该行为还在处理中。
- Completed 已完成：该行为处理完成，成功或者失败。

运行结果可以包含以下几种情况：

- Succeeded 成功结束运行。
- Failed 运行失败。
- Aborted 终止运行。
- In Progress 正在运行进程中。

根据 Behavior Trees in Robotics and AI 一书描述，行为树一般有：

- 4 种控制节点 Sequence, Fallback, Parallel, Decorator。
- 2 种执行节点，Action 和 Condition，只有执行节点才能成为叶子节点。

装饰节点在行为树系统中起条件设置作用，其功能相当于条件语句。许多行为树实现方案中，都有 Blackboard
概念，它用来存储行为树的状态数据。

行为树的设计，首先定义一个基类 `BT_Node`：

- BT_Node 作为其它子节点的基类，需要有一个调用子节点任务的方法；
- 每个节点本身定义一个任务方法 Task()，定义节点本身所拥有的行为、功能，由父节点执行；
- 可以考虑设置一个 Abort() 方法用于主动结束任务的执行；

定义一个控制节点，`BT_Control` 并派生各种具体控制节点，例如：

- BT_Sequenecer
- BT_Paralleler
- BT_Selector
- BT_Condition
- BT_Repeater
- BT_Randomizer
- BT_Decorator
    - BT_AlwaysFail
    - BT_AlwaysSuccess
    - BT_UntilFail
    - BT_UntilSuccess

定义一个行为节点，`BT_Action` 并派生各种具体行为节点，这些子类型作为行为树中的叶节点，例如：

- BT_Wait
- BT_Jump
- BT_Run
- BT_Patrol
- BT_Retarget

行为节点应该根据需要添加，并通过控制节点来组织，最终构造成为一个完整的行为树。

Andrew Wilkes 中提供的行为树实现中，使用 `Task` 作为基类，行为节点类型定义为 Leaf。其设计思路：

- 定义一套 Final methods 修改对应的执行状态，running() success() fail() cancel()；
- 定义一套抽象方法用于不同的任务执行方式，run() child_running() child_success() child_fail()；
- 另外两个方法 start() reset() 分别用于配置任务节点和复位；

其中，start() 这个方法其实是行为树节点的初始化方法，名称有点不恰当，而 run() 才是任务启动方法。
叶子节点 Leaf 只定义了 run()，默认需要用户在继承子类中的具体逻辑中主动调用。

Final methods 方法还会调用抽象方法中和子节点状态相关方法，根据子节点运行状态来设置父节点的状态。
`Task` 基类中，除了定义 State 枚举表示运任务的状态，还定义了与行为树结构相关的 control、tree
两个属性。

- `control` 表示控制节点，默认在 start() 方法初始为父节点，它调用和子节点状态相关的三个抽象方法；
- `tree` 表示行为树本身，所有子节点都有行为树的一个引用，通过它可以枚举所有子节点。

以下代码适用于 Godot 3.5，新版本 Godot 4 中提供了 super 关键字来调用父类，而不是通过一个点号：

```py
extends Node

class_name Task

# States
enum {
    FRESH,
    RUNNING,
    FAILED,
    SUCCEEDED,
    CANCELLED
}

var control = null
var tree = null
# var guard = null
var status = FRESH

# Final methods
func running():
    status = RUNNING
    if control != null:
        control.child_running()

func success():
    status = SUCCEEDED
    if control != null:
        control.child_success()

func fail():
    status = FAILED
    if control != null:
        control.child_fail()

func cancel():
    if status == RUNNING:
        status = CANCELLED
        # Cancel child tasks
        for child in get_children():
            child.cancel()

# Abstract methods
func run():
    # Process the task and call running(), success(), or fail()
    pass

func child_success():
    success()

func child_fail():
    fail()

func child_running():
    running()

# Non-final non-abstact methods
func start():
    status = FRESH
    for child in get_children():
        child.control = self
        child.tree = self.tree
        child.start()

func reset():
    cancel()
    status = FRESH
```

AlwaysFail 装饰器节点：它总是返回 FAILED 状态，所以不用管 child_success() child_fail()：

```py
extends Task

class_name AlwaysFail

func run():
  if get_child_count() > 0:
    get_child(0).run()
  fail()

# Ignore child success
func child_success():
  pass

# Ignore child failure
func child_fail():
  pass
```


以并行控制节点为例，并行任务额外设置了一个 policy 来控制并行方式。

```py
extends Task

# Run all child Tasks together in SEQUENCE or SELECTOR policy mode

class_name Parallel, "res://icons/parallel.png"

enum Policy { SEQUENCE, SELECTOR }

#export(bool) var policy = bool(SEQUENCE)
export(Policy) var policy = Policy.SEQUENCE

var num_results = 0

func run():
    for child in get_children():
        child.run()
    running()

func child_success():
    num_results += 1
    #if policy == bool(SEQUENCE):
    if policy == (Policy.SEQUENCE):
        if num_results >= get_child_count():
            num_results = 0
            success()
    else:
        success()

func child_fail():
    num_results += 1
    #if policy == bool(SELECTOR):
    if policy == (Policy.SELECTOR):
        if num_results >= get_child_count():
            num_results = 0
            fail()
    else:
        fail()

func cancel():
    num_results = 0
    .cancel()

func start():
    num_results = 0
    .start()
```

Andrew Wilkes 提供的代码中包含了一个测试，这里也提供一个简化的版本演示任务运行。注意：在处理任务
时，使用当前任务节点的 idx 索引来执行当前的任务，run() 之后会修改索引值，在 process 处理时，要
避免因为 idx 的变化导致 get_child() 引用节点错误。

从状态转换角度来看，控制节点的状态除了直接通过 `Task` 的 Final 方法控制，还同样受到子节点的状态
通知方法修改，这里就涉及到多个子节点修改父节点状态的可能。以下代码中，添加了一个新状态 FINISHED，
用来表示一个任务的完成状态，不管它是成功执行还是失败。

另外，因为 Godot 场景树是多线程处理的，为了确保线程安全地执行节点状态的设置，需要使用延后调用方法：
`call_deferred("finished")` 可以确保其它线程完成计算后，再执行完成状态的设置。如果不通过延后调用，
那么这个完成状态设置后，就可能被子线程紧接着修改了。

```py
extends Task

var list
var idx = 0

func _ready():
    list = get_node("/root/Test/Results") as ItemList
    add_result("TEST", "RESULT")
    tree = self
    start()
    status = States.RUNNING

func child_running():
    status = States.RUNNING

func child_success():
    status = States.SUCCEEDED
    log_result()

func child_fail():
    status = States.FAILED
    log_result()

func _process(_delta):
    if status == States.RUNNING and idx < tree.get_children().size():
        var task = tree.get_child(idx)
        task.run()

func add_result(description, result):
    list.add_item(description)
    list.add_item(result)

func log_result():
    add_result(get_child(idx).to_string(), enum2str(status))
    
    idx += 1
    if idx == tree.get_children().size():
        status = States.FINISHED
        idx = 0
        call_deferred("finished")
        add_result("--", enum2str(status))
    else:
        status = States.RUNNING

func finished():
    status = States.FINISHED

enum States {FRESH, RUNNING, FAILED, SUCCEEDED, CANCELLED, FINISHED }

func enum2str(status):
    # enum like a Dictionary
    return States.keys()[status].capitalize()
#   match status:
#       FRESH:
#           return "Fresh"
#       RUNNING:
#           return "Running"
#       FAILED:
#           return "Failed"
#       SUCCEEDED:
#           return "Succeeded"
#       CANCELLED:
#           return "Cancelled"
#       FINISHED:
#           return "Finished"
```

Godot 中的枚举类型 enum 和字典对象同源，可以使用 keys() 方法获取枚举量的名称来实现到字符串的转换。
参考 global_constants.cpp 源代码文件，其中注册了全局类型常量。GDScript 解释器也没有专门设置一个
Token 用于表示枚举类型，而是和字典类型一样，直接通过检测代码中的花括号来识别枚举类型。



## 🟡 Network Multiplayer 联网游戏
- [High-level multiplayer](https://docs.godotengine.org/en/3.5/tutorials/networking/high_level_multiplayer.html)
- [High-level multiplayer](https://docs.godotengine.org/en/stable/tutorials/networking/high_level_multiplayer.html)
- [18.网络游戏的架构基础 | GAMES104-现代游戏引擎：从入门到实践](https://www.bilibili.com/video/BV1La411o7kG/)
- [Exporting for dedicated servers](https://docs.godotengine.org/en/latest/tutorials/export/exporting_for_dedicated_servers.html)
- [Making HTTP requests](https://docs.godotengine.org/en/stable/tutorials/networking/http_request_class.html)
- [HTML5 and WebSocket](https://docs.godotengine.org/en/stable/tutorials/networking/websocket.html)
- [HTML5, WebSocket, WebRTC](https://docs.godotengine.org/en/stable/tutorials/networking/webrtc.html)
- [GodotSteam tutorials - Initializing](https://godotsteam.com/tutorials/initializing/)
- [Godot 4 MultiplayerSpawner MultiplayerSynchronizer](https://www.bilibili.com/video/BV1he4y1W7cV/)
- [Multiplayer in Godot 4.0: RPC syntax, channels, ordering](https://godotengine.org/article/multiplayer-changes-godot-4-0-report-2/)
- [[Net] New @rpc annotation](https://github.com/godotengine/godot/pull/49882)
- [Add a multiplayer interface and visual nodes for SceneTree replication](https://github.com/godotengine/godot-proposals/issues/3459)
- [Godot Multiplayer Networking Cheatsheet](https://blog.iancolwell.ca/godot-multiplayer-networking-cheatsheet)
- [StreamPeerTCP client blocked on STATUS_CONNECTING](https://github.com/godotengine/godot/issues/61197)
- godot\thirdparty\enet\enet\enet.h
- godot\3.5.1-stable\core\io\multiplayer_api.h
- godot\scene\main\multiplayer_api.h

![gRPC framework](https://grpc.io/img/landing-2.svg)

连网在线游戏开发需要解决的两个首要问题就是：多个终端的同步问题，网络安全问题，其次是并发性能问题。
Massive Multiplayer Online Game (MMO) 最能体现这几个问题。

在游戏中加入社交网络需要承担一定的责任，如果程序做错了，会使应用程序很容易受到攻击，并可能导致欺诈，
甚至是上升为刑事案件。它甚至可能允许攻击者破坏运行应用程序运行的机器，并使用游戏服务器发送垃圾邮件，
攻击他人或窃取用户数据。

联网同步过程涉及两个基本概念：

- Spawn 生成：本地创建或远程请求创建新对象。
- Sync 同步：本地更新或远程请求更新对象的状态。

比如，有两个玩家在同一场景下遇到一个随机生成的 NPC，那么假设这个 NPC 是在服务器生成，接下来就需要
将其状态同步到两个玩家的网络节点上。

程序联网必不可以少要使用互联网络通信协议，又以 TCP/IP 协议栈为最基础：

- UDP (User Datagram Protocol)
- TCP (Transmission Control Protocol)
- HTTP (Hypertext Transfer Protocol)`
- SSL (Secure Sockets Layer)

![Multiplayer](https://godotengine.org/storage/app/uploads/public/610/918/f3e/610918f3ec53b713518837.png)

Godot 始终支持通过 UDP 或 TCP 协议，还有一些更高级别的协议，如 SSL、HTTP，进行标准的低级网络连接。
这些协议非常灵活，几乎可以用于任何事情。然而，游戏开发中使用它们来手动同步游戏状态可能需要大量的工作，
因此需要一种 High-level multiplayer 机制简化这部分流程，其中 Remote Procedure Calls (RPC)
就是流行技术，通过 RPC，可以在本地主机向远程主机发起代码调用。

Godot 定义了 StreamPeer 流式类型，这是一个抽象类，由其子实现具体需求，例如提供 TCP 这类流式数据
协议的支持，这个类型派生的子类：

- StreamPeerBuffer 
- StreamPeerExtension 
- StreamPeerGZIP 
- StreamPeerTCP 
- StreamPeerTLS 

在项目导出到 Android 平台运行时，需要启用 INTERNET 授权设置，以允许网络访问。

使用 StreamPeerTCP 建立 TCP 连接时，注意，`StreamPeerTCP` 的 status 需要更新状态再连接，先
执行 `poll()` 轮询并处理数据阻塞，转换状态后再连接。否则，get_status() 总是 `STATUS_CONNECTING`。
使用 `TCPServer` 对象创建 TCP 服务器并获取数据流：

```py
      int get_local_port() const
     bool is_connection_available() const
     bool is_listening() const
    Error listen(port: int, bind_address: String = "*")
     void stop()
    StreamPeerTCP take_connection()
```

执行 Listen 动作时，支持绑定 IPv4/IPv6 地址格式：

- `bind_address = "*"` 默认值，服务器会同时侦听 IPv4/IPv6 地址；
- `bind_address = "0.0.0.0"` IPv4 格式，或者 "::" IPv6 格式；
- `bind_address` 绑定其它有效地址，如 "192.168.1.101", "::1"，服务器只响应这个地址；


Godot 提供 ENet 支持，基于不可靠 UDP 连接提供一个相对轻量、简单、稳定的网络通信，比 UDP 可靠，
同时又比基于连接 TCP 协议更快速。UDP 缺少排序，连接管理，带宽管理，包大小限制等。TCP 不能同时
打开多个套接字故缺少多流的通信，并且由于其缓冲特性，其包管理机制过于复杂。

根据服务器的设置方式，联网游戏有两种基本的运行方式：

- Server: Use this one for running dedicated servers.
- Headless (no rendering): This binary contains editor functionality and is intended to be used for exporting projects.

所谓无头显示 Headless 即无渲染功能的服务端，可以通过 --display-driver headless 参数启动。
专用服务器模式下，服务端程序移除了 Godot 编辑器的功能，只包含游戏逻辑，程序是优化精简的。Godot 
目前只提供 Linux 平台下的专用服务端以及 Headless 服务器。

开发者可以使用低级网络 API 来实现最大限度的控制，并在完全裸露的网络协议之上实现所有功能, 或者使用
基于 SceneTree 实现的高级网络同步 API, 后者以一种优化的方式在后台完成大部分繁重的工作，从而大大
减少开发者的工作量。

Godot 支持的大多数平台都提供所有或大部分上述的高、低网络功能。但是，由于网络在很大程度上依赖于硬件
和操作系统，在某些目标平台上一些特性可能会改变或者不可用。注意，HTML5 平台目前只提供 WebSocket
和 WebRTC 两种协议支持，缺乏一些高级功能，以及对 TCP 和 UDP 等低级协议的原始访问。

Godot 3.5 的关键字列表中提供了以下这组用于标注 RPC 方法的关键字，后缀 sync 表示同步。API 调用
方式对应关键字有 6 个，分别是有 sync 后缀和没后缀的两种。比如，有后缀 `sync` 就带有本地同步调用，
比如 `remotesync` 调用，双人对战中一方发出攻击动作，双方都同步看到效果。

- `remote` 由远程端而不是本地调用的方法或更改的属性，无论它们是节点的主控还是傀儡。
- `master` 仅接受来自傀儡网络节点的调用或属性更改，请参见 node.set_network_master()。
- `puppet` 仅接受来自主控网络节点的调用或属性更改，请参见 node.set_network_master()。

另外，还有一个 `sync` 关键字，从源代码中可以看到，它与 remotesync 是等价的：

```C++
        case GDScriptTokenizer::TK_PR_REMOTESYNC:
        case GDScriptTokenizer::TK_PR_SYNC: {
            //may be fallthrough from export, ignore if so
            tokenizer->advance();
            if (tokenizer->get_token() != GDScriptTokenizer::TK_PR_VAR 
                && tokenizer->get_token() != GDScriptTokenizer::TK_PR_FUNCTION) {
                // ...
                return;
            }

            rpc_mode = MultiplayerAPI::RPC_MODE_REMOTESYNC;
            continue;
        } break;
```

一个联网游戏的 API 调用，发生的场所：服务器、主控节点（master）、任意傀儡节点（slave/puppet）。
对于双人联网游戏，其中一方将充当服务器即主控节点，那么另一方就是傀儡节点。对于当前玩家来说，自己当前
控制的主机就是 network master 主控节点。

以下是一个触发机制对照表，场景中的角色分为两类，其中 **Player** 节点代表测试者，其它角色为 **NPC**。
玩家所在主机为 Player Host，其它角色所在所在主机为 NPC Host。玩家或 NPC 在自己主机以外的副本对象
称为 **Shadow**。在玩家的主机上进行测试操作，分别在玩家和 NPC 两种对象节点上进行触发 RPC 调用的
测试操作：

|    RPC     |   Trigger    | Player Host |  NPC Host | Player Shadow | NPC Shadow |
|------------|--------------|-------------|-----------|---------------|------------|
| remote     | Player/NPC   | -           | -         | exec          | exec       |
| remotesync | Both[exec]   | exec        | exec      | exec          | exec       |
|------------|--------------|-------------|-----------|---------------|------------|
| master     | Player[exec] | exec        | not-allow | not-allow     | not-allow  |
| master     | NPC          | not-allow   | exec      | not-allow     | not-allow  |
| mastersync | Player[exec] | exec        | -         | -             | -          |
| mastersync | NPC[exec]    | -           | exec      | -             | not-allow  |
|------------|--------------|-------------|-----------|---------------|------------|
| puppet     | Player       | -           | -         | exec          | -          |
| puppet     | NPC[exec]    | -           | not-allow | -             | not-allow  |
| puppetsync | Player       | exec        | -         | exec          | -          |
| puppetsync | NPC[exec]    | -           | not-allow | -             | not-allow  |

总结，remote 和 remotesync 是最容易理解的两个，`remote` 就是由本地任何对象向所有远端发送 RPC
调用，在所有远端执行的函数。后缀 sync 后，就包括了本地也会执行 RPC 调用，即包含联网中的所有主机。

然后是，`master`，它代表主控 RPC 调用，即在节点的主控端执行 RPC 调用，可以在主控或傀儡端发起调用。
注意，非主控节点需要做权限判断，上表中出现 not-allow 的情况都需要做 peer ID 判权。然后是带后缀的
`mastersync`，这里的逻辑有点复杂，就是在傀儡节点上操作时，有两个主机可以响应 RPC 调用，而其它的
傀儡需要做鉴权。表中的 NPC 节点触发主控调用时，其本身以及 NPC 主机也响应 RPC 调用，但其它除外。

傀儡节点（slave/puppet）是相对主控的概念，所行为也有类似的地方，是指在傀儡节点上响应 RPC 调用。
对于 Player 来说，傀儡就是 Player Shadow，对于 NPC 来说，傀儡就是 Player Shadow。因为测试
操作在 Player Host，此主机上的所有 NPC 都傀儡节点。所以，无论 `puppet` 还是 `puppetsync`，
在 NPC 上总能触发 RPC 并响应这个远程调用，但是在 NPC Host 上不会响应。

至于 Player 来说，因为是主控，在使用 `puppetsync` 才会响应 RPC 远程调用，其 Shadow 也会响应。

这些关键字除了修饰函数，还可以用来修饰变量，正常定义的变量只在本机上读写：

    remote var somevar
    remotesync var somevar

    master var somevar
    mastersync var somevar

    puppet var somevar
    puppetsync var somevar

再来说说鉴权，以下两种条件判断是有所差别的，也是常用的两种鉴权：

    is_network_master()
    get_network_master() == multiplayer.get_rpc_sender_id()

前者根据节点绑定的 peer ID，即 set_network_master() 指定的 ID，与当前主机上分配到的 ID 比较，
而后者则是与 RPC 的发起方分配到的 ID 进行比较。但是，Godot 3.5 中，返回的 ID 总为 0。

除了这些标注 API 用法关键字外，联网游戏中还使用 peer ID 用于标识对等网络中的节点，每个玩家对应
一个 ID，服务端 ID = 1。可以通过向游戏传递参数来启动服务器功能，通过 OS.get_cmdline_args()
获取命令行参数，比如 --server 用于启动服务器。

场景中的节点可以使用 set_network_master() 方法指定其归属 master 的 ID，通过比较 peer ID，
使用节点的 is_network_master()，就可以确定程序逻辑中是否应该修改节点数据。如下图所示，假设当前
玩家作为服务器端运行，显示在左侧节点列表中。其中归属于对手的节点使用红色表示，对于主控节点来说，这个
红色节点属于网络中的傀儡节点，当前玩家的程序逻辑不应主动修改这节点的数据。

![Network multiplayers](https://docs.godotengine.org/en/latest/_images/nmms.png)

主控节点的概念在 Godot 4 中更新为多端授权 multiplayer authority，编程中依然可以使用对等网络
节点的 ID 来做判断。默认状态下，场景树中的的节点都为服务器端授权。即不调用 set_network_master 或
set_multiplayer_authority 的条件下，获取 Node 的授权 peer ID 值都是 1，子节点继承父节点的值。

这个 ID 在 peer 连接到服务器端时自动生成，连接信号或 multiplayer.get_unique_id() 都可以获取。

以上 RPC 关键字与 MultiplayerAPI.RPCMode 指示的状态相对应：

|       RPCMode       | Value |                            Notes                            |  Keywords  |
|---------------------|-------|-------------------------------------------------------------|------------|
| RPC_MODE_DISABLED   |     0 | to disable a method or property for all RPC calls.          |            |
| RPC_MODE_REMOTE     |     1 | method/property only on the remote end, not locally.        | remote     |
| RPC_MODE_MASTER     |     2 | method/property only on the network master.                 | master     |
| RPC_MODE_PUPPET     |     3 | method/property only on puppets for this node.              | puppet     |
| RPC_MODE_REMOTESYNC |     4 | RPC_MODE_REMOTE + make the call or property change locally. | remotesync |
| RPC_MODE_MASTERSYNC |     5 | RPC_MODE_MASTER + make the call or property change locally. | mastersync |
| RPC_MODE_PUPPETSYNC |     6 | RPC_MODE_PUPPET + make the call or property change locally. | puppetsync |
| RPC_MODE_SLAVE      |     3 | Deprecated. Use RPC_MODE_PUPPET instead.                    | slave      |
| RPC_MODE_SYNC       |     4 | Deprecated. Use RPC_MODE_REMOTESYNC instead.                | sync       |


升级到 Godot 4.x 后，RPC 机制精简并引用标注，这些关键字不再使用，MultiplayerAPI.RPCMode 模式
也只剩下 3 种，统一使用同一个 rpc_config() 配置方法进行配置：

- *RPC_MODE_DISABLED* = 0，所有方法的默认 RPC 模式。
- *RPC_MODE_ANY_PEER* = 1，供一切远端调用，不管是否授权，`@rpc("any_peer")` 标注，相当于 `remotesync`。
- *RPC_MODE_AUTHORITY* = 2，Multiplayer authority 授权远程调用，默认情况下为服务器，`@rpc("authority")` 标注，相当于 `master` 或 `mastersync`。

Godot 4.x RPC 配置方法 Node.rpc_config() 参数包括四个属性与 @rpc 标注一致：

```py
{
    rpc_mode = MultiplayerAPI.RPCMode,
    transfer_mode = MultiplayerPeer.TranferMode,
    call_local = false,
    channel = 0,
}
```

新版本中 @rpc 参数说明：

    @rpc(mode: String = "", sync: String = "", transfer_mode: String = "", transfer_channel: int = 0, ...) vararg

- `mode` - RPC mode ("any_peer", "authority").
- `sync` - calls the function locally too when RPCing ("call_local", "call_remote").
- `transfer_mode` - Transfer mode (one of reliable, unreliable, unreliable_ordered).
- `transfer_channel` - Transfer channel (not used by the MultiplayerAPI for now, need implementation).

解释一下其中前两个参数：

- RPCMode 指示 RPC 方法能不能被调用，标注为 "any_peer" 在所有对等端都会调用，"authority" 则是在主控端调用；
- call_local 指示 RPC 方法的同步方式，"call_local" 本地和远端一并同步，"call_remote" 只同步远端；

另外，unreliable 这类控制网络协议的注解参数对应 Godot 3.5 中的 rpc_unreliable() 等方法。
旧版本中，master 和 remote 不能同时用来注解一个 RPC 方法，不像 Godot 4.x 可以通过 @rpc 标注
所有 RPC 方法的配置参数。

使用 Node.set_multiplayer_authority() 方法给节点授权，指定 ID 对等端作为主控授权，多端授权
是对网络上的拥有有节点权限的对等方。结合 rpc_config() 和 MultiplayerAPI 结合使用非常有用。默认
情况下从父节点继承，最终默认为对等端 ID 1 为服务器。如果是递归的，则将给定的对等端递归地设置为该
节点的所有子节点的权限。


Godot 3 关键字与 Godot 4 标注的等价关系参考：

|      Godot 3.5 keywords     |                 Godot 4 @rpc annotations                |
|-----------------------------|---------------------------------------------------------|
| remote                      | @rpc("any_peer", "call_remote")                         |
| remotesync                  | @rpc("any_peer", "call_local")                          |
| master                      | @rpc("authority", "call_remote")                        |
| mastersync                  | @rpc("authority", "call_local")                         |
| rpc_unreliable()            | @rpc("unreliable")                                      |
| rpc_unreliable(master func) | @rpc or @rpc("authority", "call_remote", "reliable", 1) |

这个表可以作为 Godot 3.5 与 Godot 4.x Multiplayer RPC 开发参考。

标注使用示范如下，假设通过一个 Area3D 的输入事件触发 RPC 调用：

- shake_me() 方法使用默认标注，即在主控执行远端同步，等同旧版本的 `master` 关键字；
- shake_all() 方法所有对等端都执行，并且执行远端同步，等同旧版本的 `remote` 关键字；
- clicked_all() 方法在所有对等端执行，并且执行本地与远端同步，等同旧版本的 `remotesync` 关键字。

```py
@rpc
#@rpc("authority", "call_remote", "reliable", 1)
func shake_me():
    $Message.text = "Shake me!"

@rpc("any_peer", "call_remote", "reliable", 1)
func shake_all():
    $Message.text = "Shake all!"

@rpc("any_peer", "call_local", "reliable", 1)
func clicked_all():
    $Message.text = "%d clicked on me!" % [multiplayer.get_remote_sender_id()]


func _on_Area3D_input_event(camera, event, position, normal, shape_idx):
    if not event is InputEventMouseButton:
        return
    match event.button_index:
        MOUSE_BUTTON_LEFT:
            rpc("clicked_by_player")
        MOUSE_BUTTON_RIGHT:
            rpc("shake_me")
        MOUSE_BUTTON_MIDDLE:
            rpc("shake_all")
```

总结来看，network master 也好，multiplayer authority 也好，就是一个主控概念。场景树中所有
节点都可以归属给对等网络连接中的一个对等端，而默认归属为服务器端。比如，创建一个节点 Player，默认
状态下就归属于服务器，在所有联网主机中它应该都有一个同样的副本，那么：这个节点定义为 "authority"
的方法，在服务器执行时，通过查询当下 MultiplayerPeer 所关联的 ID，即可以知道当下的 peer ID 
与 Player 归属一致，所以方法可以执行。在其它客户端，同一 Player 方法就会因为主机所分配的 peer ID
值与 Player 节点归属不一致，而不会被执行。

而对于标注为 "any_peer" 的方法，相当于广播方法，假设在某一个客户中执行，会向所有连网主机通报：
现在要执行这个 "any_peer" 标注过的方法。如果还配合 "call_local"，那么主动发起调用的这个客户机
上也会执行这个方法，而不是单纯向其它连网主机发出 RPC 调用。

具体参数使用可以参考源代码 GDScriptParser::rpc_annotation() 方法中的定义：

```cpp
    // godot\master\modules\gdscript\gdscript_parser.cpp:3905
    for (int i = last; i >= 0; i--) {
        String mode = p_annotation->resolved_arguments[i].operator String();
        if (mode == "any_peer") {
            rpc_config["rpc_mode"] = MultiplayerAPI::RPC_MODE_ANY_PEER;
        } else if (mode == "authority") {
            rpc_config["rpc_mode"] = MultiplayerAPI::RPC_MODE_AUTHORITY;
        } else if (mode == "call_local") {
            rpc_config["call_local"] = true;
        } else if (mode == "call_remote") {
            rpc_config["call_local"] = false;
        } else if (mode == "reliable") {
            rpc_config["transfer_mode"] = MultiplayerPeer::TRANSFER_MODE_RELIABLE;
        } else if (mode == "unreliable") {
            rpc_config["transfer_mode"] = MultiplayerPeer::TRANSFER_MODE_UNRELIABLE;
        } else if (mode == "unreliable_ordered") {
            rpc_config["transfer_mode"] = MultiplayerPeer::TRANSFER_MODE_UNRELIABLE_ORDERED;
        } else {
            push_error(R"(Invalid RPC argument. Must be one of: 'call_local'/'call_remote' (local calls), 'any_peer'/'authority' (permission), 'reliable'/'unreliable'/'unreliable_ordered' (transfer mode).)", p_annotation);
        }
    }
```

不同 Godot 版本下的 SceneTree 连网相关方法及属性，Godot 3 与新版本最大的差别在于，场景树包装了
完整的 MultiplayerAPI 信号，并且直接引用 MultiplayerPeer。为了同步游戏开始，可以使用场景树的
set_pause() 方法。

```py
# Godot 3
# https://docs.godotengine.org/en/3.5/classes/class_scenetree.html
MultiplayerAPI multiplayer
    Setter set_multiplayer(value)
    Getter get_multiplayer()

NetworkedMultiplayerPeer network_peer
    Setter set_network_peer(value)
    Getter get_network_peer()

bool multiplayer_poll = true
    Setter set_multiplayer_poll_enabled(value)
    Getter is_multiplayer_poll_enabled()

bool refuse_new_network_connections = false
    Setter set_refuse_new_network_connections(value)
    Getter is_refusing_new_network_connections()

PoolIntArray get_network_connected_peers ( ) const
int get_network_unique_id ( ) const
int get_rpc_sender_id ( ) const
bool has_network_peer ( ) const
bool is_network_server ( ) const

# Godot 4
# https://docs.godotengine.org/en/latest/classes/class_scenetree.html
bool multiplayer_poll [default: true]
    set_multiplayer_poll_enabled(value) setter
    is_multiplayer_poll_enabled() getter

MultiplayerAPI get_multiplayer ( NodePath for_path=NodePath("") ) const
void set_multiplayer ( MultiplayerAPI multiplayer, NodePath root_path=NodePath("") )
```


不同 Godot 版本下的 Node 节点和 RPC 相关的属性、方法定义如下：

```py
# Godot 3
# https://docs.godotengine.org/en/3.5/classes/class_node.html
MultiplayerAPI custom_multiplayer
    Setter set_custom_multiplayer(value)
    Getter get_custom_multiplayer()

MultiplayerAPI multiplayer
    Getter get_multiplayer()

int get_network_master() const
bool is_network_master() const
void set_network_master(id: int, recursive: bool = true)


void rpc_config(method: String, mode: RPCMode 和 call_local 方式的用途：)
void rset_config(property: String, mode: RPCMode)

Variant rpc(method: String, ...) vararg
Variant rpc_unreliable(method: String, ...) vararg
Variant rpc_id(peer_id: int, method: String, ...) vararg
Variant rpc_unreliable_id(peer_id: int, method: String, ...) vararg

void rset(property: String, value: Variant)
void rset_id(peer_id: int, property: String, value: Variant)
void rset_unreliable(property: String, value: Variant)
void rset_unreliable_id(peer_id: int, property: String, value: Variant)

# Godot 4
# https://docs.godotengine.org/en/latest/classes/class_node.html
MultiplayerAPI multiplayer
    Getter get_multiplayer()

Error rpc ( StringName method, ... ) vararg
void  rpc_config ( StringName method, Variant config )
Error rpc_id ( int peer_id, StringName method, ... ) vararg

void  set_multiplayer_authority ( int id, bool recursive=true )
int get_multiplayer_authority() const
bool is_multiplayer_authority() const
```

Godot 3.5 中提供的 remote, master, puppet, remotesync, mastersync, puppetsync 这些
关键字用于标注 RPC 方法，可以当作 rpc_config() 或 reset_config() 方法使用。默认地，所有属性
都不向 RPC 网络公开。总的来说，这套 API 有三类：以 rpc 为前缀的与方法设置相关，以 rset 为前缀的
与属性同步相关，带有 unreliable 名称的基于 UDP 协议。或者从另一个角度分类：一类 RPC API 执行
配置，和使用 remote 这些关键字一样；另外一类 RPC API 用于执行节点方法；最后一类修改节点属性值。

- `rpc_config()` 执行 RPC 服务配置，设置指定 method 的 RPCMode 模式。
- `rset_config()` 执行 RPC 服务配置，设置指定 property 的 RPCMode 模式。
- `rpc()` 向远程主机发送 RPC 调用，只由远程主机上运行的程序中相同 NodePath 节点响应，并严格匹配节点名称。
- `rpc_id()` 向指定远程端 ID 的主机发送 RPC 调用。
- `rset()` 远程更改其他对等方（和本地）上的属性值，remotely set。
- `rset_id()` 远程更改指定远程端 ID 的主机的属性值，remotely set by peer ID。
- `rpc_unreliable()` 使用 UDP 协议的 `rpc()`。
- `rpc_unreliable_id()` 使用 UDP 协议的 `rpc_id()`。
- `rset_unreliable()` 使用 UDP 协议的 `rset()`。
- `rset_unreliable_id()` 使用 UDP 协议的 `rset_id()`。

Godot 4 精简了 RPC API，移除了属性设置的 RPC API。

Godot 联网中间层抽象为 `MultiplayerPeer`，对应 Godot 3 的类型 NetworkedMultiplayerPeer，
继承自 `PacketPeer`，这是从端点数据包传输的角度进行抽象。

|          Godot 3.5           |         Godot 4.0          |
|------------------------------|----------------------------|
|                              | ENetPacketPeer             |
| PacketPeerDTLS               | PacketPeerDTLS             |
| PacketPeerGDNative           | PacketPeerExtension        |
| PacketPeerStream             | PacketPeerStream           |
| PacketPeerUDP                | PacketPeerUDP              |
| WebRTCDataChannel            | WebRTCDataChannel          |
| WebSocketPeer                | WebSocketPeer              |
| NetworkedMultiplayerPeer     | MultiplayerPeer            |
| - MultiplayerPeerGDNative    | - MultiplayerPeerExtension |
| - NetworkedMultiplayerCustom | - OfflineMultiplayerPeer   |
| - NetworkedMultiplayerENet   | - ENetMultiplayerPeer      |
| - WebRTCMultiplayer          | - WebRTCMultiplayerPeer    |
| - WebSocketMultiplayerPeer   | - WebSocketMultiplayerPeer |

MultiplayerAPI 类型是 High-level multiplayer API 接口的实现者，通过 Node 节点相应方法提供服务，
默认地，SceneTree 包含了 MultiplayerAPI 的引用，通过 `get_multiplayer()` 方法获取。

Godot 4 中细化了 MultiplayerAPI，新增子 `SceneMultiplayer` 是这套 API 的默认实现，为节点
Node.rpc() 或 Node.rpc_id() 等方法提供支持，它们都需要 MultiplayerAPI.rpc() 方法。通过
另一个子类 `MultiplayerAPIExtension` 可以进行 API 扩展。

MultiplayerAPI 提供了联网相关的信号，在不同 Godot 版本下名称有所差别。信号参数中的 id 标记了
新连接或断开连接的 multiplayer_peer，服务端 ID 值为 1。建立连接或断开连接会向所有 clients 
发出信号，通过 id 判断发生连接或断开连接的对等端。

|              Godot 3               |          Godot 4           |          Notes           |
|------------------------------------|----------------------------|--------------------------|
| connected_to_server()              | connected_to_server()      | Only emitted on clients. |
| connection_failed()                | connection_failed()        | Only emitted on clients. |
| server_disconnected()              | server_disconnected()      | Only emitted on clients. |
| network_peer_connected(id: int)    | peer_connected(id: int)    | Emiited on any peer.     |
| network_peer_disconnected(id: int) | peer_disconnected(id: int) | Emiited on any peer.     |

还有一个数据接收时触发的信号，新版本中类结构有调整，这个信号整合到的新增的 SceneMultiplayer 类型上。
对方通过 MultiplayerAPI 或 SceneMultiplayer 接口 send_bytes() 发送数据，id 为其标识符。

- Godot 3.5 MultiplayerAPI: network_peer_packet(id: int, packet: PoolByteArray)
- Godot 4.0 SceneMultiplayer: peer_packet(id: int, packet: PackedByteArray)

前一个方法需要在 network_peer 接收到来自 `send_bytes()` 方法发送的数据时触发。

另外，NetworkedMultiplayerPeer，对应新版本的 MultiplayerPeer 只保留了两个连接信号：

|          Godot 3.4           |          Godot 4.x          |
|------------------------------|-----------------------------|
| NetworkedMultiplayerPeer     | MultiplayerPeer             |
| - connection_failed()        |                             |
| - connection_succeeded()     |                             |
| - peer_connected(id: int)    | -peer_connected(id: int)    |
| - peer_disconnected(id: int) | -peer_disconnected(id: int) |
| - server_disconnected()      |                             |

在旧版本文档中，只是说 peer_connected(id: int) 在服务端触发，但在客户端也一样会触发，只有断开
连接时 peer_disconnected(id: int) 才只发生在服务器。另外，在 Goodt 3.5.1 中，服务器断开连接
信号可以通过 NetworkedMultiplayerENet 触发，但是 MultiplayerAPI.server_disconnected()
可能并不会触发，如果改变了其默认绑定的信号处理函数。

无论如何，peer_disconnected 是一定会触发的，因为在 `poll()` 检测到对端断开连接就触发此信号。

在这些信号中，主要关心的是 peer 的连接与断开信号，另外三个信号只会在客户端触发，可以反映网络的状态。
而 peer 相关的两信号才是游戏联网中重点处理的。在接收到连接信号时，才可以安全地进行 RPC 操作，需要
随时跟踪与服务器的连接状态，或者 server_disconnected 信号：

```py
    # Godot 3
    SceneTree.network_peer.get_connection_status() == CONNECTION_CONNECTED ...
    Node.is_network_master()
    MultiplayerAPI.is_network_server()

    # Godot 4
    MultiplayerAPI mp_api = SceneTree.get_multiplayer()
    MultiplayerPeer mp_peer = mpapi.get_multiplayer_peer()
    if mp_pert.get_connection_status() == CONNECTION_CONNECTED ...
    MultiplayerAPI.is_server()
```

以下是一些常见错误信息，因为 client/server 端场景树节点结构不一致导致的：

    get_node: Node not found: "Main/1" (relative to "/root").
    process_simplify_path: Condition "node == nullptr" is true.
    _process_get_node: Failed to get path from RPC: Main/1.
    process_rpc: Invalid packet received. Requested node was not found.

服务器断开连接后还在调用 is_multiplayer_authority() 这些 RPC API 产生的错误：

    The multiplayer instance isn't currently active.
    No multiplayer peer is assigned. Unable to get unique ID.

连接超时后再尝试连接时出现的错误，因为没有调用 close_connection() 就尝试重新连接：

    ERROR: The multiplayer instance is already active.
       at: (modules/enet/networked_multiplayer_enet.cpp:118)

因为节点关闭后再对其调用 RPC API 导致的错误：

    ERROR: Condition "peer == nullptr" is true. Returning: -1
    at: send (modules/enet/enet_packet_peer.cpp:60)

服务器在接收到 peer_disconnected 信号时，应该等待一下再发送广播式调用，避免对已经断开连接的客户
客户端进行调用：

```py
func peer_disconnected(peer_id):
    print_debug("peer disconnected: %d." % [peer_id])
    # Disconnect peer specific from host.
    # multiplayer_peer.disconnect_peer(peer_id)
    # 
    # Wait ENet for less seconds to keep clean
    # Destroy player node on other clients peers
    call_deferred("rpc", "destroy_peer_broadcast", peer_id)
    #rpc("destroy_peer_broadcast", peer_id)
```


    ERROR: Condition "!is_inside_tree()" is true. Returning: false
       at: is_multiplayer_authority (scene/main/node.cpp:575)

开发 TCP 协议，可以设置工程中设置超时等待时间：

    ProjectSettings.set_setting("network/limits/tcp/connect_timeout_seconds", 9)


### 🟠🔵 DNS & IP Address 域名与地址分类
- [RFC 791 - IP(Internet Protocol)](https://www.rfc-editor.org/info/rfc791)
- [RFC 793 - TCP(Transmission Control Protocol)](https://www.rfc-editor.org/info/rfc793)
- [RFC3986 - Uniform Resource Identifier (URI)](https://www.rfc-editor.org/rfc/rfc3986)

IP 地址包含网络标识（网络号）和主机标识（主机号）两部分，用掩码来分割，掩码为 1 的比特位对应网络号。

IP 协议文档 RFC 791 中将 32-bit 得 IP 地址划分成三个类型：

      High Order Bits   Format                           Class
      ---------------   -------------------------------  -----
            0            7 bits of net, 24 bits of host    A
            10          14 bits of net, 16 bits of host    B
            110         21 bits of net,  8 bits of host    C
            111         escape to extended addressing mode

A 类地址最高位为 0，网络号占 7-bit network number，主机地址占 24-bit，共有 128 个 A 类网络。

       0                 1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0|   NETWORK   |                Local Address                  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

             Class A Address 0.0.0.0~127.255.255.255

B 类地址最高位为 10，网络号占 14-bit，主机地址占 16-bit，可以分配 16,384 个 B 类网络。

       0                 1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |1 0|           NETWORK         |          Local Address        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

             Class B Address 128.0.0.0~191.255.255.255

C 类地址最高位为 110，网络号占 21-bit，主机地址占 8-bit，可以分配 2,097,152 个 C 类网络。

       0                 1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |1 1 0|                    NETWORK              | Local Address |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

             Class C Address 192.0.0.0~224.255.255.255

互联网数字分配机构 IANA - The Internet Assigned Numbers Authority 在 RFC 1918 文档中
说明为私有网络预留出了三个 IP 地址块：

     10.0.0.0        -   10.255.255.255  (10/8 prefix)
     172.16.0.0      -   172.31.255.255  (172.16/12 prefix)
     192.168.0.0     -   192.168.255.255 (192.168/16 prefix)


除地址 A、B、C 分类外，还可根据传输的消息特征将 IP 地址分为单播、广播或多播。主机使用IP地址进行单播
一对一传输、多播一对多传输，或一对全网主机广播的通信。


单播地址是 IP 网络中最常见的，包含单播目标地址的分组发送给特定主机，例如 192.168.1.5 主机向地址
为 192.168.1.200 的服务器请求网页。

要发送和接收单播分组 Packet 数据报，IP 分组报头部中必须有一个目标 IP 地址，而以太网帧报头中必须
有相应的目标 MAC 地址。IP 地址和 MAC 地址一起将数据传输到特定的目标主机。

如果目标 IP 地址属于另一个网络，则在帧中使用的目标 MAC 地址将改为与源 IP 地址位于同一个网络中的
路由器接口的 MAC 地址。


广播分组的目标 IP 地址的主机部分全为 1，这意味着本地网络中的所有主机都将接收并查看该分组数据报。
诸如 ARP 和 DHCP 等很多网络协议都使用广播。例如，对于 C 类 IP 地址，前 24-bit 为网络号，最后
8-bit 为主机号，其对应广播地址为 192.168.1.255，主机部分为十进制数 255 或二进制数 11111111：

    类型  IP 单播地址   子网掩码         IP 广播地址
       A  10.0.0.0     255.0.0.0      10.255.255.255
       B  172.16.0.0   255.255.0.0    172.16.255.255
       C  192.168.1.0  255.255.255.0  192.168.1.255

在以太网帧中，必须包含与 IP 广播地址对应的 MAC 广播地址。在以太网中，MAC 广播地址长48位，其十六
进制表示为 FF-FF-FF-FF-FF-FF，全 1 为 MAC 广播地址，主机地址为全 1 即 IP 广播地址。


多播地址让源设备能够将分组报文 Packet 发送给一组设备。属于多播组的设备将被分配一个多播组 IP 地址，
多播地址范围为 224.0.0.0～239.255.255.255。由于多播地址表示一组设备，有时被称为主机组，因此只能
用作分组的目标地址，源地址总是为单播地址。

远程游戏就是一个使用多播地址的例子，很多玩家通过远程连接玩同一个游戏；另一例子是通过视频会议进行远程
教学，其中很多学生连接到同一个教室。

同单播地址、广播地址一样，IP 多播地址也需要相应的多播 MAC 地址在本地网络中实际传送帧。MAC 多播地址
以十六进制值 `01-00-5E` 打头，余下的 6 个十六进制位是根据 IP 多播组地址的最后 23 位转换得到的。
例如一个 MAC 多播地址可以是 01-00-5E-0F-64-C5。

由于广播方式无论连接到局域网的客户端想不想接收该数据，Server 都会给客户端发送该数据。进而造成客户端
数据拥塞，因此引入组播：Server 数据包只发送给指定组内的客户端，而不发送给指定组外的客户端。


互联网络中有两种经典模型，软件开发常用 TCP/IP 为核心的四层模型，IP 地址是核心元素：

|    OSI 七层网络模型   | 四层概念模型  |               对应网络协议               |
|---------------------|-------------|---------------------------------------|
| 应用层 Application   | 应用层       | HTTP、TFTP, FTP, NFS, WAIS、SMTP        |
| 表示层 Presentation  | -           | Telnet, Rlogin, SNMP, Gopher           |
| 会话层 Session       | -           | SMTP, DNS                              |
| 传输层 Transport     | 传输层       | TCP, UDP                               |
| 网络层 Network       | 网络层       | IP, ICMP, ARP, RARP, AKP, UUCP         |
| 数据链路层 Data Link  | 数据链路层   | FDDI, Ethernet, Arpanet, PDN, SLIP, PPP |
| 物理层 Physical      | -           | IEEE 802.1A, IEEE 802.2...IEEE 802.11    |

传输层及以下，都涉及相关的硬件进行工作，如：

- 传输层：四层交换机、四层路由器；
- 网络层：三层交换机、路由器；
- 链路层：网卡、网桥、以太网交换机；
- 物理层：中继器、集线器，网线。

除直接使用 IP 地址外，还有一种更人性化的 IP 使用方式，就是使用域名指代 IP。通过国际域名森林构架和
基础网络协议 Domain Name System (DNS) 的支持，用户只需要提供一个域名，就可以通过域名服务系统
查询到相应的 IP 地址，这比直接记住 IP 的方式好太多了。


DNS 域名空间使用分布式的解析方案，整个 DNS 架构是一种层次树状结构，这个树状结构称为 DNS 域名空间。

- 根域 Root Domain 位于域名空间最顶层，一般用一个 “.” 表示。
- 顶级域 Top Level Domain (TLD)，代表组织机构或国家地区，如 net、com、org、edu、gov、mil、cn、jp、hk。
- 二级域，用来标明顶级域内的一个特定的组织，如 .com.cn .net.cn .edu.cn 等等。
- 子域 Sub-Domain，二级域下所创建的各级域统称为子域，如 fanyi.baidu.com 前头的"翻译"。
- 主机 Host，主机位于域名空间最下层，就是一台具体的计算机，如 www、mail 都是具体的计算机名字。

Fully Qualified Domain Name (FQDN) 完全合格域名是指包含所有域名元素的域名表示方式，也是这
台主机在域名中的全名，比较少用，比如 www.fanyi.baidu.com。还有一些特殊的域名，比如本地主机用
loalhost 表示 127.0.0.1。

URI's are transferred as strings. The URI's format is defined in 
[http://tools.ietf.org/html/rfc3986](http://tools.ietf.org/html/rfc3986)

    3.  Syntax Components

      foo://example.com:8042/over/there?name=ferret#nose
      \_/   \______________/\_________/ \_________/ \__/
       |           |            |            |        |
    scheme     authority       path        query   fragment
       |   _____________________|__
      / \ /                        \
      urn:example:animal:ferret:nose


整个 DNS 域名查询过程是递归查询过程，从客户端开始，先向本地域名服务器发起查询请求外，即本机操作系统
提供的服务，然后，向本地域名服务器，直到根域服务器逐级查询，直到获取最终结果。

IPv6 的推出，相应出现了 inet_pton() 和 inet_ntop() 两个函数，它们支持 IPv4 和 IPv6 地址
的格式转换，即 "ddd.ddd.ddd.ddd" 格式与数值的转换，presentation 和 numeric 之间的转换。

Godot 中用 `IP` 类型来做域名、IP 地址转换，根据操作系统差别，会在内部方法中调用相应的 API：

```C++
// godot\core\io\ip.cpp
IPAddress IP::resolve_hostnam(const String &p_hostname, IP::Type p_type) {
    const PackedStringArray addresses = resolve_hostname_addresses(p_hostname, p_type);
    return addresses.size() ? (IPAddress)addresses[0] : IPAddress();
}

PackedStringArray IP::resolve_hostname_addresse(const String &p_hostname, Type p_type) {
    List<IPAddress> res;
    String key = _IP_ResolverPrivate::get_cache_key(p_hostname, p_type);

    resolver->mutex.lock();
    if (resolver->cache.has(key)) {
        res = resolver->cache[key];
    } else {
        // This should be run unlocked so the resolver thread can keep resolving
        // other requests.
        resolver->mutex.unlock();
        _resolve_hostname(res, p_hostname, p_type);
        resolver->mutex.lock();
        // We might be overriding another result, but we don't care as long as the result is valid.
        if (res.size()) {
            resolver->cache[key] = res;
        }
    }
    resolver->mutex.unlock();

    PackedStringArray result;
    for (int i = 0; i < res.size(); ++i) {
        result.push_back(String(res[i]));
    }
    return result;
}
```


### 🟠🔵 RPC APIs over ENet
- [Godot history in images!](https://godotengine.org/article/godot-history-images/)
- [ENet with DTLS encryption in 4.0](https://godotengine.org/article/enet-dtls-encryption/)
- [冗余传输机制的网络库](https://github.com/Uyouii/Redundancy-Transmission-Protocol)
- [Enet实现原理](https://blog.csdn.net/gamekit/article/details/107092176)
- [ENet Reliable UDP networking library](https://github.com/lsalzman/enet)
- [Lee Salzman's Page of Random Stuff](http://sauerbraten.org/lee/)
- [ENet v1.3.17 Reliable UDP networking library](http://enet.bespin.org/Features.html)
- [What Every Programmer Needs To Know About Game Networking](https://gafferongames.com/post/what_every_programmer_needs_to_know_about_game_networking/)
- [UDP vs. TCP by Glenn Fiedler](https://gafferongames.com/post/udp_vs_tcp/)
- [User Datagram Protocol (UDP)](https://www.khanacademy.org/a/transmission-control-protocol--tcp)
- [Transmission Control Protocol (TCP)](https://www.khanacademy.org/a/user-datagram-protocol-udp)
- [TCP 图解千百问](https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw)
- [gRPC Docs](https://grpc.io/docs/)
- [Protocol Buffers](https://github.com/protocolbuffers/protobuf)
- [Protocol Buffers Documentation](https://protobuf.dev)
- [Protobuf in GDScript](https://github.com/oniksan/godobuf)
- godot-docs\classes\class_multiplayerapi.rst
- godot-docs\classes\class_multiplayerpeer.rst
- godot-docs\classes\class_networkedmultiplayerenet.rst
- godot-docs\classes\class_enetmultiplayer.rst
- godot\core\io\multiplayer_api.cpp:260
- godot\core\io\networked_multiplayer_peer.h
- godot\modules\enet\enet_connection.h
- godot\modules\enet\networked_multiplayer_enet.cpp
- godot\scene\main\multiplayer_api.h
- godot\scene\main\multiplayer_peer.h
- [Multiplayer RPC APIs over ENet 【Godot 源代码阅读】](https://www.bilibili.com/read/cv21810824)

首先，这里涉及到源代码阅读，这就需要讨论一下阅读代码的方法论。阅读源代码的能力算是程序员的一种底层
基础能力之一，这个能力的重要性与研究数据结构与算法同等重要。软件开发的过程中必不避免接触到其他人的
工作成果，而阅读源代码可能是出于学习行为，也可以是出于项目需求问题的解决。

这里就阅读源代码给出几点参考意见：

- 源代码是人类的思想表达形式之一，阅读源代码相当于在做一个思维逆向工程，与软件破解逆向程没有本质区别。
- 每个人的代码组织会有所差异，与各人的思维方式直接相关，应该尽量尝试代入作者的思维看待问题。
- 不要想着通透所有代码，应该轻重分明，把握主线。阅读源代码前先建立目标，避免过多关注不相关代码。
- 阅读过程陷入停滞，就应该暂停一下，可能是某些相关的基础缺失导致这种结果，应该将时间用在打基础上。
- 不要完美主义，但可以更进一步，关注一每个小问题的解决。不要纠结缺失，它是提供一个未来进步的空间。
- 保持使用笔记的习惯，特别是方便快速检索和加查的工具。我推荐具有强大跳转功能的 Sublime Text。
- 将阅读结果整理成流程图，像以下这种简洁风格 ASCII 流程图最爱，它也是 RFC 文档的图表工具。
- 最后，以史为镜，可以知兴衰；以人为镜，可以知得失。遇事不决问历史。

记得第一次尝试阅读的源代码是 Wordpress，这是一个 Web 内容管理工具，我的习惯是先过一遍官方文档。
学习 Python、Lua、Vim 或者 Rust 等等，在也保持同样的习惯，当然，这可能要消耗大量时间。

特别是一点，当过程进行不下去的时候，几乎可以直接下定论：你可能遇到一个全新领域，对此，开启一个学习
专题，进行深入的探索才是出路。没有一个工程可以单靠单一的技术实现的，涉及面广泛是一个成功项目的标志，
探索过程带来的认识提升，也就是阅读源代码所带来的终极效果。


在 Godot RPC API 系统中，`MultiplayerAPI` 和 `MultiplayerPeer` 是两种最重要的类型，前者
用来管理 RPC 协议的规则与配置，后者通过具体网络传输协议提供网络通信支持，其中又以 ENet 协议的实现
类型 `NetworkedMultiplayerENet` 或者新版本中的 `ENetMultiplayerPeer` 为基础。


    +================+     +======+             +======+     +================+
    | MultiplayerAPI | --> | Peer | --> UDP --> | Peer | --> | MultiplayerAPI |
    +================+     +======+             +======+     +================+
           ↑              -------------------------------            ↓
     +============+                                            +============+
     | RPC Client |               ENet Protocol                | RPC Server |
     +============+                                            +============+

<!-- ![RPC](http://waylau.com/images/post/20160630-rpc.png) -->

通过后续的分析，最终可以得到以下这样的一个 RPC API 执行逻辑图，这里先展示出来。此图简化了网络传递，
着重 RPC 执行过程。发起 RPC API 调用过程是左侧 ENet Peer Host，以 `rpc()` 方法执行为线索，
其实 `rset()` 最后也会执行到 `_send_rpc()`，统一由 ENetPeer 进行网络传输：


              ENet Peer Host                            ENet Peer Host
    +=================================+         +============================+
    |   Nodes in SceneTree            |         |   Nodes in SceneTree       |
    |---------------------------------|         |                            |
    |            rpc() ->  rpcp()     |         |   +===================+    |
    |           get_multiplayer()     |         |   | MultiplayerAPI    |    |
    |----------------v----------------|         |   |-------------------|    |
    |   +=========================+   |         |   |            poll() |-+  |
    |   | MultiplayerAPI          |   |         |   |---------v---------| |  |
    |   |                  rpcp() |   |         |   | _process_packet() | |  |
    |   |------------v------------|   |         |   |---------v---------| |  |
    |   | network_peer            |   |         |   |_process_get_node()| |  |
    |   |       ->get_unique_id() |   |         |   |    _process_rpc() | |  |
    |   | p_node                  |   |         |   |   _process_rset() | |  |
    |   |   ->is_network_master() |   |         |   |---------v---------| |  |
    |   |   ->get_node_rpc_mode() |   |         |   +=========v=========+ |  |
    |   | ->get_script_instance() |   |         |             v           |  |
    |   |        ->get_rpc_mode() |   |         |   ->get_node_rpc_mode() |  |
    |   |------------v------------|   |         | ->get_script_instance() |  |
    |   |             _send_rpc() |   |         |  script->get_rpc_mode() |  |
    |   | network_peer            |   |         |        _can_call_mode() |  |
    |   |   ->set_transfer_mode() |   |         |                ->call() |  |
    |   |  ->_send_confirm_path() |   |         |                         |  |
    |   | =====all_peers_or====== |   |         |   +===================+ |  |
    |   | ======one_by_one======= |   |         |   |   MultiplayerENet | |  |
    |   |     ->set_target_peer() |   |         |   |-------------------| |  |
    |   |          ->put_packet() |>>>>>==ENet  |   |            poll() <-+  |
    |   | ========server========= |   | Socket=>>>>>|          ENetPeer |    |
    |   | ->enet_host_broadcast() |   |         |   +===================+    |
    |   | ========client========= |   |         |                            |
    |   |      ->enet_peer_send() |   |         +============================+
    |   |------------v------------|   |
    |   |    _should_call_local() |   |
    |   | get_network_unique_id() |   |
    |   |------------v------------|   |
    |   | ===call_local_native=== |   |
    |   | p_node                  |   |
    |   |                ->call() |   |
    |   |------------v------------|   |
    |   | ===call_local_script=== |   |
    |   | p_node                  |   |
    |   | ->get_script_instance() |   |
    |   |                ->call() |   |
    |   +=========================+   |
    +=================================+


Birrell 和 Nelson 在 1984 发表于 ACM Transactions on Computer Systems 的论文 
Implementing remote procedure calls 对 Remote Procedure Call Protocol (RPC) 
远程过程调用协议做了经典的诠释。客户端程序透过网络调用远程计算机上的对象，就像调用本地应用程序一样。

第一代 RPC 是 ONC RPC，以前称为 Sun RPC，它提供一个编译器，需要用户定义一个远程过程接口来生成
客户机和服务器的存根函数，client stub，这个编译器叫做 rpcgen，谷歌的 protobuf 构架也是这种。

第二代 RPC 支持对象，以微软 DCOM(COM+) 为代表。面向对象的语言开始在 1980 年代末兴起，很明显，
当时的 Sun ONC 和 DCE RPC 系统都没有提供任何支持诸如从远程类实例化远程对象、跟踪对象的实例或
提供支持多态性。

第三代 RPC 以 Web Services，Simple Object Access Protoco (SOAP) 简单对象访问协议为代表，
是 Web 平台编程流行的产物。

Enet 省略了某些更高级别的网络功能，例如身份验证，服务发现，加密或其他特定于应用程序的类似任务，
因此该库保持灵活，可移植且易于嵌入，并具以下优点：

01. 克服 TCP 不支持多信道问题；
02. 克服 TCP 需要用户自己处理粘包问题，UPD 数据包则先天有边界保护；
03. 克服 UDP 不支持排序，连接管理，带宽资源管理，数据包的大小有限制；
04. Enet 基于单一 UDP 协议实现了具有 UDP 和 TCP 等价功能，但比同时集成两者更干净、统一。

TCP 协议特点：

- TCP 基于连接实现可靠性传输，使开发更为简单，但同时也带来效率慢的特点。
- TCP 为流量设计，可使用滑动窗口控制每秒内可以传输多少KB的数据，讲究的是充分利用带宽。
- TCP 为了可靠性使用复杂的拥塞控制算法，3 次握手 4 次挥手建立和断开连接、重传策略。
- TCP 内置在系统协议栈中，极难对其进行改进。 

滑动窗口是一种基于双指针的一种算法思想，两个指针指向的元素之间形成一个窗口，通过调整窗口大小来控制
数据包的数量，以实现流量控制。窗口有两类，一种是固定大小类的窗口，一类是大小动态变化的窗口。

UDP 协议特点：

- UDP 协议基于**无连接**进行高效的**不可靠**数据传输，但同时应用层收到的数据有缺失、乱序等问题。
- UDP 协议头开销小，使用 8 个字节，相比 TCP 要占用 20 个字节。
- UDP 面向报文，有数据包边界保护。
- UDP 支持一对一、一对多、多对一和多对多的交互通信等。

UDP 协议以其简单、传输快的优势，在越来越多场景下取代 TCP，如网页浏览、流媒体、实时游戏、物联网。

从数据类型定义的角度来看，Godot 集成 ENet 源代码中：

- 每个主机对应 `ENetHost`：An ENet host for communicating with peers.
- 每个连接端对应的是 `ENetPeer`： An ENet peer which data packets may be sent or received from. 
- 每个数据包对应 `ENetPacket`：ENet packet structure.
- 每个数据信道对应 `ENetChannel`：ENet packet structure.

ENet 起源自 Lee Salzman 开发的一个免费联网 FSP 游戏，最新版本是 Cube 2: Sauerbraten，
为其编写的网络库就是 ENet。

基于 ENet 实现的各种 RPC API 有两种调用方式：

- Reliable 可靠：当函数调用到达时，将返回确认；一定时间后没有收到确认，则重新发送函数调用。
- Unreliable 不可靠：函数调用只发送一次，不检查是否到达，没有额外开销，典型的 UPD 协议风格。

![Client/Server vs. P2P Network](https://cdn.ttgtmedia.com/rms/onlineimages/client_server_vs_p2p_network-f.png)

服务器/客户端网络模型 Peer-to-Peer 是两种常见的网络模型，而 P2P 则是去中心化的网络模型。

ENet 对等网中所有主机在创建连接时都会相互确认连接，虽然建立连接时也需要服务器，但和传统的 C/S 网络
构架不同，ENet 中是对等网络模型。Peer to Peer (P2P) 打破了传统的 Client/Server (C/S) 模式，
在网络中的每个节点的地位都是对等的。每个节点既充当服务器，为其他节点提供服务，同时也享用其他节点提供
的服务。“Peer”在英语里有“对等者、伙伴、对端”的意义。

根据 ENet 文档描述，其功能包括：

- **连接管理** Connection Management：提供与外部主机通信的接口，动态监管外部主机及网络状况。
- **排序** Sequencing：提供多个合理排序的网络包流而非单一比特流，从而简化不同类型数据的传输。
- **通道** Channels：连接可用多个具有网络包独立排序的数据通道，解决因推迟可靠网络包的乱序排序问题。
- **可靠性** Reliability：可靠性是可选项，外部主机在特定时间内没有确认收到网络包就触发重传。
- **拆分和重组** Fragmentation & Reassembly：大数据包拆解发送，在接收端重组，此过程自动完成。
- **聚合** Aggregation：集合多个协议指令，ack，packet transfer 等，确保可用性，减少丢包及延时等。
- **适应性** Adaptability：使用动态适应的数据窗口，和静态的带宽分配机制，解决网络拥塞问题。

ENet 作为一种有传输信道的协议，ENetHost 以 channelLimit 指示信道数量，取值范围 [1, 255]，
默认定义了三种专用信道：

- **SYSCH_CONFIG** 系统配置变更通知
- **SYSCH_RELIABLE** 可靠模式专用通道
- **SYSCH_UNRELIABLE** 非可靠模式通道

ENet 协议定义了 12 条指令，每条指令都相应定义了其数据结构体，其中的：

- Acknowledge 确认指令，在收到可靠包后用来答复发送方，表明已经收到了相应的数据包；
- Ping 指令用于监测外部主机的连接状态等等，与心跳包发送时机相关；
- connect 指令用于主动发起连接的一端进行主动连接操作
- Verify Connect 建立连接时，在第二次握手用于答复，同时用于主动连接方同步被动连接方的相关信息。
- Bandwidth Limit 流量限制指令，调节对端对应本地的 peer 的带宽的相应的数值。
- Throttle Configure 流量控制调整指令，用于调节由 RTT 控制的 packetThrottle 相关设置。
- Send Reliable 可靠包发送指令，用于发送不用分片的可靠包，相应的数据跟在指令的后面。
- Send Unreliable 不可靠包发送指令，发送不用分片的不可靠包，与 unrealiable 包的实现机制相关。
- Send Unsequenced 指令发送不需要分片的 Unsequenced，用相应的 unsequencedGroup 标记序号。
- Send Fragment 指令用于发送所有需要分片的数据包，通过 flag 标记 reliable 和 unreliable 等类型。

```C++
    typedef enum _ENetProtocolCommand
    {
       ENET_PROTOCOL_COMMAND_NONE               = 0,
       ENET_PROTOCOL_COMMAND_ACKNOWLEDGE        = 1,
       ENET_PROTOCOL_COMMAND_CONNECT            = 2,
       ENET_PROTOCOL_COMMAND_VERIFY_CONNECT     = 3,
       ENET_PROTOCOL_COMMAND_DISCONNECT         = 4,
       ENET_PROTOCOL_COMMAND_PING               = 5,
       ENET_PROTOCOL_COMMAND_SEND_RELIABLE      = 6,
       ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE    = 7,
       ENET_PROTOCOL_COMMAND_SEND_FRAGMENT      = 8,
       ENET_PROTOCOL_COMMAND_SEND_UNSEQUENCED   = 9,
       ENET_PROTOCOL_COMMAND_BANDWIDTH_LIMIT    = 10,
       ENET_PROTOCOL_COMMAND_THROTTLE_CONFIGURE = 11,
       ENET_PROTOCOL_COMMAND_SEND_UNRELIABLE_FRAGMENT = 12,
       ENET_PROTOCOL_COMMAND_COUNT              = 13,

       ENET_PROTOCOL_COMMAND_MASK               = 0x0F
    } ENetProtocolCommand;

    typedef union _ENetProtocol
    {
       ENetProtocolCommandHeader header;
       ENetProtocolAcknowledge acknowledge;
       ENetProtocolConnect connect;
       ENetProtocolVerifyConnect verifyConnect;
       ENetProtocolDisconnect disconnect;
       ENetProtocolPing ping;
       ENetProtocolSendReliable sendReliable;
       ENetProtocolSendUnreliable sendUnreliable;
       ENetProtocolSendUnsequenced sendUnsequenced;
       ENetProtocolSendFragment sendFragment;
       ENetProtocolBandwidthLimit bandwidthLimit;
       ENetProtocolThrottleConfigure throttleConfigure;
    } ENET_PACKED ENetProtocol;
```

在创建时，ENet 会建立一个 `ENetHost` 作为通信的客户端，包含与 peer 进行通信的 socket。使用一个
ENetList dispatchQueue 队列存放有事件产生的 peers，还使用一个 ENetPeer* peers 数组用于
存放与外部客户端通信的 peer 数据结构。

ENet 使用比 TCP 更轻量的三次握手连接的二次握手断连，使用 verify Connect 指令确认，同时它用于
主动连接方同步被动连接方的相关信息。

ENet 在连接建立过程中可以改变 peer 的状态，过程如下：

- 首先，两个 host 建立连接前需要保证 peers 数组内有空闲的 peer，其状态为 `disconnected`。
- 主动连接方使用空闲 peer 向对端发送 `connect` 指令，状态变为 `connecting`。
- 对端接收到 `connect` 指令后，返回 `verify connect` 指令作为答复，状态变为 ack connect。
- 主动连接方收到 `verify connect` 指令后，并答复一个 ack 指令，其状态变为 `connected`，连接建立。
- 并且，向用户 dispatch 一个 **connect event** 事件。
- 对端接收到 ack 命令后，状态变为 `connnected`，双方连接建立完成。
- 并且，同样向用户 dispatch 一个 **connect event** 事件。

至此，双方连接建立完成。

ENet 提供了三种断开连接的方式：disconnect, disconneted now 和 disconnect later。

在断开连接再发起时，出现新旧两个连接的端口号相同的情况，会被判定为相同的连接，ENet 使用 SessionID
防止两个具有相同 IP 地址和端口号的前后两次连接发送的数据发生混淆。而 TCP 协议会使主动断开连接的一方
处于 TIME_WAIT 的状态来防止这种情况的发生。

但是，这只是简单的 ID 匹配，所以并不能像 TCP 100% 防止两次连接中数据包混淆这种情况的发生，但是
大部分情况下仍是有效的。

ENet 采用的是选择重传的方式，为保证新旧窗口的序号没有重叠，窗口的最大尺寸不应该超过序号空间的一半。
ENet 在发送新的数据包时会通过**usedReliableWindows**判断当前窗口占用是否与空闲窗口重叠，如果
重叠则暂停数据包的发送。reliableWindows 会记录各个窗口中目前在传输中的包的个数。

更进一步，ENet 提供了一个动态的阀门，packet throttle，来响应网络连接时带来的偏差，通过限制包的
发送数量来应对各种类型的网络拥塞问题。

网络状况评估指标：

    RTTV[n] = RTTV[n-1]* 3/4 + (RTT[n] - RTTS[n-1])1/4
    RTTS[n] = RTTS[n-1] * 7/8 +RTT[n]* 1/8
    RTO Limit： Min(30, Max(5, RTO * 32))

- Round-Trip Time (RTT) 往返时延，是指数据从网络一端传到另一端所需的时间。
- RTT smoothed (RTTs) 单位时间内 RTT 加权平均值。
- RTT variance (RTTv) 单位时间内 RTT 偏差加权平均值。
- Retransmission TimeOut (RTO) 重传超时时间。初始 RTO = RTTs + 4RTTv

初始超时重传时间 RTO = RTTs+4RTTv，下次超时重传时间是上一次重传时间的两倍，但最大不超过 500ms。
超时断开判定使用心跳信号，即在没有发送数据包的状态，超过 500ms 就会发送一个心跳包。

断开连接判定条件： currentTime-earliestTimeout > RTO Limit。


为了对 ENet 的源代码作一管中窥豹之举，这里以 Unique ID 以及它在接收端的身份 Sender ID 作为
Godot 集成的 ENet 源代码阅读线索，对涉及的关键内容进行梳理。

Godot 使用 C++ 封装了基于 C 语言的 ENet，整个构架封装在 NetworkedMultiplayerENet 类型中。
而 ENet 源代码存放在第三方目录下。

ENet 定义了四种事件，使用 I/O 事件轮询模型，封装在 NetworkedMultiplayerENet::poll()。当新
连接请求到来，根据读取到的 peer id，分别触发连接状态信号。在服务器端不触发连接成功信号，但会向当前
所有已连接的 peers 发送通告。将新加入 peer 通告给已有的 peers，反过来又将已有的 peers 通告给
新加入的 peer，这种双向的操作体现了对等网的基本特征：

```C++
    // godot\modules\enet\networked_multiplayer_enet.h
    void NetworkedMultiplayerENet::poll() {
        // ...
        ENetEvent event;
        int ret = enet_host_service(host, &event, 0);
        // ...
        /* Keep servicing until there are no available events left in the queue. */
        do {
            if (!host || !active) { // Check again after every event
                return;
            }
            switch (event.type) {
                case ENET_EVENT_TYPE_CONNECT: {
                    // ...
                    int *new_id = memnew(int);
                    *new_id = event.data;

                    // Data zero is sent by server. Server is always 1.
                    if (*new_id == 0) { 
                        *new_id = 1;
                    }

                    event.peer->data = new_id;

                    peer_map[*new_id] = event.peer;

                    // If connecting, this means it connected to something!
                    connection_status = CONNECTION_CONNECTED; 
                    emit_signal("peer_connected", *new_id);
                    // ...
                    if (server) {
                        for (Map<int, ENetPeer *>::Element *E = peer_map.front(); E; E = E->next()) {
                            if (E->key() == *new_id) {
                                continue;
                            }
                            // Someone connected, notify all the peers available
                            // 1. Send existing peers to new peer
                            // 2. Send the new peer to existing peers
                            // ...
                            packet = enet_packet_create(nullptr, 8, ENET_PACKET_FLAG_RELIABLE);
                            encode_uint32(SYSMSG_ADD_PEER, &packet->data[0]);
                            //encode_uint32(E->key(), &packet->data[4]);
                            encode_uint32(*new_id, &packet->data[4]);
                            enet_peer_send(E->get(), SYSCH_CONFIG, packet);
                        }
                    } else {
                        emit_signal("connection_succeeded");
                    }
                } break;
                case ENET_EVENT_TYPE_DISCONNECT: {
                    // ...
                    if (!server) {
                        emit_signal("connection_failed");
                    }
                    // ...
                    if (!server) {
                        // Client just disconnected from server.
                        emit_signal("server_disconnected");
                        close_connection();
                        return;
                    } else if (server_relay) {
                        // Server just received a client disconnect and is in 
                        // relay mode, notify everyone else.
                    }
                    emit_signal("peer_disconnected", *id);

                } break;
                case ENET_EVENT_TYPE_RECEIVE: {
                    if (event.channelID == SYSCH_CONFIG) {
                        // Some config message
                        // ...
                        switch (msg) {
                            case SYSMSG_ADD_PEER: {
                                peer_map[id] = NULL;
                                emit_signal("peer_connected", id);

                            } break;
                            case SYSMSG_REMOVE_PEER: {
                                peer_map.erase(id);
                                emit_signal("peer_disconnected", id);
                            } break;
                        }

                        enet_packet_destroy(event.packet);
                    }
                } break;
                case ENET_EVENT_TYPE_NONE: {
                    // Do nothing
                } break;
            }
        } while (enet_host_check_events(host, &event) > 0);
    }
```

在接收数据阶段，也会触发 peer 的连接与断开信号，对应 SYSCH_CONFIG 信道发送的 SYSMSG_ADD_PEER
和 SYSMSG_REMOVE_PEER 两种配置消息。接收的数据保存到 **incoming_packets**，稍后就可以使用它。


NetworkedMultiplayerPeer 中定义的 get_unique_id() 方法是一个纯虚函数，它需要由子类根据具体
协议来实现，例如 NetworkedMultiplayerENet 的实现中，就使用 1 代表服务器。而创建服务器时，就根据
时钟加用户目录、数据指针地址等生成一个 ID，使用的算法是 Hash Djb 2：

```C++
    // godot\core\io\networked_multiplayer_peer.h

    virtual int get_unique_id() const = 0;

    // godot\modules\enet\networked_multiplayer_enet.h

    int NetworkedMultiplayerENet::get_unique_id() const {
        return unique_id;
    }

    Error NetworkedMultiplayerENet::create_client(
        const String &p_address, int p_port, 
        int p_in_bandwidth, int p_out_bandwidth, int p_client_port) {
        // ...
        unique_id = _gen_unique_id();
    }

    uint32_t NetworkedMultiplayerENet::_gen_unique_id() const {
        uint32_t hash = 0;

        while (hash == 0 || hash == 1) {
            hash = hash_djb2_one_32(
                    (uint32_t)OS::get_singleton()->get_ticks_usec());
            hash = hash_djb2_one_32(
                    (uint32_t)OS::get_singleton()->get_unix_time(), hash);
            hash = hash_djb2_one_32(
                    (uint32_t)OS::get_singleton()->get_user_data_dir().hash64(), hash);
            hash = hash_djb2_one_32(
                    (uint32_t)((uint64_t)this), hash); // Rely on ASLR heap
            hash = hash_djb2_one_32(
                    (uint32_t)((uint64_t)&hash), hash); // Rely on ASLR stack

            // Make it compatible with unsigned, since negative ID is used for exclusion
            hash = hash & 0x7FFFFFFF; 
        }

        return hash;
    }

    static inline uint32_t hash_djb2_one_32(uint32_t p_in, uint32_t p_prev = 5381) {
        return ((p_prev << 5) + p_prev) + p_in;
    }
```

触发 `peer_connected` 信号时，或者自己给自己发送 RPC 调用时，get_rpc_sender_id() 返回值为 0。
Godot 3.5 中如果配置错误会导致 ScreenTree 获取到的发送方 ID 总是为 0，它又直接包装调用 MultiplayerAPI 的
get_rpc_sender_id() 方法获取 peer ID，而后者直接返回数据成员 `rpc_sender_id`。这个值会在
MultiplayerAPI 构造函数中初始化为 0。


MultiplayerAPI 有多个位置涉及 rpc_sender_id 的读写：

- **MultiplayerAPI::MultiplayerAPI()** 构造器中初始化为 0 值；
- 执行 `poll()` 方法轮询数据时，`get_packet_peer()` 获取 ID；
- **MultiplayerAPI::rpcp()** 执行远程调用；
- **MultiplayerAPI::rsetp()** 执行远程属性设置；

一般同不直接调用 NetworkPeer `poll()` 方法，而是通过 MultiplayerAPI 根据当前联接状态调用它。

ENet 接收到的数据会保存到 **incoming_packets**，其中就包含 sender id，`get_packet_peer()` 
就可以查询数据包中的这个 ID，在轮询时，这个 ID 会在 `_process_packet()` 期间生效。根据数据包
指定的命令，数据包处理函数会进行相应操作，Godot 将这些命令定义在枚举类型 `NetworkCommands`，对应
各种 RPC 行为。也就是说，要读取 sender id，就应该在执行 REMOTE_CALL 和 REMOTE_SET 两个命令
期间进行，也就是远端 RPC 远程调用方法执行时。

其中的 RAW 命令是更低层的数据接收处理，会触发 **network_peer_packet** 信号，让用户有机会参与。


```C++
    // godot\modules\multiplayer\scene_multiplayer.h
    // godot-3.5.1-stable\core\io\multiplayer_api.h:113
    enum NetworkCommands {
        NETWORK_COMMAND_REMOTE_CALL,
        NETWORK_COMMAND_REMOTE_SET,
        NETWORK_COMMAND_SIMPLIFY_PATH,
        NETWORK_COMMAND_CONFIRM_PATH,
        NETWORK_COMMAND_RAW,
    };

    // godot\modules\multiplayer\scene_multiplayer.cpp
    // godot-3.5.1-stable\core\io\multiplayer_api.cpp
    void MultiplayerAPI::poll() {
        // ...
        network_peer->poll();
        // ...
        while (network_peer->get_available_packet_count()) {
            int sender = network_peer->get_packet_peer();
            // ...
            Error err = network_peer->get_packet(&packet, len);
            // ...
            rpc_sender_id = sender;
            _process_packet(sender, packet, len);
            rpc_sender_id = 0;
            // ...
        }
    }

    void MultiplayerAPI::_process_raw(int p_from, const uint8_t *p_packet, int p_packet_len) {
        PoolVector<uint8_t> out;
        int len = p_packet_len - 1;
        out.resize(len);
        {
            PoolVector<uint8_t>::Write w = out.write();
            memcpy(&w[0], &p_packet[1], len);
        }
        emit_signal("network_peer_packet", p_from, out);
    }
```

将关注点转到 process packet 的部分来，它才是 Godot 3.x RPC 远程调用的终点站。在这里，会触发
Godot 3.x 两类远程调用的响应方法，即 `rpc()` 和 `rset()` 两者调用的远程方法。

RPC 执行到 `_process_rpc()` 或者 `_process_rset()` 就要进行鉴权，如果节点没有相应的权限，
则不给予执行，还要检测数据包是否有问题等等，并提示错误信息。`_can_call_mode()` 方法验证 RPC
配置与节点设置是否对应：

```C++
void MultiplayerAPI::_process_packet(int p_from, const uint8_t *p_packet, int p_packet_len) {
    // ...
    uint8_t packet_type = p_packet[0];

    switch (packet_type) {
        // ...
        case NETWORK_COMMAND_REMOTE_CALL:
        case NETWORK_COMMAND_REMOTE_SET: {

            Node *node = _process_get_node(p_from, p_packet, p_packet_len);
            // ...
            StringName name = String::utf8((const char *)&p_packet[5]);

            if (packet_type == NETWORK_COMMAND_REMOTE_CALL) {
                _process_rpc(node, name, p_from, p_packet, p_packet_len, len_end + 1);
                // --> bool can_call = _can_call_mode(p_node, rpc_mode, p_from);
            } else {
                _process_rset(node, name, p_from, p_packet, p_packet_len, len_end + 1);
            }
        } break;
        // ...
    }
}

void MultiplayerAPI::_process_rpc(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {

    // Check that remote can call the RPC on this node.
    RPCMode rpc_mode = RPC_MODE_DISABLED;
    const Map<StringName, RPCMode>::Element *E = p_node->get_node_rpc_mode(p_name);
    if (E) {
        rpc_mode = E->get();
    } else if (p_node->get_script_instance()) {
        rpc_mode = p_node->get_script_instance()->get_rpc_mode(p_name);
    }

    bool can_call = _can_call_mode(p_node, rpc_mode, p_from);

    int argc = p_packet[p_offset];
    // ...
    p_offset++;

    for (int i = 0; i < argc; i++) {

        int vlen;
        Error err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen, allow_object_decoding || network_peer->is_object_decoding_allowed());
        ERR_FAIL_COND_MSG(err != OK, "Invalid packet received. Unable to decode RPC argument.");

        argp.write[i] = &args[i];
        p_offset += vlen;
    }
    // ...
    p_node->call(p_name, (const Variant **)argp.ptr(), argc, ce);
    // ...
}

_FORCE_INLINE_ bool _can_call_mode(Node *p_node, MultiplayerAPI::RPCMode mode, int p_remote_id) {
    switch (mode) {
        case MultiplayerAPI::RPC_MODE_DISABLED: {
            return false;
        } break;
        case MultiplayerAPI::RPC_MODE_REMOTE:
        case MultiplayerAPI::RPC_MODE_REMOTESYNC: {
            return true;
        } break;
        case MultiplayerAPI::RPC_MODE_MASTERSYNC:
        case MultiplayerAPI::RPC_MODE_MASTER: {
            return p_node->is_network_master();
        } break;
        case MultiplayerAPI::RPC_MODE_PUPPETSYNC:
        case MultiplayerAPI::RPC_MODE_PUPPET: {
            return !p_node->is_network_master() && p_remote_id == p_node->get_network_master();
        } break;
    }

    return false;
}
```

通过以上分析，最终可以得到开始展示的 RPC API 执行逻辑图，简化了网络传递，着重 RPC 执行过程。
从发起 RPC API 调用 `rpc()` 方法，到远端执行为线索，`rset()` 最后也会执行到 `_send_rpc()`，
一由 ENetPeer 进行网络传输。


执行到 MultiplayerEnet 的 `put_packet()` 方法后，就即将进入 ENet 源代码的 C API，其中有
`enet_peer_send()` 和 `enet_host_broadcast()`，分别用于单端消息和广播消息的发送。

另外一个路线是 rset() -> rsetp()，大体上流程一致。

在数据经网络传输之前或接收到数据，需要相应调用 `encode_variant()` 和 `decode_variant()` 
进行类型进制制表达转换，涉及到对象的序列化与反序列化，Serialization vs. Deserialization。
Go 语言中又称为 marshalling 和 unmarshalling。这是一个新的领域，可以开启另一个专题进行探索。

源代码文件参考：

- godot-3.5.1-stable\core\io\marshalls.h
- godot-3.5.1-stable\scene\main\node.cpp
- godot-3.5.1-stable\core\io\multiplayer_api.cpp@_send_rpc
- godot-3.5.1-stable\modules\enet\networked_multiplayer_enet.cpp@put_packet
- godot-3.5.1-stable\thirdparty\enet\peer.c@enet_peer_send
- godot-3.5.1-stable\thirdparty\enet\host.c@enet_host_broadcast
- godot-3.5.1-stable\core\io\packet_peer.h
- godot-3.5.1-stable\core\io\packet_peer_udp.cpp
- godot\core\io\net_socket.h
- godot\core\io\marshalls.cpp
- godot\scene\main\multiplayer_api.cpp
- godot\modules\multiplayer\scene_multiplayer.h
- godot\modules\multiplayer\scene_rpc_interface.h
- godot\core\io\packet_peer.h
- godot\modules\multiplayer\scene_cache_interface.h


### 🟠🔵 Custom MultiplayerAPI 3.x
- https://godotforums.org/d/32791-invalid-packet-received-tries-to-confirm-a-path-which-was-not-found-in-cache
- https://github.com/godotengine/godot/issues/73194

Node 节点提供 `set_custom_multiplayer()` 用来指定用户自定义的 MultiplayerAPI 对象，为其
设置根节点能有效地使用不同的 MultiplayerAPI 管理场景树的不同分支，例如，允许在同一场景中运行
客户端和服务器。

注意 `set_root_node()` 指定的根节点，RPC 机制将使用相对它的路径而不是绝对路径来查找应该在其上
执行 RPC 的节点。比如，有这样的节点路径，/main/test，并且 RPC 方法定义在 test 节点上。那么设置
根节点时，就要指定 main 节点，而不能指定 test 为根节点，这样会导致定位不到。

注意，使用轮询方法应该对 multiplayer_poll 属性做判断，当 ScreenTree 禁止数据轮询就应该停下来。

触发 `peer_connected` 信号时，或者自己给自己发送 RPC 调用时，get_rpc_sender_id() 返回值为 0。
但是 Godot 3.5 中 ScreenTree 获取到的发送方 ID 总是为 0。什么情况算是自己给自己发 RPC 调用呢？

比如说，定义一个 `sync func test()` 方法，sync 等价于 remotesync，会在触发 RPC 调用的主机
上执行，也会在所有远程端执行。那么对于调用 `rpc("test")` 的主机，执行这个函数时，就是自己给自己
发送 RPC 调用。这种情况下，**SceneTree** get_rpc_sender_id() 总是返回 0 值。其它主机上则相反，
**MultiplayerAPI** get_rpc_sender_id() 总是返回 0 值。

对于 sender id 这个获取方法，文档中的描述，肯定是要在 RPC 调用时才有效：

- **SceneTree**: Returns the sender's peer ID for the most recently received RPC call.
- **MultiplayerAPI** Returns the sender's peer ID for the RPC currently being executed.

ScreenTree 获取发送方 peer ID 的方法直接包装调用 MultiplayerAPI 的 get_rpc_sender_id() 
方法，而后者直接返回数据成员 `rpc_sender_id`。这个值会在 MultiplayerAPI 构造函数中初始化为 0，
在 MultiplayerAPI 执行 `poll()` 方法轮询数据时，临时用 `get_packet_peer()` 去获取当前正在
操作中的主机 ID。

但是用来获取当前主机 ID 方法逻辑不同，get_network_unique_id() 等价于 get_unique_id()，无论是
ScreenTree 包装 MultiplayerAPI，还再包装 NetworkPeer，因为只是获取当月前主机的 ID，所以返回的
值部是创建 ENetPeer 时生成的值：

```C++
    // void MultiplayerAPI::_bind_methods() {
    ClassDB::bind_method(D_METHOD("get_rpc_sender_id"), &MultiplayerAPI::get_rpc_sender_id);

    int get_rpc_sender_id() const { return rpc_sender_id; }

    MultiplayerAPI::MultiplayerAPI() : allow_object_decoding(false) {
        rpc_sender_id = 0;
        root_node = nullptr;
        clear();
    }

    int MultiplayerAPI::get_network_unique_id() const {
        return network_peer->get_unique_id();
    }

    int SceneTree::get_network_unique_id() const {
        return multiplayer->get_network_unique_id();
    }
```

由于 ENet 是对待网络模型，其中的 `peer_connected` 信号会在服务端和客户端执行，并且，每当有新
的客户端连接到服务器，服务器都会将这个新连接信息广播给其它已连接的客户端，同时又将原有连接的客户端
通行给这个新加入的客户端。随着客户数量增加，后面加入的客户端就会在刚建立连接时接收到越多的连接信号。

以下是一个纯脚本编写的 Godot 程序，可以通过命令行工具来运行它，在 Powershell 中可以给 Godot
指定不同的参数方便调试，如窗口位置、大小，GPU 指定，还有脚本路径，或者无窗口等等：

```sh
cls; cd C:\download\games\mainloop;
$base = "C:\download\games"
$gd = "$base\mainloop\scenetree3.gd"
$gd3 = "$base\Godot_v3.5.1-stable_win64.exe"
$gd4 = "$base\Godot_v4.0-rc1_win64.exe"
$gd3m = "$base\Godot_v3.5.1-stable_mono_win64\Godot_v3.5.1-stable_mono_win64.exe"
$gd4m = "$base\Godot_v4.0-rc1_mono_win64\Godot_v4.0-rc1_mono_win64.exe"
&$gd3 --script $gd --client --gpu-index 0 -t --resolution 180x240 --position 200,640 --no-window --headless
#&$gd4 --path . --client --gpu-index 0 -t --resolution 180x240 --position 800,400
```

```py

```

测试中发现 Godot 3.5.1 无法触发 `send_bytes()` 成功发送数据，倒是产生一条错误信息：

    ERROR: Condition "incoming_packets.size() == 0" is true. Returned: 1
       at: get_packet_peer (modules/enet/networked_multiplayer_enet.cpp:49)

以下有一些常见错误。RPC 配置或者节点权限不匹配导致 RPC 不能远程调用的问题：

    ERROR: RPC 'test' is not allowed on node /root from: 1399276778. Mode is 0, master is 1.
       at: (core/io/multiplayer_api.cpp:285)

错误提示 RPC_MODE_DISABLED = 0 禁用了 RPC 行为，或者使用自定义 MultiplayerAPI 配置错误。


因为没有场景根节点产生的错误，只要给 SceneTree.root 节点下添加一个名为 "Main" 的根节点即可：

    ERROR: (Node not found: "Main" (relative to "/root").)
       at: (scene/main/node.cpp:1465)
    ERROR: Failed to get path from RPC: Main.
       at: _process_get_node (core/io/multiplayer_api.cpp:251)

有些更怪异的问题会随着 RPC 调用的时间不同而产生，紧接在 peer_connected 信号触发时调用 rpc() 
就可能产生以下问题，但只需要等待少许时间就没有问题：

    https://github.com/godotengine/godot/issues/34676

    ERROR: Invalid packet received. Unabled to find requested cached node.
       at: (core/io/multiplayer_api.cpp:260)
    ERROR: Invalid packet received. Requested node was not found.
       at: (core/io/multiplayer_api.cpp:203)

提示信息表示，缓存节点中找不到与请求一致的节点，发生在 `_process_packet()`，这里，这个函数不能
通过 `_process_get_node()` 方法找到 **path_get_cache** 缓存有一致的节点。

以下错误发生在 `_process_confirm_path()`，确认到 **path_send_cache** 没有缓存一致的节点。
这个问题会在首次 `rpc()` 执行完成后触发。

    ERROR: Invalid packet received. Tries to confirm a path which was not found in cache.
       at: (core/io/multiplayer_api.cpp:404)

发生在 `_process_packet()` 的路径确认行为由 NETWORK_COMMAND_CONFIRM_PATH 命令触发。这是
`rpc()` 执行周期结束后的另一轮数据处理流程，新数据包的首字节包含一个 RPC 命令，。

以上这些问题都指向节点路径缓存，在接收端触发的问题行为。

```C++
    // godot\modules\multiplayer\scene_multiplayer.h
    // godot-3.5.1-stable\core\io\multiplayer_api.h:113
    enum NetworkCommands {
        NETWORK_COMMAND_REMOTE_CALL,
        NETWORK_COMMAND_REMOTE_SET,
        NETWORK_COMMAND_SIMPLIFY_PATH,
        NETWORK_COMMAND_CONFIRM_PATH,
        NETWORK_COMMAND_RAW,
    };

    // godot-3.5.1-stable\core\io\multiplayer_api.cpp:188
    // Extract the `packet_type` from the LSB three bits:
    uint8_t packet_type = p_packet[0] & CMD_MASK;

    switch (packet_type) {
        case NETWORK_COMMAND_SIMPLIFY_PATH: {
            _process_simplify_path(p_from, p_packet, p_packet_len);
        } break;

        case NETWORK_COMMAND_CONFIRM_PATH: {
            _process_confirm_path(p_from, p_packet, p_packet_len);
        } break;

        case NETWORK_COMMAND_REMOTE_CALL:
        case NETWORK_COMMAND_REMOTE_SET: { 
            // ...
            Node *node = _process_get_node(p_from, p_packet, p_packet_len);
            // ...
            if (packet_type == NETWORK_COMMAND_REMOTE_CALL) {
                _process_rpc(node, name, p_from, p_packet, p_packet_len, len_end + 1);
            } else {
                _process_rset(node, name, p_from, p_packet, p_packet_len, len_end + 1);
            }
        } break;
        case NETWORK_COMMAND_RAW: {
            _process_raw(p_from, p_packet, p_packet_len);
        } break;
        // ...
    }
```

Godot 3.5 使用了节点路径缓存，发送方和接收方分开两个 HashMap 存储，peer ID 作为 key 使用。
在 ENet 网络中，有连接或断开时会相应对 path_get_cache 进行修改，断开连接则两处都需要更新。
有多个位置会修改这些 HashMap：

- `MultiplayerAPI::_send_rpc()`，发送 RPC 调用时执行。
- `MultiplayerAPI::_add_peer()`，默认的 peer_connected 信号的处理函数。
- `MultiplayerAPI::_del_peer()`，默认的 peer_disconnected 信号的处理函数。

值得注意的是 `set_network_peer()` 方法，调用它设置不同值会执行重置行为，`clear()` 掉原来的
缓存数据。如果是指定新的 NetworkPeer，还会连接默认的信号处理方法。MultiplayerAPI 构造和解构时
都会清理缓存数据。

```C++
    //path sent caches
    struct PathSentCache {
        Map<int, bool> confirmed_peers;
        int id;
    };

    //path get caches
    struct PathGetCache {
        struct NodeInfo {
            NodePath path;
            ObjectID instance;
        };

        Map<int, NodeInfo> nodes;
    };

    HashMap<NodePath, PathSentCache> path_send_cache;
    Map<int, PathGetCache> path_get_cache;


    void MultiplayerAPI::_send_rpc(Node *p_from, int p_to, bool p_unreliable, bool p_set, const StringName &p_name, const Variant **p_arg, int p_argcount) {
        // ...
        // See if the path is cached.
        PathSentCache *psc = path_send_cache.getptr(from_path);
        if (!psc) {
            // Path is not cached, create.
            path_send_cache[from_path] = PathSentCache();
            psc = path_send_cache.getptr(from_path);
            psc->id = last_send_cache_id++;
        }
        // ...
    }

    void MultiplayerAPI::_add_peer(int p_id) {
        connected_peers.insert(p_id);
        path_get_cache.insert(p_id, PathGetCache());
        emit_signal("network_peer_connected", p_id);
    }

    void MultiplayerAPI::_del_peer(int p_id) {
        connected_peers.erase(p_id);
        // Cleanup get cache.
        path_get_cache.erase(p_id);
        // Cleanup sent cache.
        // Some refactoring is needed to make this faster and do paths GC.
        List<NodePath> keys;
        path_send_cache.get_key_list(&keys);
        for (List<NodePath>::Element *E = keys.front(); E; E = E->next()) {
            PathSentCache *psc = path_send_cache.getptr(E->get());
            psc->confirmed_peers.erase(p_id);
        }
        emit_signal("network_peer_disconnected", p_id);
    }

    void MultiplayerAPI::clear() {
        connected_peers.clear();
        path_get_cache.clear();
        path_send_cache.clear();
        packet_cache.clear();
        last_send_cache_id = 1;
    }
```


### 🟠🔵 Custom MultiplayerAPI 4.x
- [Npcap](https://nmap.org/npcap/#download)
- [Add peer authentication support](https://github.com/godotengine/godot/pull/67917)
- https://docs.godotengine.org/en/latest/classes/class_scenemultiplayer.html
- https://github.com/Faless/gd-mp-password-auth


测试用命令行：

```sh
cls; cd C:\download\games\mainloop;
$base = "C:\download\games"
$gd = "$base\mainloop\mainloop.gd"
$gd3 = "$base\Godot_v3.5.1-stable_win64.exe"
$gd4 = "$base\Godot_v4.0-rc1_win64.exe"
$gd3m = "$base\Godot_v3.5.1-stable_mono_win64\Godot_v3.5.1-stable_mono_win64.exe"
$gd4m = "$base\Godot_v4.0-rc1_mono_win64\Godot_v4.0-rc1_mono_win64.exe"
$gd4c = "$base\godot\godot\bin\godot.windows.editor.x86_64.exe"
#$gd4 --script $gd --client --no-window --headless
&$gd4 --script $gd --server --gpu-index 0 -t --resolution 180x240 --position 900,640
```

Godot 4.x 中移除了 SceneTree 获取 sender id 方法。另外，MultiplayerAPI 中的方法名称更新，
`get_remote_sender_id()` 为新方法名称，还有 `get_network_unique_id()` 变更为更一致的
`get_unique_id()`。

Godot 4.x 指定自定义 MultiplayerAPI 的差异与配置要点：

- 设置自定义使用 SceneTree `set_multiplayer()` 方法，同时可以指定 root path (NodePath)；
- 用户不再需要处理 poll，只需要设置相应的 SceneTree.multiplayer_poll 状态即可；
- Node 节点不再提供 `set_custom_multiplayer()`，同时，multiplayer 也成为只读属性；
- 新版本中 MultiplayerAPI 变为接口，提供 SceneMultiplayer 作为具体实现；
- 提供服务器联接后，要重置 MultiplayerAPI，multiplayer_peer = null，并且禁止 loll。


连接事件处理注意，它们的触发模型不一样：

- `ENetMultiplayerPeer` peer_connected 会在与服务器建立连接时触发。
- `MultiplayerAPI` peer_connected 会在与与对等端建立连接时触发，服务器也算对待端。
- 在断开连接时，以上两个对象上注册的 **peer_disconnected** 都会触发。

虽然文档中说 MultiplayerPeer **set_target_peer()** 可以指定数据包要发向哪个对端，或是广播。
但测试 Godot 4.0 RC1 只有在 `send_bytes()` 方法中指定才有效。

另外，`set_multiplayer()` 方法按 root path 来设置自定义 MultiplayerAPI 实例，可以给不同的
节点路径指定一个自定义的对象。旧版本的操作则是直接调用节点的 `set_custom_multiplayer()` 设置。


Godot 4.0 RC1 SceneMultiplayer 增加了两个授权相关信号，并且有配套的属性与方法一起使用，连接的
同时进行权限配置：

```py
# Properties
Callable auth_callback
float auth_timeout

# Methods
Error send_auth(id: int, data: PackedByteArray)
Error send_bytes(bytes: PackedByteArray, id: int = 0, mode: TransferMode = 2, channel: int = 0)
Error complete_auth(id: int)
PackedInt32Array get_authenticating_peers()

# Signals
peer_authenticating(id: int) # used id with send_auth()
peer_authentication_failed(id: int)
peer_packet(id: int, packet: PackedByteArray) # used with send_bytes()
```

传入 `send_auth()` 的数据作为身份验证消息的一部分发送到 id 对应的远端，可用于验证，并控制何时
发出 MultiplayerAPI **peer_connected** 信号，通常是远程对等端被接受为已连接时。

新版本鉴权 API 使用流程：

- 设置有效的 auth_callback (int, PackedByteArray) 以触发审核信号，等待对端连接请求；
- 触发审核信号后，可以接收到对端 ID，和其它数据一起通过 send_auth() 发送到对端；
- 对端的 auth_callback 将被调用，并且，调用 `complete_auth()` 后发出 peer_connected 信号。

在未建立对等连接的状态下，对等体只包含在 `get_authenticating_peers()`，而不在 MultiplayerAPI
`get_peers()` 返回的表中，并且只会发送或接收身份验证数据。

默认审核超时 3s，此时间内没有完成审核即触发审核失败信号。



    ERROR: Invalid packet received. Tries to confirm a path which was not found in cache.
       at: (modules/multiplayer/scene_cache_interface.cpp:122)



    ERROR: Invalid target peer: 1
       at: (modules/enet/enet_multiplayer_peer.cpp:339)

    ERROR: Invalid target peer: 793682958
       at: (modules/enet/enet_multiplayer_peer.cpp:339)


调用 send_bytes() 发送数据时触发，执行 `get_packet_peer()` 查询数据包来源方 ID 时：

    ERROR: Condition "incoming_packets.size() == 0" is true. Returning: 1
       at: get_packet_peer (modules/enet/enet_multiplayer_peer.cpp:42)


以上错误具体触发时机也在 poll() 轮询入站数据时，ENet 接收到的入站数据保存在 `incoming_packets`
这向量列表中，按代码逻辑，在有数据包入站并且数据长度为 0 时就触发这样的错误。

```C++
Error SceneMultiplayer::poll() {
    // ...
    multiplayer_peer->poll();
    // ...
    while (multiplayer_peer->get_available_packet_count()) {
        int sender = multiplayer_peer->get_packet_peer();
        // ...
}
```

Godot 4.0 为 ENet 新增 MODE_MESH 联网模式，原有 MODE_SERVER，MODE_CLIENT，不同的活动模式
基本都与 peer 连接与断开信号相关。Mesh 原指无线网格网络组网方式，取间其自组织能力，网络节点和授权
最终用户可即时加入网络。

```C++
void ENetMultiplayerPeer::poll() {

    switch (active_mode) {

        case MODE_MESH: {
            HashSet<int> to_drop;
            for (KeyValue<int, Ref<ENetConnection>> &E : hosts) {
                ENetConnection::Event event;
                ENetConnection::EventType ret = E.value->service(0, event);
                do {
                    if (ret == ENetConnection::EVENT_CONNECT) {
                        event.peer->reset();
                    } else if (ret == ENetConnection::EVENT_RECEIVE) {
                        _store_packet(E.key, event);
                    } else if (ret == ENetConnection::EVENT_NONE) {
                        break; // Keep polling the others.
                    } else {
                        to_drop.insert(E.key); // Error or disconnect.
                        break; // Keep polling the others.
                    }
                } while (E.value->check_events(ret, event) > 0);
            }
            for (const int &P : to_drop) {
                if (peers.has(P)) {
                    emit_signal(SNAME("peer_disconnected"), P);
                    peers.erase(P);
                }
                hosts.erase(P);
            }
        } break;
    }
}
```

Godot 4.0 新增了用于 Scene Replication API 的命令，主要是 SPAWN 和 DESPAWN。定义了每个
RPC 命令至少有 6 个字节，外加用户数据，通过 SceneMultiplayer::send_command() 发送：
改造的 MultiplayerAPI 向节点提供 `rpc()` 和  `rpc_id()` 方法支持，同时也为 SceneTree
自动同步复制提供支持，通过 `MultiplayerSpawner` 和 `MultiplayerSynchronizer` 节点。
还有相应的配置资源类型 `SceneReplicationConfig`。

```C++
    enum NetworkCommands {
        NETWORK_COMMAND_REMOTE_CALL = 0,
        NETWORK_COMMAND_SIMPLIFY_PATH,
        NETWORK_COMMAND_CONFIRM_PATH,
        NETWORK_COMMAND_RAW,
        NETWORK_COMMAND_SPAWN,
        NETWORK_COMMAND_DESPAWN,
        NETWORK_COMMAND_SYNC,
        NETWORK_COMMAND_SYS,
    };

    enum SysCommands {
        SYS_COMMAND_AUTH,
        SYS_COMMAND_ADD_PEER,
        SYS_COMMAND_DEL_PEER,
        SYS_COMMAND_RELAY,
    };

    enum {
        // Command + sys command + peer_id (+ optional payload).
        SYS_CMD_SIZE = 6,
    };
```

Wireshark 抓包工具可以调试各种网络协议，要监听 127.0.0.1 本地回环网络通信，只需要安装 Npcap。
安装完后，在 Wireshark 主界面选择网卡接口时，使用 Adapter for loopback traffic capture。
揽入抓包状态下，可以使用过滤器，在过滤器输入框录入 udp 即可以将所有 UDP 流量过滤出来。

点击抓包列表中的任意流量记录，在解码内容窗口中会直接显示 IP、UDP 等协议头数据，和用户数据。



用户数据发送逻辑，进行到 `put_packet()` 就是属于 ENet 部分：

    +===============================+
    |         SceneMultiplayer      |
    |-------------------------------|
    | ===============> send_bytes() |
    |                               |
    | multiplayer_peer:             |
    |                  ->is_valid() |
    |     ->get_connection_status() |
    |      ->set_transfer_channel() |
    |         ->set_transfer_mode() |
    |----------------v--------------|
    | =============> send_command() |
    |               get_unique_id() |
    | multiplayer_peer:             |
    | ->is_server_relay_supported() |
    |           ->set_target_peer() |
    |----------------v--------------|
    | ====================> _send() |
    |          _profile_bandwidth() |
    | multiplayer_peer:             |
    |                ->put_packet() |
    +===============================+


非连接状态下调用 RPC API，如 poll(), get_unique_id() 触发以下错误。断开连接后，需要重置 peer：

    ERROR: The multiplayer instance isn't currently active.
       at: (modules/enet/enet_multiplayer_peer.cpp:439)


ObjectDB 使用 **slot_count** 记录所创建的实例，add_instance 和 remove_instance 对其更新，
程序退出执行清理方法 cleanup()，发现 slot_count 没有归零，就警告有实例泄露：

    WARNING: ObjectDB instances leaked at exit (run with --verbose for details).
         at: cleanup (core/object/object.cpp:1982)
    Leaked instance: SceneTreeTimer:-9222500124133949013
    Hint: Leaked instances typically happen when nodes are removed from the scene tree (with `remove_child()`) but not freed (with `free()` or `queue_free()`).
    Orphan StringName: SceneMultiplayer
    Orphan StringName: FileAccess
    Orphan StringName: timeout
    Orphan StringName: SceneTreeTimer
    StringName: 4 unclaimed string names at exit.

场景树的节点会在退出时自动清理，但是对于没有通过 add_child() 附加到场景树上的节点，则不会被清理，
它们是游离节点，Orphans，可以在调试面板中查看当前的孤儿节点。另外，Reference 或者 RefCounted
使用引用计数系统，会在不什么时自动清理。

使用 `--verbose` 启动 Godot 可以打印出细节信息，如上面所示：导致泄露的是 SceneTreeTimer 实例，
因为定时器还在运行，在主动退出时导致这个警告。



### 🟠🔵 Marshalling vs unmarshalling
- [Binary serialization API](https://docs.godotengine.org/en/stable/tutorials/io/binary_serialization_api.html)

对象的序列化与反序列化，Serialization vs. Deserialization。 
Go 语言中又称为 marshalling 和 unmarshalling。



### 🟠🔵 Multiplayer: Scene Replication
- [HTerrain plugin](https://hterrain-plugin.readthedocs.io/en/latest/)
- [HTerrain plugin demo project in Godot Engine 3](https://github.com/Zylann/godot_hterrain_demo)
- [HeightMap terrain for Godot](https://github.com/Zylann/godot_heightmap_plugin)
- [Voxel module for Godot](https://github.com/Zylann/godot_voxel)
- [Mitchell Reid - MitchMakesThings](https://github.com/MitchMakesThings/Godot-Things/tree/main/Networking)
- [Godot 4 Multiplayer - RPC 教程](https://www.bilibili.com/video/BV17P411c75s/)
- [Godot 4 Multiplayer - RPC](https://github.com/TheGodojo/Godot-4-Networking-Demonstration-Complete)
- [Godot 4 Multiplayer - Spawner/Synchronizer 教程](https://www.bilibili.com/video/BV1VY411o793/)
- [Godot 4 Multiplayer - Spawner/Synchronizer](https://github.com/TheGodojo/Multiplayer-Nodes-Complete)
- [Multiplayer in Godot 4.0: Scene Replication (part 1)](https://godotengine.org/article/multiplayer-changes-godot-4-0-report-4/)
- [Add a multiplayer interface and visual nodes for SceneTree replication](https://github.com/godotengine/godot-proposals/issues/3459)
- [Visual Nodes for multiplayer scene replication](https://github.com/godotengine/godot-proposals/issues/3359)
- godot\master\modules\multiplayer\multiplayer_synchronizer.h
- godot\master\modules\multiplayer\multiplayer_synchronizer.cpp

使用 Godot 4 新增两个联网专用节点可能是最简单的联网游戏开发工具了：

- `MultiplayerSpawner` 孵化器节点，自动同步复制节点，自动从授权端将 spawn 节点复制到其远端。
- `MultiplayerSynchronizer` 同步节点，数据自动同步复制节点，自动将本地节点的属性同步到远端。
- SceneReplicationConfig 数据自动同步复制节点的配置对象。

这两个自动化同步节点包装了 RPC API，简化了游戏同步功能的实现，目标是无代码地实现快速开发原型产品。

Godot 4 最新提供的这套 Scene Replication API 设计目的就是开箱即用，能快速地开发原型：

- Provide an out-of-the-box solution for scene state replication across the network.
- Allow for (almost) no-code prototyping.
- Be extensible with game-specific behaviours (custom reconciliation, interpolation, interest management, etc).
- Allow ex-post (incremental) optimizations of network code.
- Be easy to use for game developers, of course :)

设置同步属性中会遇到两个选项配置：

- **Spawn**: Creating, or requesting remotely to create a new Object.
- **Sync**: Updating, or requesting remotely to update the state of an Object.

在场景中添加 `MultiplayerSpawner` 节点，在添加要同步的对象及属性，在列表中提供相应的设置。在属性
面板中，还可以设置：

- Spawn Limit 可以自动孵化的节点数量限制值；
- Spawn Path 指定要检测的节点路径，这个节点路径下可能包含要自动同步复制的场景节点实例；
- Auto Spawn List 列表中和 Spawn Path 节点下匹配的场景节点会被同步复制；

Spawner 可以设置一个 `spawn_function` 孵化函数，当 authority 调用 `spawn()` 方法时，就会
发到远程调用，在所有 peer 主机上执行它，可以通过 `spawn()` 向孵化函数传递数据。孵化函数应该返回
一个 Node，引擎会自动将这个新生节点添加到场景树上。

一个小缺点是，所有这些都是用节点指定的，会附加这些额外生成的节点，没有太多理论上的运行时逻辑。

有两个节点孵化相关信号：

- `despawned(node: Node)` 孵化节点被 authority 撤消之后触发，只在 puppets 端触发。
- `spawned(node: Node)` 可孵化节点被 authority 生成后触发，只在 puppets 端触发。



假设这样一个场景：玩家控制 Player.tscn 场景节点，服务器端接收到客户端的连接请求时，就实例化一个
新的 Player 节点。而这个新的节点当下只在服务器端生成，还没有在刚刚建立连接的客户端创建。Spawner
节点的作用就是在检测到新增的 Player 场景节点时，自动同步复制到客户端。为了方便管理同步复制的节点，
就需要给 Spawner 设置一个 Spawn Path 路径，在这个节点路径下挂载新创建的 Player 场景节点。

玩家节点同步复制成功后，所有网络节点上都会拥有相同的场景树结构，而不同的玩家控制着不同的 Player。
在游戏的过程中，会产生新的 Player 状态数据，而这些数据又需要向其它对等端广播，以实现全场的玩家
观看到的游戏画面是一致的，这就是 Synchronizer 节点的作用。

SceneMultiplayer 作为 MultiplayerAPI 的子类，其中一个功能就是通过以上 Scene Replication
相关节点提供无代码化的同步复制功能。在选中 `MultiplayerSynchronizer` 节点时，底部面板区会出现
Replication 面板，这里用来配置需要自动同步复制的属性。

配置 replication_interval 属性可以改变同步频率，默认值为 0.0 表示在每个网络处理帧都会同步。
根节点路径用于 RPC 和 Scene Replication API，使用相对路径来查找应该在其上执行 RPC 的节点。
数据同步节点可以通过修改配置来改变自动同步的行为，通常由 SceneTree 内部配置 MultiplayerAPI。
在属性面板中，提供了一个 Root Path 属性，指示 Synchronizer 要同步的数据来源节点相对于此路径。

数据同步的逻辑比节点同步要复杂一点，假设当前有 3 个玩家，那么其中一个玩家 Player 节点有更新，那么
Synchronizer 就要负责责将最新的节点数据同步到其它两个玩家的网络节点上。Scene Replication API
设计目的就是开箱即用，无代码化，所以配置好要同步的节点根路径，和要同步的属性后，Synchronizer 就会
根据 `replication_interval` 属性设置同步频率，以最快速度将节点属性数据发送出去。

而开发者要做的事情就是，按正常逻辑修改同步中的属性，Synchronizer 会负责读取并在网络上广播。


```py
Error object_configuration_add(object: Object, configuration: Variant)
Error object_configuration_remove(object: Object, configuration: Variant)
```



### 🟠🔵 Multiplayer RPC 实例演示
- [Multiplayer Bomber Demo](https://godotengine.org/asset-library/asset/139)
- [Pong Multiplayer](https://godotengine.org/asset-library/asset/138)
- [Pong Non-Multiplayer](https://github.com/godotengine/godot-demo-projects/tree/master/2d/pong)
- [Godot Multiplayer Networking Cheatsheet](https://blog.iancolwell.ca/godot-multiplayer-networking-cheatsheet)
- [Godot 4.x Multiplayer RPC](https://github.com/jeangowhy/godot-tour/tree/4.x/multiplayer_rpc)
- [Godot 3.5 Multiplayer RPC](https://github.com/jeangowhy/godot-tour/tree/main/multiplayer_rpc)

使用 Godot 4.x RPC API 进行网络游戏开发的工作流程概要：

- 配置 MultiplayerPeer 启动相应的服务器/客户端；
- 建立连接，记录 peer ID 并给相应的节点设置主控端 ID；
- 配置 RPC API，根据需要设置 RPC 的调用方式，主要是：any_peer authority call_local call_remote；
- 通过 is_network_master() 或 is_multiplayer_authority() 主动判断当前节点是否归属于主控；
- 执行 rpc() 或 rpc_id() 等方法执行 RPC 调用远程方法，进行数据同步；
- 处理网络连接，以下结束连接；

使用 RPC API 涉及到的数据同步，需要通过定义各种 RPC 方法来实现，比如，以下例子中用于记录所有客户
连接标志的 connected_peer_ids，在服务器端总能记录到所有客户端的 ID。但是新加入的客户端，只知道
自己与服务器的连接，其它客户端的连接需要通过查询（同步）服务器中的数据。所以，每当有新客户端发出连接
请求时，服务端都需要执行一个 new_peer_broadcast 广播，远程调用所有客户端的方法，以创建相应的新
玩家节点。同时，对于原有玩家，需要通过 rpc_id() 指定 ID 调用新玩家主机上的 API，同步创建与服务
场景树一致的节点结构：

```py
var connected_peer_ids = []

func new_peer_connected(peer_id):
    await get_tree().create_timer(0.5).timeout
    # create player on all clients side.
    rpc("new_peer_broadcast", peer_id)
    rpc_id(peer_id, "old_peer_replication", connected_peer_ids)
    # create player on server side for client.
    create_player(peer_id)

func create_player(peer_id = 1):
    connected_peer_ids.append(peer_id)
    var player = preload("res://player.tscn").instantiate()
    player.set_multiplayer_authority(peer_id)
    add_child(player)
    rpc("refresh_peer_node_inf")
    if peer_id == multiplayer.get_unique_id():
        local_player = player

@rpc 
#@rpc("authority", "call_remote", "reliable", 1)
func new_peer_broadcast(new_peer_id):
    create_player(new_peer_id)

@rpc
#@rpc("authority", "call_remote", "reliable", 1)
func old_peer_replication(peer_ids):
    for peer_id in peer_ids:
        create_player(peer_id)
```

注意，默认的 @rpc 标注是 call_remote 方式调用，不会在主控端运行，只在其它所有远程端执行数据同步。
因为连接信号是服务器端的行为，所以 @rpc 方式调用就是在所有客户端执行，由服务器发起 RPC 调用，但是
不包括服务器。

使用 RPC API 最后阶段包含结束连接处理，当客户端或服务器端断开连接，就应该做相当的处理。客户端结束，
整个连网系统还在运行，只是其中一个对等端的退出，需要将其占用的资源清理掉。而对于服务器结束，所以客户
端都会失去连网功能，要么等待服务器重新启动再尝试连接，要么清理所有客户端相关资源。MultiplayerPeer
需要关闭，并且释放 multiplayer_peer = null，同时场景中也不能再调用相关的 RPC API。

通过 MultiplayerAPI.has_multiplayer_peer() 可以查询当前的连接状态，作为执行 RPC 的依据。

服务器端开启后就会进行侦听，等待客户端的连接请求。而客户端连接服务器则需要根据网络状态而定，有时可能
因为网络不稳定，需要越长时间的才能建立连接。更坏的情况是，根本不能正常建立连接，经过一段时间尝试还
不能建立连接，就会因为连接超时，进而触发 connetion_failed 信号。可以说，connected_to_server
是最不重要的连接信号之一。

工程设置 Network Limits 可以配置 TCP 连接超时秒数 connect_timeout_seconds，默认值 30。

服务器信号使用不恰当可能会导致服务器端在首个客户端连接时，重复出现 ID = 1 的 peer 连接。一般只
需要将客户端的信号，与服务器端的信号分开连接使用。

|              Godot 3               |          Godot 4           |          Notes           |
|------------------------------------|----------------------------|--------------------------|
| connected_to_server()              | connected_to_server()      | Only emitted on clients. |
| connection_failed()                | connection_failed()        | Only emitted on clients. |
| server_disconnected()              | server_disconnected()      | Only emitted on clients. |
| network_peer_connected(id: int)    | peer_connected(id: int)    | Emiited on any peer.     |
| network_peer_disconnected(id: int) | peer_disconnected(id: int) | Emiited on any peer.     |

注意，虽然文档中表示客户端也会触发 peer_disconnected 信号，但测试中发现 peer_connected 才会
在客户端触发，需要通过 server_disconnected 来检测服务器是否断开。

在旧版本文档中，只是说 peer_connected(id: int) 在服务端触发，但在客户端也一样会触发，只有断开
连接时 peer_disconnected(id: int) 才只发生在服务器。另外，在 Goodt 3.5.1 中，服务器断开连接
信号可以通过 NetworkedMultiplayerENet 触发，但是 MultiplayerAPI.server_disconnected()
并不会触发。

以下示范工程为 Godot 4.x 版本，只包含两个场景：

- player.tscn 玩家场景节点，提供玩家的基本角色行为和外观；
- main.tscn 主场景，提供连接类型选择界面，和连接信号的管理；

Godot 3.5 的一些 API 差别，另外 Godot 4.x 新增了 Signl 类型，Object 原有的信息相关 API 保留：

|               Godot 3.5               |           Godot 4.x           |
|---------------------------------------|-------------------------------|
| ENetMultiplayerPeer                   | MultiplayerPeer               |
| - -                                   | - close()                     |
| NetworkedMultiplayerENet              | ENetMultiplayerPeer           |
| - close_connection()                  | - -                           |
| MultiplayerAPI                        | MultiplayerAPI                |
| - network_peer                        | - multiplayer_peer            |
| - get_rpc_sender_id()                 | - get_remote_sender_id()      |
| - set_network_peer()                  | - set_multiplayer_peer()      |
| - get_network_unique_id()             | - get_unique_id()             |
|---------------------------------------|-------------------------------|
| Array                                 |                               |
| - remove(position: int)               | - remove_at()                 |
|---------------------------------------|-------------------------------|
| LineEdit                              |                               |
| - text_entered                        | - text_submitted              |
|---------------------------------------|-------------------------------|
| Spatial                               | Node3D                        |
| - global_translation                  | - global_position             |
|---------------------------------------|-------------------------------|
| Node                                  |                               |
| - is_network_master()                 | - is_multiplayer_authority()  |
| - set_network_master()                | - set_multiplayer_authority() |
|---------------------------------------|-------------------------------|
| InputEventMouseButton                 |                               |
| - doubleclick                         | - double_click                |
|---------------------------------------|-------------------------------|
| InputEventKey                         |                               |
| - scancode                            | - key_code                    |
|---------------------------------------|-------------------------------|
| Signal                                |                               |
| - Object.get_signal_connection_list() | - Signal.get_connections()    |
| - Object.disconnect()                 | - Signal.disconnect()         |
|---------------------------------------|-------------------------------|
| yield                                 | await                         |
| - yield( object, "completed" )        | - await object                |
| - yield( object, "signal" )           | - await object.signal         |


Godot 3.5 中，MultiplayerAPI 还绑定了默认的信号处理函数，并且获取信号绑定列表返回的字典包含的
字段比 Godot 4.x 中的更多：

```py
    object.get_signal_connection_list("signal"):
    return array of dictionary:
    { 
        binds:[], flags:0, 
        method:_server_disconnected, 
        signal:server_disconnected, 
        source:[MultiplayerAPI:1249], 
        target:[SceneTree:1242]
    }

    signal.get_connections() 
    return array of dict: {signal, callable}
```


以下示范工程为 Godot 4.x 版本，只包含两个场景：

- player.tscn 玩家场景节点，提供玩家的基本角色行为和外观；
- main.tscn 主场景，提供连接类型选择界面，和连接信号的管理；

主场景使用的 main_rpc.gd 脚本参考如下：

```py
    extends Node3D


    const PORT = 4567
    const HOST = "127.0.0.1"

    var multiplayer_peer = ENetMultiplayerPeer.new()
    var connected_peer_ids = []
    var local_player

    @onready var message_input = $MessageInput
    @onready var menu = $Menu
    @onready var host = $Menu/bg/vbox/Host
    @onready var join = $Menu/bg/vbox/Join
    @onready var network_side = $NetworkInfo/NetworkSide
    @onready var peer_node_inf = $NetworkInfo/PeerNodeInfo


    func _ready():
        # Start the server/client by pass "--server" or "--client" argument.
        if "--server" in OS.get_cmdline_args():
            start_server()
        elif "--client" in OS.get_cmdline_args():
            start_client()
        else:
            menu.visible = true

        host.pressed.connect(start_server)
        join.pressed.connect(start_client)

        #message_input.connect("text_submitted", _on_message_input_text_submitted)
        message_input.connect("focus_entered", _on_message_input_focus_entered)
        message_input.connect("focus_exited", _on_message_input_focus_exited)


    func toggle_pause_mode():
        var mode = get_tree().paused
        var fps = ProjectSettings.get_setting("physics/common/physics_ticks_per_second", 60)
        # set_physics_process(false)
        # set_process(false)
        get_tree().set_pause(!mode)
        if mode:
            Engine.set_physics_ticks_per_second(fps)
        else:
            Engine.set_physics_ticks_per_second(fps/3)


    func _unhandled_input(event):
        if not event is InputEventKey or not event.is_pressed():
            return
        if event.keycode == KEY_ESCAPE:
            clear_connections()
        elif event.keycode == KEY_ENTER and not message_input.has_focus():
            message_input.grab_focus()
        elif event.keycode == KEY_P:
            toggle_pause_mode()

    func reset_signals(is_server = true):
        clear_signal(multiplayer_peer.peer_disconnected)
        clear_signal(multiplayer_peer.peer_connected)
        clear_signal(multiplayer.server_disconnected)
        clear_signal(multiplayer.connected_to_server)
        clear_signal(multiplayer.connection_failed)
        if is_server:
            # Signals for server
            multiplayer_peer.peer_disconnected.connect(peer_disconnected)
            multiplayer_peer.peer_connected.connect(new_peer_connected)
        else:
            # Signals for clietns
            multiplayer.server_disconnected.connect(func(): destroy_peer(get_multiplayer_authority()))
            multiplayer.connected_to_server.connect(func(): print_debug("Connected to server: %s:%d" % [HOST, PORT]))
            multiplayer.connection_failed.connect(connection_failed)

    func clear_signal(sgl: Signal):
        for conn in sgl.get_connections():
            print_debug("disconnect observer: ", conn["signal"])
            conn["signal"].disconnect(conn.callable)


    func start_server():
        reset_signals(true)
        message_input.text = "Starting a new server ..."
        var err = multiplayer_peer.create_server(PORT)
        if OK != err:
            print_debug("Can't create an ENet server on %s:%s" % [HOST, PORT])
            return
            
        multiplayer.multiplayer_peer = multiplayer_peer
        menu.visible = false
        network_side.text = "Server"
        message_input.text = ""
        print_debug("Start ENet Server on %s:%d." % [HOST, PORT])
        
        # create server side player
        create_player()


    func start_client():
        reset_signals(false)
        message_input.text = "Starting a new client ..."
        var err = multiplayer_peer.create_client(HOST, PORT)
        if OK != err:
            print_debug("Can't create an ENet client on %s:%s" % [HOST, PORT])
            return
            
        multiplayer.multiplayer_peer = multiplayer_peer
        menu.visible = false
        network_side.text = "Client"
        print_debug("Start ENet Client on %s:%d." % [HOST, PORT])
        await get_tree().create_timer(0.5).timeout
        message_input.text = ""


    func connection_failed():
        message_input.text = "Connection failed: %s:%d" % [HOST, PORT]
        await get_tree().create_timer(3).timeout
        menu.visible = true


    func new_peer_connected(peer_id):
        print_debug("new peer connected: %d." % [peer_id])
        message_input.text = "new peer connected: %d." % [peer_id]
        await get_tree().create_timer(0.5).timeout
        message_input.text = ""
        # create player on all clients side.
        rpc("new_peer_broadcast", peer_id)
        rpc_id(peer_id, "old_peer_replication", connected_peer_ids)
        # create player on server side for client.
        create_player(peer_id)


    func create_player(peer_id = 1):
        connected_peer_ids.append(peer_id)
        var player = preload("res://player.tscn").instantiate()
        player.set_multiplayer_authority(peer_id)
        add_child(player)
        rpc("refresh_peer_node_inf")
        if peer_id == multiplayer.get_unique_id():
            local_player = player

        # exit power saving mode when peers connection comming
        set_physics_process(true)
        set_process(true)


    func peer_disconnected(peer_id):
        print_debug("peer disconnected: %d." % [peer_id])
        # Disconnect peer specific from host.
        # multiplayer_peer.disconnect_peer(peer_id)
        
        # Wait ENet for less seconds to keep clean
        # Destroy player node on other clients peers
        call_deferred("rpc", "destroy_peer_broadcast", peer_id)
        #rpc("destroy_peer_broadcast", peer_id)


    func clear_connections():
        multiplayer_peer.close()
        multiplayer.multiplayer_peer = null
        #get_tree().set_multiplayer_poll_enabled(false)
        #get_tree().multiplayer_poll = false
        for id in connected_peer_ids:
            get_node(str(id)).queue_free()
        connected_peer_ids.clear()
        menu.visible = true
        # power saving when there no connection
        set_physics_process(false)
        set_process(false)

    func destroy_peer(peer_id):
        if peer_id == 1:
            print_debug("Server closed!")
            clear_connections()
            return
        get_node(str(peer_id)).queue_free()
        connected_peer_ids.remove_at(connected_peer_ids.find(peer_id))
        refresh_peer_node_inf()


    @rpc 
    #@rpc("authority", "call_remote", "reliable", 1)
    func new_peer_broadcast(new_peer_id):
        create_player(new_peer_id)

    @rpc("authority", "call_local", "reliable", 1)
    func destroy_peer_broadcast(peer_id):
        destroy_peer(peer_id)


    @rpc("any_peer", "call_local")
    func refresh_peer_node_inf():
        peer_node_inf.text = "#%d / %d" % [multiplayer.get_unique_id(), len(connected_peer_ids)]

    @rpc("any_peer")
    func old_peer_replication(peer_ids):
        for peer_id in peer_ids:
            create_player(peer_id)


    func _on_message_input_focus_entered():
        local_player.enable_input(false)

    func _on_message_input_focus_exited():
        local_player.enable_input(true)

    func _on_message_input_text_submitted(new_text):
        local_player.rpc("display_message", new_text)
        message_input.text = ""
        message_input.release_focus()
        message_input.accept_event();
```

玩家场景使用的脚本参考：

```py
    extends MeshInstance3D

    var speed = 10
    var can_process_input = true

    @onready var message = $Message
    @onready var myname = $Name

    func _ready():
        name = str(get_multiplayer_authority())
        myname.text = str(name)

    func _physics_process(delta):
        if can_process_input and multiplayer.has_multiplayer_peer() and is_multiplayer_authority():
            var axis_x = int(Input.is_key_pressed(KEY_A)) - int(Input.is_key_pressed(KEY_D))
            var axis_z = int(Input.is_key_pressed(KEY_W)) - int(Input.is_key_pressed(KEY_S))
            var direction:Vector3 = Vector3(-axis_x, 0, -axis_z)
            
            if direction.length():
                # update my position by myself.
                global_position += direction.normalized() * delta * speed
                # refresh my position of all clients by RPC API.
                rpc("remote_set_position", global_position)

    func _unhandled_input(event):
        if not event is InputEventMouseButton:
            return
        match [event.button_index, event.double_click, event.pressed]:
            [MOUSE_BUTTON_LEFT, true, true]:
                set_my_message("I'm myself!")

    func enable_input(enable):
        can_process_input = enable


    func set_my_message(msg):
        # This api works just for me
        #if not name != str(get_multiplayer_authority()):
        if not is_multiplayer_authority():
            return
        message.text = msg


    @rpc("unreliable")
    func remote_set_position(pos):
        print_debug("authority call remote: #%d - %s - " % [get_multiplayer_authority(), pos])
        global_position = pos

    @rpc
    #@rpc("authority", "call_remote", "reliable", 1)
    func display_message(msg):
        message.text = str(msg)

    @rpc
    #@rpc("authority", "call_remote", "reliable", 1)
    func shake_me():
        message.text = "Shake me!"

    @rpc("any_peer", "call_local", "reliable", 1)
    func shake_all():
        message.text = "Shake all!"

    @rpc("any_peer", "call_local", "reliable", 1)
    func clicked_by_player():
        var sender = multiplayer.get_remote_sender_id()
        message.text = str(sender) + " hit me!"
        if get_multiplayer_authority() == sender:
            message.text = "hit myself!"


    func _on_area_input_event(_camera, event, _position, _normal, _shape_idx):
        if not event is InputEventMouseButton:
            return
        match event.button_index:
            MOUSE_BUTTON_LEFT:
                rpc("clicked_by_player")
            MOUSE_BUTTON_RIGHT:
                if is_multiplayer_authority():
                    rpc("shake_me")
            MOUSE_BUTTON_MIDDLE:
                rpc("shake_all")
```

## 🟡 GDScript 
- [GDScript Basics](https://docs.godotengine.org/en/3.5/tutorials/scripting/gdscript/gdscript_basics.html)
- [GDScript Advanced](https://docs.godotengine.org/en/3.5/tutorials/scripting/gdscript/gdscript_advanced.html)
- [GDScript exports](https://docs.godotengine.org/en/3.5/tutorials/scripting/gdscript/gdscript_exports.html)
- [Singletons (AutoLoad)](https://docs.godotengine.org/en/3.5/tutorials/scripting/singletons_autoload.html)
- [When you should use an Autoload](https://docs.godotengine.org/en/3.5/tutorials/best_practices/autoloads_versus_internal_nodes.html)
- [GDScript grammar](https://docs.godotengine.org/en/stable/development/file_formats/gdscript_grammar.html)
- [Import process](https://docs.godotengine.org/en/stable/tutorials/assets_pipeline/import_process.html)
- [GDScript 2.0 reference](https://docs.godotengine.org/en/latest/tutorials/scripting/gdscript/gdscript_basics.html)
- [Godot 4 GDScript Features - GDScript 2.0](https://gdscript.com/articles/godot-4-gdscript/)
- [Data preferences](https://docs.godotengine.org/en/3.5/tutorials/best_practices/data_preferences.html)
- [Optimizing GDScript Code](https://www.gdquest.com/tutorial/godot/gdscript/optimization-code/)
- https://gdscript.com/tutorials/classes/

Godot 4 GDScript 2.0 Features:

- first-class functions
- lambdas
- new property syntax
- `await` keyword
- `super` keyword
- typed arrays
- built-in annotations
- automatically generate documentation

Godot 诞生于 2007 年，GDScript 之父 Juan Linietsky 为了简化解释实现的复杂度，许多语法与其它
流行语言不太一样。他与另一名开发者 Ariel Manzur 共同合作开发了 Godot，由于当时阿根廷的政治与经济
一直不太稳定，影响 Godot 的开发进度，在 2014 年才发布了 1.0 版本，但当时的 2D 引擎有很多限制，
无法使用 3D，直到 2016 年推出的 2.0 版本才改进了可用性方面的问题。

GDScript 是面向对象编程脚本，它专门为 Godot 游戏编程做了优化，比如向量定义、及相关运算方面的支持，
还 match 模式匹配功能，方便做分支选择，有 6 种 pattern types，满足大多数应用场景。匹配数组时，
数组元素顺序也需要对应。而匹配字典则不需要顺序，并且不指定值时，只需要 keys 匹配：


```py
# 1. Constant pattern - Matches constant primitives, like numbers and strings.
     match x:
         1:
             print("We are number one!")
         2:
             print("Two are better than one!")
         "test":
                print("Oh snap! It's a string!")
# 2. Variable pattern - Matches the contents of a variable/enum.
        match typeof(x):
            TYPE_REAL:
                print("float")
            TYPE_STRING:
                print("text")
            TYPE_ARRAY:
                print("array")
# 3. Wildcard pattern - This pattern matches everything. 
        match x:
            1:
                print("It's one!")
            2:
                print("It's one times two!")
            _:
                print("It's not 1 or 2. I don't care to be honest.")
# 4. Binding pattern - A binding pattern introduces a new variable. 
        match x:
            1:
                print("It's one!")
            2:
                print("It's one times two!")
            var new_var:
                print("It's not 1 or 2, it's ", new_var)
# 5. Array pattern - Matches an array.
        match x:
            []:
                print("Empty array")
            [1, 3, "test", null]:
                print("Very specific array")
            [var start, _, "test"]:
                print("First element is ", start, ", and the last is \"test\"")
            [42, ..]:
                print("Open ended array")
# 6. Dictionary pattern - Works in the same way as the array pattern.
        match x:
            {}:
                print("Empty dict")
            {"name": "Dennis"}:
                print("The name is Dennis")
            {"name": "Dennis", "age": var age}:
                print("Dennis is ", age, " years old.")
            {"name", "age"}:
                print("Has a name and an age, but it's not Dennis :(")
            {"key": "godotisawesome", ..}:
                print("I only checked for one entry and ignored the rest")
# 7. Multiple patterns - Matches 
        match x:
            1, 2, 3:
                print("It's 1 - 3")
            "Sword", "Splash potion", "Fist":
                print("Yep, you've taken damage")
```

脚本资源在引擎内部都使用 `GDScript` 类型表示，使用``load`` 或者 ``preload``方法加载脚本即
可以获取到脚本资源对象。每一个新创建的 gd 脚本文件都是一个匿名类，可以：

- 使用 **extends** 关键字指定继承一个父类，使用 `super` 调用父类构造器或方法；
- 使用 **class_name** 关键字注册为一个全局类，还可以指定一个图标，注册后类会添加到节点列表；
- 构造函数是 ``_init``，实例化一般使用 `ClassName.new()` 方法调用构造器；

通过注册类型和静态函数，工具函数可以全局空间中组织，方便调用，不必使用 Singletons (AutoLoad)：

```py
class_name Utils

static func dbg(msg):
    print_debug(msg)
```

Singletons 还有一定用途，因为 static 只能定义静态函数，不能定义静态成员属性。每个单态对象都会在
/root/MySingleton 这个路径中产生一个节点，假设单态类名设置为 MySingleton。


Godot 没有提供直接初始化大数组的方法，使用 range() 和 resize() 函数间接获取大数组需要的内存，
或者通过 C++ 底层进行内存动态分配。

关于数组的注意事项：

使用 append_array() 附加新数据到数组中，避免因使用 += 操作产生新数组，并且进行数据拷贝。如果，
确定需要新的数据副本，使用 duplicate() 方法，并且可以指定 deep copy 或者 shallow copy。

- Note: Concatenating with the += operator will create a new array, which has a cost.
- Note: Arrays are always passed by reference.
- Note: Erasing elements while iterating over arrays is not supported and will result in unpredictable behavior.

注意文档说： const 声明数组只会阻止常量元素初化后再赋不同值，数组本身仍可修改，通过在单个索引或 
pushing/removing 元素来改变数组本身。

常量不能修改是显然的，但是 const 修饰的数组怎么可以改变呢？应该是文档搞错了。

```py
func _test_const():
    # Not allow reassign const value.
    const ca = [1,2,3]
    var ca2 = ca # ca2 reference to ca, it is const now. 

    # Parse Error: Cannot assign a new value to a constant.
    # ca = [4,5,6]

    # Parse Error: Cannot get index "3" from "[1, 2, 3]".
    # Parse Error: Cannot assign a new value to a constant.
    # ca[3] = 4

    # Invalid set index '3' (on base: 'Array') with value of type 'int'
    # ca2[3] = 5
    
    # ERROR: Array is in read-only state.
    # ca.resize(1000)
    # ca2.remove_at(0)
    # ca2.push_back(6)
    # ca2.insert(-1,7)

    ca2 = [4,5,6] # It's OK

    print_debug("const array: %s %s" % [ca, ca2])
    assert(ca[0] == 1, "Const 1D Array, passed by reference.")


func _test_copy():
    var a2d = [[1,2,3],[4,5,6]]
    var a2d2 = a2d.duplicate()     # shallow copy
    var a2d3 = a2d.duplicate(true) # deep copy
    a2d[1][0] = 6
    assert(a2d2[1][0] == 6, "Shallow copy, sub-array passed by reference.")
    assert(a2d3[1][0] == 4, "Deep copy, sub-array passed by value.")

func _test_array():
    var arr1d = [1,2,3]
    var arr1d2 = arr1d
    arr1d2[0] = arr1d[2]
    assert(arr1d[0] == 3, "1D Array, passed by reference.")

    var arr2d = [[1,2,3],[4,5,6],[7,8,9]]
    var arr2d2 = arr2d
    arr2d2[0] = arr2d[2]
    arr2d[2][0] = 9
    assert(arr2d[0] == [9,8,9], "2D Array, passed by reference.")
    print_debug("1D Array: %s \n2D Array: %s" % [arr1d, arr2d])
```

Godot 3.x 没有 `super` 不能主动调用父类构造，但可以通过 `func _init(args).(parent_args)` 
这种方式来向父类构造器传递参数，调用基类成员方法使用 `.base_method()` 方式调用，Godot 4.x 改进
后就不再需要这样奇怪的语法了。并且，旧版本中，也不能直接继承同文件下的类，Godot 4.x 则可以。

此外，在方法中直接使用 `super()` 还可以调用父类中的同名方法，而不仅仅是调用构造器。

```py
    #!/usr/bin/env -S godot -s
    extends SceneTree
    class_name MyScene

    func _init():
        print_debug("bool to int false: %d, true: %d " % [int(false), int(true)])
        Derived.new().test()
        
        quit()

    class Base:

        #default extends to RefCounted

        func _init():
            print_debug("Base init ", self)

        func test():
            print_debug("Base test!")

    class Derived:

        extends Base

        func _init():
            super() # call Base._init()
            print_debug("Derived init ", self)

        func test():
            super() # call Base.test()
            print_debug("Derived test!")
```

每个类可以使用两种基本继承方式：通过全局类名或通过脚本路径：

```py
    # Inherit/extend a globally available class.
    extends SomeClass

    # Inherit/extend a named class file.
    extends "somefile.gd"

    # Inherit/extend an inner class in another file.
    extends "somefile.gd".SomeInnerClass
    
    extends "../MyNode.gd"
    extends "res://src/MyNode.gd"
    extends "user://src/MyNode.gd"

    # extends Node
    # class_name Item, "res://interface/icons/item.png"
```

如果继承中使用脚本路径，那么路径可以使用相对路径或者协议路径，res:// 和 user:// 都可以。注意，
相对路径这种表达只在 extends 中使用，加载资源时不能使用相对路径，如 load() 或 preload()。
在编程插件时，相对路径非常有用，并且插件中注册好的类型可以在工程中使用。

注意，如果在用户目录中保存脚本，这些脚本即使使用 class_name 注册了名字，也不会出现在节点列表中，
也不能直接在 extends 中使用类名作为扩展的基类，Godot 不会去主动解释它们，除非使用 load() 这类
函数主动加载它们。

另外，使用相对路径继承得到的子类，也不能通过 class_name 进行注册。

使用 ``is`` 关键字可以进行类型判断，类型可以是通过 preload() 方法加载的 GDScript 对象，这种
方式加载的类型为 Constant names，但是不能是 load() 方式加载的。使用 print() 函数打印自定类实例，
会打印 Godot 系统内置的父类。如果，没使用显式继承父类，那么默认父类为 `Reference`，Godot 4.x
更名为 `RefCounted`。

所有类型都有一个枚举值对应，Variant.Type 定义在 @GlobalScope 全局空间，使用 ``typeof`` 函数
可以获取类型的枚举值，例如，typeof("abc") 是字符串类型的枚举值 TYPE_STRING。

每个 Variant 实例至少占用内存为 20 bytes，使用 float 作为浮点数类型，如果使用 double 则
占用 30 bytes。另外像 PoolVector，aabb，metrix 这些数组或专用类型的额外内存占用另计。

```py
    # Cache the enemy class.
    const Enemy = preload("enemy.gd")

    # Use 'is' to check inheritance.
    if entity is Enemy:
        entity.apply_damage()
```

GDSCript 类型系统包含以下几种分类：

- Built-in types (Array, Vector2, int, String, etc.).
- Engine classes (Node, Resource, Reference, etc.).
- Constant names (``const MyScript = preload("res://my_script.gd")``).
- Other classes in the same script, respecting scope (``InnerClass.NestedClass`` if you declared ``class NestedClass`` inside the ``class InnerClass`` in the same scope).
- Script classes declared with the ``class_name`` keyword.
- Autoloads registered as singletons.


Godot 4.x Beta 16 中基类构造方法不会主动执行，除非使用 super() 显式调用，Godot 3.5.1 则会
自动调用父类构造器，但是旧版本不支持继承同一脚本文件中的类，没有解决循环引用问题：

```py
extends MyClass.InnerClass.NestedClass
# Default extends: RefCounted in Godot 4.x or Reference in Godot 3.x

class_name MyClass

# MyClass' constructor
func _init(seq):
    #super(seq+1)
    print("MyClass init: %s" % seq)

# Inner class
class InnerClass:
    extends MyClass.InnerClass.NestedClass
    # InnerClass' constructor
    func _init(seq):
        super(seq + 1)
        print("InnerClass init: %s" % seq)

    class NestedClass:
        extends Object
        func _init(seq):
            # Calls the method on the object during idle time. 
            self.call_deferred("_delay_4_idle", "call deferred not for RefCounted!")
            print("NestedClass init: %s" % seq)
        
        func _delay_4_idle(seq):
            print("NestedClass _delay_4_idle: %s" % seq)
```

与活动场景树交互需要考虑线程安全问题，因为场景树使用了多线程进行计算处理。为了正确处理场景树中的节点，
使用延后调用 `Object.call_deferred()` 会在场景计算完成时执行指定的方法，这是线程安全方法。但是，
对资源引用无效，基类 Object 或 Node 类型都可以。

使用 Expression 可以运行时解析 GDScript 表达式：

```py
onready var expression = Expression.new()

func _ready():
    $LineEdit.connect("text_entered", self, "_on_text_entered")

func _on_text_entered(command):
    var error = expression.parse(command, [])
    if error != OK:
        print(expression.get_error_text())
        return
    var result = expression.execute([], null, true)
    if not expression.has_execute_failed():
        $LineEdit.text = str(result)
```

但是，Expression 类型只能解析表达式，不能用来处理函数、类等复杂脚本。可以使用 `GDScript` 类型
来解析全功能的脚本，通过 `load()` 等资源加载方法加载脚本文件，返回的就是脚本对象，通过附加到场景
树上实例化执行。也可以手动设置 GDScript 源代码赋值给 source_code 属性，并调用 reload() 之后
附加到场景树上执行。

可以借助 ClassDB 调用 C++ 底层实现的解析器工具类型对脚本进行处理：

```py
const PARSE_WRAPPER_CLASS := "GDScriptParserWrap"

# Array[ScriptError]
var errors := []


func _init(new_script_text: String).(new_script_text) -> void:
    pass


func test() -> void:
    if ClassDB.class_exists(PARSE_WRAPPER_CLASS):
        var wrap: Reference = ClassDB.instance(PARSE_WRAPPER_CLASS)
        wrap.parse_script(_new_script_text)
        if wrap.has_error():
            var error_line: int = wrap.get_error_line() - 1
            var line_text := _new_script_text.split("\n")[error_line]
            var error_data := make_error_from_data(
                1,
                wrap.get_error(),
                "gdscript",
                -1,
                error_line,
                line_text.length() - line_text.strip_edges(true, false).length(),
                line_text.strip_edges(false).length()
            )
            errors = [error_data]
        else:
            errors = []
    else:
        push_error("Script Parser Wrapper class is missing!")
        var error := make_error_no_parser_wrapper_class()
        errors = [error]
        return
```


Godot 全局空间 @GDScript 和 @GlobalScope 包含所有脚本中可以直接使用的函数，用户要向全局空间
添加对象，可以使用工程设置自动加载，Singletons (AutoLoad)，自动加载得到位于全局空间的单态对象。

例如，将以下脚本保存到 Global.gd，并设置工程的 AutoLoad 加载它，即可以实现自动剧中窗口。运行程序
时，引擎将加载并附着 GlobalNS 到场景树上，初始化方法会被调用：

```py
extends Node

class_name GlobalNS

func _init():
    print("Global.gd _init")
    # Center window on screen
    var screen_size = OS.get_screen_size(OS.get_current_screen())
    var window_size = OS.get_window_size()
    var centered_pos = (screen_size - window_size) / 2
    OS.set_window_position(centered_pos)
```

从编译器原理的角度看，GDScript grammar 是一种 EBNF 范式，所以范式就是一种语法书写格式。
GDScript 脚本解析器根据这种语法来处理脚本，按规则解析后再执行脚本。

看懂 GDScript EBNF grammar 规范后也就相当于掌握了 Godot 脚本编程，来看开头部分：

    (* GDScript EBNF grammar.
       Uppercase words are terminals generated by the tokenizer.
       INDENT/DEDENT are not generated by the tokenizer yet, but they are added
       here for reading convenience.
       Naturally, this only cover syntax. Semantics can't be inferred from this
       description.
    *)

    program = [ inheritance NEWLINE ] [ className ] { topLevelDecl } ;

    inheritance = "extends" ( IDENTIFIER | STRING ) { "." IDENTIFIER } ;
    className = "class_name" IDENTIFIER [ "," STRING ] NEWLINE ;

    topLevelDecl
        = classVarDecl
        | constDecl
        | signalDecl
        | enumDecl
        | methodDecl
        | constructorDecl
        | innerClass
        | "tool"
        ;

这个部分是说，一个脚本程序 program 应该包含三个部分的内容，方括号表示可选项，花括号表示必选项：

- [ inheritance NEWLINE ] 可选的继承关系定义，独占一行，使用 **extends** 关键字；
- [ className ] 可选的类名定义，使用 **class_name** 关键字，后面可以指定一个图标；
- { topLevelDecl } 必选的顶级声明，包含类成员、常量、用户信号、枚举、方法、构造、内部类、编辑器工具等等；



### 🟠🔵 Threads & Coroutines
- https://docs.godotengine.org/en/stable/classes/class_@gdscript.html
- https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html
- https://docs.godotengine.org/en/latest/tutorials/scripting/gdscript/gdscript_basics.html
- https://docs.godotengine.org/en/latest/tutorials/scripting/c_sharp/c_sharp_differences.html#await-keyword
- [Using multiple threads](https://docs.godotengine.org/en/stable/tutorials/performance/threads/using_multiple_threads.html)
- [Add 'await' operator to GDScript](https://github.com/godotengine/godot/pull/32034)

操作系统以进程 Process 作为资源分配和管理的基本单位，以线程 Thread 为代码执行的基本单位。而协程
Coroutines 是线程内模拟多线程的并发处理问题能力的一种并发技术。

Godot 3 全局函数 `yield()` 有两大用途，它和协程是一体的概念，因为需要通过 yield 支持协程。版本
升级后，yield 全局函数被替换为 Godot 4 的 await 关键字。

升级到 Godot 4 后，`yield()` 全局函数已经移除，只是增加了一个 yield 关键字作为版本变化的过度。
代码中使用到 yield 关键字时，就会被提示应该使用 await 关键字替代。

与早期的 `yield()` 不同，为了确保类型安全，无法通过 await 获得函数状态对象。有了这种类型安全性，
一个函数就不能说它在运行时返回一个 int，而实际上它在运行期间返回一个函数状态对象。

```py
GDScriptFunctionState yield ( Object object=null, String signal="" )
```

文档中展示了两种 yield 用法：传递数据和等待信号，其中最后一种等待协程 completed 完成信号是最普遍，
另外，等待定时器 timeout 信号也是最常见的用法：

- Coroutines with yield, to pass values between ``yield()`` and ``resume()``
- Coroutines & signals, yield(node, "signal")
- Coroutines & signals, yield(coroutine, "completed")

```py
func wait_confirmation():
    print("Prompting user")
    await $Button.button_up # Waits for the button_up signal from Button node.
    print("User confirmed")
    return true

func request_confirmation():
    await get_tree().process_frame
    var confirmed = await wait_confirmation()
    if confirmed:
        print("User confirmed")
    else:
        print("User cancelled")
```

函数中使用 yield 或 await 就是在定义一个协程函数，"调用协程函数"其实并不是在调用函数，而是在执行
协程！认清这个概念很重要，协程执行到 `yield()` 调用这里，就放弃 CPU 时间进入等待，直到其它协程执行
`resume()` 恢复这个协程继续运行：

```py
func my_func():
    var world = yield()
    print("Hello ", world)
    return "cheers!"

func _ready():
    var y = my_func() # return GDScriptFunctionState
    var cheers = y.resume("world")
    # 'y' resumed and is now an invalid state.
    print(cheers)

# Output:
# Hello world
# cheers!
```

引入 wait 作为关键字的动机是简化 yield() 全局函数的使用，满足 Godot 社区的诉求，语法上有些差别。
假设 could_yield() 是一个可等待的函数，yield 和 await 两种操作等价关系如下：

```py
    var x = could_yield()
    if x is GDScriptFunctionState:
        x = yield(x, "completed")

    # This PR introduces an await operator to clear away this friction.
    var x = await could_yield()
```

使用 `await` 显然是简洁的，相对使用函数状态对象的 yield 方式因为潜函数内部没有使用 yield 的可能，
所以需要进行判断。而使用 await 就不用考虑这种可能，因为在 `could_yield()` 不是协程的情况下，就相当
于没有使用 `await` 这个关键字，同样可以获得函数的返回值。另一个差别就是 `await` 方式中，x 只计算一次，
无法像旧式那样可以使用 resume() 方法传递数据。await 可看作最高优先级的一元运算符，其他表达式中可用。

This await operator would have a couple of benefits:

01. Saves a lot of typing for one of the most common use cases of GDScript coroutines
02. Accomplishes what is otherwise syntactically impossible without introducing a local variable
03. Doesn't affect GDScript's bytecode format
04. await is still a valid identifier for non-local variables, so APIs using this name will not break
05. Fulfills a common request from the community (#21039, #22947, #30328 )

Godot 社区的普遍诉求是，使用 "completed" 信号作为 yield() 的默认参数，引入 await 关键字，以及 
希望添加 fluent syntax。在引入 await 之前，社区对 yield 可能的各种表达方式的观点如下，特别是在
嵌套使用 yield 的情况下，代码相当臃肿：

```py
# yield() calls are nested.
yield(yield(foo(), "completed").bar(), "completed")

# "fluent" yielding with signals that looks like subject.yield(signal).
foo().yield("completed").bar().yield("completed")

# to wait on the "completed" signal of a GDScriptFunctionState (a very common use case),
# the argument between the parenthesis can be omitted.
foo().yield().bar().yield()
```

新版本改用 await 关键字后，使用方式上有些差别。首先，它已经不是函数了，不需要使用圆括号。其次，调用
协程时，需要使用 await 前置在协程名称前面。最后就是，不能使用像 yield() 这样的空等待。另外，也没有
resume() 这样方法来传递数据，需要结合信号重新设计代码，协程本身只有一个返回值可以通过 await 获取：

```py
#!/usr/bin/env -S godot -s
# class_name MyScene
# extends SceneTree

# func _init():
#     assert(Engine.get_version_info().major == 4)
#     root.title = "MyScene 4.x" # root is Window in Godot 4
#     root.set("theme_override_colors/title_color", Color.YELLOW)
#     co_test()
#     # quit()


func co_func():
    for i in range(1, 5):
        await create_timer(.1).timeout # wait for a timeout signal.
        await process_frame            # wait for next idle_frame.
        print("Turn %d" % i)


func co_test():
    var co = await co_func()
    assert(typeof(co) == TYPE_NIL) # nothing return from co_func()
    print_debug("co_test done with %s" % [co])
```

执行协程时，返回一个函数状态对象，通过这个状态对象来改变协程的运行状态，参数可以通过 yield() 和
resume() 进行传递。

如果协程中还有更多多的 yield() 调用，那么 resume() 恢复协程后又继续获得更多的 FunctionState，
直到获取到协程 return 返回的值。返回的函数状态代表 suspended state。

如果给 yield() 传入参数，那么这时就是在使用另一个功能：等待信号，直到信号触发才继续执行，相当于
一个匿名协程，等待中的信号负责恢复协程的执行。

```py
# Resume execution the next frame.
yield(get_tree(), "idle_frame")

# Resume execution when animation is done playing.
yield(get_node("AnimationPlayer"), "animation_finished")

# Wait 5 seconds, then resume execution.
yield(get_tree().create_timer(5.0), "timeout")

if armor <= 0:
    create_explosion()
    yield(get_tree().create_timer(.5), "timeout")
    queue_free()
```

协程本身转换到 invalid 状态时使用的是 `completed` 信号，即协程已经运行完成，变成无效状态。
在不知道该不该用 yield() 或者该用多少次时，就可以直接使用这个信号，等待协程结束。例如，以下示范
代码，就会等待所有按钮都触发 `pressed` 信号，即都被按下后，`button_func()` 协程就执行完毕，
并且恢复 `my_func()` 协程的运行：

```py
func my_func():
    yield(button_func(), "completed")
    print("All buttons were pressed, hurray!")


func button_func():
    yield($Button0, "pressed")
    yield($Button1, "pressed")
```

可以通过循环处理批量的 GDScriptFunctionState：

```py
func co_func():
    for i in range(1, 5):
        print("Turn %d" % i)
        yield();


func _ready():
    var co = co_func();
    while co is GDScriptFunctionState && co.is_valid():
        co = co.resume();
```

如果使用 C#，因为它本身有 await 机制，使用 GodotObject.ToSignal 可以将 Godot 信号转换为
C# 中的可等待对象：

```C#
    await ToSignal(timer, "timeout");
    GD.Print("After timeout");
```



Godot 自带的 GDScript 脚本和 Python 语法非常相似，但是在多线程支持上要好很多。例如，以下使用
Thread 类创建一个线程对象，然后，执行 **start()** 就会在另一个线程种执行 GDScript 函数，调用
线程对象的 **wait_to_finish()** 进入阻塞以等待线程完成工作。

```py
var thread

# The thread will start here.
func _ready():
    thread = Thread.new()
    # Third argument is optional userdata, it can be any variable.
    thread.start(self, "_thread_function", "Wafflecopter")


# Run here and exit.
# The argument is the userdata passed from start().
# If no argument was passed, this one still needs to
# be here and it will be null.
func _thread_function(userdata):
    # Print the userdata ("Wafflecopter")
    print("I'm a thread! Userdata is: ", userdata)

# Thread must be disposed (or "joined"), for portability.
func _exit_tree():
    thread.wait_to_finish()
```

多线程编程中数据竞态问题 Data race 是普遍的，即不同线程在同一时间读写同一份数据可能会导致数据不
完整，出现逻辑错误。而为了保证关键数据的逻辑一致性，通常需要引入各种同步技术，包括各种同步锁，这也
就引入额外的多线程编程问题。例如，线程的死锁问题，一个线程可能先获取到资源，并锁定它，但后续可能某些
异常导致线程卡死，从而又导致了资源被锁死得不到释放。

Godot 提供了两种线程同步工具：

- **Mutex** 互斥锁，通过 lock() 和 unlock() 方法锁定、解锁资源，资源读写操作在两个方法之间；
- **Semaphore** 信号量，通过 wait() 和 post() 方法使用线程挂起或恢复执行；

使用信号量可以按需要运行线程，换句话说，告诉它什么时候工作，当它什么都不做时让它暂停。信号量 **wait()**
函数用来挂起线程，直到一些数据到达。相反，主线程使用信号量 **post()** 表示数据已准备好处理。

信号量起始计数为 0，表示资源没有执行权，wait() 函数后的代码就会被阻塞，阻止其它线程执行直到有数据。

```py
    var counter = 0
    var mutex
    var semaphore
    var thread
    var exit_thread = false


    # The thread will start here.
    func _ready():
        mutex = Mutex.new()
        semaphore = Semaphore.new()
        exit_thread = false

        thread = Thread.new()
        thread.start(self, "_thread_function")


    func _thread_function(userdata):
        while true:
            semaphore.wait() # Wait until posted.

            mutex.lock()
            var should_exit = exit_thread # Protect with Mutex.
            mutex.unlock()

            if should_exit:
                break

            mutex.lock()
            counter += 1 # Increment counter, protect with Mutex.
            mutex.unlock()


    func increment_counter():
        semaphore.post() # Make the thread process.


    func get_counter():
        mutex.lock()
        # Copy counter, protect with Mutex.
        var counter_value = counter
        mutex.unlock()
        return counter_value


    # Thread must be disposed (or "joined"), for portability.
    func _exit_tree():
        # Set exit condition to true.
        mutex.lock()
        exit_thread = true # Protect with Mutex.
        mutex.unlock()

        # Unblock by posting.
        semaphore.post()

        # Wait until it exits.
        thread.wait_to_finish()

        # Print the counter.
        print("Counter is: ", counter)
```


### 🟠🔵 GodotObject is Base
- https://docs.godotengine.org/en/stable/development/cpp/object_class.html
- https://docs.godotengine.org/en/stable/development/cpp/variant_class.html
- https://docs.godotengine.org/en/stable/development/cpp/inheritance_class_tree.html
- https://docs.godotengine.org/en/latest/tutorials/best_practices/data_preferences.html
- https://docs.godotengine.org/en/latest/contributing/development/core_and_modules/godot_architecture_diagram.html
- https://docs.godotengine.org/en/latest/contributing/development/core_and_modules/common_engine_methods_and_macros.html
- https://docs.godotengine.org/en/latest/contributing/development/core_and_modules/core_types.html
- https://docs.godotengine.org/en/latest/contributing/development/core_and_modules/object_class.html
- https://docs.godotengine.org/en/latest/tutorials/best_practices/godot_notifications.html
- https://docs.godotengine.org/en/latest/tutorials/best_practices/node_alternatives.html
- https://docs.godotengine.org/en/latest/classes/class_object.html
- https://docs.godotengine.org/en/latest/classes/class_signal.html
- godot-docs\classes\class_object.rst
- godot\modules\gdscript\gdscript.cpp
- godot\3.5.1-stable\core\object.h
- godot\3.5.1-stable\core\class_db.h
- godot\3.5.1-stable\core\variant.h
- godot\master\core\object\object.h
- godot\master\core\object\class_db.h
- godot\master\core\variant\variant.h
- godot-docs\classes\class_signal.rst

<!-- ![Inheritance class tree](https://docs.godotengine.org/en/stable/_images/Object.png) -->
![Godot's architecture diagram](https://docs.godotengine.org/en/latest/_images/architecture_diagram.jpg)

Godot 4.x C# 基础类更名为 `Godot.GodotObject`，旧版本 `Godot.Object` 为所有类型的基类。
基类是 GDScript 与 C++ 之间的桥梁，当然还有 ClassDB 这个类型注册中心，Object 基础类实现的
重要机制如下：

- Object.new()/init/free 生命周期管理机制；
- properties 属性读写、导出机制；
- notify 通知机制；
- signal 信号机制；
- script 脚本附加扩展机制；
- reflection 反射调用机制；
- deferred 延后调用机制；
- Localization using gettext 国际化/本地化机制；
- meta 元数据；

在不同语言中使用不同的方法实例化：

- GDScript: Object.new()
- C#: new Object
- VisualScript: Construct Object

注意：因为逻辑问题，Object 本身不能通过 Object.new() 实例化，这个 bug 只出现在 Object 这里。
可以使用  ClassDB.instance("Object") 来实例化基础类。只有 Godot 引擎内部定义的类型才需要使用
new() 方法进行实例化，像 Vector 这类基础数据结构不需要。

```C++
GDScriptNativeClass::GDScriptNativeClass(const StringName &p_name) {
    name = p_name;
}

void GDScriptNativeClass::_bind_methods() {
    ClassDB::bind_method(D_METHOD("new"), &GDScriptNativeClass::_new);
}

Variant GDScriptNativeClass::_new() {
    Object *o = instance();
    ERR_FAIL_COND_V_MSG(!o, Variant(), "Class type: '" + String(name) + "' is not instantiable.");

    Reference *ref = Object::cast_to<Reference>(o);
    if (ref) {
        return REF(ref);
    } else {
        return o;
    }
}

Object *GDScriptNativeClass::instance() {
    return ClassDB::instance(name);
}
```

ClassDB 类型注册中心相关 API，在 ClassInfo 定义了 creation_func 来引用构造器：

```C++
static HashMap<StringName, ClassInfo> classes;
static HashMap<StringName, StringName> resource_base_extensions;
static HashMap<StringName, StringName> compat_classes;

Object *ClassDB::instance(const StringName &p_class) {
    ClassInfo *ti;
    {
        OBJTYPE_RLOCK;
        ti = classes.getptr(p_class);
        if (!ti || ti->disabled || !ti->creation_func) {
            if (compat_classes.has(p_class)) {
                ti = classes.getptr(compat_classes[p_class]);
            }
        }
        ERR_FAIL_COND_V_MSG(!ti, nullptr, "Cannot get class '" + String(p_class) + "'.");
        ERR_FAIL_COND_V_MSG(ti->disabled, nullptr, "Class '" + String(p_class) + "' is disabled.");
        ERR_FAIL_COND_V_MSG(!ti->creation_func, nullptr, "Class '" + String(p_class) + "' or its base class cannot be instantiated.");
    }
#ifdef TOOLS_ENABLED
    if (ti->api == API_EDITOR && !Engine::get_singleton()->is_editor_hint()) {
        ERR_PRINT("Class '" + String(p_class) + "' can only be instantiated by editor.");
        return nullptr;
    }
#endif
    return ti->creation_func();
}
bool ClassDB::can_instance(const StringName &p_class) {
    OBJTYPE_RLOCK;

    ClassInfo *ti = classes.getptr(p_class);
    ERR_FAIL_COND_V_MSG(!ti, false, "Cannot get class '" + String(p_class) + "'.");
#ifdef TOOLS_ENABLED
    if (ti->api == API_EDITOR && !Engine::get_singleton()->is_editor_hint()) {
        return false;
    }
#endif
    return (!ti->disabled && ti->creation_func != nullptr);
}
```

可能是出于 Godot 4 开发者的个人喜好，实例化的相关方法名称更改为 instantiate，这是一个纯动词：

```C++
Variant instantiate(class: StringName) const
bool can_instantiate(class: StringName) const
```

以下示范动态加载并执行脚本：

```py
#!/usr/bin/env -S godot -s
extends SceneTree
class_name MyScene

var script_text = """
extends Node2D
func _init():
    print_debug("script_text")
"""

func _init():
    script_test()
    assert(Engine.get_version_info().major == 4)
    root.title = "MyScene 4.x" # root is Window in Godot 4
    root.set("theme_override_colors/title_color", Color.YELLOW)
    # quit()

func script_test():
    var script = GDScript.new()
    # script = preload("path/to/script.gd")
    script.source_code = script_text
    var is_valid = script.reload()
    if is_valid != OK:
        print_debug("Script error: %d" % is_valid)
    # ClassDB.can_instance("Node2D") in Godot 3.x
    elif ClassDB.can_instantiate("Node2D"):
        var object = ClassDB.instantiate("Node2D")
        object.set_script(script)
        root.add_child(object)
        # Parse Error: Function "new()" not found in base Object.
        # var object = Object.new()
```

Object 本身没有内存管理，需要手动执行 free 或调用 C++ 方法清理实例所占用的内存。子类 `Reference`，
即新版本中的 `RefCounted` 类型使用引用计数算法进行内存管理，当引用计数值为 0 即回收节点或其它基础
类所占用的内存。


Godot 定义了一个 Variant 变体类型，可以称之为数据类型之母。它用于表达所有基础的数据类型，遵循 C99
类型规范标准，Godot 文档称之为 Core types，包括：

- ``uint8_t``,``uint32_t``,``int64_t``等等常规数值类型；
- Vector  List  Set  Map 等等容器类型；
- String
- StringName
- Math types 线性代数使用的各种向量类型
- NodePath 节点路径
- RID 资源标识符

每个 Variant 实例至少占用内存为 20 bytes，使用 real_t 作为浮点数类型，如果使用 double 则
占用 30 bytes。另外像 PoolVector，aabb，metrix 这些数组或专用类型的额外内存占用另计。

Variant 定义了相当多的与各种数据类型相关的方法，但数据成员不多：

```C++
    // Variant takes 20 bytes when real_t is float, and 36 if double
    // it only allocates extra memory for aabb/matrix.

    Type type;

    struct ObjData {
        ObjectID id;
        Object *obj = nullptr;
    };

    union {
           bool  _bool;
        int64_t  _int;
         double  _real;
    Transform2D *_transform2d;
         ::AABB *_aabb;
          Basis *_basis;
      Transform *_transform;
           void *_ptr; //generic pointer
         uint8_t _mem[sizeof(ObjData) > (sizeof(real_t) * 4) ? sizeof(ObjData) : (sizeof(real_t) * 4)];
    } _data GCC_ALIGNED_8;
```

Variant 的作用也非常大：

- Store almost any datatype
- Perform operations between many variants (GDScript uses Variant as its atomic/native datatype).
- Be hashed, so it can be compared quickly to other variants
- Be used to convert safely between datatypes
- Be used to abstract calling methods and their arguments (Godot exports all its functions through variants)
- Be used to defer calls or move data between threads.
- Be serialized as binary and stored to disk, or transferred via network.
- Be serialized to text and use it for printing values and editable settings.
- Work as an exported property, so the editor can edit it universally.
- Be used for dictionaries, arrays, parsers, etc.

Variant 实例至少占用内存为 20 bytes，以 10000 方形二维数组为例，使用默认的变体类型大小就占用
2GB = 10000 * 10000 * 20 内存，这是相当占用内存！

分段式的内存管理对于大多数常见小内存分配来说，会缓慢地创建的漏洞，从而浪费内存。关于堆和分段的文献
有很多。现代操作系统使用分页内存，这有助于缓解分段问题，但无法解决。

然而，在许多研究和测试中表明，如果给定足够的内存，如果最大分配大小低于给定的阈值，与最大堆大小和
未使用内存的比例成比例，分段将不会随着时间的推移而成为问题，因为它将保持不变。换句话说，保持 10-20%
的内存空闲，并执行所有小的分配，就没问题。

Godot 确保所有可以动态分配的对象都很小，几个 kb。但如果分配太大，如图像或网格几何体或大型阵列，
Godot 可以选择使用动态内存池。该内存需要被锁定才能访问，分配的内存用完时，再根据需要重新排列和压缩。
根据游戏的需要，程序员可以配置动态内存池大小。


Godot 通知回调实现了引擎中最基本节点处理、渲染流程事件，以及与程序窗口的交互：

- `_ready()` : NOTIFICATION_READY
- `_enter_tree()` : NOTIFICATION_ENTER_TREE
- `_exit_tree()` : NOTIFICATION_EXIT_TREE
- `_process(delta)` : NOTIFICATION_PROCESS (`_idle` in Godot 3.5)
- `_physics_process(delta)` : NOTIFICATION_PHYSICS_PROCESS (`_iteration` in Godot 3.5)
- `_draw()` : NOTIFICATION_DRAW

对象属性读写和导出是非常有用的机制，它和 Godot 编辑器紧密结合，可以通过编辑属性界面修改属性值：

- Serializing and deserializing the object.
- Creating a list of editable values for the Object derived class.

在 C++ 底层，属性导出通过 `PropertyInfo` 结体体实现：

```C++
// PropertyInfo(type, name, hint, hint_string, usage_flags)
// For example:
PropertyInfo(Variant::INT, "amount", PROPERTY_HINT_RANGE, "0,49,1", PROPERTY_USAGE_EDITOR)
```

另外，还有更底层的属性绑定方法，它们在 GDScript 中使用下划线前缀表示，它们不是虚函数，子类继承
覆盖后，在上层子依然有效，可以被多级调用，DO NOT make them virtual：

```C++
protected:
     void _get_property_list(List<PropertyInfo> *r_props) const;      // return list of properties
     bool _get(const StringName &p_property, Variant &r_value) const; // return true if property was found
     bool _set(const StringName &p_property, const Variant &p_value); // return true if property was found

```

Godot Object 的 API 分类参考，在源代码的 `Object::_bind_methods()` 中注册：

```py
Variant _get(property: String) virtual
  Array _get_property_list() virtual
   bool _set(property: String, value: Variant) virtual
Variant  get(property: String) const
  Array  get_property_list() const
   void  set(property: String, value: Variant)
Variant  get_indexed ( NodePath property ) const
   void  set_indexed ( NodePath property, Variant value )


   void _init() virtual
   void  free ( )
    int  get_instance_id ( ) const
   bool  is_class ( String class ) const
   bool  is_queued_for_deletion ( ) const


   void _notification(what: int) virtual
   void  notification ( int what, bool reversed=false )
   void  property_list_changed_notify ( )


   void  add_user_signal ( String signal, Array arguments=[ ] )
  Error  connect ( String signal, Object target, String method, Array binds=[ ], int flags=0 )
   void  disconnect ( String signal, Object target, String method )
   void  emit_signal ( String signal, ... ) vararg
  Array  get_incoming_connections ( ) const
  Array  get_signal_connection_list ( String signal ) const
   Arra  get_signal_list ( ) const
   bool  has_signal ( String signal ) const
   bool  has_user_signal ( String signal ) const
   bool  is_connected ( String signal, Object target, String method ) const
   bool  is_blocking_signals ( ) const
   void  set_block_signals ( bool enable )


Reference  get_script ( ) const
     void  set_script ( Reference script )


Variant  call ( String method, ... ) vararg
   void  call_deferred ( String method, ... ) vararg
Variant  callv ( String method, Array arg_array )
  Array  get_method_list ( ) const
  Array  get_property_list ( ) const
   bool  has_method ( String method ) const
   void  set_deferred ( String property, Variant value )


Variant  get_meta ( String name, Variant default=null ) const
PoolStringArray get_meta_list ( ) const
   bool  has_meta ( String name ) const
   void  remove_meta ( String name )
   void  set_meta ( String name, Variant value )



 String _to_string() virtual
   bool  can_translate_messages() const
   void  set_message_translation ( bool enable )
 String  to_string ( )
 String  tr ( String message ) const
```

Godot 4 的变化，一个通知方法更名，另外新增 5 个 API，还有消息机制 API 的使用方式变更，返回数组的
API 基本者改变为返回 Dictionary[]，等等：

```py
# void  property_list_changed_notify ( )
  void  notify_property_list_changed()

String  tr_n(message: StringName, plural_message: StringName, n: int, context: StringName = "") const

   bool _property_can_revert(property: StringName) virtual
Variant _property_get_revert(property: StringName) virtual
   bool  property_can_revert(property: StringName) const
Variant  property_get_revert(property: StringName) const
```

Godot 4 引入信号类型，以 Signal 类型重新组织信号相关的 API，Objec 原有的信号 API 保留。另外
注意代码中 `signl` 是关键字，`Signal` 是类型：

```py
# Constructors
    Signal Signal ( )
    Signal Signal ( Signal from )
    Signal Signal ( Object object, StringName signal )

# Methods
       int connect ( Callable callable, int flags=0 )
      void disconnect ( Callable callable )
      void emit ( ... ) vararg const
     Array get_connections ( ) const
StringName get_name ( ) const
    Object get_object ( ) const
       int get_object_id ( ) const
      bool is_connected ( Callable callable ) const
      bool is_null ( ) const
```

Godot 3.5 中，MultiplayerAPI 还绑定了默认的信号处理函数，并且获取信号绑定列表返回的字典包含的
字段比 Godot 4.x 中的更多：

```py
    object.get_signal_connection_list("signal"):
    return array of dictionary:
    { 
        binds:[], flags:0, 
        method:_server_disconnected, 
        signal:server_disconnected, 
        source:[MultiplayerAPI:1249], 
        target:[SceneTree:1242]
    }

    signal.get_connections() 
    return array of dict: {signal, callable}
```


### 🟠🔵 enum is a Dictionary
- [GraphViz](http://www.graphviz.org/Download.php)
- [CodeViz](http://www.csn.ul.ie/~mel/projects/codeviz/)
- [GDScript progress report: Writing a tokenizer](https://godotengine.org/article/gdscript-progress-report-writing-tokenizer/)

CodeViz 是 Understanding The Linux Virtual Memory Manager 一书的作者 Mel Gorman 编写
的一款分析 C/C++ 源代码中函数调用关系的开源工具，类似软件有 egypt、ncc 等。在编译源文件时，它会导出
其中函数的 call graph，然后用 Perl 脚本收集并整理调用关系，转交给 Graphviz 绘制图形。

CodeViz 现在已经基本支持 C++ 语言，最新的 1.0.9 版能在 Windows + Cygwin 下顺利地编译使用。


Godot 中的枚举类型 enum 和字典对象同源，可以使用 keys() 方法获取枚举量的名称来实现到字符串的转换。
参考 global_constants.cpp 源代码文件，其中注册了全局类型常量。GDScript 解释器也没有专门设置一个
Token 用于表示枚举类型，而是和字典类型一样，直接通过检测代码中的花括号来识别枚举类型。

Godot 3.5 中的 GDScript 解析器定义了一个 parse_class 方法，它包揽了脚本的解析工作，整个方法
非常臃肿。Godot 4.x 后，重新编写了解析器，这个方法也被拆解成各个分工方法。

GDScriptTokenizer 定义了脚本中的 `Token` 类型，名字中的科室符号含义如下：

- TK 前缀简写为 Token；
- OP 表示 Operation code 操作码；
- CF 表示 Control flow 流程控制；
- PR 表示 Keywords，可能是缩写 Propose，但绝不 GitHub 中 PR(pull request)；

Godot 3.5 Token 类定义如下，其中 TK_PR_SLAVE 由 TK_PR_PUPPET 取代，TK_CURSOR 用自动完成功能，
可以看到 ++ 或 -- 这样的运算符号还未提供实现，共有 99 个 Token：

|  Control Flow  |      Operation Code      |        PR        |     miscellaneous      |
|----------------|--------------------------|------------------|------------------------|
| TK_CF_IF       | TK_OP_IN                 | TK_PR_FUNCTION   | TK_BRACKET_CLOSE       |
| TK_CF_ELIF     | TK_OP_EQUAL              | TK_PR_CLASS      | TK_BRACKET_OPEN        |
| TK_CF_ELSE     | TK_OP_NOT_EQUAL          | TK_PR_CLASS_NAME | TK_BUILT_IN_FUNC       |
| TK_CF_FOR      | TK_OP_LESS               | TK_PR_EXTENDS    | TK_BUILT_IN_TYPE       |
| TK_CF_WHILE    | TK_OP_LESS_EQUAL         | TK_PR_IS         | TK_COLON               |
| TK_CF_BREAK    | TK_OP_GREATER            | TK_PR_ONREADY    | TK_COMMA               |
| TK_CF_CONTINUE | TK_OP_GREATER_EQUAL      | TK_PR_TOOL       | TK_CONSTANT            |
| TK_CF_PASS     | TK_OP_AND                | TK_PR_STATIC     | TK_CONST_INF           |
| TK_CF_RETURN   | TK_OP_OR                 | TK_PR_EXPORT     | TK_CONST_NAN           |
| TK_CF_MATCH    | TK_OP_NOT                | TK_PR_SETGET     | TK_CONST_PI            |
|                | TK_OP_ADD                | TK_PR_CONST      | TK_CONST_TAU           |
|                | TK_OP_SUB                | TK_PR_VAR        | TK_CURLY_BRACKET_CLOSE |
|                | TK_OP_MUL                | TK_PR_AS         | TK_CURLY_BRACKET_OPEN  |
|                | TK_OP_DIV                | TK_PR_VOID       | TK_CURSOR (completion) |
|                | TK_OP_MOD                | TK_PR_ENUM       | TK_DOLLAR              |
|                | TK_OP_SHIFT_LEFT         | TK_PR_PRELOAD    | TK_EMPTY               |
|                | TK_OP_SHIFT_RIGHT        | TK_PR_ASSERT     | TK_EOF                 |
|                | TK_OP_ASSIGN             | TK_PR_YIELD      | TK_ERROR               |
|                | TK_OP_ASSIGN_ADD         | TK_PR_SIGNAL     | TK_FORWARD_ARROW       |
|                | TK_OP_ASSIGN_SUB         | TK_PR_BREAKPOINT | TK_IDENTIFIER          |
|                | TK_OP_ASSIGN_MUL         | TK_PR_REMOTE     | TK_MAX                 |
|                | TK_OP_ASSIGN_DIV         | TK_PR_SYNC       | TK_NEWLINE             |
|                | TK_OP_ASSIGN_MOD         | TK_PR_MASTER     | TK_PARENTHESIS_CLOSE   |
|                | TK_OP_ASSIGN_SHIFT_LEFT  | TK_PR_SLAVE      | TK_PARENTHESIS_OPEN    |
|                | TK_OP_ASSIGN_SHIFT_RIGHT | TK_PR_PUPPET     | TK_PERIOD              |
|                | TK_OP_ASSIGN_BIT_AND     | TK_PR_REMOTESYNC | TK_QUESTION_MARK       |
|                | TK_OP_ASSIGN_BIT_OR      | TK_PR_MASTERSYNC | TK_SELF                |
|                | TK_OP_ASSIGN_BIT_XOR     | TK_PR_PUPPETSYNC | TK_SEMICOLON           |
|                | TK_OP_BIT_AND            |                  | TK_WILDCARD            |
|                | TK_OP_BIT_OR             |                  |                        |
|                | TK_OP_BIT_XOR            |                  |                        |
|                | TK_OP_BIT_INVERT         |                  |                        |
|                | //TK_OP_PLUS_PLUS        |                  |                        |
|                | //TK_OP_MINUS_MINUS      |                  |                        |

Godot 4.x 引入的多个关键字，或关键字功能的提升：

- in 作为关键字定义，对应旧版本的 TK_OP_IN，用于决断元素是否在 string, list, range, 字典或者节点中，也用于 for 循环；
- super 用于调用父类构造函数或成员，不用像旧版本中那样使用 . 运算符号来调用父类；
- await 替代旧版本的 TK_PR_YIELD，虽然 yield 这个关键字还在，但使用它只会得到错误提示；
- tool、icon、onready、export 等等变更为标注，由 GDScriptParser 提供实现，不同作为关键字使用；
- @warning_ignore 和 @rpc 是新增的两个功能标注；

此外，还有引入了以下有符号定义但未提供实现的关键字：

- namespace 虽然在代码中已经有个关键字，是是还没有具体实现命名空间的功能；
- trait 是混合编程模式概念，是代码复用方法；

解析器方法 get_rule() 可以查询 Token 类型与具体实现的规则。


```cpp ,ignore
    // godot-4.0-beta6\modules\gdscript\gdscript_parser.cpp
    static HashMap<StringName, Variant::Type> builtin_types;
    Variant::Type GDScriptParser::get_builtin_type(const StringName &p_type) {
        if (builtin_types.is_empty()) {
            // ...
            builtin_types["Dictionary"] = Variant::DICTIONARY;


    GDScriptParser::PatternNode *GDScriptParser::parse_match_pattern(PatternNode *p_root_pattern) {
        // ...
            case GDScriptTokenizer::Token::BRACE_OPEN: {
                // Dictionary.


    //  godot-3.5.1-stable\core\global_constants.cpp
    BIND_GLOBAL_ENUM_CONSTANT_CUSTOM("TYPE_DICTIONARY", Variant::DICTIONARY); // 20


    // godot-3.5.1-stable\modules\gdscript\gdscript_parser.cpp
    void GDScriptParser::_parse_class(ClassNode *p_class) {
        // ...
        while (true) {
            GDScriptTokenizer::Token token = tokenizer->get_token();
            // ...
            switch (token) {

            case GDScriptTokenizer::TK_CURSOR:  { /*...*/ } break;
            case GDScriptTokenizer::TK_EOF:     { /*...*/ } break;
            case GDScriptTokenizer::TK_ERROR:   { /*...*/ } break;
            case GDScriptTokenizer::TK_NEWLINE:     { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_EXTENDS:  { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_CLASS_NAME:   { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_TOOL:     { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_CLASS:    { /*...*/ } break;
            case GDScriptTokenizer::TK_CF_PASS:     { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_STATIC:   { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_FUNCTION: { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_SIGNAL:   { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_EXPORT: { 
                    // ...
                    if (tokenizer->get_token() == GDScriptTokenizer::TK_BUILT_IN_TYPE) {
                        Variant::Type type = tokenizer->get_token_type();
                        // ...
                            switch (type) {
                                case Variant::INT:  { /*...*/ } break;
                                case Variant::REAL:     { /*...*/ } break;
                                case Variant::STRING:   { /*...*/ } break;
                                case Variant::COLOR:    { /*...*/ } break;
                                default: {
                                    current_export = PropertyInfo();
                                    _set_error("Type \"" + Variant::get_type_name(type) + "\" can't take hints.");
                                    return;
                                } break;

                        Variant constant = static_cast<ConstantNode *>(subexpr)->value;
                    } else {
                        // ...
                        if (constant.get_type() == Variant::OBJECT) {
                            // ...
                        } else if (constant.get_type() == Variant::DICTIONARY) {
                            // Enumeration
                            // ...
            } break;
            case GDScriptTokenizer::TK_PR_ONREADY:  { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_REMOTE:   { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_MASTER:   { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_SLAVE:    { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_PUPPET:   { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_REMOTESYNC:   { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_SYNC:     { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_MASTERSYNC:   { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_PUPPETSYNC:   { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_VAR:      { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_CONST:    { /*...*/ } break;
            case GDScriptTokenizer::TK_PR_ENUM:     { /*...*/ } break;
            case GDScriptTokenizer::TK_CONSTANT:    { /*...*/ } break;
            case GDScriptTokenizer::TK_CF_PASS:     { /*...*/ } break;
```




### 🟠🔵 MySprite 精灵类派生演示

工具脚本是会在 Godot IDE 中运行的脚本，在开头使用 **tool** 关键字，通过 Engine.editor_hint 全局
状态判断当前运行环境是否是编辑器环境。另外，继承 **EditorScript** 的脚本可以直接在脚本编器中运行。
而要为编辑器提供更多功能，可以编写编辑器插件，继承 **EditorPlugin** 类型。Asset Library 提供了
现有的插件，在 Godot IDE 中可以直接搜索、安装各种插件。也可以手动下载插件，安装到项目的 addons 目录下。

```py
tool
extends EditorScript

func _run():
    print("Hello from the Godot Editor!")
```

GDScript 脚本作为快速迭代开发的语言，它最大的优点就是使用上的便利，无编译时间开销，同时与 Godot
编辑器界面紧密结合，通过 **export** 关键字导出脚本符号，可以在属性检查器 Inspector 产生相应的
GUI 控件对导致变量进行赋值等操作。在脚本中修改已导出的符号，可以主动调用 Object 提供的通知发布方法，
以使用 Inspector 检测到导出符号内容有变动并相应更新，使用属性面板内容及时反映出变化：

```py
void notify_property_list_changed()
```

要继承一个类，除了直接在 **extends** 关键字后面编写类名外，也可以使用 res:// 协议指定脚本资源文件。
给一个脚本设置 **class_name** 后，这个类型就具有名称，不是匿名类。如果继承 Node 或其子类型，就
可以直接当作场景树的节点使用，在给场景添加节点时，节点列表中也会显示这个对象。


```py
tool

extends Sprite
class_name MySprite, "res://icon.png"

# Declare member variables here. Examples:
# var a = 2
# var b = "text"


# Called when the node enters the scene tree for the first time.
func _ready():
    pass # Replace with function body.

# http://kehomsforge.com/tutorials/single/process-physics-process-godot
# Called every frame. 'delta' is the elapsed time since the previous frame.
# In Godot we sort of get this decoupling by having the 
# _physics_process() (fixed time step) and the _process() (as fast as possible) functions.
func _process(delta):
    if Engine.editor_hint:
        rotation_degrees += 90 * delta
    else:
        rotation_degrees -= 18 * delta

func _physics_process(delta):
    print(self.name)
    pass

# http://kehomsforge.com/tutorials/single/gdConditionalProperty
# Object._get_property_list() _get() _set()
```

每个脚本的本身是 **GDScript** 类型，是一种资源类型，需要与节点结合使用，即附加到场景树中的节点，
使节点可以通过脚本进行操控：

    Class: Script
    Inherits: Resource < Reference < Object
    Inherited by: GDScript , NativeScript , PluginScript , VisualScript

以下脚本演示如何通过全局函数 load 加载类型，然后在实例化后加载到场景树中：

```py
#extends "res://L3 GDScript/MySprite.gd"
extends MySprite

class_name MyObject, 'res://icon.png'

func _ready():
    # Anonymous types: local script as GDScript class
    var MyClass = load("res://L3 GDScript/MySprite.gd")
    var instance = MyClass.new()
    assert(instance.get_script() == MyClass)
    
    # attach scene tree
    instance.position += Vector2(100, 100)
    instance.texture = load("icon.png")
    get_node("..").call_deferred("add_child", instance)
```

继承声明使用 res:// 资源协议指定父类时，可能会在编辑器中检测到循环加载问题，但不影响使用：

    Parse Error: Script isn't fully loaded (cyclic preload?): res://L2 GDScript/MySprite.gd

创建的节点不再需要时，需要调用 queue_free() 或 free() 释放节点所占用内存，否则会成为孤儿节点占用内容。

全局函数与资源加载相关的有两个，要避免多次加载资源，可以将资源引用保存在变量中或者使用 preload() 方法：

```py
Resource load(path: String)

Resource preload(path: String)
```

注意，preload 不是函数，是关键字，在解析器提供的方法，load() 是全局函数，它们的功能不太一样。

GDScript 对象生命周期主要有两个，一般使用 new() 方法进行实例化，并执行类型中的 `_init()` 方法，
参数可以在此传递，另外一个就是 **free()** 销毁实例回收内存。在场景中设置好的所有属性数据，构造过程
中会自动加载，在初始化方法 **_init()** 执行前就设置好。


```py
# MyObject.new("argument pass to _init()")

func _init(arg):
    print("MyObject _init(\"%s\")" % arg)
```


### 🟠🔵 Godot 3.x to 4.x 版本差异
- godot-docs\development\file_formats\gdscript_grammar.rst
- godot-docs\tutorials\scripting\gdscript\gdscript_exports.rst
- godot-docs\tutorials\scripting\gdscript\gdscript_basics.rst
- godot-docs\tutorials\scripting\gdscript\gdscript_advanced.rst
- godot-docs/tutorials/editor/upgrading_to_godot_4.rst
- [GDScript documentation comments](https://docs.godotengine.org/en/latest/tutorials/scripting/gdscript/gdscript_documentation_comments.html)
- [Add a Godot 3 to Godot 4 upgrade guide #6393](https://github.com/godotengine/godot-docs/pull/6393/files)
- [Upgrading to Godot 4](https://docs.godotengine.org/en/latest/tutorials/migrating/upgrading_to_godot_4.html)
- [GDScript progress report: Feature-complete for 4.0](https://godotengine.org/article/gdscript-progress-report-feature-complete-40/)
- [双因素认证（2FA）教程 - TOTP](https://ruanyifeng.com/blog/2017/11/2fa-tutorial.html)


低版本中的项目升级为高版本项目时，Godot 4 会按已经的名称替换规则修改代码及注解，但不一定义能正确
处理程序逻辑。脚本文件可能引用丢失，需要重连在工程中导入。并且可能导致场景无法运行，甚至可能出现闪退，
连初始化函数都不会执行，这种情况就需要考虑重新构造场景节点结构。

新版本引入了两种新的字面量表达，StringName 和 % ^ 节点路径表达

+--------------------------+----------------------------------------+
| **Literal**              | **Type**                               |
+--------------------------+----------------------------------------+
| ``45``                   | Base 10 integer                        |
| ``0x8f51``               | Base 16 (hexadecimal) integer          |
| ``0b101010``             | Base 2 (binary) integer                |
| ``3.14``, ``58.1e-10``   | Floating-point number (real)           |
| ``"Hello"``, ``"Hi"``    | Strings                                |
| ``"""Hello"""``          | Multiline string                       |
| ``&"name"``              | :ref:`StringName <class_StringName>`   |
| ``^"Node/Label"``        | :ref:`NodePath <class_NodePath>`       |
| ``$NodePath``            | Shorthand for ``get_node("NodePath")`` |
+--------------------------+----------------------------------------+


新版本支持 Typed Arrays：

```py
    var my_array: Array[int] = [1, 2, 3]
    var inferred_array := [1, 2, 3] # This is Array[int].
```

支持 Lambda 函数，增加了 `Callable` 类型：

```py
func _ready():
    var my_lambda = func(x):
        print(x)
    my_lambda.call("hello") # Callable.call()
    my_lambda.bind("hello").call() # Callable.bind(args).call()
```

信号可以直接绑定一个方法，比旧式的调用 connect() 绑定信号更直观：

```py
func _init():
    self.tree_entered.connect(func(): print("tree entered"))
```


内存管理上，一般使用 free() 或 queue_free() 来释放节点及其子节点，另外，使用弱引用 weakref()
可以避免循环引用而导致的内存泄露问题。

```py
    extends Node

    var my_node_ref

    func _ready():
        my_node_ref = weakref(get_node("MyNode"))

    func _this_is_called_later():
        var my_node = my_node_ref.get_ref()
        if my_node:
            my_node.do_something()
```

Godot 4.x 引入的多个关键字，或关键字功能的提升：

- in 作为关键字定义，对应旧版本的 TK_OP_IN，用于决断元素是否在 string, list, range, 字典或者节点中，也用于 for 循环；
- super 用于调用父类构造函数或成员，不用像旧版本中那样使用 . 运算符号来调用父类；
- await 替代旧版本的 TK_PR_YIELD，虽然 yield 这个关键字还在，但使用它只会得到错误提示；
- tool、icon、onready、export 等等变更为标注，由 GDScriptParser 提供实现，不同作为关键字使用；
- @warning_ignore 和 @rpc 是新增的两个功能标注；

类形继承上，引入了 `super` 关键字用于访问父类构造函数，或者成员方法，在旧版本调用父类构造器：

    func _init(args).(parent_args): ...

新增的 @warning_ignore 和 @rpc 两个功能标注由于文档更新可能不及时，其使用方法可以参考源代码；

| RPCMode | 
| "any_peer"  | "call_local"  | "reliable"           |
| "authority" | "call_remote" | "unreliable"         |
|             |               | "unreliable_ordered" |


新版本中 @rpc 参数说明：

    @rpc(mode: String = "", sync: String = "", transfer_mode: String = "", transfer_channel: int = 0, ...) vararg

- `mode` - MultiplayerAPI.RPCMode ("any_peer", "authority").
- `sync` - calls the function locally too when RPCing ("call_local", "call_remote").
- `transfer_mode` - MultiplayerPeer.TranferMode (one of reliable, unreliable, unreliable_ordered).
- `transfer_channel` - Transfer channel (not used by the MultiplayerAPI for now, need implementation).


```cpp
# godot\master\modules\gdscript\gdscript_parser.cpp:3884
bool GDScriptParser::rpc_annotation(const AnnotationNode *p_annotation, Node *p_node) {
    ERR_FAIL_COND_V_MSG(p_node->type != Node::FUNCTION, false, vformat(R"("%s" annotation can only be applied to functions.)", p_annotation->name));

    FunctionNode *function = static_cast<FunctionNode *>(p_node);
    if (function->rpc_config.get_type() != Variant::NIL) {
        push_error(R"(RPC annotations can only be used once per function.)", p_annotation);
        return false;
    }

    Dictionary rpc_config;
    rpc_config["rpc_mode"] = MultiplayerAPI::RPC_MODE_AUTHORITY;
    if (!p_annotation->resolved_arguments.is_empty()) {
        int last = p_annotation->resolved_arguments.size() - 1;
        if (p_annotation->resolved_arguments[last].get_type() == Variant::INT) {
            rpc_config["channel"] = p_annotation->resolved_arguments[last].operator int();
            last -= 1;
        }
        if (last > 3) {
            push_error(R"(Invalid RPC arguments. At most 4 arguments are allowed, where only the last argument can be an integer to specify the channel.')", p_annotation);
            return false;
        }
        for (int i = last; i >= 0; i--) {
            String mode = p_annotation->resolved_arguments[i].operator String();
            if (mode == "any_peer") {
                rpc_config["rpc_mode"] = MultiplayerAPI::RPC_MODE_ANY_PEER;
            } else if (mode == "authority") {
                rpc_config["rpc_mode"] = MultiplayerAPI::RPC_MODE_AUTHORITY;
            } else if (mode == "call_local") {
                rpc_config["call_local"] = true;
            } else if (mode == "call_remote") {
                rpc_config["call_local"] = false;
            } else if (mode == "reliable") {
                rpc_config["transfer_mode"] = MultiplayerPeer::TRANSFER_MODE_RELIABLE;
            } else if (mode == "unreliable") {
                rpc_config["transfer_mode"] = MultiplayerPeer::TRANSFER_MODE_UNRELIABLE;
            } else if (mode == "unreliable_ordered") {
                rpc_config["transfer_mode"] = MultiplayerPeer::TRANSFER_MODE_UNRELIABLE_ORDERED;
            } else {
                push_error(R"(Invalid RPC argument. Must be one of: 'call_local'/'call_remote' (local calls), 'any_peer'/'authority' (permission), 'reliable'/'unreliable'/'unreliable_ordered' (transfer mode).)", p_annotation);
            }
        }
    }
    function->rpc_config = rpc_config;
    return true;
}

# godot\master\modules\gdscript\gdscript_parser.cpp:3863
bool GDScriptParser::warning_annotations(const AnnotationNode *p_annotation, Node *p_node) {
#ifdef DEBUG_ENABLED
    bool has_error = false;
    for (const Variant &warning_name : p_annotation->resolved_arguments) {
        GDScriptWarning::Code warning = GDScriptWarning::get_code_from_name(String(warning_name).to_upper());
        if (warning == GDScriptWarning::WARNING_MAX) {
            push_error(vformat(R"(Invalid warning name: "%s".)", warning_name), p_annotation);
            has_error = true;
        } else {
            p_node->ignored_warnings.push_back(warning);
        }
    }

    return !has_error;

#else // ! DEBUG_ENABLED
    // Only available in debug builds.
    return true;
#endif // DEBUG_ENABLED
}

# godot\master\modules\gdscript\gdscript_warning.cpp
String GDScriptWarning::get_name_from_code(Code p_code) {
    ERR_FAIL_COND_V(p_code < 0 || p_code >= WARNING_MAX, String());

    static const char *names[] = {
        "UNASSIGNED_VARIABLE",
        "UNASSIGNED_VARIABLE_OP_ASSIGN",
        "UNUSED_VARIABLE",
        "UNUSED_LOCAL_CONSTANT",
        "SHADOWED_VARIABLE",
        "SHADOWED_VARIABLE_BASE_CLASS",
        "UNUSED_PRIVATE_CLASS_VARIABLE",
        "UNUSED_PARAMETER",
        "UNREACHABLE_CODE",
        "UNREACHABLE_PATTERN",
        "STANDALONE_EXPRESSION",
        "NARROWING_CONVERSION",
        "INCOMPATIBLE_TERNARY",
        "UNUSED_SIGNAL",
        "RETURN_VALUE_DISCARDED",
        "PROPERTY_USED_AS_FUNCTION",
        "CONSTANT_USED_AS_FUNCTION",
        "FUNCTION_USED_AS_PROPERTY",
        "INTEGER_DIVISION",
        "UNSAFE_PROPERTY_ACCESS",
        "UNSAFE_METHOD_ACCESS",
        "UNSAFE_CAST",
        "UNSAFE_CALL_ARGUMENT",
        "UNSAFE_VOID_RETURN",
        "DEPRECATED_KEYWORD",
        "STANDALONE_TERNARY",
        "ASSERT_ALWAYS_TRUE",
        "ASSERT_ALWAYS_FALSE",
        "REDUNDANT_AWAIT",
        "EMPTY_FILE",
        "SHADOWED_GLOBAL_IDENTIFIER",
        "INT_AS_ENUM_WITHOUT_CAST",
        "INT_AS_ENUM_WITHOUT_MATCH",
        "STATIC_CALLED_ON_INSTANCE",
        "CONFUSABLE_IDENTIFIER",
        "RENAMED_IN_GODOT_4_HINT"
    };

    static_assert((sizeof(names) / sizeof(*names)) == WARNING_MAX, "Amount of warning types don't match the amount of warning names.");

    return names[(int)p_code];
}

GDScriptWarning::Code GDScriptWarning::get_code_from_name(const String &p_name) {
    for (int i = 0; i < WARNING_MAX; i++) {
        if (get_name_from_code((Code)i) == p_name) {
            return (Code)i;
        }
    }

    return WARNING_MAX;
}
```

变量导出 @export 语法变化，旧版使用圆括号指示导出类型及参数，新版导出类型自动识别，或者关键字后缀表明。

新版本的 GDScript 语法上有些变动，如 onready、export 这类关键字使用 @onready、@export 这样的
标注方式，并增加了一些新标注。在将 Godot 3.x 工程迁移到 Godot 4.x 时，可能因为这些语法兼容问题，
导致新版本中不能正确打开脚本，并显示脚本内容。

|        Annotation        |                           Description                           |
|--------------------------|-----------------------------------------------------------------|
| @tool                    | Enable the Tool mode.                                           |
| @onready                 | Defer initialization of variable until the node is in the tree. |
| @icon(path)              | Set the class icon to show in editor, used with class_name.     |
| @rpc                     | RPC modifiers. See high-level multiplayer docs.                 |
|--------------------------|-----------------------------------------------------------------|
| @export                  | Export hints for the editor. See GDScript exports.              |
| @export_enum             |                                                                 |
| @export_file             |                                                                 |
| @export_dir              |                                                                 |
| @export_global_file      |                                                                 |
| @export_global_dir       |                                                                 |
| @export_multiline        |                                                                 |
| @export_placeholder      |                                                                 |
| @export_range            |                                                                 |
| @export_exp_easing       |                                                                 |
| @export_color_no_alpha   |                                                                 |
| @export_node_path        |                                                                 |
| @export_flags            |                                                                 |
| @export_flags_2d_render  |                                                                 |
| @export_flags_2d_physics |                                                                 |
| @export_flags_3d_render  |                                                                 |
| @export_flags_3d_physics |                                                                 |


```py
    # (optional) class definition:
    class_name MyClass
 
    # Inheritance:
    extends BaseClass
 
    # (optional) icon to show in the editor dialogs:
    @icon("res://path/to/optional/icon.svg")
```

属性（Properties）的定义语法糖变更，旧版本属性使用 setget 指定属性读写器，新版本借鉴了更简洁的
C# 语法格式，直接在属性定义后使用 ``set`` 和 ``get`` 定义访问器。注意，旧版 setter 或 getter 
中直接访问属性而不会引起循环引用问题，在新版本 getter、setter 调用其它函数时读写了属性值时，则会
导致循环访问问题。

需要设置默认值，可以在默认值后面添加冒号再定义属性访问器。

```py
    signal changed(new_value)
    var warns_when_changed = "some value":
        get:
            return warns_when_changed
        set(value):
            changed.emit(value)
            warns_when_changed = value

    var my_prop:
        get = get_my_prop, set = set_my_prop
```

Unlike ``setget`` in previous Godot versions, the properties setter and getter 
are **always** called, even when accessed inside the same class (with or without 
prefixing with ``self.``). This makes the behavior consistent. If you need direct 
access to the value, use another variable for direct access and make the property
code use that name.

新增加 Lambda functions，定义匿名函数更方便，不必实例化 Callable 类就只可以通过函数创建一个
可调用对象。为了调试目的，可以给匿名函数指定一个名称。匿名函数会捕捉当前局部环境，变量会按值传递，所以
局部变量的后续变动不会反映到匿名函数内：

```py
    var lambda = func(x): print(x)
    lambda.call(42) # Prints "42"

    # Lambda functions can be named for debugging purposes::

    var lambda = func my_lambda(x):
        print(x)

    # Lambda functions capture the local environment. Local variables are passed by value, 
    # so they won't be updated in the lambda if changed in the local function::

    var x = 42
    var my_lambda = func(): print(x)
    my_lambda.call() # Prints "42"
    x = "Hello"
    my_lambda.call() # Prints "42"
```

信号链接处理方法的变化，Callable 可以直接获取类型方法成员而来，也可以和 lambda 表达配合使用。对于
要绑定参数的需求，就直接使用 Callable 对象的 bind() 方法来绑定。

另外，单次触发常量名字变更为 CONNECT_ONE_SHOT，旧版为 CONNECT_ONESHOT。

```py
Error connect(signal: StringName, callable: Callable, flags: int = 0)
void disconnect(signal: StringName, callable: Callable)
bool is_connected(signal: StringName, callable: Callable) const
# node.connect(some_method.bind("arg", 100))
```

新版本引入 `await` 关键字取代 yield 用于协程的异步编程，Awaiting for signals。例如，以下代码
片断演示等待按钮的按下并释放时才继续运行函数。使用了 await 语句的函数就不是一般的函数，而是协程，调用
协程时同样需要使用 await 关键字。

```py
await self.process_frame
yield(get_tree(), "idle_frame") # 下一帧恢复执行

GDScriptFunctionStateyield(object: Object = null, signal: String = "")


    func wait_confirmation():
        print("Prompting user")
        await $Button.button_up # Waits for the button_up signal from Button node.
        print("User confirmed")
        return true

    func request_confirmation():
        print("Will ask the user")
        var confirmed = await wait_confirmation()
        if confirmed:
            print("User confirmed")
        else:
            print("User cancelled")

    func wrong():
        var confirmed = wait_confirmation() # Will give an error.
```

作为一个不直接添加到场景树的节点类型，CanvasItem 在旧版本中可以在节点脚本中继承，但在 Godot 4.x
中可能引起 Could not find base class "CanvasItem"。

全局空间中 OS 的变动，将窗口相关的 API 调整到 DisplayServer 类型中，以及 Clipboard API：

```py
    # Godot 4
    var id = DisplayServer.window_get_current_screen()
    var wsize = DisplayServer.window_get_size()
    var ssize = DisplayServer.screen_get_size(id)
    var center = (ssize - wsize) / 2
    DisplayServer.window_set_position(center)
    
    # Center window on screen in GDScript 1.0
    var screen_size = OS.get_screen_size(OS.get_current_screen())
    var window_size = OS.get_window_size()
    var centered_pos = (screen_size - window_size) / 2
    OS.set_window_position(centered_pos)
```

其它节点对象名称及 API 调整：

+-----------------------------------------+-------------------------------------------+
| Old name (Godot 3.x)                    | New name (Godot 4)                        |
+=========================================+===========================================+
| AnimatedSprite                          | AnimatedSprite2D                          |
| ARVRCamera                              | XRCamera3D                                |
| ARVRController                          | XRController3D                            |
| ARVRAnchor                              | XRAnchor3D                                |
| ARVRInterface                           | XRInterface                               |
| ARVROrigin                              | XROrigin3D                                |
| ARVRPositionalTracker                   | XRPositionalTracker                       |
| ARVRServer                              | XRServer                                  |
| CubeMesh                                | BoxMesh                                   |
| EditorSpatialGizmo                      | EditorNode3DGizmo                         |
| EditorSpatialGizmoPlugin                | EditorNode3DGizmoPlugin                   |
| GIProbe                                 | VoxelGI                                   |
| GIProbeData                             | VoxelGIData                               |
| GradientTexture                         | GradientTexture1D                         |
| KinematicBody                           | CharacterBody3D                           |
| KinematicBody2D                         | CharacterBody2D                           |
| Light2D                                 | PointLight2D                              |
| LineShape2D                             | WorldBoundaryShape2D                      |
| Listener                                | AudioListener3D                           |
| NavigationMeshInstance                  | NavigationRegion3D                        |
| NavigationPolygonInstance               | NavigationRegion2D                        |
| Navigation2DServer                      | NavigationServer2D                        |
| PanoramaSky                             | Sky                                       |
| Particles                               | GPUParticles3D                            |
| Particles2D                             | GPUParticles2D                            |
| ParticlesMaterial                       | ParticleProcessMaterial                   |
| Physics2DDirectBodyState                | PhysicsDirectBodyState2D                  |
| Physics2DDirectSpaceState               | PhysicsDirectSpaceState2D                 |
| Physics2DServer                         | PhysicsServer2D                           |
| Physics2DShapeQueryParameters           | PhysicsShapeQueryParameters2D             |
| Physics2DTestMotionResult               | PhysicsTestMotionResult2D                 |
| PlaneShape                              | WorldBoundaryShape3D                      |
| Position2D                              | Marker2D                                  |
| Position3D                              | Marker3D                                  |
| ProceduralSky                           | Sky                                       |
| RayShape                                | SeparationRayShape3D                      |
| RayShape2D                              | SeparationRayShape2D                      |
| ShortCut                                | Shortcut                                  |
| Spatial                                 | Node3D                                    |
| Camera                                  | Camera3D                                    |
| SpatialGizmo                            | Node3DGizmo                               |
| SpatialMaterial                         | StandardMaterial3D                        |
| Sprite                                  | Sprite2D                                  |
| StreamTexture                           | CompressedTexture2D                       |
| TextureProgress                         | TextureProgressBar                        |
| VideoPlayer                             | VideoStreamPlayer                         |
| ViewportContainer                       | SubViewportContainer                      |
| Viewport                                | SubViewport                               |
| VisibilityEnabler                       | VisibleOnScreenEnabler3D                  |
| VisibilityNotifier                      | VisibleOnScreenNotifier3D                 |
| VisibilityNotifier2D                    | VisibleOnScreenNotifier2D                 |
| VisibilityNotifier3D                    | VisibleOnScreenNotifier3D                 |
| VisualServer                            | RenderingServer                           |
| VisualShaderNodeScalarConstant          | VisualShaderNodeFloatConstant             |
| VisualShaderNodeScalarFunc              | VisualShaderNodeFloatFunc                 |
| VisualShaderNodeScalarOp                | VisualShaderNodeFloatOp                   |
| VisualShaderNodeScalarClamp             | VisualShaderNodeClamp                     |
| VisualShaderNodeVectorClamp             | VisualShaderNodeClamp                     |
| VisualShaderNodeScalarInterp            | VisualShaderNodeMix                       |
| VisualShaderNodeVectorInterp            | VisualShaderNodeMix                       |
| VisualShaderNodeVectorScalarMix         | VisualShaderNodeMix                       |
| VisualShaderNodeScalarSmoothStep        | VisualShaderNodeSmoothStep                |
| VisualShaderNodeVectorSmoothStep        | VisualShaderNodeSmoothStep                |
| VisualShaderNodeVectorScalarSmoothStep  | VisualShaderNodeSmoothStep                |
| VisualShaderNodeVectorScalarStep        | VisualShaderNodeStep                      |
| VisualShaderNodeScalarSwitch            | VisualShaderNodeSwitch                    |
| VisualShaderNodeScalarTransformMult     | VisualShaderNodeTransformOp               |
| VisualShaderNodeScalarDerivativeFunc    | VisualShaderNodeDerivativeFunc            |
| VisualShaderNodeVectorDerivativeFunc    | VisualShaderNodeDerivativeFunc            |
| VisualShaderNodeBooleanUniform          | VisualShaderNodeBooleanParameter          |
| VisualShaderNodeColorUniform            | VisualShaderNodeColorParameter            |
| VisualShaderNodeScalarUniform           | VisualShaderNodeFloatParameter            |
| VisualShaderNodeCubeMapUniform          | VisualShaderNodeCubeMapParameter          |
| VisualShaderNodeTextureUniform          | VisualShaderNodeTexture2DParameter        |
| VisualShaderNodeTextureUniformTriplanar | VisualShaderNodeTextureParameterTriplanar |
| VisualShaderNodeTransformUniform        | VisualShaderNodeTransformParameter        |
| VisualShaderNodeVec3Uniform             | VisualShaderNodeVec3Parameter             |
| VisualShaderNodeUniform                 | VisualShaderNodeParameter                 |
| VisualShaderNodeUniformRef              | VisualShaderNodeParameterRef              |
| File                                    | FileAccess                                |
| Directory                               | DirAccess                                 |
| SceneTreeTween                          | Tween                                     |
+-----------------------------------------+-------------------------------------------+

**Removed or replaced nodes/resources**

+---------------------+-----------------------+----------------------------------------------------------------------------+
| Removed node        | Closest approximation | Comment                                                                    |
+=====================+=======================+============================================================================+
| AnimationTreePlayer | AnimationTree         | AnimationTreePlayer was deprecated since Godot 3.1.                        |
+---------------------+-----------------------+----------------------------------------------------------------------------+
| BakedLightmap       | LightmapGI            | See :ref:`doc_baked_lightmaps`.                                            |
+---------------------+-----------------------+                                                                            |
| BakedLightmapData   | LightmapGIData        |                                                                            |
+---------------------+-----------------------+----------------------------------------------------------------------------+
| BitmapFont          | FontFile              | See :ref:`doc_gui_using_fonts`.                                            |
+---------------------+-----------------------+                                                                            |
| DynamicFont         | FontFile              |                                                                            |
+---------------------+-----------------------+                                                                            |
| DynamicFontData     | FontFile              |                                                                            |
+---------------------+-----------------------+----------------------------------------------------------------------------+
| Navigation2D        | Node2D                | Replaced by :ref:`other 2D Navigation nodes <doc_navigation_overview_2d>`. |
+---------------------+-----------------------+----------------------------------------------------------------------------+
| Navigation3D        | Node3D                | Replaced by :ref:`other 3D Navigation nodes <doc_navigation_overview_3d>`. |
+---------------------+-----------------------+----------------------------------------------------------------------------+
| OpenSimplexNoise    | FastNoiseLite         | Has different parameters and more noise types such as cellular. No         |
|                     |                       | support for 4D noise as it's absent from the FastNoiseLite library.        |
+---------------------+-----------------------+----------------------------------------------------------------------------+
| ToolButton          | Button                | ToolButton was Button with the **Flat** property enabled by default.       |
+---------------------+-----------------------+----------------------------------------------------------------------------+
| YSort               | Node2D                | Node2D has a new **Y Sort** property in 4.0.                               |
+---------------------+-----------------------+----------------------------------------------------------------------------+
| ProximityGroup      | Node3D                | :ref:`class_VisibleOnScreenNotifier3D` can act as a replacement.           |
+---------------------+-----------------------+----------------------------------------------------------------------------+
| Portal              | Node3D                | Portal and room occlusion culling was replaced by raster                   |
|                     |                       | :ref:`occlusion culling <doc_occlusion_culling>`                           |
|                     |                       | (OccluderInstance3D node), which requires a different setup process.       |
+---------------------+-----------------------+                                                                            |
| Room                | Node3D                |                                                                            |
+---------------------+-----------------------+                                                                            |
| RoomManager         | Node3D                |                                                                            |
+---------------------+-----------------------+                                                                            |
| RoomGroup           | Node3D                |                                                                            |
+---------------------+-----------------------+----------------------------------------------------------------------------+
| Occluder            | Node3D                | Geometry occlusion culling was replaced by raster                          |
|                     |                       | :ref:`occlusion culling <doc_occlusion_culling>`                           |
|                     |                       | (OccluderInstance3D node), which requires a different setup process.       |
+---------------------+-----------------------+                                                                            |
| OccluderShapeSphere | Resource              |                                                                            |
+---------------------+-----------------------+----------------------------------------------------------------------------+

|-----------------|-------------------------------------|------------------------------------------|
|      Object     |              Godot 3.x              |                Godot 4.x                 |
|-----------------|-------------------------------------|------------------------------------------|
| @GDScript       | deg2rad()                           | @GlobalScope.deg_to_rad()                |
|-----------------|-------------------------------------|------------------------------------------|
| CanvasItem      | update()                            | queue_redraw()                           |
| ClassDB         | instance()                          | instantiate()                            |
| PackedScene     | instance()                          | instantiate()                            |
| Object          | property_list_changed_notify()      | notify_property_list_changed()           |
| Control         | rect_min_size                       | custom_minimum_size                      |
|                 | rect_size                           | size                                     |
| Label           | ALIGN_CENTER                        | HORIZONTAL_ALIGNMENT_CENTER              |
| Color           | darkorange                          | DARK_ORANGE                              |
| Engine          | editor_hint                         | is_editor_hint()                         |
| Sprite          | Sprite.rotation_degrees             | Sprite2D.rotation                        |
|-----------------|-------------------------------------|------------------------------------------|
| Node            | find_node()                         | find_child                               |
|-----------------|-------------------------------------|------------------------------------------|
| Spatial         | global_translation                  | Node3D.global_position                   |
|-----------------|-------------------------------------|------------------------------------------|
| TileMap         | cell_size                           | tile_set.tile_size                       |
|                 | local_to_map/map_to_local           | world_to_map/map_to_world                |
|-----------------|-------------------------------------|------------------------------------------|
| Theme Overrides | custom_colors/font_color            | theme_override_colors/font_color         |
|                 | custom_colors/font_color_shadow     | theme_override_colors/font_shadow_color  |
|                 | custom_colors/font_outline_modulate | theme_override_colors/font_outline_color |
|                 | custom_constants/shadow_offset_y    | theme_override_constants/shadow_offset_x |
|-----------------|-------------------------------------|------------------------------------------|
| Anchor & Margin | anchor_left & margin_left           | anchors_preset                           |
| Rect Position   | rect_position                       | position                                 |
| Node            | name: String                        | name: StringName                         |
| SceneTree       | idle_frame                          | process_frame                            |
| EditorInterface | get_editor_viewport()               | get_base_control()                       |
| OS              | get_scancode_string                 | get_keycode_string()                     |
|-----------------|-------------------------------------|------------------------------------------|
| InputEventKey   | scancode                            | keycode                                  |
|                 | physical_scancode                   | physical_keycode                         |
|                 |                                     |                                          |


### 🟠🔵 Godot Editor Layout 编辑器布局
- [Documentation Writing guidelines](https://docs.godotengine.org/en/latest/contributing/documentation/docs_writing_guidelines.html)

根据官方文档 Writing guidelines 所展示的 Godot 用户界面结构：

![Overview of the interface](https://docs.godotengine.org/en/latest/_images/editor-vocabulary-overview.png)

Godot 用户界面包含以下几个布局结构：

- Main Menu 主菜单栏；
- 主工作视图区切换工具栏，包括 2D, 3D, Script, AssetLib 按钮，对应 `CONTAINER_TOOLBAR`；
- Workspace 主工作视图区，包含 Main Viewport 和 Toolbar；
- Scene Tree Dock 工程中的场景树面板；
- FileSystem Dock 文件资源目录面板；
- Inspector Dock 属性探测器面板；
- Bottom Panel 底部面板区；
- Toolbar 右上角工具按钮区，包括常用的场景运行测试按钮等等；

主工作视图区中的视口用于容纳各种专用编辑器，默认有 2D, 3D, Script, AssetLib，其中 2D/3D 编辑器
又划分为：菜单区、SIDE_LEFT、SIDE_RIGHT 和 BOTTOM 区域。

使用 EditorPlugin 的信号可以监测到主工作区视图类型的切换：

- *main_screen_changed(screen_name: String)* 视图名称为 2D, 3D, Script, AssetLib，也可以由用户插件定义。
- *project_settings_changed()* 修改工程配置，即配置改变即触发此信号。
- *resource_saved(resource: Resource)* 保存文件资源时触发。
- *scene_changed(scene_root: Node)* 主工作视图中切换场景时触发，如果关闭了所有场景或只有新场景，参数值为 null。
- *scene_closed(filepath: String)* 关闭场景时触发，文件路径为已关闭的场景。

停靠坞设置了 8 个槽位用于停放各种面板，左右两侧各 4 个槽位，通过面板右上角的三点图标按钮弹出菜单，
可以调整面板的停靠位。这些槽位使用 `DockSlot` 枚举类型定义。

Godot 编辑器中的各种面板就是一个个容器，`CustomControlContainer` 枚举标记这些容器，对各个容器
进行修改时需要通过它来指定要操作的容器。

通过 EditorPlugin 来引用以下这些枚举值：

|     CustomControlContainer Enum     | Value |                             Note                            |
|-------------------------------------|-------|-------------------------------------------------------------|
| CONTAINER_TOOLBAR                   |     0 | Main editor toolbar, next to play buttons.                  |
| CONTAINER_SPATIAL_EDITOR_MENU       |     1 | The toolbar that appears when 3D editor is active.          |
| CONTAINER_SPATIAL_EDITOR_SIDE_LEFT  |     2 | Left sidebar of the 3D editor.                              |
| CONTAINER_SPATIAL_EDITOR_SIDE_RIGHT |     3 | Right sidebar of the 3D editor.                             |
| CONTAINER_SPATIAL_EDITOR_BOTTOM     |     4 | Bottom panel of the 3D editor.                              |
| CONTAINER_CANVAS_EDITOR_MENU        |     5 | The toolbar that appears when 2D editor is active.          |
| CONTAINER_CANVAS_EDITOR_SIDE_LEFT   |     6 | Left sidebar of the 2D editor.                              |
| CONTAINER_CANVAS_EDITOR_SIDE_RIGHT  |     7 | Right sidebar of the 2D editor.                             |
| CONTAINER_CANVAS_EDITOR_BOTTOM      |     8 | Bottom panel of the 2D editor.                              |
| CONTAINER_INSPECTOR_BOTTOM          |     9 | Bottom section of the inspector.                            |
| CONTAINER_PROJECT_SETTING_TAB_LEFT  |    10 | Tab of Project Settings dialog, to the left of other tabs.  |
| CONTAINER_PROJECT_SETTING_TAB_RIGHT |    11 | Tab of Project Settings dialog, to the right of other tabs. |

|   DockSlot Enum    | Value |                                                Note                                                |
|--------------------|-------|----------------------------------------------------------------------------------------------------|
| DOCK_SLOT_LEFT_UL  |     0 | Dock slot, left side, upper-left (empty in default layout).                                        |
| DOCK_SLOT_LEFT_BL  |     1 | Dock slot, left side, bottom-left (empty in default layout).                                       |
| DOCK_SLOT_LEFT_UR  |     2 | Dock slot, left side, upper-right (in default layout includes Scene and Import docks).             |
| DOCK_SLOT_LEFT_BR  |     3 | Dock slot, left side, bottom-right (in default layout includes FileSystem dock).                   |
| DOCK_SLOT_RIGHT_UL |     4 | Dock slot, right side, upper-left (empty in default layout).                                       |
| DOCK_SLOT_RIGHT_BL |     5 | Dock slot, right side, bottom-left (empty in default layout).                                      |
| DOCK_SLOT_RIGHT_UR |     6 | Dock slot, right side, upper-right (in default layout includes Inspector, Node and History docks). |
| DOCK_SLOT_RIGHT_BR |     7 | Dock slot, right side, bottom-right (empty in default layout).                                     |


通过插件对象 `EditorPlugin` 提供的方法，get_editor_interface()，可以获取到 `EditorInterface`，
这个编辑器接口对象代表整个 Godot 编辑器。

编辑器接口提供了多个方法，用于获取 Godot IDE 界面的各个功能区，使用 **get_editor_viewport()**
获取到的是当前界面的 Main Viewport，它包含 2D/3D，Script, AssetLib 等编辑器视图。这个顶层视口
下包含一个 **EditorNode**，可以通过源代码观察其节点组织层次。Main Screen 插件就是将自己的场景通过
add_child(MainPanel) 添加到 Main Viewport 下实现主屏幕的定制。

新旧版本 Main Screen 节点获取方法：
```py
 Control get_editor_viewport() # Godot 3.x
VBoxContainer get_editor_main_screen() # Godot 4.x
```

通过接口的“添加”方法可以了解到，Godot 编辑器的各个区域都可以进行定制：

```py
void add_autoload_singleton(name: String, path: String)
Button add_control_to_bottom_panel(control: Control, title: String)
void add_control_to_container(container: CustomControlContainer, control: Control)
void add_control_to_dock(slot: DockSlot, control: Control)
void add_custom_type(type: String, base: String, script: Script, icon: Texture2D)
void add_debugger_plugin(script: EditorDebuggerPlugin)
void add_export_plugin(plugin: EditorExportPlugin)
void add_import_plugin(importer: EditorImportPlugin, first_priority: bool = false)
void add_inspector_plugin(plugin: EditorInspectorPlugin)
void add_node_3d_gizmo_plugin(plugin: EditorNode3DGizmoPlugin)
void add_resource_conversion_plugin(plugin: EditorResourceConversionPlugin)
void add_scene_format_importer_plugin(scene_format_importer: EditorSceneFormatImporter, first_priority: bool = false)
void add_scene_post_import_plugin(scene_import_plugin: EditorScenePostImportPlugin, first_priority: bool = false)
void add_tool_menu_item(name: String, callable: Callable)
void add_tool_submenu_item(name: String, submenu: PopupMenu)
void add_translation_parser_plugin(parser: EditorTranslationParserPlugin)
void add_undo_redo_inspector_hook_callback(callable: Callable)
```

部分 API 说明：

- *add_autoload_singleton()* 对应 Project → Project Settings... → Autoload 的全局加载功能；
- *add_control_to_bottom_panel()* 给底部面板区域添加节点，自定义面板，title 会作为切换按钮的标题；
- *add_control_to_container()* 给指定容器添加节点，自定义面板；
- *add_control_to_dock()* 给指定 DockSlot 插槽添加节点，自定义面板；
- *add_custom_type()* 向 Godot 注册自定义节点；
- *add_tool_menu_iteme()* 向 Project > Tools 菜单添加菜单项；
- *add_tool_submenu_iteme()* 向 Project > Tools 菜单添加子菜单；

所有自定义面板有对应的方法添加到指定区域，也有对应的 remove 方法来解除，需要在适当的时间，如插件
禁用时，移除这些自定义面板。

虽然，可以通过节点的 get_parent() 检测节点是否附加到界面，但是并不能直接通过 remove_child() 方法
直接移除节点，必需调用专用方法。加载场景时需要注意，使用 `preload` 关键字重复加载同一资源可能导致循环加载，
出错导致场景中的脚本无法被执行。

默认添加新面板的位置在后，对于 CONTAINER_TOOLBAR 来说，新加入的按钮就在右侧，可以通过父级节点
的 move_child() 方法来调整新增按钮的位置：

```py
    add_control_to_container(CONTAINER_TOOLBAR, container)
    # We are 100% sure that there are 2 items to the left.
    container.get_parent().move_child(container, container.get_index() - 2)
```

EditorInterface 还可以获取其它一些对象或场景信息，这些对象通常不应该直接实例化：

```py
EditorSettings get_editor_settings()
FileSystemDock get_file_system_dock()
EditorInspector get_inspector() const
EditorFileSystem get_resource_filesystem()
EditorResourcePreview get_resource_previewer()
ScriptEditor get_script_editor()
```


### 🟠🔵 GDScript Plugins 插件扩展
- [Editor plugins](https://docs.godotengine.org/en/stable/tutorials/plugins/editor/index.html)
- [Conditionally Export Properties in Godot](http://kehomsforge.com/tutorials/single/gdConditionalProperty)
- [Plugin Demos](https://github.com/godotengine/godot-demo-projects/tree/master/plugins)
- [2.5D Demo Project with GDScript](https://godotengine.github.io/godot-demo-projects/misc/2.5d/)
- [Ridiculous Coding](https://github.com/jotson/ridiculous_coding)
- [Heightmap terrain 1.6.1](https://godotengine.org/asset-library/asset/231)
- [Heightmap terrain 地形制作](https://www.bilibili.com/video/BV1uf4y1k7LF/)
- [Shell Fur 0.3.0 by Arnklit](https://godotengine.org/asset-library/asset/752)
- [Material Maker by R0dZill4](https://godotengine.org/showcase/material-maker/)
- [Irfanview Plugins](https://www.irfanview.com/plugins.htm#UpdatedPlugins)
- [How and why to use EXR in Blender](https://artisticrender.com/how-and-why-to-use-exr-in-blender/)
- [Standard Material 3D and ORM Material 3D](https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html)
- [Learn GDScript from ZERO online](https://gdquest.github.io/learn-gdscript/)
- [Learn GDScript from ZERO](https://github.com/GDQuest/learn-gdscript)
- [Editor Highlighter](https://github.com/GDQuest/godot-plugin-highlighter)
- [Godot 2D Visual Novel](https://github.com/GDQuest/godot-2d-visual-novel)
- [GDQuest Godot Demos](https://github.com/GDQuest/godot-demos)
- [GDQuest Godot Shaders](https://github.com/GDQuest/godot-shaders)
- [GDQuest Godot Plugin Tour](https://github.com/GDQuest/godot-plugin-tour)
- [Godot Steering AI motion](https://github.com/GDQuest/godot-steering-ai-framework-submodule)
- [GDQuest Godot Design Patterns](https://github.com/GDQuest/godot-design-patterns)
- [Godello kanban board](https://github.com/alfredbaudisch/Godello)
- [UI Design Tool](https://godotengine.org/asset-library/asset/717)
- https://godotengine.org/article/we-should-all-use-gltf-20-export-3d-assets-game-engines/
- [the Godot glTF 2.0 scene exporter](https://godotengine.org/article/introducing-the-godot-gltf-2-0-scene-exporter/)
- [Better Collada Blender add-on](https://github.com/godotengine/collada-exporter)

Ridiculous Coding 插件为 Godot 编辑器提供编写代码时的打字特效，这个插件值得学习，他已经将 Godot
本身就是游戏这个概念玩透了，插件就是基于游戏构架本身定义的一种节点，同时 Godot 编辑器也是由同一套节点
按指定的布局编排得到的。


工具脚本和插件是扩展 Godot IDE 能力的两种上基本方法。

编写编辑器插件，继承 **EditorPlugin** 类型，可以为编辑器提供更多功能。Asset Library 提供了
现有的插件，在 Godot IDE 中可以直接搜索、安装各种插件。也可以手动下载插件，安装到项目的 addons 目录下。

Godot Plugins 有多种类型：

- Editor plugins **EditorPlugin** 所有编辑器插件的基类；
- Main screen plugins 主屏插件；
- Import plugins **EditorImportPlugin** 资源导入插件；
- Spatial gizmo plugins **EditorSpatialGizmo** 空间节点辅助线框插件；
- Inspector plugins **EditorInspectorPlugin** 属性探测器插件；
- Visual Shader plugins **VisualShaderNodeCustom** 可视化着色器节点插件；

主屏插件通过编辑器插件的 **has_main_screen()**、**get_editor_interface ( )** 等方法实现，
配合 **EditorInterface** 接口类型对编辑器主界面进行扩展，像顶部的 2D、3D、Script、AssetLib 
一样，从整体上改变编辑器界面。因为 Godot IDE 界面就是使用引擎自身实现的，程序逻辑类似开发一个游戏。

另外，可视化着色器插件主要是通过 GDScript 脚本为 VisualShader 添加节点。

将脚本作为 Godot IDE 工具，在开发环境下就可以运行脚本进行自动化工作的处理，配合符号导出，与属性
探测器紧密结合。例如，以下实现一个 MyTitle 标签控件，在场景树中添加控件时，就会运行脚本完成控件的
基本设置，自动匹配当前工程的视口宽度。通过导出用于保存资源的变量，用户可以在属性探测器中给控件设置
一个纹理图片，控件将会自动将其添加到节点树中。

在工具脚本中，如果修改了导出的变量，为了使用属性探测器中能及时反映出变化，就需要使用 **Object** 
提供的 property_list_changed_notify() 方法发布通知。以下脚本中，在 AutoRefresh 为激活时，
脚本设置 ResourceInfo 变量的变化就可以及时反映在属性探测器上：

```py
tool

class_name MyTitle, "res://icon.png" extends Label

export var resource: Resource setget set_resource
export var ResourceInfo:String

# Auto Refresh inspector property list
export var AutoRefresh:bool = true

func set_resource(res: Resource):
    resource = res
    ResourceInfo = res.resource_path if res else ""
    
    if res is Texture:
        var tr = ClassDB.instance("TextureRect") # TextureRect.new()
        tr.texture = res
        for child in get_children():
            remove_child(child)
        add_child(tr)
    
    if AutoRefresh:
        .property_list_changed_notify()
    
func _ready():
    if Engine.editor_hint and not text:
        text = "MyTitle"
        rect_min_size = Vector2(ProjectSettings.get("display/window/size/width"), 64)
    # else:
    #   rect_min_size = Vector2(get_tree().root.size.x, 64)

func _init():
    set("align", ALIGN_CENTER)
    set("valign", ALIGN_CENTER)
    set("custom_colors/font_size", Color.whitesmoke)
    set("custom_colors/font_color", Color.whitesmoke)
    set("custom_colors/font_color_shadow", Color.darkorange)
    set("custom_constants/shadow_offset_x", 2)
    set("custom_constants/shadow_offset_y", 2)
    set("custom_constants/shadow_offset_y", 2)
    
    theme = load("res://L7 UI/theme.tres")
    theme_type_variation = "MyLabel"
```

需要注意，Node 数据可以由多种设置方式，在场景中创建节点后，用户可以在属性探测器中设置节点数据，或者
也可以通过工具脚本的形式设置数据，这些数据会保存在场景文件 TSCN 中，这是 Godot 场景的字符串保存格式。
列如，以下是一个 MyTitle 节点在场景文件中保存的格式：

    [node name="MyTitle" parent="." index="0"]
    text = "IO & Serialization"

MyTitle 标签在新创建时，text 为空，这时可以提供一个默认标题内容。但是，在后续重新打开场景时，
工具脚本会再次运行，此时如不不判断数据是否被改变，则可能会将用户在属性探测器中设置的数据覆盖。
已经在场景中设置好的数据会在类型构造过程中加载，在初始化方法 **_init()** 中就可以访问。

通过脚本添加的节点并不会出现在场景树面板上，也就是说脚本添加的生成的节点内容不会被记录到场景文件中，
节点类有一个 owner 属性，给节点的设置的所有者可以是任意级的父节点，只要是有效的父节点、增父节点等等，
这样，场景保存为 PackedScene，即 TSCN 文件时就会记录下已指定 owner 的节点数据，包括 owner 点。
通常在插件中调用 add_child() 添加节点时，附带设置 owner 以记录复杂的场景树结构。

不设置所有者的情况下调用 add_child()，则新添加的节点将在场景树中不可见，只在 2D/3D 视图中可见。
场景根节点 owner 为 null。

在编写插件时注意，Godot 可以切换不同的场景文件，所以只有节点已经附加到场景树中，即激活的节点才能
通过 get_tree() 获取到 ScreenTree 引用。编辑器切换到其它场景后，如果节点注册的事件还在工作，
就不能再使用 get_tree() 来获取场景树的引用，EditorPlugin 则总是可以通过 **get_tree()** 获取到。
要清楚，场景树在整个工程中只有一个，最顶层始终是 root 属性引用的 Viewport。场景却不断地切换，场景
根节点也不断变更，插件的 **get_edited_scene_root()** 方法获取当前处于编辑中的场景根节点。

注意，EditorPlugin 只有在编辑器模式下才被实例化，在游戏运行模式执行实例化时返回空引用。另外，通过
get_selection() 返回的节点选择对象不能持久引用，在切换编辑场景时会失效。


```py
tool
extend Node2D

var editor = EditorPlugin.new().get_editor_interface()

func _ready():
    pass

func _enter_tree():
    var selection = editor.get_selection()
    selection.connect("selection_changed", self, "attach_to_scenetree")
    get_tree().connect("node_added", self, "_on_node_added", [], CONNECT_ONESHOT)


func _exit_tree():
    var selection = editor.get_selection()
    selection.disconnect("selection_changed", self, "attach_to_scenetree")


func _on_node_added(node:Node):
    if node is Label:
        print("_on_node_added %s (%s)" % [node, node.text])


func attach_to_scenetree():
    var selection = editor.get_selection()
    var nodes = selection.get_selected_nodes()
    var sceneroot = editor.get_edited_scene_root()
    var root = editor.get_tree().root  # Top most level viewport $"/root"

    if not nodes.size():
        return
    print("node owner is ", nodes[0].owner)
    
    var label = ClassDB.instance("Label") # Label.new()
    label.text = "LabelText"
    nodes[0].add_child(label)
    label.owner = nodes[0].owner if nodes[0].owner else nodes[0]

    # yield(editor.get_tree(), "idle_frame")
    # call_deferred("add_child", label)
```



Godot IDE 工程配置的插件面板提供了创建插件的操作，也可以手动在 Addons 目录下创建插件，创建一个
子目录保存插件文件，首先是插件配置文件，格式如下：

```sh
[plugin]

Plugin Name: MyPlugin
Subfolder: my_plugin
Description: A plugin to extend the Godot Engine.
Author: Your Name Here
Version: 1.0.0
Language: GDScript
Script Name: plugin.gd
Activate now: No
```

然后，就是插件的主要脚本编写，需要根据不同类型的插件去继承对应的插件基类。工程插件配置中，可以对插件
进行激活、禁用操作，而插件的对应响应方法是进入、脱离场景树事件，没有专用事件。

一个最简单的插件可以只包含两个方法，它向引擎注册自定义节点：

```py
tool
extends EditorPlugin

func _enter_tree():
    # When this plugin node enters tree, add the custom type
    add_custom_type("Heart", "Node2D", preload("res://addons/custom_node/heart.gd"), preload("res://addons/custom_node/heart_icon.png"))


func _exit_tree():
    # When the plugin node exits the tree, remove the custom type
    remove_custom_type("Heart")
```

自定义节点 Heart 功能如下，只是进行图案绘制：

```py
tool
extends Node2D

var heart = preload("res://addons/custom_node/heart.png")

func _draw():
    draw_texture(heart, -heart.get_size() / 2)


func _get_item_rect():
    # override
    return Rect2(-heart.get_size() / 2, heart.get_size())
```

其它一些专用插件基于这种基本结构实现，如资源导入插件 EditorImportPlugin，通过专用方法注册插件：

```py
tool
extends EditorPlugin

var import_plugin

func _enter_tree():
    import_plugin = preload("import_plugin.gd").new()
    add_import_plugin(import_plugin)


func _exit_tree():
    remove_import_plugin(import_plugin)
    import_plugin = null
```

以下示范 Main Screen 插件的实现，在 has_main_screen() 方法返回 true 表示这是一个主屏插件。

当用户在场景树中选择不同的节点时，引擎会调用 handles() 方法判断插件是否要处理这种节点，如果需要
处理，接下来就调用 make_visible() 准备切换到插件的主界面，并调用 edit() 执行编辑。除非用户界面
当前处于脚本编辑界面，即使插件表示需要处理当前节点，这时也不会触发后续的编辑行为： 

```py
bool handles(object: Object) virtual

void make_visible(visible: bool) virtual

void edit(object: Object) virtual
```

以下是一个 Main Screen 插件的实现，可以根据需要创建插件的面板所使用的场景文件，注意使用 tool 关键字
以使脚本在编辑器中可以被执行。使用 add_autoload_singleton() 等方法可以加载全局的 Singleton 对象，
但是这种方法加载的对象，在插件禁用后再激活时会出现不稳定问题。注意，挂载在 MainScrren 场景中的脚本
一定要添加 tool 关键字标记工具脚本，否则不会被执行，只能通过插件脚本来处理 MainScreen 场景。

添加 MainScreen 时，一般使用 make_visible() 方法中调整其可见属性，但初次添加节点到场景中时，
需要默认地隐藏它，否则激活插件时，会和其它 MainScreen 共用 Main Viewport。例如，通过 AssetLib
视图的 Plugins 按键打开插件时，就会看到两个 MainScreen 同屏。

以下是 Godot 4.x 中实现的一个 MainScreen 插件：

```py
@tool
extends EditorPlugin

const Main = preload("res://addons/MyMainScreen/Main.tscn")
var mainscreen = Main.instantiate()
var label = mainscreen.get_node("Label")
var container = get_editor_interface().get_editor_main_screen()


func _enter_tree():
    _make_visible(false)
    container.add_child(mainscreen)

func _ready():
    #main_screen_changed.connect(handle_main_screen_changed)
    pass

func _exit_tree():
    container.remove_child(mainscreen)
    mainscreen.queue_free()

func _has_main_screen():
    return true

func _make_visible(visible):
    mainscreen.visible = visible
    label.text = "mainscreen size: %s" % [mainscreen.size]

# Implement this function if your plugin edits a specific type of object (Resource or Node). 
# If you return true, then you will get the functions _edit() and _make_visible() called 
# when the editor requests them. If you have declared the methods _forward_canvas_gui_input() and 
# _forward_3d_gui_input() these will be called too.
func _handles(object):
    print_debug("handles MainScreen only: ", object)
    return object is MainScreen


# This function is used for plugins that edit specific object types (nodes or resources). 
# It requests the editor to edit the given object.
# object can be null if the plugin was editing an object, but there is no longer 
# any selected object handled by this plugin. It can be used to cleanup editing state.
func _edit(object):
    mainscreen.get_node("Label").text = "editing: %s" % [object]

# Custom plugin name displayed in the Godot editor.
# For main screen plugins, this appears at the top of the screen, 
# to the right of the "2D", "3D", "Script", and "AssetLib" buttons.
func _get_plugin_name():
    return "MS"

func _get_plugin_icon():
    # You can use a custom icon:
    return preload("res://addons/MyMainScreen/bullet_32.svg")
    # Or use a built-in icon:
    return get_editor_interface().get_base_control().get_theme_icon("Node", "EditorIcons")
```

插件提供了多个方法，用于往 Godot IDE 主界面添加任意的控件节点，如右上角的 Toolbar 区域，指定专用
容器，底部的 Bottom Panel 区域，又或者是停靠坞 DockSlot。并且需要在插件禁止时，调用相应的方法解除。
虽然，可以通过节点的 get_parent() 检测节点是否附加到界面，但是并不能直接通过 remove_child() 方法
直接移除节点，必需调用专用方法。加载场景时需要注意，使用 preload 关键字重复加载同一资源可能导致循环加载，
出错导致场景中的脚本无法被执行：

```py
tool
extends Button

# When reactived plugin cause error:
# Autoload singleton 'MyPluginAutoload' has been removed.
#onready var ap:EditorPlugin = MyPluginAutoload
onready var plugin:EditorPlugin = EditorPlugin.new()
onready var panel:Node = load("res://addons/main_screen/main_panel.tscn").instance()

enum Location { NoneSet = 0, DockSlot= 1, Toolbar = 2, BottomBar = 3 }
var location

func _exit_tree():
    if panel:
        detach()
        panel.queue_free()
        print("panel ", panel)

func detach():
    if not panel.get_parent():
        return
    
    #panel.get_parent().remove_child(panel)
    match location:
        Location.DockSlot:
            plugin.remove_control_from_docks(panel)
        Location.BottomBar:
            plugin.remove_control_from_bottom_panel(panel)
        Location.Toolbar:
            plugin.remove_control_from_container(EditorPlugin.CONTAINER_TOOLBAR, panel)

func _on_Button_pressed():
    detach()
    location = Location.BottomBar
    plugin.add_control_to_bottom_panel(panel, "MyPlugin")


func _on_Button2_pressed():
    detach()
    location = Location.DockSlot
    plugin.add_control_to_dock(EditorPlugin.DOCK_SLOT_LEFT_BL, panel)


func _on_Button3_pressed():
    detach()
    location = Location.Toolbar
    plugin.add_control_to_container(EditorPlugin.CONTAINER_TOOLBAR, panel)
```


### 🟠🔵 GDScript grammar 语法规范文档
- [GDScript grammar](https://docs.godotengine.org/en/stable/development/file_formats/gdscript_grammar.html)
- [GDScript exports](https://docs.godotengine.org/en/3.5/tutorials/scripting/gdscript/gdscript_exports.html)
- [GDScript format strings](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_format_string.html)
- [GDScript 2.0](https://docs.godotengine.org/en/latest/tutorials/scripting/gdscript/gdscript_basics.html)
- [GDScript 2.0 exports](https://docs.godotengine.org/en/latest/tutorials/scripting/gdscript/gdscript_exports.html)

GDScript grammar

This is the formal grammar of GDScript written in EBNF, for reference purposes.

Note

This grammar is descriptive only, derived from the reference documentation and 
current implementation. The GDScript parser is not generated from a grammar definition. 
Inconsistencies here likely mean an error in this grammar, not a bug in GDScript.

```rs
(* GDScript EBNF grammar.
   Uppercase words are terminals generated by the tokenizer.
   INDENT/DEDENT are not generated by the tokenizer yet, but they are added
   here for reading convenience.
   Naturally, this only cover syntax. Semantics can't be inferred from this
   description.
*)

program = [ inheritance NEWLINE ] [ className ] { topLevelDecl } ;

inheritance = "extends" ( IDENTIFIER | STRING ) { "." IDENTIFIER } ;
className = "class_name" IDENTIFIER [ "," STRING ] NEWLINE ;

topLevelDecl
    = classVarDecl
    | constDecl
    | signalDecl
    | enumDecl
    | methodDecl
    | constructorDecl
    | innerClass
    | "tool"
    ;

classVarDecl = [ "onready" ] [ export ] "var" IDENTIFIER [ ":" typeHint ]
    [ "=" expression ] [ setget ] NEWLINE ;
setget = "setget" [ IDENTIFIER ] [ "," IDENTIFIER] ;
export = "export" [ "(" [ BUILTINTYPE | IDENTIFIER { "," literal } ] ")" ] ;
typeHint = BUILTINTYPE | IDENTIFIER ;

constDecl = "const" IDENTIFIER [ ":" typeHint ] "=" expression NEWLINE ;

signalDecl = "signal" IDENTIFIER [ signalParList ] NEWLINE ;
signalParList = "(" [ IDENTIFIER { "," IDENTIFIER } ] ")" ;

enumDecl = "enum" [ IDENTIFIER ] "{" [ IDENTIFIER [ "=" INTEGER ]
    { "," IDENTIFIER [ "=" INTEGER ] } [ "," ] ] "}" NEWLINE ;

methodDecl = [ rpc ] [ "static" ] "func" IDENTIFIER "(" [ parList ] ")"
    [ "->" typeHint] ":" stmtOrSuite ;
parList = parameter { "," parameter } ;
parameter = [ "var" ] IDENTIFIER [ ":" typeHint ] [ "=" expression ] ;
rpc = "remote" | "master" | "puppet"
    | "remotesync" | "mastersync"  | "puppetsync";

constructorDecl = "func" IDENTIFIER "(" [ parList ] ")"
    [ "." "(" [ argList ] ")" ] ":" stmtOrSuite ;
argList = expression { "," expression } ;

innerClass = "class" IDENTIFIER [ inheritance ] ":" NEWLINE
    INDENT [ inheritance NEWLINE ] topLevelDecl { topLevelDecl } DEDENT ;

stmtOrSuite = stmt | NEWLINE INDENT suite DEDENT ;
suite = stmt { stmt };

stmt
    = varDeclStmt
    | ifStmt
    | forStmt
    | whileStmt
    | matchStmt
    | flowStmt
    | assignmentStmt
    | exprStmt
    | assertStmt
    | yieldStmt
    | preloadStmt
    | "breakpoint" stmtEnd
    | "pass" stmtEnd
    ;
stmtEnd = NEWLINE | ";" ;

ifStmt = "if" expression ":" stmtOrSuite { "elif" expression ":" stmtOrSuite }
    [ "else" ":" stmtOrSuite ] ;
whileStmt = "while" expression ":" stmtOrSuite;
forStmt = "for" IDENTIFIER "in" expression ":" stmtOrSuite ;

matchStmt = "match" expression ":" NEWLINE INDENT matchBlock DEDENT;
matchBlock = patternList ":" stmtOrSuite { patternList ":" stmtOrSuite };
patternList = pattern { "," pattern } ;
(* Note: you can't have a binding in a pattern list, but to not complicate the
grammar more it won't be restricted syntactically *)
pattern = literal | BUILTINTYPE | CONSTANT | "_" | bindingPattern
    | arrayPattern | dictPattern ;
bindingPattern = "var" IDENTIFIER ;
arrayPattern = "[" [ pattern { "," pattern } [ ".." ] ] "]" ;
dictPattern = "{" [ keyValuePattern ] { "," keyValuePattern } [ ".." ] "}" ;
keyValuePattern = STRING [ ":" pattern ] ;

flowStmt
    = "continue" stmtEnd
    | "break" stmtEnd
    | "return" [ expression ] stmtEnd
    ;

assignmentStmt = subscription "=" expression stmtEnd;
varDeclStmt = "var" IDENTIFIER [ "=" expression ] stmtEnd;

assertStmt = "assert" "(" expression [ "," STRING ] ")" stmtEnd ;
yieldStmt = "yield" "(" [ expression "," expression ] ")" ;
preloadStmt = "preload" "(" CONSTANT ")" ;

(* This expression grammar encodes precedence. Items later in the list have
higher precedence than the ones before. *)
exprStmt = expression stmtEnd ;
expression = cast [ "[" expression "]" ] ;
cast = ternaryExpr [ "as" typeHint ];
ternaryExpr = logicOr [ "if" logicOr "else" logicOr ] ;
logicOr = logicAnd { ( "or" | "||" ) logicAnd } ;
logicAnd = logicNot { ( "and" | "&&" ) logicNot };
logicNot = ( "!" | "not" ) logicNot | in;
in = comparison { "in" comparison };
comparison = bitOr { ( "<" | ">" | "<=" | ">=" | "==" | "!=" ) bitOr } ;
bitOr = bitXor { "|" bitXor } ;
bitXor = bitAnd { "^" bitAnd } ;
bitAnd = bitShift { "&" bitShift } ;
bitShift = minus { ( "<<" | ">>" ) minus } ;
minus = plus { "-" plus } ;
plus = factor { "+" factor } ;
factor = sign { ( "*" | "/" | "%" ) sign } ;
sign = ( "-" | "+" ) sign | bitNot ;
bitNot = "~" bitNot | is ;
is = call [ "is" ( IDENTIFIER | BUILTINTYPE ) ] ;
call = attribute [ "(" [ argList ] ")" ];
attribute = subscription { "." IDENTIFIER } ;
subscription = primary [ "[" expression "]" ] ;
primary = "true" | "false" | "null" | "self" | literal | arrayDecl
    | dictDecl | "(" expression ")" ;

literal = STRING | NUMBER | IDENTIFIER | BUILTINTYPE
    | "PI" | "TAU" | "NAN" | "INF" ;
arrayDecl = "[" [ expression { "," expression } "," ] "]" ;
dictDecl = "{" [ keyValue { "," keyValue } "," ] "}" ;
keyValue
    = expression ":" expression
    | IDENTIFIER "=" expression
    ;
```

新版本规范变化主要有两处：

```py
    assignmentStmt = subscription ( "=" | "+=" | "-=" | "*=" | "/="
    | "%=" | "&=" | "|=" | "^=" ) expression stmtEnd;

    call
        = (attribute [ "(" [ argList ] ")" ])
        | "." IDENTIFIER "(" [ argList ] ")"
        | "$" ( STRING | IDENTIFIER { '/' IDENTIFIER } );
```

### 🟠🔵 GDScript 1.0 exports
- [GDScript 1.0 exports](https://github.com/godotengine/godot-docs/blob/3.6/tutorials/scripting/gdscript/gdscript_exports.rst)
- [GDScript 2.0 exports](https://github.com/godotengine/godot-docs/blob/master/tutorials/scripting/gdscript/gdscript_exports.rst)



Introduction to exports
    ----------------------------------------------------------------------------

In Godot, class members can be exported. This means their value gets saved along
with the resource (such as the :ref:`scene <class_PackedScene>`) they're
attached to. They will also be available for editing in the property editor.
Exporting is done by using the ``export`` keyword::

    extends Button

    export var number = 5 # Value will be saved and visible in the property editor.

An exported variable must be initialized to a constant expression or have an
export hint in the form of an argument to the ``export`` keyword (see the
*Examples* section below).

One of the fundamental benefits of exporting member variables is to have
them visible and editable in the editor. This way, artists and game designers
can modify values that later influence how the program runs. For this, a
special export syntax is provided.

.. note::

    Exporting properties can also be done in other languages such as C#.
    The syntax varies depending on the language.

..
   See  ref `doc_c_sharp_exports` for information on C# exports.

Examples
    ----------------------------------------------------------------------------

::

```py
    # If the exported value assigns a constant or constant expression,
    # the type will be inferred and used in the editor.

    export var number = 5

    # Export can take a basic data type as an argument, which will be
    # used in the editor.

    export(int) var number

    # Export can also take a resource type to use as a hint.

    export(Texture) var character_face
    export(PackedScene) var scene_file
    # There are many resource types that can be used this way, try e.g.
    # the following to list them:
    export(Resource) var resource

    # Integers and strings hint enumerated values.

    # Editor will enumerate as 0, 1 and 2.
    export(int, "Warrior", "Magician", "Thief") var character_class
    # Editor will enumerate with string names.
    export(String, "Rebecca", "Mary", "Leah") var character_name

    # Named enum values

    # Editor will enumerate as THING_1, THING_2, ANOTHER_THING.
    enum NamedEnum {THING_1, THING_2, ANOTHER_THING = -1}
    export(NamedEnum) var x

    # Strings as paths

    # String is a path to a file.
    export(String, FILE) var f
    # String is a path to a directory.
    export(String, DIR) var f
    # String is a path to a file, custom filter provided as hint.
    export(String, FILE, "*.txt") var f

    # Using paths in the global filesystem is also possible,
    # but only in scripts in "tool" mode.

    # String is a path to a PNG file in the global filesystem.
    export(String, FILE, GLOBAL, "*.png") var tool_image
    # String is a path to a directory in the global filesystem.
    export(String, DIR, GLOBAL) var tool_dir

    # The MULTILINE setting tells the editor to show a large input
    # field for editing over multiple lines.
    export(String, MULTILINE) var text

    # Limiting editor input ranges

    # Allow integer values from 0 to 20.
    export(int, 20) var i
    # Allow integer values from -10 to 20.
    export(int, -10, 20) var j
    # Allow floats from -10 to 20 and snap the value to multiples of 0.2.
    export(float, -10, 20, 0.2) var k
    # Allow values 'y = exp(x)' where 'y' varies between 100 and 1000
    # while snapping to steps of 20. The editor will present a
    # slider for easily editing the value.
    export(float, EXP, 100, 1000, 20) var l

    # Floats with easing hint

    # Display a visual representation of the 'ease()' function
    # when editing.
    export(float, EASE) var transition_speed

    # Colors

    # Color given as red-green-blue value (alpha will always be 1).
    export(Color, RGB) var col
    # Color given as red-green-blue-alpha value.
    export(Color, RGBA) var col

    # Nodes

    # Another node in the scene can be exported as a NodePath.
    export(NodePath) var node_path
    # Do take note that the node itself isn't being exported -
    # there is one more step to call the true node:
    onready var node = get_node(node_path)

    # Resources

    export(Resource) var resource
    # In the Inspector, you can then drag and drop a resource file
    # from the FileSystem dock into the variable slot.

    # Opening the inspector dropdown may result in an
    # extremely long list of possible classes to create, however.
    # Therefore, if you specify an extension of Resource such as:
    export(AnimationNode) var resource
    # The drop-down menu will be limited to AnimationNode and all
    # its inherited classes.
```
It must be noted that even if the script is not being run while in the
editor, the exported properties are still editable. This can be used
in conjunction with a :ref:`script in "tool" mode <doc_gdscript_tool_mode>`.

Exporting bit flags
    ----------------------------------------------------------------------------

Integers used as bit flags can store multiple ``true``/``false`` (boolean)
values in one property. By using the export hint ``int, FLAGS, ...``, they
can be set from the editor::

    # Set any of the given flags from the editor.
    export(int, FLAGS, "Fire", "Water", "Earth", "Wind") var spell_elements = 0

You must provide a string description for each flag. In this example, ``Fire``
has value 1, ``Water`` has value 2, ``Earth`` has value 4 and ``Wind``
corresponds to value 8. Usually, constants should be defined accordingly (e.g.
``const ELEMENT_WIND = 8`` and so on).

Export hints are also provided for the physics and render layers defined in the project settings::

    export(int, LAYERS_2D_PHYSICS) var layers_2d_physics
    export(int, LAYERS_2D_RENDER) var layers_2d_render
    export(int, LAYERS_3D_PHYSICS) var layers_3d_physics
    export(int, LAYERS_3D_RENDER) var layers_3d_render

Using bit flags requires some understanding of bitwise operations.
If in doubt, use boolean variables instead.

Exporting arrays
    ----------------------------------------------------------------------------

Exported arrays can have initializers, but they must be constant expressions.

If the exported array specifies a type which inherits from Resource, the array
values can be set in the inspector by dragging and dropping multiple files
from the FileSystem dock at once.

::

```py
    # Default value must be a constant expression.

    export var a = [1, 2, 3]

    # Exported arrays can specify type (using the same hints as before).

    export(Array, int) var ints = [1, 2, 3]
    export(Array, int, "Red", "Green", "Blue") var enums = [2, 1, 0]
    export(Array, Array, float) var two_dimensional = [[1.0, 2.0], [3.0, 4.0]]

    # You can omit the default value, but then it would be null if not assigned.

    export(Array) var b
    export(Array, PackedScene) var scenes

    # Arrays with specified types which inherit from resource can be set by
    # drag-and-dropping multiple files from the FileSystem dock.

    export(Array, Texture) var textures
    export(Array, PackedScene) var scenes

    # Typed arrays also work, only initialized empty:

    export var vector3s = PoolVector3Array()
    export var strings = PoolStringArray()

    # Default value can include run-time values, but can't
    # be exported.

    var c = [a, 2, 3]
```

Setting exported variables from a tool script
    ----------------------------------------------------------------------------

When changing an exported variable's value from a script in
:ref:`doc_gdscript_tool_mode`, the value in the inspector won't be updated
automatically. To update it, call
:ref:`property_list_changed_notify() <class_Object_method_property_list_changed_notify>`
after setting the exported variable's value.

Advanced exports
    ----------------------------------------------------------------------------

Not every type of export can be provided on the level of the language itself to
avoid unnecessary design complexity. The following describes some more or less
common exporting features which can be implemented with a low-level API.

Before reading further, you should get familiar with the way properties are
handled and how they can be customized with
:ref:`_set() <class_Object_method__get_property_list>`,
:ref:`_get() <class_Object_method__get_property_list>`, and
:ref:`_get_property_list() <class_Object_method__get_property_list>` methods as
described in :ref:`doc_accessing_data_or_logic_from_object`.

.. seealso:: For binding properties using the above methods in C++, see
             :ref:`doc_binding_properties_using_set_get_property_list`.

.. warning:: The script must operate in the ``tool`` mode so the above methods
             can work from within the editor.

Properties
    ----------------------------------------------------------------------------

To understand how to better use the sections below, you should understand
how to make properties with advanced exports.

::

```py
    func _get_property_list():
        var properties = [] 
        # Same as "export(int) var my_property"
        properties.append({
            name = "my_property",
            type = TYPE_INT
        })
        return properties
```

* The ``_get_property_list()`` function gets called by the inspector. You
  can override it for more advanced exports. You must return an ``Array``
  with the contents of the properties for the function to work.

* ``name`` is the name of the property

* ``type`` is the type of the property from ``Variant.Type``.

.. note:: The ``float`` type is called a real (``TYPE_REAL``) in the ``Variant.Type`` enum.

Attaching variables to properties
    ----------------------------------------------------------------------------

To attach variables to properties (allowing the value of the property to be used
in scripts), you need to create a variable with the exact same name as the
property or else you may need to override the 
:ref:`_set() <class_Object_method__get_property_list>` and 
:ref:`_get() <class_Object_method__get_property_list>` methods. Attaching
a variable to to a property also gives you the ability to give it a default state.
::


```py
    # This variable is determined by the function below.
    # This variable acts just like a regular gdscript export.
    var my_property = 5

    func _get_property_list():
        var properties = [] 
        # Same as "export(int) var my_property"
        properties.append({
            name = "my_property",
            type = TYPE_INT
        })
        return properties
```

Adding default values for properties
    ----------------------------------------------------------------------------

To define default values for advanced exports, you need to override the ``property_can_revert()`` and ``property_get_revert()`` methods.

* The ``property_can_revert()`` method takes the name of a property and must return ``true`` if the property can be reverted. This will enable the Revert button next to the property in the inspector.

* The ``property_get_revert()`` method takes the name of a property and must return the default value for that property.

::

```py
    func _get_property_list():
        var properties = []
        properties.append({
            name = "my_property",
            type = TYPE_INT
        })
        return properties

    func property_can_revert(property):
        if property == "my_property":
            return true
        return false

    func property_get_revert(property):
        if property == "my_property":
            return 5
```

Adding script categories
    ----------------------------------------------------------------------------

For better visual distinguishing of properties, a special script category can be
embedded into the inspector to act as a separator. ``Script Variables`` is one
example of a built-in category.
::

```py
    func _get_property_list():
        var properties = []
        properties.append({
            name = "Debug",
            type = TYPE_NIL,
            usage = PROPERTY_USAGE_CATEGORY | PROPERTY_USAGE_SCRIPT_VARIABLE
        })
        
        # Example of adding a property to the script category
        properties.append({
            name = "Logging_Enabled",
            type = TYPE_BOOL
        })
        return properties
```

* ``name`` is the name of a category to be added to the inspector;

* Every following property added after the category definition will be a part
  of the category. 

* ``PROPERTY_USAGE_CATEGORY`` indicates that the property should be treated as a
  script category specifically, so the type ``TYPE_NIL`` can be ignored as it
  won't be actually used for the scripting logic, yet it must be defined anyway.

Grouping properties
    ----------------------------------------------------------------------------

A list of properties with similar names can be grouped.
::

```py
    func _get_property_list():
        var properties = []
        properties.append({
            name = "Rotate",
            type = TYPE_NIL,
            hint_string = "rotate_",
            usage = PROPERTY_USAGE_GROUP | PROPERTY_USAGE_SCRIPT_VARIABLE
        })

        # Example of adding to the group
        properties.append({
            name = "rotate_speed",
            type = TYPE_REAL
        })

        # This property won't get added to the group 
        # due to not having the "rotate_" prefix.
        properties.append({
            name = "trail_color",
            type = TYPE_COLOR
        })
        return properties
```

* ``name`` is the name of a group which is going to be displayed as collapsible
  list of properties;

* Every following property added after the group property with the prefix
  (which determined by ``hint_string``) will be shortened. For instance, 
  ``rotate_speed`` is going to be shortened to ``speed`` in this case.
  However, ``movement_speed`` won't be a part of the group and will not
  be shortened.

* ``PROPERTY_USAGE_GROUP`` indicates that the property should be treated as a
  script group specifically, so the type ``TYPE_NIL`` can be ignored as it
  won't be actually used for the scripting logic, yet it must be defined anyway.


### 🟠🔵 GDScript 2.0 exports
- [GDScript 1.0 exports](https://github.com/godotengine/godot-docs/blob/3.6/tutorials/scripting/gdscript/gdscript_exports.rst)
- [GDScript 2.0 exports](https://github.com/godotengine/godot-docs/blob/master/tutorials/scripting/gdscript/gdscript_exports.rst)

In Godot, class members can be exported. This means their value gets saved along
with the resource (such as the :ref:`scene <class_PackedScene>`) they're
attached to. They will also be available for editing in the property editor.
Exporting is done by using the ``@export`` annotation::

    extends Button

    @export var number = 5

In that example the value `5` will be saved and visible in the property editor.

An exported variable must be initialized to a constant expression or have a type specifier
in the variable. Some of the export annotations have a specific type and don't need the variable to be typed (see the
*Examples* section below).

One of the fundamental benefits of exporting member variables is to have
them visible and editable in the editor. This way, artists and game designers
can modify values that later influence how the program runs. For this, a
special export syntax is provided.

Exporting can only be done with built-in types or objects derived from the :ref:`Resource class <class_Resource>`.

.. note::

    Exporting properties can also be done in other languages such as C#.
    The syntax varies depending on the language. See :ref:`doc_c_sharp_exports`
    for information on C# exports.

Basic use
    ----------------------------------------------------------------------------

If the exported value assigns a constant or constant expression,
the type will be inferred and used in the editor.

::

    @export var number = 5

If there's no default value, you can add a type to the variable.

::

    @export var number: int

Export works with resource types.

::

    @export var character_face: Texture
    @export var scene_file: PackedScene

There are many resource types that can be used this way, try e.g.
the following to list them:

::

    @export var resource: Resource

Integers and strings hint enumerated values.

::

    # Editor will enumerate as 0, 1 and 2.
    @export_enum("Warrior", "Magician", "Thief") var character_class

If type is String, editor will enumerate with string names.

::

    @export_enum("Rebecca", "Mary", "Leah") var character_name: String

Named enum values
    ----------------------------------------------------------------------------

Editor will enumerate as THING_1, THING_2, ANOTHER_THING.

::

    enum NamedEnum {THING_1, THING_2, ANOTHER_THING = -1}
    @export var x: NamedEnum

Strings as paths
    ----------------------------------------------------------------------------

String as a path to a file.

::

    @export_file var f

String as a path to a directory.

::

    @export_dir var f

String as a path to a file, custom filter provided as hint.

::

    @export_file("*.txt") var f

Using paths in the global filesystem is also possible,
but only in scripts in tool mode.

String as a path to a PNG file in the global filesystem.

::

    @export_global_file("*.png") var tool_image

String as a path to a directory in the global filesystem.

::

    @export_global_dir var tool_dir

The multiline annotation tells the editor to show a large input
field for editing over multiple lines.

::

    @export_multiline var text

Limiting editor input ranges
    ----------------------------------------------------------------------------

Allow integer values from 0 to 20.

::

    @export_range(0, 20) var i

Allow integer values from -10 to 20.

::

    @export_range(-10, 20) var j

Allow floats from -10 to 20 and snap the value to multiples of 0.2.

::

    @export_range(-10, 20, 0.2) var k: float

The limits can be only for the slider if you add the hints "or_greater" and/or "or_lesser".

::

    @export_range(0, 100, 1, "or_greater", "or_lesser")

.. TODO: Document other hint strings usable with export_range.

Floats with easing hint
    ----------------------------------------------------------------------------

Display a visual representation of the 'ease()' function
when editing.

::

    @export_exp_easing var transition_speed

Colors
    ----------------------------------------------------------------------------

Regular color given as red-green-blue-alpha value.

::

    @export var col: Color

Color given as red-green-blue value (alpha will always be 1).

::

    @export_color_no_alpha var col: Color

Nodes
    ----------------------------------------------------------------------------

Nodes can't be directly exported. Instead you need to export
a node path, then use that node path with `get_node()`

::

    @export var node_path: NodePath
    var node = get_node(node_path)

If you want to limit the types of nodes, you can use the @export_node_path annotation.

::

    @export_node_path(Button, TouchScreenButton) var some_button

Resources
    ----------------------------------------------------------------------------

::

    @export var resource: Resource

In the Inspector, you can then drag and drop a resource file
from the FileSystem dock into the variable slot.

Opening the inspector dropdown may result in an
extremely long list of possible classes to create, however.
Therefore, if you specify an extension of Resource such as:

::

    @export var resource: AnimationNode

The drop-down menu will be limited to AnimationNode and all
its inherited classes.

It must be noted that even if the script is not being run while in the
editor, the exported properties are still editable. This can be used
in conjunction with a :ref:`script in "tool" mode <doc_gdscript_tool_mode>`.

Exporting bit flags
    ----------------------------------------------------------------------------

Integers used as bit flags can store multiple ``true``/``false`` (boolean)
values in one property. By using the ``@export_flags`` annotation, they
can be set from the editor::

    # Set any of the given flags from the editor.
    @export_flags("Fire", "Water", "Earth", "Wind") var spell_elements = 0

You must provide a string description for each flag. In this example, ``Fire``
has value 1, ``Water`` has value 2, ``Earth`` has value 4 and ``Wind``
corresponds to value 8. Usually, constants should be defined accordingly (e.g.
``const ELEMENT_WIND = 8`` and so on).

Export annotations are also provided for the physics, render, and navigation 
layers defined in the project settings::

    @export_flags_2d_physics var layers_2d_physics
    @export_flags_2d_render var layers_2d_render
    @export_flags_2d_navigation var layers_2d_navigation
    @export_flags_3d_physics var layers_3d_physics
    @export_flags_3d_render var layers_3d_render
    @export_flags_3d_navigation var layers_3d_navigation

Using bit flags requires some understanding of bitwise operations.
If in doubt, use boolean variables instead.

Exporting arrays
    ----------------------------------------------------------------------------

Exported arrays can have initializers, but they must be constant expressions.

If the exported array specifies a type which inherits from Resource, the array
values can be set in the inspector by dragging and dropping multiple files
from the FileSystem dock at once.

The default value **must** be a constant expression.

::

    @export var a = [1, 2, 3]

Exported arrays can specify type (using the same hints as before).

::

    @export var ints: Array[int] = [1, 2, 3]

    # Nested typed arrays such as `Array[Array[float]]` are not supported yet.
    @export var two_dimensional: Array[Array] = [[1.0, 2.0], [3.0, 4.0]]

You can omit the default value, but it would then be ``null`` if not assigned.

::

    @export var b: Array
    @export var scenes: Array[PackedScene]

Arrays with specified types which inherit from resource can be set by
drag-and-dropping multiple files from the FileSystem dock.

::

    @export var textures: Array[Texture] = []
    @export var scenes: Array[PackedScene] = []

Packed type arrays also work, but only initialized empty:

::

    @export var vector3s = PackedVector3Array()
    @export var strings = PackedStringArray()

Setting exported variables from a tool script
    ----------------------------------------------------------------------------

When changing an exported variable's value from a script in
:ref:`doc_gdscript_tool_mode`, the value in the inspector won't be updated
automatically. To update it, call
:ref:`notify_property_list_changed() <class_Object_method_notify_property_list_changed>`
after setting the exported variable's value.

Advanced exports
    ----------------------------------------------------------------------------

Not every type of export can be provided on the level of the language itself to
avoid unnecessary design complexity. The following describes some more or less
common exporting features which can be implemented with a low-level API.

Before reading further, you should get familiar with the way properties are
handled and how they can be customized with
:ref:`_set() <class_Object_method__get_property_list>`,
:ref:`_get() <class_Object_method__get_property_list>`, and
:ref:`_get_property_list() <class_Object_method__get_property_list>` methods as
described in :ref:`doc_accessing_data_or_logic_from_object`.

.. seealso:: For binding properties using the above methods in C++, see
             :ref:`doc_binding_properties_using_set_get_property_list`.

.. warning:: The script must operate in the ``tool`` mode so the above methods
             can work from within the editor.


## 🟡 GPU Gems 1/2/3 系列书籍目录
- [GPU Gems 1](https://developer.nvidia.com/gpugems/gpugems/contributors)
- [GPU Gems 1 Code](https://http.download.nvidia.com/developer/GPU_Gems/CD_Image/GPU_Gems_code.zip)
- [GPU Gems 1 CD Content](https://http.download.nvidia.com/developer/GPU_Gems/CD_Image/Index.html)
- [GPU Gems 2](https://developer.nvidia.com/gpugems/gpugems2/contributors)
- [GPU Gems 2 Code](https://http.download.nvidia.com/developer/GPU_Gems_2/CD/GPU_Gems_2_code.zip)
- [GPU Gems 2 CD Content](https://http.download.nvidia.com/developer/GPU_Gems_2/CD/Index.html)
- [GPU Gems 3](https://developer.nvidia.com/gpugems/gpugems3/contributors)
- [GPU Gems 3 Code](https://http.download.nvidia.com/developer/GPU_Gems_3/CD/GPU_Gems_3_code.zip)
- [GPU Gems 3 CD Content](https://http.download.nvidia.com/developer/GPU_Gems_3/CD/)

GPU Gems 1 contents

- [Contributors](https://developer.nvidia.com/gpugems/gpugems/contributors)
- [Copyright](https://developer.nvidia.com/gpugems/gpugems/copyright)
- [Foreword](https://developer.nvidia.com/gpugems/gpugems/foreword)
- [Part I: Natural Effects](https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects)
    - [Chapter 1. Effective Water Simulation from Physical Models](https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models)
    - [Chapter 2. Rendering Water Caustics](https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-2-rendering-water-caustics)
    - [Chapter 3. Skin in the "Dawn" Demo](https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-3-skin-dawn-demo)
    - [Chapter 4. Animation in the "Dawn" Demo](https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-4-animation-dawn-demo)
    - [Chapter 5. Implementing Improved Perlin Noise](https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-5-implementing-improved-perlin-noise)
    - [Chapter 6. Fire in the "Vulcan" Demo](https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-6-fire-vulcan-demo)
    - [Chapter 7. Rendering Countless Blades of Waving Grass](https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-7-rendering-countless-blades-waving-grass)
    - [Chapter 8. Simulating Diffraction](https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-8-simulating-diffraction)
- [Part II: Lighting and Shadows](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows)
    - [Chapter 9. Efficient Shadow Volume Rendering](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-9-efficient-shadow-volume-rendering)
    - [Chapter 10. Cinematic Lighting](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-10-cinematic-lighting)
    - [Chapter 11. Shadow Map Antialiasing](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-11-shadow-map-antialiasing)
    - [Chapter 12. Omnidirectional Shadow Mapping](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-12-omnidirectional-shadow-mapping)
    - [Chapter 13. Generating Soft Shadows Using Occlusion Interval Maps](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-13-generating-soft-shadows-using-occlusion)
    - [Chapter 14. Perspective Shadow Maps: Care and Feeding](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-14-perspective-shadow-maps-care-and-feeding)
    - [Chapter 15. Managing Visibility for Per-Pixel Lighting](https://developer.nvidia.com/gpugems/gpugems/part-ii-lighting-and-shadows/chapter-15-managing-visibility-pixel-lighting)
- [Part III: Materials](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials)
    - [Chapter 16. Real-Time Approximations to Subsurface Scattering](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering)
    - [Chapter 17. Ambient Occlusion](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-17-ambient-occlusion)
    - [Chapter 18. Spatial BRDFs](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-18-spatial-brdfs)
    - [Chapter 19. Image-Based Lighting](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-19-image-based-lighting)
    - [Chapter 20. Texture Bombing](https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-20-texture-bombing)
- [Part IV: Image Processing](https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing)
    - [Chapter 21. Real-Time Glow](https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-21-real-time-glow)
    - [Chapter 22. Color Controls](https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-22-color-controls)
    - [Chapter 23. Depth of Field: A Survey of Techniques](https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-23-depth-field-survey-techniques)
    - [Chapter 24. High-Quality Filtering](https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-24-high-quality-filtering)
    - [Chapter 25. Fast Filter-Width Estimates with Texture Maps](https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-25-fast-filter-width-estimates-texture-maps)
    - [Chapter 26. The OpenEXR Image File Format](https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-26-openexr-image-file-format)
    - [Chapter 27. A Framework for Image Processing](https://developer.nvidia.com/gpugems/gpugems/part-iv-image-processing/chapter-27-framework-image-processing)
- [Part V: Performance and Practicalities](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities)
    - [Chapter 28. Graphics Pipeline Performance](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-28-graphics-pipeline-performance)
    - [Chapter 29. Efficient Occlusion Culling](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-29-efficient-occlusion-culling)
    - [Chapter 30. The Design of FX Composer](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-30-design-fx-composer)
    - [Chapter 31. Using FX Composer](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-31-using-fx-composer)
    - [Chapter 32. An Introduction to Shader Interfaces](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-32-introduction-shader-interfaces)
    - [Chapter 33. Converting Production RenderMan Shaders to Real-Time](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-33-converting-production-renderman)
    - [Chapter 34. Integrating Hardware Shading into Cinema 4D](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-34-integrating-hardware-shading-cinema)
    - [Chapter 35. Leveraging High-Quality Software Rendering Effects in Real-Time Applications](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-35-leveraging-high-quality-software)
    - [Chapter 36. Integrating Shaders into Applications](https://developer.nvidia.com/gpugems/gpugems/part-v-performance-and-practicalities/chapter-36-integrating-shaders-applications)
- [Part VI: Beyond Triangles](https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles)
  - [Appendix](https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/appendix)
  - [Chapter 37. A Toolkit for Computation on GPUs](https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-37-toolkit-computation-gpus)
  - [Chapter 38. Fast Fluid Dynamics Simulation on the GPU](https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-38-fast-fluid-dynamics-simulation-gpu)
  - [Chapter 39. Volume Rendering Techniques](https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-39-volume-rendering-techniques)
  - [Chapter 40. Applying Real-Time Shading to 3D Ultrasound Visualization](https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-40-applying-real-time-shading-3d-ultrasound)
  - [Chapter 41. Real-Time Stereograms](https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-41-real-time-stereograms)
  - [Chapter 42. Deformers](https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-42-deformers)
- [Preface](https://developer.nvidia.com/gpugems/gpugems/preface)


GPU Gems 2 contents


- [Copyright](https://developer.nvidia.com/gpugems/gpugems2/copyright)
- [Inside Back Cover](https://developer.nvidia.com/gpugems/gpugems2/inside-back-cover)
- [Inside Front Cover](https://developer.nvidia.com/gpugems/gpugems2/inside-front-cover)
- [Part I: Geometric Complexity](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity)
    - [Chapter 1. Toward Photorealism in Virtual Botany](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-1-toward-photorealism-virtual-botany)
    - [Chapter 2. Terrain Rendering Using GPU-Based Geometry Clipmaps](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-2-terrain-rendering-using-gpu-based-geometry)
    - [Chapter 3. Inside Geometry Instancing](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-3-inside-geometry-instancing)
    - [Chapter 4. Segment Buffering](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-4-segment-buffering)
    - [Chapter 5. Optimizing Resource Management with Multistreaming](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-5-optimizing-resource-management-multistreaming)
    - [Chapter 6. Hardware Occlusion Queries Made Useful](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-6-hardware-occlusion-queries-made-useful)
    - [Chapter 7. Adaptive Tessellation of Subdivision Surfaces with Displacement Mapping](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-7-adaptive-tessellation-subdivision-surfaces)
    - [Chapter 8. Per-Pixel Displacement Mapping with Distance Functions](https://developer.nvidia.com/gpugems/gpugems2/part-i-geometric-complexity/chapter-8-pixel-displacement-mapping-distance-functions)
- [Part II: Shading, Lighting, and Shadows](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows)
    - [Chapter 9. Deferred Shading in S.T.A.L.K.E.R.](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker)
    - [Chapter 10. Real-Time Computation of Dynamic Irradiance Environment Maps](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-10-real-time-computation-dynamic)
    - [Chapter 11. Approximate Bidirectional Texture Functions](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-11-approximate-bidirectional-texture)
    - [Chapter 12. Tile-Based Texture Mapping](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-12-tile-based-texture-mapping)
    - [Chapter 13. Implementing the mental images Phenomena Renderer on the GPU](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-13-implementing-mental-images)
    - [Chapter 14. Dynamic Ambient Occlusion and Indirect Lighting](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-14-dynamic-ambient-occlusion-and)
    - [Chapter 15. Blueprint Rendering and "Sketchy Drawings"](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-15-blueprint-rendering-and-sketchy)
    - [Chapter 16. Accurate Atmospheric Scattering](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering)
    - [Chapter 17. Efficient Soft-Edged Shadows Using Pixel Shader Branching](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-17-efficient-soft-edged-shadows-using)
    - [Chapter 18. Using Vertex Texture Displacement for Realistic Water Rendering](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-18-using-vertex-texture-displacement)
    - [Chapter 19. Generic Refraction Simulation](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-19-generic-refraction-simulation)
- [Part III: High-Quality Rendering](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering)
    - [Chapter 20. Fast Third-Order Texture Filtering](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-20-fast-third-order-texture-filtering)
    - [Chapter 21. High-Quality Antialiased Rasterization](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-21-high-quality-antialiased-rasterization)
    - [Chapter 22. Fast Prefiltered Lines](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-22-fast-prefiltered-lines)
    - [Chapter 23. Hair Animation and Rendering in the Nalu Demo](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-23-hair-animation-and-rendering-nalu-demo)
    - [Chapter 24. Using Lookup Tables to Accelerate Color Transformations](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-24-using-lookup-tables-accelerate-color)
    - [Chapter 25. GPU Image Processing in Apple's Motion](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-25-gpu-image-processing-apples-motion)
    - [Chapter 26. Implementing Improved Perlin Noise](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-26-implementing-improved-perlin-noise)
    - [Chapter 27. Advanced High-Quality Filtering](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-27-advanced-high-quality-filtering)
    - [Chapter 28. Mipmap-Level Measurement](https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-28-mipmap-level-measurement)
- [Part IV: General-Purpose Computation on GPUS: A Primer](https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer)
    - [Chapter 29. Streaming Architectures and Technology Trends](https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-29-streaming-architectures)
    - [Chapter 30. The GeForce 6 Series GPU Architecture](https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-30-geforce-6-series-gpu)
    - [Chapter 31. Mapping Computational Concepts to GPUs](https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-31-mapping-computational)
    - [Chapter 32. Taking the Plunge into GPU Computing](https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-32-taking-plunge-gpu)
    - [Chapter 33. Implementing Efficient Parallel Data Structures on GPUs](https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-33-implementing-efficient)
    - [Chapter 34. GPU Flow-Control Idioms](https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-34-gpu-flow-control-idioms)
    - [Chapter 35. GPU Program Optimization](https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-35-gpu-program-optimization)
    - [Chapter 36. Stream Reduction Operations for GPGPU Applications](https://developer.nvidia.com/gpugems/gpugems2/part-iv-general-purpose-computation-gpus-primer/chapter-36-stream-reduction)
- [Part V: Image-Oriented Computing](https://developer.nvidia.com/gpugems/gpugems2/part-v-image-oriented-computing)
    - [Chapter 37. Octree Textures on the GPU](https://developer.nvidia.com/gpugems/gpugems2/part-v-image-oriented-computing/chapter-37-octree-textures-gpu)
    - [Chapter 38. High-Quality Global Illumination Rendering Using Rasterization](https://developer.nvidia.com/gpugems/gpugems2/part-v-image-oriented-computing/chapter-38-high-quality-global-illumination)
    - [Chapter 39. Global Illumination Using Progressive Refinement Radiosity](https://developer.nvidia.com/gpugems/gpugems2/part-v-image-oriented-computing/chapter-39-global-illumination-using-progressive)
    - [Chapter 40. Computer Vision on the GPU](https://developer.nvidia.com/gpugems/gpugems2/part-v-image-oriented-computing/chapter-40-computer-vision-gpu)
    - [Chapter 41. Deferred Filtering: Rendering from Difficult Data Formats](https://developer.nvidia.com/gpugems/gpugems2/part-v-image-oriented-computing/chapter-41-deferred-filtering-rendering-difficult)
    - [Chapter 42. Conservative Rasterization](https://developer.nvidia.com/gpugems/gpugems2/part-v-image-oriented-computing/chapter-42-conservative-rasterization)
- [Part VI: Simulation and Numerical Algorithms](https://developer.nvidia.com/gpugems/gpugems2/part-vi-simulation-and-numerical-algorithms)
    - [Chapter 43. GPU Computing for Protein Structure Prediction](https://developer.nvidia.com/gpugems/gpugems2/part-vi-simulation-and-numerical-algorithms/chapter-43-gpu-computing-protein)
    - [Chapter 44. A GPU Framework for Solving Systems of Linear Equations](https://developer.nvidia.com/gpugems/gpugems2/part-vi-simulation-and-numerical-algorithms/chapter-44-gpu-framework-solving)
    - [Chapter 45. Options Pricing on the GPU](https://developer.nvidia.com/gpugems/gpugems2/part-vi-simulation-and-numerical-algorithms/chapter-45-options-pricing-gpu)
    - [Chapter 46. Improved GPU Sorting](https://developer.nvidia.com/gpugems/gpugems2/part-vi-simulation-and-numerical-algorithms/chapter-46-improved-gpu-sorting)
    - [Chapter 47. Flow Simulation with Complex Boundaries](https://developer.nvidia.com/gpugems/gpugems2/part-vi-simulation-and-numerical-algorithms/chapter-47-flow-simulation-complex)
    - [Chapter 48. Medical Image Reconstruction with the FFT](https://developer.nvidia.com/gpugems/gpugems2/part-vi-simulation-and-numerical-algorithms/chapter-48-medical-image-reconstruction)



GPU Gems 3 contents

- [Contributors](https://developer.nvidia.com/gpugems/gpugems3/contributors)
- [Foreword](https://developer.nvidia.com/gpugems/gpugems3/foreword)
- [Part I: Geometry](https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry)
    - [Chapter 1. Generating Complex Procedural Terrains Using the GPU](https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-1-generating-complex-procedural-terrains-using-gpu)
    - [Chapter 2. Animated Crowd Rendering](https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-2-animated-crowd-rendering)
    - [Chapter 3. DirectX 10 Blend Shapes: Breaking the Limits](https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-3-directx-10-blend-shapes-breaking-limits)
    - [Chapter 4. Next-Generation SpeedTree Rendering](https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-4-next-generation-speedtree-rendering)
    - [Chapter 5. Generic Adaptive Mesh Refinement](https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-5-generic-adaptive-mesh-refinement)
    - [Chapter 6. GPU-Generated Procedural Wind Animations for Trees](https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-6-gpu-generated-procedural-wind-animations-trees)
    - [Chapter 7. Point-Based Visualization of Metaballs on a GPU](https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-7-point-based-visualization-metaballs-gpu)
- [Part II: Light and Shadows](https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows)
    - [Chapter 8. Summed-Area Variance Shadow Maps](https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-8-summed-area-variance-shadow-maps)
    - [Chapter 9. Interactive Cinematic Relighting with Global Illumination](https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-9-interactive-cinematic-relighting-global)
    - [Chapter 10. Parallel-Split Shadow Maps on Programmable GPUs](https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-10-parallel-split-shadow-maps-programmable-gpus)
    - [Chapter 11. Efficient and Robust Shadow Volumes Using Hierarchical Occlusion Culling and Geometry Shaders](https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-11-efficient-and-robust-shadow-volumes-using)
    - [Chapter 12. High-Quality Ambient Occlusion](https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-12-high-quality-ambient-occlusion)
    - [Chapter 13. Volumetric Light Scattering as a Post-Process](https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process)
- [Part III: Rendering](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering)
    - [Chapter 14. Advanced Techniques for Realistic Real-Time Skin Rendering](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin)
    - [Chapter 15. Playable Universal Capture](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-15-playable-universal-capture)
    - [Chapter 16. Vegetation Procedural Animation and Shading in Crysis](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-16-vegetation-procedural-animation-and-shading-crysis)
    - [Chapter 17. Robust Multiple Specular Reflections and Refractions](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-17-robust-multiple-specular-reflections-and-refractions)
    - [Chapter 18. Relaxed Cone Stepping for Relief Mapping](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-18-relaxed-cone-stepping-relief-mapping)
    - [Chapter 19. Deferred Shading in Tabula Rasa](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-19-deferred-shading-tabula-rasa)
    - [Chapter 20. GPU-Based Importance Sampling](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling)
- [Part IV: Image Effects](https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects)
    - [Chapter 21. True Impostors](https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-21-true-impostors)
    - [Chapter 22. Baking Normal Maps on the GPU](https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-22-baking-normal-maps-gpu)
    - [Chapter 23. High-Speed, Off-Screen Particles](https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-23-high-speed-screen-particles)
    - [Chapter 24. The Importance of Being Linear](https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear)
    - [Chapter 25. Rendering Vector Art on the GPU](https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-25-rendering-vector-art-gpu)
    - [Chapter 26. Object Detection by Color: Using the GPU for Real-Time Video Image Processing](https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-26-object-detection-color-using-gpu-real-time-video)
    - [Chapter 27. Motion Blur as a Post-Processing Effect](https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-27-motion-blur-post-processing-effect)
    - [Chapter 28. Practical Post-Process Depth of Field](https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-28-practical-post-process-depth-field)
- [Part V: Physics Simulation](https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation)
    - [Chapter 29. Real-Time Rigid Body Simulation on GPUs](https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-29-real-time-rigid-body-simulation-gpus)
    - [Chapter 30. Real-Time Simulation and Rendering of 3D Fluids](https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-30-real-time-simulation-and-rendering-3d-fluids)
    - [Chapter 31. Fast N-Body Simulation with CUDA](https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-31-fast-n-body-simulation-cuda)
    - [Chapter 32. Broad-Phase Collision Detection with CUDA](https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-32-broad-phase-collision-detection-cuda)
    - [Chapter 33. LCP Algorithms for Collision Detection Using CUDA](https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-33-lcp-algorithms-collision-detection-using-cuda)
    - [Chapter 34. Signed Distance Fields Using Single-Pass GPU Scan Conversion of Tetrahedra](https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-34-signed-distance-fields-using-single-pass-gpu)
    - [Chapter 35. Fast Virus Signature Matching on the GPU](https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-35-fast-virus-signature-matching-gpu)
- [Part VI: GPU Computing](https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing)
    - [Chapter 36. AES Encryption and Decryption on the GPU](https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-36-aes-encryption-and-decryption-gpu)
    - [Chapter 37. Efficient Random Number Generation and Application Using CUDA](https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-37-efficient-random-number-generation-and-application)
    - [Chapter 38. Imaging Earth's Subsurface Using CUDA](https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-38-imaging-earths-subsurface-using-cuda)
    - [Chapter 39. Parallel Prefix Sum (Scan) with CUDA](https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda)
    - [Chapter 40. Incremental Computation of the Gaussian](https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-40-incremental-computation-gaussian)
    - [Chapter 41. Using the Geometry Shader for Compact and Variable-Length GPU Feedback](https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-41-using-geometry-shader-compact-and-variable-length)
- [Preface](https://developer.nvidia.com/gpugems/gpugems3/preface)

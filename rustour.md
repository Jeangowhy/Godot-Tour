# Contents üîÜüîÖ

 üü°üü† Getting Started
 ‚ö° Installation
 ‚ö° Cargo Tool
 ‚ö° Windows Resource(ICO) 
 ‚ö° mdBook ÁîµÂ≠ê‰π¶Ê°ÜÊû∂
 ‚ö° Packages Crates Modules
 ‚ö° HelloWorldüîÜüîÖ
 ‚ö° Printing ÊâìÂç∞‰ø°ÊÅØ
 ‚ö° Guessing Game
 ‚ö° Basic Concepts & Data Types
 üü¢üîµ Comments & Doc
 üü¢üîµ Variables and Mutability ÂèòÈáè‰∏éÂèØÂèòÊÄß
 üü¢üîµ Data Types Âü∫Êú¨Êï∞ÊçÆÁ±ªÂûã
 üü¢üîµ Type Conversions Á±ªÂûãËΩ¨Êç¢
 üü¢üîµ Control Flow ÊµÅÁ®ãÊéßÂà∂
 ‚ö° Features ÁâπËâ≤Ê¶ÇÂøµ
 üü¢üîµ Zero-cost Abstraction Èõ∂ÊàêÊú¨ÊäΩË±°
 üü¢üîµ Ownership ÊâÄÊúâÊùÉ
 üü¢üîµ Borrowing ÂÄüÁî®ÊâÄÊúâÊùÉ
 üü¢üîµ Slices ÂàáÁâáÁ±ªÂûã‰∏éÊâÄÊúâÊùÉ
 ‚ö° Lifetime ÁîüÂëΩÂë®Êúü
 üü¢üîµ Function & Lifetimes
 üü¢üîµ Temporary & Lifetimes elision
 üü¢üîµ Lifetime Bound Syntax
 üü¢üîµ Static ÈùôÊÄÅÁîüÂëΩÂë®Êúü
 üü¢üîµ Struct ‰∏éÁîüÂëΩÂë®Êúü
 üü¢üîµ Trait ‰∏éÁîüÂëΩÂë®Êúü
 ‚ö° Functional OOP ÂáΩÊï∞ÂºèÈù¢ÂêëÂØπË±°ÁºñÁ®ã
 üü¢üîµ Functions ÂáΩÊï∞
 üü¢üîµ FOOP ÂáΩÊï∞ÂºèÈù¢ÂêëÂØπË±°ÁºñÁ®ã
 üü¢üîµ Traits & Polymorphism
 üü¢üîµ Dynamic vs Static Dispatch
 üü¢üîµ Blog Demo
 üü¢üîµ Traits ÁâπË¥®Êâ©Â±ï
 üü¢üîµ Drop & Copy Trait
 üü¢üîµ Operator Overloading
 üü¢üîµ Iterator Ëø≠‰ª£Âô®
 üü¢üîµ Generic Types
 ‚ö° Patterns & Match Ê®°ÂºèÂåπÈÖç
 ‚ö° Enums Êûö‰∏æÁ±ªÂûã
 ‚ö° Structures ÁªìÊûÑ‰Ωì
 ‚ö° Union ËÅîÂêà‰Ωì
 ‚ö° Error Handling ÈîôËØØÂ§ÑÁêÜ
 üü¢üîµ Panics Option Result
 üü¢üîµ Unpacking & Propagating Errors with ?
 üü¢üîµ Panic Hook
 üü¢üîµ Error Message
 ‚ö° Collections ÈõÜÂêà
 üü¢üîµ Vec ÂêëÈáèÂàóË°®
 üü¢üîµ String Â≠óÁ¨¶‰∏≤ÂàóË°®
 üü¢üîµ VecDeque
 üü¢üîµ LinkedList
 üü¢üîµ HashMap
 üü¢üîµ BTreeMap
 üü¢üîµ HashSet BTreeSet
 üü¢üîµ BinaryHeap
 ‚ö° Smart Pointers
 ‚ö° Box - heap allocation
 ‚ö° owning_ref Âç†Áî®ÂºïÁî®
 ‚ö° I/O & Command Line
 üü¢üîµ CLI Arguments
 üü¢üîµ Shell ÂëΩ‰ª§ÊâßË°å
 üü¢üîµ CLAP ÂëΩ‰ª§Ë°åÂèÇÊï∞Ëß£ÊûêÂô®
 üü¢üîµ Files Êñá‰ª∂ËØªÂÜô
 üü°üü† Memory Layout ÂÜÖÂ≠òÊ®°Âûã
 üü°üü† Advanced Features
 ‚ö° Unsafe Rust 
 ‚ö° FFI - Foreign Function Interface
 ‚ö° Type Layout
 ‚ö° Advanced traits
 ‚ö° Advanced types
 ‚ö° Closures Èó≠ÂåÖ
 üü¢üîµ Closures Lifetime
 üü¢üîµ Closures Type Anonymity
 ‚ö° Macros ÂÆè
 üü°üü† Reflection
 üü°üü† Test Ëá™Âä®ÊµãËØï
 üü°üü† Asynchronous ÂºÇÊ≠•ÁºñÁ®ã
 üü°üü† Fearless Concurrency
 ‚ö° Âü∫Êú¨Â§öÁ∫øÁ®ãÁ®ãÂ∫è
 ‚ö° Synchronization ÂêåÊ≠•ÂØπË±°
 ‚ö° Message Passing Ê∂àÊÅØ‰º†ÈÄí
 ‚ö° Shared State ÂÖ±‰∫´Áä∂ÊÄÅ 
 ‚ö° Send & Sync traits
 üü°üü† Multithreaded Web Server
 ‚ö° Thread Pool Á∫øÁ®ãÊ±†ÂÆûÁé∞
 üü°üü† Game
 üü°üü† OpenCV in Rust
 üü°üü† Compilers Principles
 üü°üü† Structure and Interpretation of Computer Programs, SICP
 üü°üü† rustc-serialize
 üü°üü† webview_sys
 üü°üü† Ruffle SWF Player
 üü°üü† Rust Reference
 ‚ö° Primitive Types
 ‚ö° Modules
 ‚ö° Macros
 ‚ö° Keywords
 ‚ö° Operators and Symbols
 ‚ö° Struct TypeId & Trait Any
 ‚ö° Struct Cell
 ‚ö° Struct Vec
 ‚ö° Trait Iterator
 ‚ö° std::fs
 ‚ö° Range Expressions



Â¶ÇÊûúË¶ÅÊü•ÁúãÊú¨Ë∫´ HTML ÊñáÊ°£Ôºå‰ΩøÁî® rustup docs ÂëΩ‰ª§ÊâìÂºÄÁõ∏Â∫îÁöÑÊñáÊ°£È°µÈù¢Ôºö

```sh
    > rustup docs --help
    rustup.exe-doc
    Open the documentation for the current toolchain

    USAGE:
        rustup.exe doc [FLAGS] [OPTIONS] [topic]

    FLAGS:
            --alloc              The Rust core allocation and collections library
            --book               The Rust Programming Language book
            --cargo              The Cargo Book
            --core               The Rust Core Library
            --edition-guide      The Rust Edition Guide
            --embedded-book      The Embedded Rust Book
        -h, --help               Prints help information
            --nomicon            The Dark Arts of Advanced and Unsafe Rust Programming
            --path               Only print the path to the documentation
            --proc_macro         A support library for macro authors when defining new macros
            --reference          The Rust Reference
            --rust-by-example    A collection of runnable examples that illustrate various Rust concepts and standard
                                 libraries
            --rustc              The compiler for the Rust programming language
            --rustdoc            Generate documentation for Rust projects
            --std                Standard library API documentation
            --test               Support code for rustc's built in unit-test and micro-benchmarking framework
            --unstable-book      The Unstable Book 
```

‰∏∫‰∫ÜÊñπ‰æøÂú®ÊñáÊ°£‰πãÈó¥Âø´ÈÄüË∑≥ËΩ¨ÔºåÊé®ËçêÂú® Sublime Text ÁéØÂ¢É‰∏ãÈòÖËØªÊñáÊ°£ÔºåÂè™ÈúÄË¶ÅÂÆâË£Ö run-snippet Êèí‰ª∂Ôºå
‰ΩøÁî® F9 Âø´Êç∑ÈîÆË∑≥ËΩ¨Âà∞ÂÖâÊ†á‰∏ãÁöÑÊñá‰ª∂ÊàñÈìæÊé•„ÄÇ

Âø´ÈÄüÂÆâË£Ö RunSnippet Êèí‰ª∂Ôºö

- Ctrl+Shift+P ÊâìÂºÄ Sublime Text ÂëΩ‰ª§Ë∞ÉÊùøÔºõ
- ÊâßË°å Add Repository Ê∑ªÂä†Êú¨Êèí‰ª∂‰ª£Á†Å‰ªìÂ∫ìÂú∞ÂùÄ: https://github.com/jimboyeah/run-snippet
- ÁÑ∂ÂêéÊâßË°å Install Package Âπ∂ËæìÂÖ• RunSnippt ËøõË°åÁ°ÆËÆ§ÂÆâË£ÖÔºõ

ÊâãÂä®Ê∑ªÂä† RepositoryÔºåÊâßË°åËèúÂçïÔºö Perferences ü°í Package Settings ü°í Package Control ü°í Settings

    "repositories":
    [
        "https://github.com/jimboyeah/run-snippet",
    ],

ÂèØ‰ª•Âú® Packages ÁõÆÂΩïÊâßË°å‰ª•‰∏ãÂëΩ‰ª§ÂÆâË£Ö RunSnippet Êèí‰ª∂Ôºö

    git clone git@github.com/jimboyeah/run-snippet.git

Ê∑ªÂä†ÈÖçÁΩÆÊñá‰ª∂ÔºåÈªòËÆ§ÂêØÁî®ÂàÜÁªÑË∑≥ËΩ¨ÔºåÂ¶ÇÊûú Sublime Text Ê≤°ÊúâËÆæÁΩÆÂàÜÁªÑÔºåÂàôÂú®ÂΩìÂâç View ÂºπÂá∫Êñá‰ª∂Ë∑≥ËΩ¨Á™óÂè£Ôºå
ËøôÁßçË°å‰∏∫ÊúâÁÇπÊâìÊñ≠ÊÄùË∑Ø„ÄÇÊõ¥ÂêàÁêÜÁöÑÂÅöÊ≥ïÊòØ GUI ËÆæÁΩÆ 2 ‰∏™ GroupÔºåÂπ∂‰∏îÂú®Âè¶‰∏Ä‰∏™ Group ÂºπÂá∫Êñá‰ª∂ Panel„ÄÇ
Load settings from /Packages/Users/RunSnippet.sublime-settings

```json
    {
        "jump_between_group": true,
    }
```

Êú¨ÊñáÊ°£ÂÜÖÂÆπ‰∏ªË¶ÅÂèÇËÄÉ‰ª•‰∏ãÂÆòÊñπËµÑÊ∫êÂ±ïÂºÄÔºåÂÆâË£Ö Rust ÂêéÔºåÁõ¥Êé•ÂèØ‰ª•‰ΩøÁî® rustup doc ÂëΩ‰ª§ÊâìÂºÄÊú¨Âú∞ÊñáÊ°£Ôºö

- The Rust Programming Language
- Asynchronous Programming in Rust
- Rust By Example
- The Rust Reference
- The Reference
- The Rustonomicon
- The Unstable Book
- The rustc Contribution Guide
- The Edition Guide
- The Rustc Book
- The Cargo Book
- The Rustdoc Book
- The Embedded Rust Book
- Guide to Rustc Development
- The Rust RFC Book

Rust ÂÆòÊñπÊñáÊ°£ÂåÖÂê´Âú®Ê†áÂáÜÂ∫ìÊ∫ê‰ª£Á†Å‰ªìÂ∫ì‰∏≠ÔºåÂπ∂‰Ωú‰∏∫Â≠êÊ®°ÂùóÂºïÁî®ÔºåÂèØ‰ª•ÂçïÁã¨ÂÖãÈöÜ‰∏ãËΩΩÔºö

```sh
    git clone --depth=1 git@github.com:rust-lang/rust
    git submodule update --init --depth=1 --recursive

    git clone --depth=1 git@github.com:rust-lang/nomicon         src/doc/nomicon
    git clone --depth=1 git@github.com:rust-lang/reference       src/doc/reference
    git clone --depth=1 git@github.com:rust-lang/book            src/doc/book
    git clone --depth=1 git@github.com:rust-lang/rust-by-example src/doc/rust-by-example
    git clone --depth=1 git@github.com:rust-lang/rustc-dev-guide src/doc/rustc-dev-guide
    git clone --depth=1 git@github.com:rust-lang/edition-guide   src/doc/edition-guide
    git clone --depth=1 git@github.com:rust-embedded/book        src/doc/embedded-book

    git clone --depth=1 git@github.com:rust-lang/rfcs            src/doc/rfcs
    git clone --depth=1 git@github.com:rust-lang/cargo           src/tools/cargo
    git clone --depth=1 git@github.com:rust-lang/async-book      src/doc/async-book
    git clone --depth=1 git@github.com:rustwasm/wasm-bindgen     src/doc/wasm-bindgen
    git clone --depth=1 git@github.com:bytecodealliance/wasmtime src/doc/wasmtime

    # The Little Book of Rust Macros
    git clone --depth=1 git@github.com:DanielKeep/tlborm         src/doc/macros_little
    git clone --depth=1 git@github.com:veykril/tlborm            src/doc/macros_little2

```

## üü¢üîµThe Rust Programming Language

[Foreword](book/src/foreword.md)
[Introduction](ch00-00-introduction.md)

## Getting started

- [Getting Started](ch01-00-getting-started.md)
    - [Installation](ch01-01-installation.md)
    - [Hello, World!](ch01-02-hello-world.md)
    - [Hello, Cargo!](ch01-03-hello-cargo.md)

- [Programming a Guessing Game](ch02-00-guessing-game-tutorial.md)

- [Common Programming Concepts](ch03-00-common-programming-concepts.md)
    - [Variables and Mutability](ch03-01-variables-and-mutability.md)
    - [Data Types](ch03-02-data-types.md)
    - [How Functions Work](ch03-03-how-functions-work.md)
    - [Comments](ch03-04-comments.md)
    - [Control Flow](ch03-05-control-flow.md)

- [Understanding Ownership](ch04-00-understanding-ownership.md)
    - [What is Ownership?](ch04-01-what-is-ownership.md)
    - [References & Borrowing](ch04-02-references-and-borrowing.md)
    - [Slices](ch04-03-slices.md)

- [Using Structs to Structure Related Data](ch05-00-structs.md)
    - [Defining and Instantiating Structs](ch05-01-defining-structs.md)
    - [An Example Program Using Structs](ch05-02-example-structs.md)
    - [Method Syntax](ch05-03-method-syntax.md)

- [Enums and Pattern Matching](ch06-00-enums.md)
    - [Defining an Enum](ch06-01-defining-an-enum.md)
    - [The `match` Control Flow Operator](ch06-02-match.md)
    - [Concise Control Flow with `if let`](ch06-03-if-let.md)

## Basic Rust Literacy

- [Packages, Crates, and Modules](ch07-00-packages-crates-and-modules.md)
    - [Packages and crates for making libraries and executables](ch07-01-packages-and-crates-for-making-libraries-and-executables.md)
    - [Modules and `use` to control scope and privacy](ch07-02-modules-and-use-to-control-scope-and-privacy.md)

- [Common Collections](ch08-00-common-collections.md)
    - [Vectors](ch08-01-vectors.md)
    - [Strings](ch08-02-strings.md)
    - [Hash Maps](ch08-03-hash-maps.md)

- [Error Handling](ch09-00-error-handling.md)
    - [Unrecoverable Errors with `panic!`](ch09-01-unrecoverable-errors-with-panic.md)
    - [Recoverable Errors with `Result`](ch09-02-recoverable-errors-with-result.md)
    - [To `panic!` or Not to `panic!`](ch09-03-to-panic-or-not-to-panic.md)

- [Generic Types, Traits, and Lifetimes](ch10-00-generics.md)
    - [Generic Data Types](ch10-01-syntax.md)
    - [Traits: Defining Shared Behavior](ch10-02-traits.md)
    - [Validating References with Lifetimes](ch10-03-lifetime-syntax.md)

- [Testing](ch11-00-testing.md)
    - [Writing tests](ch11-01-writing-tests.md)
    - [Running tests](ch11-02-running-tests.md)
    - [Test Organization](ch11-03-test-organization.md)

- [An I/O Project: Building a Command Line Program](ch12-00-an-io-project.md)
    - [Accepting Command Line Arguments](ch12-01-accepting-command-line-arguments.md)
    - [Reading a File](ch12-02-reading-a-file.md)
    - [Refactoring to Improve Modularity and Error Handling](ch12-03-improving-error-handling-and-modularity.md)
    - [Developing the Library‚Äôs Functionality with Test Driven Development](ch12-04-testing-the-librarys-functionality.md)
    - [Working with Environment Variables](ch12-05-working-with-environment-variables.md)
    - [Writing Error Messages to Standard Error Instead of Standard Output](ch12-06-writing-to-stderr-instead-of-stdout.md)

## Thinking in Rust

- [Functional Language Features: Iterators and Closures](ch13-00-functional-features.md)
    - [Closures: Anonymous Functions that Can Capture Their Environment](ch13-01-closures.md)
    - [Processing a Series of Items with Iterators](ch13-02-iterators.md)
    - [Improving Our I/O Project](ch13-03-improving-our-io-project.md)
    - [Comparing Performance: Loops vs. Iterators](ch13-04-performance.md)

- [More about Cargo and Crates.io](ch14-00-more-about-cargo.md)
    - [Customizing Builds with Release Profiles](ch14-01-release-profiles.md)
    - [Publishing a Crate to Crates.io](ch14-02-publishing-to-crates-io.md)
    - [Cargo Workspaces](ch14-03-cargo-workspaces.md)
    - [Installing Binaries from Crates.io with `cargo install`](ch14-04-installing-binaries.md)
    - [Extending Cargo with Custom Commands](ch14-05-extending-cargo.md)

- [Smart Pointers](ch15-00-smart-pointers.md)
    - [`Box<T>` Points to Data on the Heap and Has a Known Size](ch15-01-box.md)
    - [The `Deref` Trait Allows Access to the Data Through a Reference](ch15-02-deref.md)
    - [The `Drop` Trait Runs Code on Cleanup](ch15-03-drop.md)
    - [`Rc<T>`, the Reference Counted Smart Pointer](ch15-04-rc.md)
    - [`RefCell<T>` and the Interior Mutability Pattern](ch15-05-interior-mutability.md)
    - [Creating Reference Cycles and Leaking Memory is Safe](ch15-06-reference-cycles.md)

- [Fearless Concurrency](ch16-00-concurrency.md)
    - [Threads](ch16-01-threads.md)
    - [Message Passing](ch16-02-message-passing.md)
    - [Shared State](ch16-03-shared-state.md)
    - [Extensible Concurrency: `Sync` and `Send`](ch16-04-extensible-concurrency-sync-and-send.md)

- [Object Oriented Programming Features of Rust](ch17-00-oop.md)
    - [Characteristics of Object-Oriented Languages](ch17-01-what-is-oo.md)
    - [Using Trait Objects that Allow for Values of Different Types](ch17-02-trait-objects.md)
    - [Implementing an Object-Oriented Design Pattern](ch17-03-oo-design-patterns.md)

## Advanced Topics

- [Patterns Match the Structure of Values](ch18-00-patterns.md)
    - [All the Places Patterns May be Used](ch18-01-all-the-places-for-patterns.md)
    - [Refutability: Whether a Pattern Might Fail to Match](ch18-02-refutability.md)
    - [All the Pattern Syntax](ch18-03-pattern-syntax.md)

- [Advanced Features](ch19-00-advanced-features.md)
    - [Unsafe Rust](ch19-01-unsafe-rust.md)
    - [Advanced Lifetimes](ch19-02-advanced-lifetimes.md)
    - [Advanced Traits](ch19-03-advanced-traits.md)
    - [Advanced Types](ch19-04-advanced-types.md)
    - [Advanced Functions & Closures](ch19-05-advanced-functions-and-closures.md)
    - [Macros](ch19-06-macros.md)

- [Final Project: Building a Multithreaded Web Server](ch20-00-final-project-a-web-server.md)
    - [A Single Threaded Web Server](ch20-01-single-threaded.md)
    - [Turning our Single Threaded Server into a Multithreaded Server](ch20-02-multithreaded.md)
    - [Graceful Shutdown and Cleanup](ch20-03-graceful-shutdown-and-cleanup.md)

- [Appendix](appendix-00.md)
    - [A - Keywords](appendix-01-keywords.md)
    - [B - Operators and Symbols](appendix-02-operators.md)
    - [C - Derivable Traits](appendix-03-derivable-traits.md)
    - [D - Useful Development Tools](appendix-04-useful-development-tools.md)
    - [E - Editions](appendix-05-editions.md)
    - [F - Translations](appendix-06-translation.md)
    - [G - How Rust is Made and ‚ÄúNightly Rust‚Äù](appendix-07-nightly-rust.md)


## üü¢üîµThe Rustdoc Book

- [What is rustdoc?](rustdoc/src/what-is-rustdoc.md)
- [How to write documentation](rustdoc/src/how-to-write-documentation.md)
- [What to include (and exclude)](rustdoc/src/what-to-include.md)
- [Command-line arguments](rustdoc/src/command-line-arguments.md)
- [The `#[doc]` attribute](rustdoc/src/the-doc-attribute.md)
- [Documentation tests](rustdoc/src/documentation-tests.md)
- [Linking to items by name](rustdoc/src/linking-to-items-by-name.md)
- [Lints](rustdoc/src/lints.md)
- [Passes](rustdoc/src/passes.md)
- [Advanced features](rustdoc/src/advanced-features.md)
- [Unstable features](rustdoc/src/unstable-features.md)
- [References](rustdoc/src/references.md)


## üü¢üîµRust By Example

[Introduction](rust-by-example/src/index.md)

- [Hello World](rust-by-example/src/hello.md)
    - [Comments](rust-by-example/src/hello/comment.md)
    - [Formatted print](rust-by-example/src/hello/print.md)
        - [Debug](rust-by-example/src/hello/print/print_debug.md)
        - [Display](rust-by-example/src/hello/print/print_display.md)
            - [Testcase: List](rust-by-example/src/hello/print/print_display/testcase_list.md)
        - [Formatting](rust-by-example/src/hello/print/fmt.md)

- [Primitives](rust-by-example/src/primitives.md)
    - [Literals and operators](rust-by-example/src/primitives/literals.md)
    - [Tuples](rust-by-example/src/primitives/tuples.md)
    - [Arrays and Slices](rust-by-example/src/primitives/array.md)

- [Custom Types](rust-by-example/src/custom_types.md)
    - [Structures](rust-by-example/src/custom_types/structs.md)
    - [Enums](rust-by-example/src/custom_types/enum.md)
        - [use](rust-by-example/src/custom_types/enum/enum_use.md)
        - [C-like](rust-by-example/src/custom_types/enum/c_like.md)
        - [Testcase: linked-list](rust-by-example/src/custom_types/enum/testcase_linked_list.md)
    - [constants](rust-by-example/src/custom_types/constants.md)

- [Variable Bindings](rust-by-example/src/variable_bindings.md)
    - [Mutability](rust-by-example/src/variable_bindings/mut.md)
    - [Scope and Shadowing](rust-by-example/src/variable_bindings/scope.md)
    - [Declare first](rust-by-example/src/variable_bindings/declare.md)
    - [Freezing](rust-by-example/src/variable_bindings/freeze.md)

- [Types](rust-by-example/src/types.md)
    - [Casting](rust-by-example/src/types/cast.md)
    - [Literals](rust-by-example/src/types/literals.md)
    - [Inference](rust-by-example/src/types/inference.md)
    - [Aliasing](rust-by-example/src/types/alias.md)

- [Conversion](rust-by-example/src/conversion.md)
    - [`From` and `Into`](rust-by-example/src/conversion/from_into.md)
    - [`TryFrom` and `TryInto`](rust-by-example/src/conversion/try_from_try_into.md)
    - [To and from `String`s](rust-by-example/src/conversion/string.md)

- [Expressions](rust-by-example/src/expression.md)

- [Flow of Control](rust-by-example/src/flow_control.md)
    - [if/else](rust-by-example/src/flow_control/if_else.md)
    - [loop](rust-by-example/src/flow_control/loop.md)
        - [Nesting and labels](rust-by-example/src/flow_control/loop/nested.md)
        - [Returning from loops](rust-by-example/src/flow_control/loop/return.md)
    - [while](rust-by-example/src/flow_control/while.md)
    - [for and range](rust-by-example/src/flow_control/for.md)
    - [match](rust-by-example/src/flow_control/match.md)
        - [Destructuring](rust-by-example/src/flow_control/match/destructuring.md)
            - [tuples](rust-by-example/src/flow_control/match/destructuring/destructure_tuple.md)
            - [arrays/slices](rust-by-example/src/flow_control/match/destructuring/destructure_slice.md)
            - [enums](rust-by-example/src/flow_control/match/destructuring/destructure_enum.md)
            - [pointers/ref](rust-by-example/src/flow_control/match/destructuring/destructure_pointers.md)
            - [structs](rust-by-example/src/flow_control/match/destructuring/destructure_structures.md)
        - [Guards](rust-by-example/src/flow_control/match/guard.md)
        - [Binding](rust-by-example/src/flow_control/match/binding.md)
    - [if let](rust-by-example/src/flow_control/if_let.md)
    - [let-else](rust-by-example/src/flow_control/let_else.md)
    - [while let](rust-by-example/src/flow_control/while_let.md)

- [Functions](rust-by-example/src/fn.md)
    - [Methods](rust-by-example/src/fn/methods.md)
    - [Closures](rust-by-example/src/fn/closures.md)
        - [Capturing](rust-by-example/src/fn/closures/capture.md)
        - [As input parameters](rust-by-example/src/fn/closures/input_parameters.md)
        - [Type anonymity](rust-by-example/src/fn/closures/anonymity.md)
        - [Input functions](rust-by-example/src/fn/closures/input_functions.md)
        - [As output parameters](rust-by-example/src/fn/closures/output_parameters.md)
        - [Examples in `std`](rust-by-example/src/fn/closures/closure_examples.md)
            - [Iterator::any](rust-by-example/src/fn/closures/closure_examples/iter_any.md)
            - [Searching through iterators](rust-by-example/src/fn/closures/closure_examples/iter_find.md)
    - [Higher Order Functions](rust-by-example/src/fn/hof.md)
    - [Diverging functions](rust-by-example/src/fn/diverging.md)

- [Modules](rust-by-example/src/mod.md)
    - [Visibility](rust-by-example/src/mod/visibility.md)
    - [Struct visibility](rust-by-example/src/mod/struct_visibility.md)
    - [The `use` declaration](rust-by-example/src/mod/use.md)
    - [`super` and `self`](rust-by-example/src/mod/super.md)
    - [File hierarchy](rust-by-example/src/mod/split.md)

- [Crates](rust-by-example/src/crates.md)
    - [Creating a Library](rust-by-example/src/crates/lib.md)
    - [Using a Library](rust-by-example/src/crates/using_lib.md)

- [Cargo](rust-by-example/src/cargo.md)
    - [Dependencies](rust-by-example/src/cargo/deps.md)
    - [Conventions](rust-by-example/src/cargo/conventions.md)
    - [Tests](rust-by-example/src/cargo/test.md)
    - [Build Scripts](rust-by-example/src/cargo/build_scripts.md)

- [Attributes](rust-by-example/src/attribute.md)
    - [`dead_code`](rust-by-example/src/attribute/unused.md)
    - [Crates](rust-by-example/src/attribute/crate.md)
    - [`cfg`](rust-by-example/src/attribute/cfg.md)
        - [Custom](rust-by-example/src/attribute/cfg/custom.md)

- [Generics](rust-by-example/src/generics.md)
    - [Functions](rust-by-example/src/generics/gen_fn.md)
    - [Implementation](rust-by-example/src/generics/impl.md)
    - [Traits](rust-by-example/src/generics/gen_trait.md)
    - [Bounds](rust-by-example/src/generics/bounds.md)
        - [Testcase: empty bounds](rust-by-example/src/generics/bounds/testcase_empty.md)
    - [Multiple bounds](rust-by-example/src/generics/multi_bounds.md)
    - [Where clauses](rust-by-example/src/generics/where.md)
    - [New Type Idiom](rust-by-example/src/generics/new_types.md)
    - [Associated items](rust-by-example/src/generics/assoc_items.md)
        - [The Problem](rust-by-example/src/generics/assoc_items/the_problem.md)
        - [Associated types](rust-by-example/src/generics/assoc_items/types.md)
    - [Phantom type parameters](rust-by-example/src/generics/phantom.md)
        - [Testcase: unit clarification](rust-by-example/src/generics/phantom/testcase_units.md)

- [Scoping rules](rust-by-example/src/scope.md)
    - [RAII](rust-by-example/src/scope/raii.md)
    - [Ownership and moves](rust-by-example/src/scope/move.md)
        - [Mutability](rust-by-example/src/scope/move/mut.md)
        - [Partial moves](rust-by-example/src/scope/move/partial_move.md)
    - [Borrowing](rust-by-example/src/scope/borrow.md)
        - [Mutability](rust-by-example/src/scope/borrow/mut.md)
        - [Aliasing](rust-by-example/src/scope/borrow/alias.md)
        - [The ref pattern](rust-by-example/src/scope/borrow/ref.md)
    - [Lifetimes](rust-by-example/src/scope/lifetime.md)
        - [Explicit annotation](rust-by-example/src/scope/lifetime/explicit.md)
        - [Functions](rust-by-example/src/scope/lifetime/fn.md)
        - [Methods](rust-by-example/src/scope/lifetime/methods.md)
        - [Structs](rust-by-example/src/scope/lifetime/struct.md)
        - [Traits](rust-by-example/src/scope/lifetime/trait.md)
        - [Bounds](rust-by-example/src/scope/lifetime/lifetime_bounds.md)
        - [Coercion](rust-by-example/src/scope/lifetime/lifetime_coercion.md)
        - [Static](rust-by-example/src/scope/lifetime/static_lifetime.md)
        - [Elision](rust-by-example/src/scope/lifetime/elision.md)

- [Traits](rust-by-example/src/trait.md)
    - [Derive](rust-by-example/src/trait/derive.md)
    - [Returning Traits with `dyn`](rust-by-example/src/trait/dyn.md)
    - [Operator Overloading](rust-by-example/src/trait/ops.md)
    - [Drop](rust-by-example/src/trait/drop.md)
    - [Iterators](rust-by-example/src/trait/iter.md)
    - [`impl Trait`](rust-by-example/src/trait/impl_trait.md)
    - [Clone](rust-by-example/src/trait/clone.md)
    - [Supertraits](rust-by-example/src/trait/supertraits.md)
    - [Disambiguating overlapping traits](rust-by-example/src/trait/disambiguating.md)

- [macro_rules!](rust-by-example/src/macros.md)
    - [Syntax](rust-by-example/src/macros/syntax.md)
        - [Designators](rust-by-example/src/macros/designators.md)
        - [Overload](rust-by-example/src/macros/overload.md)
        - [Repeat](rust-by-example/src/macros/repeat.md)
    - [DRY (Don't Repeat Yourself)](rust-by-example/src/macros/dry.md)
    - [DSL (Domain Specific Languages)](rust-by-example/src/macros/dsl.md)
    - [Variadics](rust-by-example/src/macros/variadics.md)

- [Error handling](rust-by-example/src/error.md)
    - [`panic`](rust-by-example/src/error/panic.md)
    - [`abort` & `unwind`](rust-by-example/src/error/abort_unwind.md)
    - [`Option` & `unwrap`](rust-by-example/src/error/option_unwrap.md)
        - [Unpacking options with `?`](rust-by-example/src/error/option_unwrap/question_mark.md)
        - [Combinators: `map`](rust-by-example/src/error/option_unwrap/map.md)
        - [Combinators: `and_then`](rust-by-example/src/error/option_unwrap/and_then.md)
        - [Defaults: `or`, `or_else`, `get_or_insert`, `get_or_insert_with`](rust-by-example/src/error/option_unwrap/defaults.md)
    - [`Result`](rust-by-example/src/error/result.md)
        - [`map` for `Result`](rust-by-example/src/error/result/result_map.md)
        - [aliases for `Result`](rust-by-example/src/error/result/result_alias.md)
        - [Early returns](rust-by-example/src/error/result/early_returns.md)
        - [Introducing `?`](rust-by-example/src/error/result/enter_question_mark.md)
    - [Multiple error types](rust-by-example/src/error/multiple_error_types.md)
        - [Pulling `Result`s out of `Option`s](rust-by-example/src/error/multiple_error_types/option_result.md)
        - [Defining an error type](rust-by-example/src/error/multiple_error_types/define_error_type.md)
        - [`Box`ing errors](rust-by-example/src/error/multiple_error_types/boxing_errors.md)
        - [Other uses of `?`](rust-by-example/src/error/multiple_error_types/reenter_question_mark.md)
        - [Wrapping errors](rust-by-example/src/error/multiple_error_types/wrap_error.md)
    - [Iterating over `Result`s](rust-by-example/src/error/iter_result.md)

- [Std library types](rust-by-example/src/std.md)
    - [Box, stack and heap](rust-by-example/src/std/box.md)
    - [Vectors](rust-by-example/src/std/vec.md)
    - [Strings](rust-by-example/src/std/str.md)
    - [`Option`](rust-by-example/src/std/option.md)
    - [`Result`](rust-by-example/src/std/result.md)
        - [`?`](rust-by-example/src/std/result/question_mark.md)
    - [`panic!`](rust-by-example/src/std/panic.md)
    - [HashMap](rust-by-example/src/std/hash.md)
        - [Alternate/custom key types](rust-by-example/src/std/hash/alt_key_types.md)
        - [HashSet](rust-by-example/src/std/hash/hashset.md)
    - [`Rc`](rust-by-example/src/std/rc.md)
    - [`Arc`](rust-by-example/src/std/arc.md)

- [Std misc](rust-by-example/src/std_misc.md)
    - [Threads](rust-by-example/src/std_misc/threads.md)
        - [Testcase: map-reduce](rust-by-example/src/std_misc/threads/testcase_mapreduce.md)
    - [Channels](rust-by-example/src/std_misc/channels.md)
    - [Path](rust-by-example/src/std_misc/path.md)
    - [File I/O](rust-by-example/src/std_misc/file.md)
        - [`open`](rust-by-example/src/std_misc/file/open.md)
        - [`create`](rust-by-example/src/std_misc/file/create.md)
        - [`read lines`](rust-by-example/src/std_misc/file/read_lines.md)
    - [Child processes](rust-by-example/src/std_misc/process.md)
        - [Pipes](rust-by-example/src/std_misc/process/pipe.md)
        - [Wait](rust-by-example/src/std_misc/process/wait.md)
    - [Filesystem Operations](rust-by-example/src/std_misc/fs.md)
    - [Program arguments](rust-by-example/src/std_misc/arg.md)
        - [Argument parsing](rust-by-example/src/std_misc/arg/matching.md)
    - [Foreign Function Interface](rust-by-example/src/std_misc/ffi.md)

- [Testing](rust-by-example/src/testing.md)
    - [Unit testing](rust-by-example/src/testing/unit_testing.md)
    - [Documentation testing](rust-by-example/src/testing/doc_testing.md)
    - [Integration testing](rust-by-example/src/testing/integration_testing.md)
    - [Dev-dependencies](rust-by-example/src/testing/dev_dependencies.md)

- [Unsafe Operations](rust-by-example/src/unsafe.md)
    - [Inline assembly](rust-by-example/src/unsafe/asm.md)

- [Compatibility](rust-by-example/src/compatibility.md)
    - [Raw identifiers](rust-by-example/src/compatibility/raw_identifiers.md)

- [Meta](rust-by-example/src/meta.md)
    - [Documentation](rust-by-example/src/meta/doc.md)
    - [Playground](rust-by-example/src/meta/playground.md)


## üü¢üîµAsynchronous Programming in Rust

- [Getting Started](async-book/src/01_getting_started/01_chapter.md)
  - [Why Async?](async-book/src/01_getting_started/02_why_async.md)
  - [The State of Asynchronous Rust](async-book/src/01_getting_started/03_state_of_async_rust.md)
  - [`async`/`.await` Primer](async-book/src/01_getting_started/04_async_await_primer.md)
- [Under the Hood: Executing `Future`s and Tasks](async-book/src/02_execution/01_chapter.md)
  - [The `Future` Trait](async-book/src/02_execution/02_future.md)
  - [Task Wakeups with `Waker`](async-book/src/02_execution/03_wakeups.md)
  - [Applied: Build an Executor](async-book/src/02_execution/04_executor.md)
  - [Executors and System IO](async-book/src/02_execution/05_io.md)
- [`async`/`await`](async-book/src/03_async_await/01_chapter.md)
- [Pinning](async-book/src/04_pinning/01_chapter.md)
- [Streams](async-book/src/05_streams/01_chapter.md)
  - [Iteration and Concurrency](async-book/src/05_streams/02_iteration_and_concurrency.md)
- [Executing Multiple Futures at a Time](async-book/src/06_multiple_futures/01_chapter.md)
  - [`join!`](async-book/src/06_multiple_futures/02_join.md)
  - [`select!`](async-book/src/06_multiple_futures/03_select.md)
  - [TODO: Spawning](async-book/src/)
  - [TODO: Cancellation and Timeouts](async-book/src/)
  - [TODO: `FuturesUnordered`](async-book/src/)
- [Workarounds to Know and Love](async-book/src/07_workarounds/01_chapter.md)
  - [`?` in `async` Blocks](async-book/src/07_workarounds/02_err_in_async_blocks.md)
  - [`Send` Approximation](async-book/src/07_workarounds/03_send_approximation.md)
  - [Recursion](async-book/src/07_workarounds/04_recursion.md)
  - [`async` in Traits](async-book/src/07_workarounds/05_async_in_traits.md)
- [The Async Ecosystem](async-book/src/08_ecosystem/00_chapter.md)
- [Final Project: HTTP Server](async-book/src/09_example/00_intro.md)
  - [Running Asynchronous Code](async-book/src/09_example/01_running_async_code.md)
  - [Handling Connections Concurrently](async-book/src/09_example/02_handling_connections_concurrently.md)
  - [Testing the Server](async-book/src/09_example/03_tests.md)
- [TODO: I/O](async-book/src/)
  - [TODO: `AsyncRead` and `AsyncWrite`](async-book/src/)
- [TODO: Asynchronous Design Patterns: Solutions and Suggestions](async-book/src/)
  - [TODO: Modeling Servers and the Request/Response Pattern](async-book/src/)
  - [TODO: Managing Shared State](async-book/src/)
- [Appendix: Translations of the Book](async-book/src/12_appendix/01_translations.md)



## üü¢üîµThe Little Book of Rust Macros


* [Macros, A Methodical Introduction](macros_little/text/mbe-README.md)
    * [Syntax Extensions](macros_little/text/mbe-syn-README.md)
        * [Source Analysis](macros_little/text/mbe-syn-source-analysis.md)
        * [Macros in the AST](macros_little/text/mbe-syn-macros-in-the-ast.md)
        * [Expansion](macros_little/text/mbe-syn-expansion.md)
    * [macro_rules!](macros_little/text/mbe-macro-rules.md)
    * [Minutiae](macros_little/text/mbe-min-README.md)
        * [Captures and Expansion Redux](macros_little/text/mbe-min-captures-and-expansion-redux.md)
        * [Hygiene](macros_little/text/mbe-min-hygiene.md)
        * [Non-Identifier Identifiers](macros_little/text/mbe-min-non-identifier-identifiers.md)
        * [Debugging](macros_little/text/mbe-min-debugging.md)
        * [Scoping](macros_little/text/mbe-min-scoping.md)
        * [Import/Export](macros_little/text/mbe-min-import-export.md)
* [Macros, A Practical Introduction](macros_little/text/pim-README.md)
* [Patterns](macros_little/text/pat-README.md)
    * [Callbacks](macros_little/text/pat-callbacks.md)
    * [Incremental TT Munchers](macros_little/text/pat-incremental-tt-munchers.md)
    * [Internal Rules](macros_little/text/pat-internal-rules.md)
    * [Push-Down Accumulation](macros_little/text/pat-push-down-accumulation.md)
    * [Repetition Replacement](macros_little/text/pat-repetition-replacement.md)
    * [Trailing Separators](macros_little/text/pat-trailing-separators.md)
    * [TT Bundling](macros_little/text/pat-tt-bundling.md)
    * [Visibility](macros_little/text/pat-visibility.md)
    * [Provisional](macros_little/text/pat-provisional.md)
* [Building Blocks](macros_little/text/blk-README.md)
    * [AST Coercion](macros_little/text/blk-ast-coercion.md)
    * [Counting](macros_little/text/blk-counting.md)
    * [Enum Parsing](macros_little/text/blk-enum-parsing.md)
* [Annotated Examples](macros_little/text/aeg-README.md)
    * [Ook!](macros_little/text/aeg-ook.md)


## üü¢üîµThe Little Book of Rust Macros 2

[Introduction](macros_little2/src/introduction.md)

- [Syntax Extensions](macros_little2/src/syntax-extensions.md)
    - [Source Analysis](macros_little2/src/syntax-extensions/source-analysis.md)
    - [Macros in the Ast](macros_little2/src/syntax-extensions/ast.md)
    - [Expansion](macros_little2/src/syntax-extensions/expansion.md)
    - [Hygiene](macros_little2/src/syntax-extensions/hygiene.md)
    - [Debugging](macros_little2/src/syntax-extensions/debugging.md)
- [Declarative Macros](macros_little2/src/decl-macros.md)
    - [A Methodical Introduction](macros_little2/src/decl-macros/macros-methodical.md)
    - [A Practical Introduction](macros_little2/src/decl-macros/macros-practical.md)
    - [Minutiae](macros_little2/src/decl-macros/minutiae.md)
        - [Fragment Specifiers](macros_little2/src/decl-macros/minutiae/fragment-specifiers.md)
        - [Metavariables and Expansion Redux](macros_little2/src/decl-macros/minutiae/metavar-and-expansion.md)
        - [Metavariable Expressions](macros_little2/src/decl-macros/minutiae/metavar-expr.md)
        - [Hygiene](macros_little2/src/decl-macros/minutiae/hygiene.md)
        - [Non-Identifier Identifiers](macros_little2/src/decl-macros/minutiae/identifiers.md)
        - [Debugging](macros_little2/src/decl-macros/minutiae/debugging.md)
        - [Scoping](macros_little2/src/decl-macros/minutiae/scoping.md)
        - [Import and Export](macros_little2/src/decl-macros/minutiae/import-export.md)
    - [Patterns](macros_little2/src/decl-macros/patterns.md)
        - [Callbacks](macros_little2/src/decl-macros/patterns/callbacks.md)
        - [Incremental TT Munchers](macros_little2/src/decl-macros/patterns/tt-muncher.md)
        - [Internal Rules](macros_little2/src/decl-macros/patterns/internal-rules.md)
        - [Push-down Accumulation](macros_little2/src/decl-macros/patterns/push-down-acc.md)
        - [Repetition Replacement](macros_little2/src/decl-macros/patterns/repetition-replacement.md)
        - [TT Bundling](macros_little2/src/decl-macros/patterns/tt-bundling.md)
    - [Building Blocks](macros_little2/src/decl-macros/building-blocks.md)
        - [AST Coercion](macros_little2/src/decl-macros/building-blocks/ast-coercion.md)
        - [Counting](macros_little2/src/decl-macros/building-blocks/counting.md)
            - [Abacus Counting](macros_little2/src/decl-macros/building-blocks/abacus-counting.md)
        - [Parsing Rust](macros_little2/src/decl-macros/building-blocks/parsing.md)
    - [Macros 2.0](macros_little2/src/decl-macros/macros2.md)
 - [Procedural Macros](macros_little2/src/proc-macros.md)
    - [A Methodical Introduction](macros_little2/src/proc-macros/methodical.md)
        - [Function-like](macros_little2/src/proc-macros/methodical/function-like.md)
        - [Attribute](macros_little2/src/proc-macros/methodical/attr.md)
        - [Derive](macros_little2/src/proc-macros/methodical/derive.md)
    - [A Practical Introduction](macros_little2/src/proc-macros/practical.md)
        - [Function-like](macros_little2/src/proc-macros/practical/function-like.md)
        - [Attribute](macros_little2/src/proc-macros/practical/attr.md)
        - [Derive](macros_little2/src/proc-macros/practical/derive.md)
    - [Third-Party Crates](macros_little2/src/proc-macros/third-party-crates.md)
    - [Hygiene and Spans](macros_little2/src/proc-macros/hygiene.md)
    - [Techniques](macros_little2/src/proc-macros/techniques.md)
        - [Testing](macros_little2/src/proc-macros/techniques/testing.md)

 [Glossary](macros_little2/src/glossary.md)



## üü¢üîµThe Rust Edition Guide

[Introduction](edition-guide/src/introduction.md)

## What are editions?

- [What are editions?](edition-guide/src/editions/index.md)
  - [Creating a new project](edition-guide/src/editions/creating-a-new-project.md)
  - [Transitioning an existing project to a new edition](edition-guide/src/editions/transitioning-an-existing-project-to-a-new-edition.md)
  - [Advanced migrations](edition-guide/src/editions/advanced-migrations.md)

## Rust 2015

- [Rust 2015](edition-guide/src/rust-2015/index.md)

## Rust 2018

- [Rust 2018](edition-guide/src/rust-2018/index.md)
  - [Path and module system changes](edition-guide/src/rust-2018/path-changes.md)
  - [Anonymous trait function parameters deprecated](edition-guide/src/rust-2018/trait-fn-parameters.md)
  - [New keywords](edition-guide/src/rust-2018/new-keywords.md)
  - [Method dispatch for raw pointers to inference variables](edition-guide/src/rust-2018/tyvar-behind-raw-pointer.md)
  - [Cargo changes](edition-guide/src/rust-2018/cargo.md)

## Rust 2021

- [Rust 2021](edition-guide/src/rust-2021/index.md)
  - [Additions to the prelude](edition-guide/src/rust-2021/prelude.md)
  - [Default Cargo feature resolver](edition-guide/src/rust-2021/default-cargo-resolver.md)
  - [IntoIterator for arrays](edition-guide/src/rust-2021/IntoIterator-for-arrays.md)
  - [Disjoint capture in closures](edition-guide/src/rust-2021/disjoint-capture-in-closures.md)
  - [Panic macro consistency](edition-guide/src/rust-2021/panic-macro-consistency.md)
  - [Reserving syntax](edition-guide/src/rust-2021/reserving-syntax.md)
  - [Warnings promoted to errors](edition-guide/src/rust-2021/warnings-promoted-to-error.md)
  - [Or patterns in macro-rules](edition-guide/src/rust-2021/or-patterns-macro-rules.md)



## üü¢üîµThe Cargo Book

[Introduction](cargo/src/index.md)

* [Getting Started](cargo/src/getting-started/index.md)
    * [Installation](cargo/src/getting-started/installation.md)
    * [First Steps with Cargo](cargo/src/getting-started/first-steps.md)

* [Cargo Guide](cargo/src/guide/index.md)
    * [Why Cargo Exists](cargo/src/guide/why-cargo-exists.md)
    * [Creating a New Package](cargo/src/guide/creating-a-new-project.md)
    * [Working on an Existing Package](cargo/src/guide/working-on-an-existing-project.md)
    * [Dependencies](cargo/src/guide/dependencies.md)
    * [Package Layout](cargo/src/guide/project-layout.md)
    * [Cargo.toml vs Cargo.lock](cargo/src/guide/cargo-toml-vs-cargo-lock.md)
    * [Tests](cargo/src/guide/tests.md)
    * [Continuous Integration](cargo/src/guide/continuous-integration.md)
    * [Cargo Home](cargo/src/guide/cargo-home.md)
    * [Build Cache](cargo/src/guide/build-cache.md)

* [Cargo Reference](cargo/src/reference/index.md)
    * [Specifying Dependencies](cargo/src/reference/specifying-dependencies.md)
        * [Overriding Dependencies](cargo/src/reference/overriding-dependencies.md)
    * [The Manifest Format](cargo/src/reference/manifest.md)
        * [Cargo Targets](cargo/src/reference/cargo-targets.md)
    * [Workspaces](cargo/src/reference/workspaces.md)
    * [Features](cargo/src/reference/features.md)
        * [Features Examples](cargo/src/reference/features-examples.md)
    * [Profiles](cargo/src/reference/profiles.md)
    * [Configuration](cargo/src/reference/config.md)
    * [Environment Variables](cargo/src/reference/environment-variables.md)
    * [Build Scripts](cargo/src/reference/build-scripts.md)
        * [Build Script Examples](cargo/src/reference/build-script-examples.md)
    * [Publishing on crates.io](cargo/src/reference/publishing.md)
    * [Package ID Specifications](cargo/src/reference/pkgid-spec.md)
    * [Source Replacement](cargo/src/reference/source-replacement.md)
    * [External Tools](cargo/src/reference/external-tools.md)
    * [Registries](cargo/src/reference/registries.md)
    * [Dependency Resolution](cargo/src/reference/resolver.md)
    * [SemVer Compatibility](cargo/src/reference/semver.md)
    * [Future incompat report](cargo/src/reference/future-incompat-report.md)
    * [Reporting build timings](cargo/src/reference/timings.md)
    * [Unstable Features](cargo/src/reference/unstable.md)

* [Cargo Commands](cargo/src/commands/index.md)
    * [General Commands](cargo/src/commands/general-commands.md)
        * [cargo](cargo/src/commands/cargo.md)
        * [cargo help](cargo/src/commands/cargo-help.md)
        * [cargo version](cargo/src/commands/cargo-version.md)
    * [Build Commands](cargo/src/commands/build-commands.md)
        * [cargo bench](cargo/src/commands/cargo-bench.md)
        * [cargo build](cargo/src/commands/cargo-build.md)
        * [cargo check](cargo/src/commands/cargo-check.md)
        * [cargo clean](cargo/src/commands/cargo-clean.md)
        * [cargo doc](cargo/src/commands/cargo-doc.md)
        * [cargo fetch](cargo/src/commands/cargo-fetch.md)
        * [cargo fix](cargo/src/commands/cargo-fix.md)
        * [cargo run](cargo/src/commands/cargo-run.md)
        * [cargo rustc](cargo/src/commands/cargo-rustc.md)
        * [cargo rustdoc](cargo/src/commands/cargo-rustdoc.md)
        * [cargo test](cargo/src/commands/cargo-test.md)
        * [cargo report](cargo/src/commands/cargo-report.md)
    * [Manifest Commands](cargo/src/commands/manifest-commands.md)
        * [cargo add](cargo/src/commands/cargo-add.md)
        * [cargo generate-lockfile](cargo/src/commands/cargo-generate-lockfile.md)
        * [cargo locate-project](cargo/src/commands/cargo-locate-project.md)
        * [cargo metadata](cargo/src/commands/cargo-metadata.md)
        * [cargo pkgid](cargo/src/commands/cargo-pkgid.md)
        * [cargo remove](cargo/src/commands/cargo-remove.md)
        * [cargo tree](cargo/src/commands/cargo-tree.md)
        * [cargo update](cargo/src/commands/cargo-update.md)
        * [cargo vendor](cargo/src/commands/cargo-vendor.md)
        * [cargo verify-project](cargo/src/commands/cargo-verify-project.md)
    * [Package Commands](cargo/src/commands/package-commands.md)
        * [cargo init](cargo/src/commands/cargo-init.md)
        * [cargo install](cargo/src/commands/cargo-install.md)
        * [cargo new](cargo/src/commands/cargo-new.md)
        * [cargo search](cargo/src/commands/cargo-search.md)
        * [cargo uninstall](cargo/src/commands/cargo-uninstall.md)
    * [Publishing Commands](cargo/src/commands/publishing-commands.md)
        * [cargo login](cargo/src/commands/cargo-login.md)
        * [cargo owner](cargo/src/commands/cargo-owner.md)
        * [cargo package](cargo/src/commands/cargo-package.md)
        * [cargo publish](cargo/src/commands/cargo-publish.md)
        * [cargo yank](cargo/src/commands/cargo-yank.md)

* [FAQ](cargo/src/faq.md)
* [Appendix: Glossary](cargo/src/appendix/glossary.md)
* [Appendix: Git Authentication](cargo/src/appendix/git-authentication.md)




## üü¢üîµThe Rustc Book


- [What is rustc?](rustc/src/what-is-rustc.md)
- [Command-line arguments](rustc/src/command-line-arguments.md)
- [Lints](rustc/src/lints/index.md)
    - [Lint levels](rustc/src/lints/levels.md)
    - [Lint Groups](rustc/src/lints/groups.md)
    - [Lint listing](rustc/src/lints/listing/index.md)
        - [Allowed-by-default lints](rustc/src/lints/listing/allowed-by-default.md)
        - [Warn-by-default lints](rustc/src/lints/listing/warn-by-default.md)
        - [Deny-by-default lints](rustc/src/lints/listing/deny-by-default.md)
- [Codegen options](rustc/src/codegen-options/index.md)
- [JSON Output](rustc/src/json.md)
- [Platform Support](rustc/src/platform-support.md)
- [Targets](rustc/src/targets/index.md)
    - [Built-in Targets](rustc/src/targets/built-in.md)
    - [Custom Targets](rustc/src/targets/custom.md)
    - [Known Issues](rustc/src/targets/known-issues.md)
- [Profile-guided Optimization](rustc/src/profile-guided-optimization.md)
- [Linker-plugin based LTO](rustc/src/linker-plugin-lto.md)
- [Exploit Mitigations](rustc/src/exploit-mitigations.md)
- [Contributing to `rustc`](rustc/src/contributing.md)


## üü¢üîµGuide to Rustc Development

[About this guide](rustc-dev-guide/src/about-this-guide.md)

[Getting Started](rustc-dev-guide/src/getting-started.md)

---

## Building and debugging `rustc`

- [How to Build and Run the Compiler](rustc-dev-guide/src/building/how-to-build-and-run.md)
    - [Prerequisites](rustc-dev-guide/src/building/prerequisites.md)
    - [Suggested Workflows](rustc-dev-guide/src/building/suggested.md)
    - [Distribution artifacts](rustc-dev-guide/src/building/build-install-distribution-artifacts.md)
    - [Building Documentation](rustc-dev-guide/src/building/compiler-documenting.md)
    - [Rustdoc overview](rustc-dev-guide/src/rustdoc.md)
    - [Adding a new target](rustc-dev-guide/src/building/new-target.md)
- [Testing the compiler](rustc-dev-guide/src/tests/intro.md)
    - [Running tests](rustc-dev-guide/src/tests/running.md)
        - [Testing with Docker](rustc-dev-guide/src/tests/docker.md)
        - [Testing with CI](rustc-dev-guide/src/tests/ci.md)
    - [Adding new tests](rustc-dev-guide/src/tests/adding.md)
    - [Compiletest](rustc-dev-guide/src/tests/compiletest.md)
        - [UI tests](rustc-dev-guide/src/tests/ui.md)
        - [Test headers](rustc-dev-guide/src/tests/headers.md)
    - [Performance testing](rustc-dev-guide/src/tests/perf.md)
    - [Crater](rustc-dev-guide/src/tests/crater.md)
- [Debugging the Compiler](rustc-dev-guide/src/compiler-debugging.md)
    - [Using the tracing/logging instrumentation](rustc-dev-guide/src/tracing.md)
- [Profiling the compiler](rustc-dev-guide/src/profiling.md)
    - [with the linux perf tool](rustc-dev-guide/src/profiling/with_perf.md)
    - [with Windows Performance Analyzer](rustc-dev-guide/src/profiling/wpa_profiling.md)
- [crates.io Dependencies](rustc-dev-guide/src/crates-io.md)


## Contributing to Rust

- [Introduction](rustc-dev-guide/src/contributing.md)
- [About the compiler team](rustc-dev-guide/src/compiler-team.md)
- [Using Git](rustc-dev-guide/src/git.md)
- [Mastering @rustbot](rustc-dev-guide/src/rustbot.md)
- [Walkthrough: a typical contribution](rustc-dev-guide/src/walkthrough.md)
- [Bug Fix Procedure](rustc-dev-guide/src/bug-fix-procedure.md)
- [Implementing new features](rustc-dev-guide/src/implementing_new_features.md)
- [Stability attributes](rustc-dev-guide/src/stability.md)
- [Stabilizing Features](rustc-dev-guide/src/stabilization_guide.md)
- [Feature Gates](rustc-dev-guide/src/feature-gates.md)
- [Coding conventions](rustc-dev-guide/src/conventions.md)
- [Notification groups](notification-groups/about.md)
    - [ARM](notification-groups/arm.md)
    - [Cleanup Crew](notification-groups/cleanup-crew.md)
    - [LLVM](notification-groups/llvm.md)
    - [RISC-V](notification-groups/risc-v.md)
    - [Windows](notification-groups/windows.md)
- [Licenses](rustc-dev-guide/src/licenses.md)

## High-level Compiler Architecture

- [Prologue](rustc-dev-guide/src/part-2-intro.md)
- [Overview of the Compiler](rustc-dev-guide/src/overview.md)
- [The compiler source code](rustc-dev-guide/src/compiler-src.md)
- [Bootstrapping](rustc-dev-guide/src/building/bootstrapping.md)
- [Queries: demand-driven compilation](rustc-dev-guide/src/query.md)
    - [The Query Evaluation Model in Detail](rustc-dev-guide/src/queries/query-evaluation-model-in-detail.md)
    - [Incremental compilation](rustc-dev-guide/src/queries/incremental-compilation.md)
    - [Incremental compilation In Detail](rustc-dev-guide/src/queries/incremental-compilation-in-detail.md)
    - [Debugging and Testing](rustc-dev-guide/src/incrcomp-debugging.md)
    - [Salsa](rustc-dev-guide/src/salsa.md)
- [Memory Management in Rustc](rustc-dev-guide/src/memory.md)
- [Serialization in Rustc](rustc-dev-guide/src/serialization.md)
- [Parallel Compilation](rustc-dev-guide/src/parallel-rustc.md)
- [Rustdoc internals](rustc-dev-guide/src/rustdoc-internals.md)

## Source Code Representation

- [Prologue](rustc-dev-guide/src/part-3-intro.md)
- [Command-line arguments](rustc-dev-guide/src/cli.md)
- [The Rustc Driver and Interface](rustc-dev-guide/src/rustc-driver.md)
    - [Example: Type checking](rustc-dev-guide/src/rustc-driver-interacting-with-the-ast.md)
    - [Example: Getting diagnostics](rustc-dev-guide/src/rustc-driver-getting-diagnostics.md)
- [Syntax and the AST](rustc-dev-guide/src/syntax-intro.md)
    - [Lexing and Parsing](rustc-dev-guide/src/the-parser.md)
    - [Macro expansion](rustc-dev-guide/src/macro-expansion.md)
    - [Name resolution](rustc-dev-guide/src/name-resolution.md)
    - [`#[test]` Implementation](rustc-dev-guide/src/test-implementation.md)
    - [Panic Implementation](rustc-dev-guide/src/panic-implementation.md)
    - [AST Validation](rustc-dev-guide/src/ast-validation.md)
    - [Feature Gate Checking](rustc-dev-guide/src/feature-gate-ck.md)
    - [Lang Items](rustc-dev-guide/src/lang-items.md)
- [The HIR (High-level IR)](rustc-dev-guide/src/hir.md)
    - [Lowering AST to HIR](rustc-dev-guide/src/lowering.md)
    - [Debugging](rustc-dev-guide/src/hir-debugging.md)
- [The THIR (Typed High-level IR)](rustc-dev-guide/src/thir.md)
- [The MIR (Mid-level IR)](rustc-dev-guide/src/mir/index.md)
    - [MIR construction](rustc-dev-guide/src/mir/construction.md)
    - [MIR visitor and traversal](rustc-dev-guide/src/mir/visitor.md)
    - [MIR passes: getting the MIR for a function](rustc-dev-guide/src/mir/passes.md)
- [Identifiers in the Compiler](rustc-dev-guide/src/identifiers.md)
- [Closure expansion](rustc-dev-guide/src/closure.md)
- [Inline assembly](rustc-dev-guide/src/asm.md)

## Analysis

- [Prologue](rustc-dev-guide/src/part-4-intro.md)
- [The `ty` module: representing types](rustc-dev-guide/src/ty.md)
    - [Generics and substitutions](rustc-dev-guide/src/generics.md)
    - [`TypeFolder` and `TypeFoldable`](rustc-dev-guide/src/ty-fold.md)
    - [Generic arguments](rustc-dev-guide/src/generic_arguments.md)
    - [Constants in the type system](rustc-dev-guide/src/constants.md)
- [Type inference](rustc-dev-guide/src/type-inference.md)
- [Trait solving](rustc-dev-guide/src/traits/resolution.md)
    - [Early and Late Bound Parameters](rustc-dev-guide/src/early-late-bound.md)
    - [Higher-ranked trait bounds](rustc-dev-guide/src/traits/hrtb.md)
    - [Caching subtleties](rustc-dev-guide/src/traits/caching.md)
    - [Specialization](rustc-dev-guide/src/traits/specialization.md)
    - [Chalk-based trait solving](rustc-dev-guide/src/traits/chalk.md)
        - [Lowering to logic](rustc-dev-guide/src/traits/lowering-to-logic.md)
        - [Goals and clauses](rustc-dev-guide/src/traits/goals-and-clauses.md)
        - [Canonical queries](rustc-dev-guide/src/traits/canonical-queries.md)
- [Type checking](rustc-dev-guide/src/type-checking.md)
    - [Method Lookup](rustc-dev-guide/src/method-lookup.md)
    - [Variance](rustc-dev-guide/src/variance.md)
    - [Opaque Types](rustc-dev-guide/src/opaque-types-type-alias-impl-trait.md)
        - [Inference details](rustc-dev-guide/src/opaque-types-impl-trait-inference.md)
- [Pattern and Exhaustiveness Checking](rustc-dev-guide/src/pat-exhaustive-checking.md)
- [MIR dataflow](rustc-dev-guide/src/mir/dataflow.md)
- [Drop elaboration](rustc-dev-guide/src/mir/drop-elaboration.md)
- [The borrow checker](rustc-dev-guide/src/borrow_check.md)
    - [Tracking moves and initialization](rustc-dev-guide/src/borrow_check/moves_and_initialization.md)
        - [Move paths](rustc-dev-guide/src/borrow_check/moves_and_initialization/move_paths.md)
    - [MIR type checker](rustc-dev-guide/src/borrow_check/type_check.md)
    - [Region inference](rustc-dev-guide/src/borrow_check/region_inference.md)
        - [Constraint propagation](rustc-dev-guide/src/borrow_check/region_inference/constraint_propagation.md)
        - [Lifetime parameters](rustc-dev-guide/src/borrow_check/region_inference/lifetime_parameters.md)
        - [Member constraints](rustc-dev-guide/src/borrow_check/region_inference/member_constraints.md)
        - [Placeholders and universes](borrow_check/region_inference/placeholders_and_universes.md)
        - [Closure constraints](rustc-dev-guide/src/borrow_check/region_inference/closure_constraints.md)
        - [Error reporting](rustc-dev-guide/src/borrow_check/region_inference/error_reporting.md)
    - [Two-phase-borrows](rustc-dev-guide/src/borrow_check/two_phase_borrows.md)
- [Parameter Environments](rustc-dev-guide/src/param_env.md)
- [Errors and Lints](rustc-dev-guide/src/diagnostics/diagnostics.md)
    - [Diagnostic and subdiagnostic structs](rustc-dev-guide/src/diagnostics/diagnostic-structs.md)
    - [Translation](rustc-dev-guide/src/diagnostics/translation.md)
    - [`LintStore`](rustc-dev-guide/src/diagnostics/lintstore.md)
    - [Diagnostic codes](rustc-dev-guide/src/diagnostics/diagnostic-codes.md)
    - [Diagnostic items](rustc-dev-guide/src/diagnostics/diagnostic-items.md)
    - [`ErrorGuaranteed`](rustc-dev-guide/src/diagnostics/error-guaranteed.md)

## MIR to Binaries

- [Prologue](rustc-dev-guide/src/part-5-intro.md)
- [MIR optimizations](rustc-dev-guide/src/mir/optimizations.md)
- [Debugging](rustc-dev-guide/src/mir/debugging.md)
- [Constant evaluation](rustc-dev-guide/src/const-eval.md)
    - [Interpreter](rustc-dev-guide/src/const-eval/interpret.md)
- [Monomorphization](rustc-dev-guide/src/backend/monomorph.md)
- [Lowering MIR](rustc-dev-guide/src/backend/lowering-mir.md)
- [Code Generation](rustc-dev-guide/src/backend/codegen.md)
    - [Updating LLVM](rustc-dev-guide/src/backend/updating-llvm.md)
    - [Debugging LLVM](rustc-dev-guide/src/backend/debugging.md)
    - [Backend Agnostic Codegen](rustc-dev-guide/src/backend/backend-agnostic.md)
    - [Implicit Caller Location](rustc-dev-guide/src/backend/implicit-caller-location.md)
- [Libraries and Metadata](rustc-dev-guide/src/backend/libs-and-metadata.md)
- [Profile-guided Optimization](rustc-dev-guide/src/profile-guided-optimization.md)
- [LLVM Source-Based Code Coverage](rustc-dev-guide/src/llvm-coverage-instrumentation.md)
- [Sanitizers Support](rustc-dev-guide/src/sanitizers.md)
- [Debugging Support in the Rust Compiler](rustc-dev-guide/src/debugging-support-in-rustc.md)

---

[Appendix A: Background topics](rustc-dev-guide/src/appendix/background.md)
[Appendix B: Glossary](rustc-dev-guide/src/appendix/glossary.md)
[Appendix C: Code Index](rustc-dev-guide/src/appendix/code-index.md)
[Appendix D: Compiler Lecture Series](rustc-dev-guide/src/appendix/compiler-lecture.md)
[Appendix E: Bibliography](rustc-dev-guide/src/appendix/bibliography.md)

[Appendix Z: HumorRust](rustc-dev-guide/src/appendix/humorust.md)

---



## üü¢üîµThe Embedded Rust Book

<!--

Definition of the organization of this book is still a work in process.

Refer to https://github.com/rust-embedded/book/issues for
more information and coordination

-->

- [Introduction](embeded-book/src/intro/index.md)
    - [Hardware](embeded-book/src/intro/hardware.md)
    - [`no_std`](embeded-book/src/intro/no-std.md)
    - [Tooling](embeded-book/src/intro/tooling.md)
    - [Installation](embeded-book/src/intro/install.md)
        - [Linux](embeded-book/src/intro/install/linux.md)
        - [MacOS](embeded-book/src/intro/install/macos.md)
        - [Windows](embeded-book/src/intro/install/windows.md)
        - [Verify Installation](embeded-book/src/intro/install/verify.md)
- [Getting started](embeded-book/src/start/index.md)
  - [QEMU](embeded-book/src/start/qemu.md)
  - [Hardware](embeded-book/src/start/hardware.md)
  - [Memory-mapped Registers](embeded-book/src/start/registers.md)
  - [Semihosting](embeded-book/src/start/semihosting.md)
  - [Panicking](embeded-book/src/start/panicking.md)
  - [Exceptions](embeded-book/src/start/exceptions.md)
  - [Interrupts](embeded-book/src/start/interrupts.md)
  - [IO](embeded-book/src/start/io.md)
- [Peripherals](embeded-book/src/peripherals/index.md)
    - [A first attempt in Rust](embeded-book/src/peripherals/a-first-attempt.md)
    - [The Borrow Checker](embeded-book/src/peripherals/borrowck.md)
    - [Singletons](embeded-book/src/peripherals/singletons.md)
- [Static Guarantees](embeded-book/src/static-guarantees/index.md)
    - [Typestate Programming](embeded-book/src/static-guarantees/typestate-programming.md)
    - [Peripherals as State Machines](embeded-book/src/static-guarantees/state-machines.md)
    - [Design Contracts](embeded-book/src/static-guarantees/design-contracts.md)
    - [Zero Cost Abstractions](embeded-book/src/static-guarantees/zero-cost-abstractions.md)
- [Portability](embeded-book/src/portability/index.md)
- [Concurrency](embeded-book/src/concurrency/index.md)
- [Collections](embeded-book/src/collections/index.md)
- [Design Patterns](embeded-book/src/design-patterns/index.md)
    - [HALs](embeded-book/src/design-patterns/hal/index.md)
        - [Checklist](embeded-book/src/design-patterns/hal/checklist.md)
        - [Naming](embeded-book/src/design-patterns/hal/naming.md)
        - [Interoperability](embeded-book/src/design-patterns/hal/interoperability.md)
        - [Predictability](embeded-book/src/design-patterns/hal/predictability.md)
        - [GPIO](embeded-book/src/design-patterns/hal/gpio.md)
- [Tips for embedded C developers](embeded-book/src/c-tips/index.md)
    <!-- TODO: Define Sections -->
- [Interoperability](embeded-book/src/interoperability/index.md)
    - [A little C with your Rust](embeded-book/src/interoperability/c-with-rust.md)
    - [A little Rust with your C](embeded-book/src/interoperability/rust-with-c.md)
- [Unsorted topics](embeded-book/src/unsorted/index.md)
  - [Optimizations: The speed size tradeoff](embeded-book/src/unsorted/speed-vs-size.md)
  - [Performing Math Functionality](embeded-book/src/unsorted/math.md)

---

[Appendix A: Glossary](embeded-book/src/appendix/glossary.md)


## üü¢üîµThe Rust Reference

[Introduction](reference/src/introduction.md)

- [Notation](reference/src/notation.md)

- [Lexical structure](reference/src/lexical-structure.md)
    - [Input format](reference/src/input-format.md)
    - [Keywords](reference/src/keywords.md)
    - [Identifiers](reference/src/identifiers.md)
    - [Comments](reference/src/comments.md)
    - [Whitespace](reference/src/whitespace.md)
    - [Tokens](reference/src/tokens.md)

- [Macros](reference/src/macros.md)
    - [Macros By Example](reference/src/macros-by-example.md)
    - [Procedural Macros](reference/src/procedural-macros.md)

- [Crates and source files](reference/src/crates-and-source-files.md)

- [Conditional compilation](reference/src/conditional-compilation.md)

- [Items](reference/src/items.md)
    - [Modules](reference/src/items/modules.md)
    - [Extern crates](reference/src/items/extern-crates.md)
    - [Use declarations](reference/src/items/use-declarations.md)
    - [Functions](reference/src/items/functions.md)
    - [Type aliases](reference/src/items/type-aliases.md)
    - [Structs](reference/src/items/structs.md)
    - [Enumerations](reference/src/items/enumerations.md)
    - [Unions](reference/src/items/unions.md)
    - [Constant items](reference/src/items/constant-items.md)
    - [Static items](reference/src/items/static-items.md)
    - [Traits](reference/src/items/traits.md)
    - [Implementations](reference/src/items/implementations.md)
    - [External blocks](reference/src/items/external-blocks.md)
    - [Generic parameters](reference/src/items/generics.md)
    - [Associated Items](reference/src/items/associated-items.md)

- [Attributes](reference/src/attributes.md)
    - [Testing](reference/src/attributes/testing.md)
    - [Derive](reference/src/attributes/derive.md)
    - [Diagnostics](reference/src/attributes/diagnostics.md)
    - [Code generation](reference/src/attributes/codegen.md)
    - [Limits](reference/src/attributes/limits.md)
    - [Type System](reference/src/attributes/type_system.md)

- [Statements and expressions](reference/src/statements-and-expressions.md)
    - [Statements](reference/src/statements.md)
    - [Expressions](reference/src/expressions.md)
        - [Literal expressions](reference/src/expressions/literal-expr.md)
        - [Path expressions](reference/src/expressions/path-expr.md)
        - [Block expressions](reference/src/expressions/block-expr.md)
        - [Operator expressions](reference/src/expressions/operator-expr.md)
        - [Grouped expressions](reference/src/expressions/grouped-expr.md)
        - [Array and index expressions](reference/src/expressions/array-expr.md)
        - [Tuple and index expressions](reference/src/expressions/tuple-expr.md)
        - [Struct expressions](reference/src/expressions/struct-expr.md)
        - [Call expressions](reference/src/expressions/call-expr.md)
        - [Method call expressions](reference/src/expressions/method-call-expr.md)
        - [Field access expressions](reference/src/expressions/field-expr.md)
        - [Closure expressions](reference/src/expressions/closure-expr.md)
        - [Loop expressions](reference/src/expressions/loop-expr.md)
        - [Range expressions](reference/src/expressions/range-expr.md)
        - [If and if let expressions](reference/src/expressions/if-expr.md)
        - [Match expressions](reference/src/expressions/match-expr.md)
        - [Return expressions](reference/src/expressions/return-expr.md)
        - [Await expressions](reference/src/expressions/await-expr.md)
        - [Underscore expressions](reference/src/expressions/underscore-expr.md)

- [Patterns](reference/src/patterns.md)

- [Type system](reference/src/type-system.md)
    - [Types](reference/src/types.md)
        - [Boolean type](reference/src/types/boolean.md)
        - [Numeric types](reference/src/types/numeric.md)
        - [Textual types](reference/src/types/textual.md)
        - [Never type](reference/src/types/never.md)
        - [Tuple types](reference/src/types/tuple.md)
        - [Array types](reference/src/types/array.md)
        - [Slice types](reference/src/types/slice.md)
        - [Struct types](reference/src/types/struct.md)
        - [Enumerated types](reference/src/types/enum.md)
        - [Union types](reference/src/types/union.md)
        - [Function item types](reference/src/types/function-item.md)
        - [Closure types](reference/src/types/closure.md)
        - [Pointer types](reference/src/types/pointer.md)
        - [Function pointer types](reference/src/types/function-pointer.md)
        - [Trait object types](reference/src/types/trait-object.md)
        - [Impl trait type](reference/src/types/impl-trait.md)
        - [Type parameters](reference/src/types/parameters.md)
        - [Inferred type](reference/src/types/inferred.md)
    - [Dynamically Sized Types](reference/src/dynamically-sized-types.md)
    - [Type layout](reference/src/type-layout.md)
    - [Interior mutability](reference/src/interior-mutability.md)
    - [Subtyping and Variance](reference/src/subtyping.md)
    - [Trait and lifetime bounds](reference/src/trait-bounds.md)
    - [Type coercions](reference/src/type-coercions.md)
    - [Destructors](reference/src/destructors.md)
    - [Lifetime elision](reference/src/lifetime-elision.md)

- [Special types and traits](reference/src/special-types-and-traits.md)

- [Names](reference/src/names.md)
    - [Namespaces](reference/src/names/namespaces.md)
    - [Scopes](reference/src/names/scopes.md)
    - [Preludes](reference/src/names/preludes.md)
    - [Paths](reference/src/paths.md)
    - [Name resolution](reference/src/names/name-resolution.md)
    - [Visibility and privacy](reference/src/visibility-and-privacy.md)

- [Memory model](reference/src/memory-model.md)
    - [Memory allocation and lifetime](reference/src/memory-allocation-and-lifetime.md)
    - [Variables](reference/src/variables.md)

- [Linkage](reference/src/linkage.md)

- [Inline assembly](reference/src/inline-assembly.md)

- [Unsafety](reference/src/unsafety.md)
    - [The `unsafe` keyword](reference/src/unsafe-keyword.md)
    - [Behavior considered undefined](reference/src/behavior-considered-undefined.md)
    - [Behavior not considered unsafe](reference/src/behavior-not-considered-unsafe.md)

- [Constant Evaluation](reference/src/const_eval.md)

- [Application Binary Interface](reference/src/abi.md)

- [The Rust runtime](reference/src/runtime.md)

- [Appendices](reference/src/appendices.md)
    - [Macro Follow-Set Ambiguity Formal Specification](reference/src/macro-ambiguity.md)
    - [Influences](reference/src/influences.md)
    - [Glossary](reference/src/glossary.md)


## üü¢üîµThe Rustonomicon

[Introduction](nomicon/src/intro.md)

* [Meet Safe and Unsafe](nomicon/src/meet-safe-and-unsafe.md)
  * [How Safe and Unsafe Interact](nomicon/src/safe-unsafe-meaning.md)
  * [What Unsafe Can Do](nomicon/src/what-unsafe-does.md)
  * [Working with Unsafe](nomicon/src/working-with-unsafe.md)
* [Data Layout](nomicon/src/data.md)
  * [repr(Rust)](nomicon/src/repr-rust.md)
  * [Exotically Sized Types](nomicon/src/exotic-sizes.md)
  * [Other reprs](nomicon/src/other-reprs.md)
* [Ownership](nomicon/src/ownership.md)
  * [References](nomicon/src/references.md)
  * [Aliasing](nomicon/src/aliasing.md)
  * [Lifetimes](nomicon/src/lifetimes.md)
  * [Limits of Lifetimes](nomicon/src/lifetime-mismatch.md)
  * [Lifetime Elision](nomicon/src/lifetime-elision.md)
  * [Unbounded Lifetimes](nomicon/src/unbounded-lifetimes.md)
  * [Higher-Rank Trait Bounds](nomicon/src/hrtb.md)
  * [Subtyping and Variance](nomicon/src/subtyping.md)
  * [Drop Check](nomicon/src/dropck.md)
  * [PhantomData](nomicon/src/phantom-data.md)
  * [Splitting Borrows](nomicon/src/borrow-splitting.md)
* [Type Conversions](nomicon/src/conversions.md)
  * [Coercions](nomicon/src/coercions.md)
  * [The Dot Operator](nomicon/src/dot-operator.md)
  * [Casts](nomicon/src/casts.md)
  * [Transmutes](nomicon/src/transmutes.md)
* [Uninitialized Memory](nomicon/src/uninitialized.md)
  * [Checked](nomicon/src/checked-uninit.md)
  * [Drop Flags](nomicon/src/drop-flags.md)
  * [Unchecked](nomicon/src/unchecked-uninit.md)
* [Ownership Based Resource Management](nomicon/src/obrm.md)
  * [Constructors](nomicon/src/constructors.md)
  * [Destructors](nomicon/src/destructors.md)
  * [Leaking](nomicon/src/leaking.md)
* [Unwinding](nomicon/src/unwinding.md)
  * [Exception Safety](nomicon/src/exception-safety.md)
  * [Poisoning](nomicon/src/poisoning.md)
* [Concurrency](nomicon/src/concurrency.md)
  * [Races](nomicon/src/races.md)
  * [Send and Sync](nomicon/src/send-and-sync.md)
  * [Atomics](nomicon/src/atomics.md)
* [Implementing Vec](nomicon/src/./vec/vec.md)
  * [Layout](nomicon/src/./vec/vec-layout.md)
  * [Allocating](nomicon/src/./vec/vec-alloc.md)
  * [Push and Pop](nomicon/src/./vec/vec-push-pop.md)
  * [Deallocating](nomicon/src/./vec/vec-dealloc.md)
  * [Deref](nomicon/src/./vec/vec-deref.md)
  * [Insert and Remove](nomicon/src/./vec/vec-insert-remove.md)
  * [IntoIter](nomicon/src/./vec/vec-into-iter.md)
  * [RawVec](nomicon/src/./vec/vec-raw.md)
  * [Drain](nomicon/src/./vec/vec-drain.md)
  * [Handling Zero-Sized Types](nomicon/src/./vec/vec-zsts.md)
  * [Final Code](nomicon/src/./vec/vec-final.md)
* [Implementing Arc and Mutex](nomicon/src/./arc-mutex/arc-and-mutex.md)
  * [Arc](nomicon/src/./arc-mutex/arc.md)
    * [Layout](nomicon/src/./arc-mutex/arc-layout.md)
    * [Base Code](nomicon/src/./arc-mutex/arc-base.md)
    * [Cloning](nomicon/src/./arc-mutex/arc-clone.md)
    * [Dropping](nomicon/src/./arc-mutex/arc-drop.md)
    * [Final Code](nomicon/src/./arc-mutex/arc-final.md)
* [FFI](nomicon/src/ffi.md)
* [Beneath `std`](nomicon/src/beneath-std.md)
  * [#[panic_handler]](nomicon/src/panic-handler.md)


## üü¢üîµThe Unstable Book

## 1. Compiler flags

- [1. Compiler flags](https://doc.rust-lang.org/unstable-book/compiler-flags.html)
    - [1.1. branch_protection](https://doc.rust-lang.org/unstable-book/compiler-flags/branch-protection.html)
    - [1.2. cf_protection](https://doc.rust-lang.org/unstable-book/compiler-flags/cf-protection.html)
    - [1.3. check_cfg](https://doc.rust-lang.org/unstable-book/compiler-flags/check-cfg.html)
    - [1.4. codegen_backend](https://doc.rust-lang.org/unstable-book/compiler-flags/codegen-backend.html)
    - [1.5. control_flow_guard](https://doc.rust-lang.org/unstable-book/compiler-flags/control-flow-guard.html)
    - [1.6. debug_info_for_profiling](https://doc.rust-lang.org/unstable-book/compiler-flags/debug_info_for_profiling.html)
    - [1.7. dwarf_version](https://doc.rust-lang.org/unstable-book/compiler-flags/dwarf-version.html)
    - [1.8. emit_stack_sizes](https://doc.rust-lang.org/unstable-book/compiler-flags/emit-stack-sizes.html)
    - [1.9. extern_options](https://doc.rust-lang.org/unstable-book/compiler-flags/extern-options.html)
    - [1.10. location_detail](https://doc.rust-lang.org/unstable-book/compiler-flags/location-detail.html)
    - [1.11. move_size_limit](https://doc.rust-lang.org/unstable-book/compiler-flags/move-size-limit.html)
    - [1.12. no_unique_section_names](https://doc.rust-lang.org/unstable-book/compiler-flags/no-unique-section-names.html)
    - [1.13. profile](https://doc.rust-lang.org/unstable-book/compiler-flags/profile.html)
    - [1.14. profile_sample_use](https://doc.rust-lang.org/unstable-book/compiler-flags/profile_sample_use.html)
    - [1.15. remap_cwd_prefix](https://doc.rust-lang.org/unstable-book/compiler-flags/remap-cwd-prefix.html)
    - [1.16. report_time](https://doc.rust-lang.org/unstable-book/compiler-flags/report-time.html)
    - [1.17. sanitizer](https://doc.rust-lang.org/unstable-book/compiler-flags/sanitizer.html)
    - [1.18. self_profile](https://doc.rust-lang.org/unstable-book/compiler-flags/self-profile.html)
    - [1.19. self_profile_events](https://doc.rust-lang.org/unstable-book/compiler-flags/self-profile-events.html)
    - [1.20. src_hash_algorithm](https://doc.rust-lang.org/unstable-book/compiler-flags/src-hash-algorithm.html)
    - [1.21. temps_dir](https://doc.rust-lang.org/unstable-book/compiler-flags/temps-dir.html)
    - [1.22. tls_model](https://doc.rust-lang.org/unstable-book/compiler-flags/tls-model.html)
    - [1.23. unsound_mir_opts](https://doc.rust-lang.org/unstable-book/compiler-flags/unsound-mir-opts.html)
    - [1.24. virtual_function_elimination](https://doc.rust-lang.org/unstable-book/compiler-flags/virtual-function-elimination.html)

## 2. Language features

- [2. Language features](https://doc.rust-lang.org/unstable-book/language-features.html)
    - [2.1. aarch64_ver_target_feature](https://doc.rust-lang.org/unstable-book/language-features/aarch64-ver-target-feature.html)
    - [2.2. abi_amdgpu_kernel](https://doc.rust-lang.org/unstable-book/language-features/abi-amdgpu-kernel.html)
    - [2.3. abi_avr_interrupt](https://doc.rust-lang.org/unstable-book/language-features/abi-avr-interrupt.html)
    - [2.4. abi_c_cmse_nonsecure_call](https://doc.rust-lang.org/unstable-book/language-features/abi-c-cmse-nonsecure-call.html)
    - [2.5. abi_efiapi](https://doc.rust-lang.org/unstable-book/language-features/abi-efiapi.html)
    - [2.6. abi_msp430_interrupt](https://doc.rust-lang.org/unstable-book/language-features/abi-msp430-interrupt.html)
    - [2.7. abi_ptx](https://doc.rust-lang.org/unstable-book/language-features/abi-ptx.html)
    - [2.8. abi_thiscall](https://doc.rust-lang.org/unstable-book/language-features/abi-thiscall.html)
    - [2.9. abi_unadjusted](https://doc.rust-lang.org/unstable-book/language-features/abi-unadjusted.html)
    - [2.10. abi_vectorcall](https://doc.rust-lang.org/unstable-book/language-features/abi-vectorcall.html)
    - [2.11. abi_x86_interrupt](https://doc.rust-lang.org/unstable-book/language-features/abi-x86-interrupt.html)
    - [2.12. adt_const_params](https://doc.rust-lang.org/unstable-book/language-features/adt-const-params.html)
    - [2.13. alloc_error_handler](https://doc.rust-lang.org/unstable-book/language-features/alloc-error-handler.html)
    - [2.14. allocator_internals](https://doc.rust-lang.org/unstable-book/language-features/allocator-internals.html)
    - [2.15. allow_internal_unsafe](https://doc.rust-lang.org/unstable-book/language-features/allow-internal-unsafe.html)
    - [2.16. allow_internal_unstable](https://doc.rust-lang.org/unstable-book/language-features/allow-internal-unstable.html)
    - [2.17. anonymous_lifetime_in_impl_trait](https://doc.rust-lang.org/unstable-book/language-features/anonymous-lifetime-in-impl-trait.html)
    - [2.18. arbitrary_enum_discriminant](https://doc.rust-lang.org/unstable-book/language-features/arbitrary-enum-discriminant.html)
    - [2.19. arbitrary_self_types](https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html)
    - [2.20. arm_target_feature](https://doc.rust-lang.org/unstable-book/language-features/arm-target-feature.html)
    - [2.21. asm_const](https://doc.rust-lang.org/unstable-book/language-features/asm-const.html)
    - [2.22. asm_experimental_arch](https://doc.rust-lang.org/unstable-book/language-features/asm-experimental-arch.html)
    - [2.23. asm_sym](https://doc.rust-lang.org/unstable-book/language-features/asm-sym.html)
    - [2.24. asm_unwind](https://doc.rust-lang.org/unstable-book/language-features/asm-unwind.html)
    - [2.25. associated_const_equality](https://doc.rust-lang.org/unstable-book/language-features/associated-const-equality.html)
    - [2.26. associated_type_bounds](https://doc.rust-lang.org/unstable-book/language-features/associated-type-bounds.html)
    - [2.27. associated_type_defaults](https://doc.rust-lang.org/unstable-book/language-features/associated-type-defaults.html)
    - [2.28. async_closure](https://doc.rust-lang.org/unstable-book/language-features/async-closure.html)
    - [2.29. auto_traits](https://doc.rust-lang.org/unstable-book/language-features/auto-traits.html)
    - [2.30. avx512_target_feature](https://doc.rust-lang.org/unstable-book/language-features/avx512-target-feature.html)
    - [2.31. box_patterns](https://doc.rust-lang.org/unstable-book/language-features/box-patterns.html)
    - [2.32. box_syntax](https://doc.rust-lang.org/unstable-book/language-features/box-syntax.html)
    - [2.33. bpf_target_feature](https://doc.rust-lang.org/unstable-book/language-features/bpf-target-feature.html)
    - [2.34. c_unwind](https://doc.rust-lang.org/unstable-book/language-features/c-unwind.html)
    - [2.35. c_variadic](https://doc.rust-lang.org/unstable-book/language-features/c-variadic.html)
    - [2.36. capture_disjoint_fields](https://doc.rust-lang.org/unstable-book/language-features/capture-disjoint-fields.html)
    - [2.37. cfg_sanitize](https://doc.rust-lang.org/unstable-book/language-features/cfg-sanitize.html)
    - [2.38. cfg_target_abi](https://doc.rust-lang.org/unstable-book/language-features/cfg-target-abi.html)
    - [2.39. cfg_target_compact](https://doc.rust-lang.org/unstable-book/language-features/cfg-target-compact.html)
    - [2.40. cfg_target_has_atomic](https://doc.rust-lang.org/unstable-book/language-features/cfg-target-has-atomic.html)
    - [2.41. cfg_target_has_atomic_equal_alignment](https://doc.rust-lang.org/unstable-book/language-features/cfg-target-has-atomic-equal-alignment.html)
    - [2.42. cfg_target_thread_local](https://doc.rust-lang.org/unstable-book/language-features/cfg-target-thread-local.html)
    - [2.43. cfg_version](https://doc.rust-lang.org/unstable-book/language-features/cfg-version.html)
    - [2.44. closure_lifetime_binder](https://doc.rust-lang.org/unstable-book/language-features/closure-lifetime-binder.html)
    - [2.45. closure_track_caller](https://doc.rust-lang.org/unstable-book/language-features/closure-track-caller.html)
    - [2.46. cmpxchg16b_target_feature](https://doc.rust-lang.org/unstable-book/language-features/cmpxchg16b-target-feature.html)
    - [2.47. cmse_nonsecure_entry](https://doc.rust-lang.org/unstable-book/language-features/cmse-nonsecure-entry.html)
    - [2.48. collapse_debuginfo](https://doc.rust-lang.org/unstable-book/language-features/collapse-debuginfo.html)
    - [2.49. compiler_builtins](https://doc.rust-lang.org/unstable-book/language-features/compiler-builtins.html)
    - [2.50. const_async_blocks](https://doc.rust-lang.org/unstable-book/language-features/const-async-blocks.html)
    - [2.51. const_eval_limit](https://doc.rust-lang.org/unstable-book/language-features/const-eval-limit.html)
    - [2.52. const_extern_fn](https://doc.rust-lang.org/unstable-book/language-features/const-extern-fn.html)
    - [2.53. const_fn_floating_point_arithmetic](https://doc.rust-lang.org/unstable-book/language-features/const-fn-floating-point-arithmetic.html)
    - [2.54. const_for](https://doc.rust-lang.org/unstable-book/language-features/const-for.html)
    - [2.55. const_mut_refs](https://doc.rust-lang.org/unstable-book/language-features/const-mut-refs.html)
    - [2.56. const_precise_live_drops](https://doc.rust-lang.org/unstable-book/language-features/const-precise-live-drops.html)
    - [2.57. const_refs_to_cell](https://doc.rust-lang.org/unstable-book/language-features/const-refs-to-cell.html)
    - [2.58. const_trait_impl](https://doc.rust-lang.org/unstable-book/language-features/const-trait-impl.html)
    - [2.59. const_try](https://doc.rust-lang.org/unstable-book/language-features/const-try.html)
    - [2.60. custom_inner_attributes](https://doc.rust-lang.org/unstable-book/language-features/custom-inner-attributes.html)
    - [2.61. custom_test_frameworks](https://doc.rust-lang.org/unstable-book/language-features/custom-test-frameworks.html)
    - [2.62. debugger_visualizer](https://doc.rust-lang.org/unstable-book/language-features/debugger-visualizer.html)
    - [2.63. decl_macro](https://doc.rust-lang.org/unstable-book/language-features/decl-macro.html)
    - [2.64. default_alloc_error_handler](https://doc.rust-lang.org/unstable-book/language-features/default-alloc-error-handler.html)
    - [2.65. default_type_parameter_fallback](https://doc.rust-lang.org/unstable-book/language-features/default-type-parameter-fallback.html)
    - [2.66. deprecated_safe](https://doc.rust-lang.org/unstable-book/language-features/deprecated-safe.html)
    - [2.67. deprecated_suggestion](https://doc.rust-lang.org/unstable-book/language-features/deprecated-suggestion.html)
    - [2.68. doc_auto_cfg](https://doc.rust-lang.org/unstable-book/language-features/doc-auto-cfg.html)
    - [2.69. doc_cfg](https://doc.rust-lang.org/unstable-book/language-features/doc-cfg.html)
    - [2.70. doc_cfg_hide](https://doc.rust-lang.org/unstable-book/language-features/doc-cfg-hide.html)
    - [2.71. doc_masked](https://doc.rust-lang.org/unstable-book/language-features/doc-masked.html)
    - [2.72. doc_notable_trait](https://doc.rust-lang.org/unstable-book/language-features/doc-notable-trait.html)
    - [2.73. dropck_eyepatch](https://doc.rust-lang.org/unstable-book/language-features/dropck-eyepatch.html)
    - [2.74. dyn_star](https://doc.rust-lang.org/unstable-book/language-features/dyn-star.html)
    - [2.75. ermsb_target_feature](https://doc.rust-lang.org/unstable-book/language-features/ermsb-target-feature.html)
    - [2.76. exclusive_range_pattern](https://doc.rust-lang.org/unstable-book/language-features/exclusive-range-pattern.html)
    - [2.77. exhaustive_patterns](https://doc.rust-lang.org/unstable-book/language-features/exhaustive-patterns.html)
    - [2.78. extern_types](https://doc.rust-lang.org/unstable-book/language-features/extern-types.html)
    - [2.79. f16c_target_feature](https://doc.rust-lang.org/unstable-book/language-features/f16c-target-feature.html)
    - [2.80. ffi_const](https://doc.rust-lang.org/unstable-book/language-features/ffi-const.html)
    - [2.81. ffi_pure](https://doc.rust-lang.org/unstable-book/language-features/ffi-pure.html)
    - [2.82. ffi_returns_twice](https://doc.rust-lang.org/unstable-book/language-features/ffi-returns-twice.html)
    - [2.83. fn_align](https://doc.rust-lang.org/unstable-book/language-features/fn-align.html)
    - [2.84. fundamental](https://doc.rust-lang.org/unstable-book/language-features/fundamental.html)
    - [2.85. generator_clone](https://doc.rust-lang.org/unstable-book/language-features/generator-clone.html)
    - [2.86. generators](https://doc.rust-lang.org/unstable-book/language-features/generators.html)
    - [2.87. generic_arg_infer](https://doc.rust-lang.org/unstable-book/language-features/generic-arg-infer.html)
    - [2.88. generic_assert](https://doc.rust-lang.org/unstable-book/language-features/generic-assert.html)
    - [2.89. generic_associated_types_extended](https://doc.rust-lang.org/unstable-book/language-features/generic-associated-types-extended.html)
    - [2.90. generic_const_exprs](https://doc.rust-lang.org/unstable-book/language-features/generic-const-exprs.html)
    - [2.91. half_open_range_patterns](https://doc.rust-lang.org/unstable-book/language-features/half-open-range-patterns.html)
    - [2.92. hexagon_target_feature](https://doc.rust-lang.org/unstable-book/language-features/hexagon-target-feature.html)
    - [2.93. if_let_guard](https://doc.rust-lang.org/unstable-book/language-features/if-let-guard.html)
    - [2.94. imported_main](https://doc.rust-lang.org/unstable-book/language-features/imported-main.html)
    - [2.95. inherent_associated_types](https://doc.rust-lang.org/unstable-book/language-features/inherent-associated-types.html)
    - [2.96. inline_const](https://doc.rust-lang.org/unstable-book/language-features/inline-const.html)
    - [2.97. inline_const_pat](https://doc.rust-lang.org/unstable-book/language-features/inline-const-pat.html)
    - [2.98. intra_doc_pointers](https://doc.rust-lang.org/unstable-book/language-features/intra-doc-pointers.html)
    - [2.99. intrinsics](https://doc.rust-lang.org/unstable-book/language-features/intrinsics.html)
    - [2.100. isa_attribute](https://doc.rust-lang.org/unstable-book/language-features/isa-attribute.html)
    - [2.101. lang_items](https://doc.rust-lang.org/unstable-book/language-features/lang-items.html)
    - [2.102. large_assignments](https://doc.rust-lang.org/unstable-book/language-features/large-assignments.html)
    - [2.103. let_chains](https://doc.rust-lang.org/unstable-book/language-features/let-chains.html)
    - [2.104. link_cfg](https://doc.rust-lang.org/unstable-book/language-features/link-cfg.html)
    - [2.105. link_llvm_intrinsics](https://doc.rust-lang.org/unstable-book/language-features/link-llvm-intrinsics.html)
    - [2.106. linkage](https://doc.rust-lang.org/unstable-book/language-features/linkage.html)
    - [2.107. lint_reasons](https://doc.rust-lang.org/unstable-book/language-features/lint-reasons.html)
    - [2.108. macro_metavar_expr](https://doc.rust-lang.org/unstable-book/language-features/macro-metavar-expr.html)
    - [2.109. marker_trait_attr](https://doc.rust-lang.org/unstable-book/language-features/marker-trait-attr.html)
    - [2.110. min_specialization](https://doc.rust-lang.org/unstable-book/language-features/min-specialization.html)
    - [2.111. mips_target_feature](https://doc.rust-lang.org/unstable-book/language-features/mips-target-feature.html)
    - [2.112. more_qualified_paths](https://doc.rust-lang.org/unstable-book/language-features/more-qualified-paths.html)
    - [2.113. movbe_target_feature](https://doc.rust-lang.org/unstable-book/language-features/movbe-target-feature.html)
    - [2.114. must_not_suspend](https://doc.rust-lang.org/unstable-book/language-features/must-not-suspend.html)
    - [2.115. naked_functions](https://doc.rust-lang.org/unstable-book/language-features/naked-functions.html)
    - [2.116. native_link_modifiers_as_needed](https://doc.rust-lang.org/unstable-book/language-features/native-link-modifiers-as-needed.html)
    - [2.117. native_link_modifiers_verbatim](https://doc.rust-lang.org/unstable-book/language-features/native-link-modifiers-verbatim.html)
    - [2.118. needs_panic_runtime](https://doc.rust-lang.org/unstable-book/language-features/needs-panic-runtime.html)
    - [2.119. negative_impls](https://doc.rust-lang.org/unstable-book/language-features/negative-impls.html)
    - [2.120. never_type](https://doc.rust-lang.org/unstable-book/language-features/never-type.html)
    - [2.121. never_type_fallback](https://doc.rust-lang.org/unstable-book/language-features/never-type-fallback.html)
    - [2.122. no_core](https://doc.rust-lang.org/unstable-book/language-features/no-core.html)
    - [2.123. no_coverage](https://doc.rust-lang.org/unstable-book/language-features/no-coverage.html)
    - [2.124. no_sanitize](https://doc.rust-lang.org/unstable-book/language-features/no-sanitize.html)
    - [2.125. non_exhaustive_omitted_patterns_lint](https://doc.rust-lang.org/unstable-book/language-features/non-exhaustive-omitted-patterns-lint.html)
    - [2.126. object_safe_for_dispatch](https://doc.rust-lang.org/unstable-book/language-features/object-safe-for-dispatch.html)
    - [2.127. omit_gdb_pretty_printer_section](https://doc.rust-lang.org/unstable-book/language-features/omit-gdb-pretty-printer-section.html)
    - [2.128. optimize_attribute](https://doc.rust-lang.org/unstable-book/language-features/optimize-attribute.html)
    - [2.129. panic_runtime](https://doc.rust-lang.org/unstable-book/language-features/panic-runtime.html)
    - [2.130. platform_intrinsics](https://doc.rust-lang.org/unstable-book/language-features/platform-intrinsics.html)
    - [2.131. plugin](https://doc.rust-lang.org/unstable-book/language-features/plugin.html)
    - [2.132. powerpc_target_feature](https://doc.rust-lang.org/unstable-book/language-features/powerpc-target-feature.html)
    - [2.133. precise_pointer_size_matching](https://doc.rust-lang.org/unstable-book/language-features/precise-pointer-size-matching.html)
    - [2.134. prelude_import](https://doc.rust-lang.org/unstable-book/language-features/prelude-import.html)
    - [2.135. proc_macro_hygiene](https://doc.rust-lang.org/unstable-book/language-features/proc-macro-hygiene.html)
    - [2.136. profiler_runtime](https://doc.rust-lang.org/unstable-book/language-features/profiler-runtime.html)
    - [2.137. raw_dylib](https://doc.rust-lang.org/unstable-book/language-features/raw-dylib.html)
    - [2.138. raw_ref_op](https://doc.rust-lang.org/unstable-book/language-features/raw-ref-op.html)
    - [2.139. register_tool](https://doc.rust-lang.org/unstable-book/language-features/register-tool.html)
    - [2.140. repr_simd](https://doc.rust-lang.org/unstable-book/language-features/repr-simd.html)
    - [2.141. repr128](https://doc.rust-lang.org/unstable-book/language-features/repr128.html)
    - [2.142. return_position_impl_trait_in_trait](https://doc.rust-lang.org/unstable-book/language-features/return-position-impl-trait-in-trait.html)
    - [2.143. riscv_target_feature](https://doc.rust-lang.org/unstable-book/language-features/riscv-target-feature.html)
    - [2.144. rtm_target_feature](https://doc.rust-lang.org/unstable-book/language-features/rtm-target-feature.html)
    - [2.145. rust_cold_cc](https://doc.rust-lang.org/unstable-book/language-features/rust-cold-cc.html)
    - [2.146. rustc_allow_const_fn_unstable](https://doc.rust-lang.org/unstable-book/language-features/rustc-allow-const-fn-unstable.html)
    - [2.147. rustc_attrs](https://doc.rust-lang.org/unstable-book/language-features/rustc-attrs.html)
    - [2.148. rustc_private](https://doc.rust-lang.org/unstable-book/language-features/rustc-private.html)
    - [2.149. rustdoc_internals](https://doc.rust-lang.org/unstable-book/language-features/rustdoc-internals.html)
    - [2.150. rustdoc_missing_doc_code_examples](https://doc.rust-lang.org/unstable-book/language-features/rustdoc-missing-doc-code-examples.html)
    - [2.151. simd_ffi](https://doc.rust-lang.org/unstable-book/language-features/simd-ffi.html)
    - [2.152. specialization](https://doc.rust-lang.org/unstable-book/language-features/specialization.html)
    - [2.153. sse4a_target_feature](https://doc.rust-lang.org/unstable-book/language-features/sse4a-target-feature.html)
    - [2.154. staged_api](https://doc.rust-lang.org/unstable-book/language-features/staged-api.html)
    - [2.155. start](https://doc.rust-lang.org/unstable-book/language-features/start.html)
    - [2.156. stmt_expr_attributes](https://doc.rust-lang.org/unstable-book/language-features/stmt-expr-attributes.html)
    - [2.157. strict_provenance](https://doc.rust-lang.org/unstable-book/language-features/strict-provenance.html)
    - [2.158. structural_match](https://doc.rust-lang.org/unstable-book/language-features/structural-match.html)
    - [2.159. target_feature_11](https://doc.rust-lang.org/unstable-book/language-features/target-feature-11.html)
    - [2.160. tbm_target_feature](https://doc.rust-lang.org/unstable-book/language-features/tbm-target-feature.html)
    - [2.161. test_2018_feature](https://doc.rust-lang.org/unstable-book/language-features/test-2018-feature.html)
    - [2.162. test_unstable_lint](https://doc.rust-lang.org/unstable-book/language-features/test-unstable-lint.html)
    - [2.163. thread_local](https://doc.rust-lang.org/unstable-book/language-features/thread-local.html)
    - [2.164. trait_alias](https://doc.rust-lang.org/unstable-book/language-features/trait-alias.html)
    - [2.165. trait_upcasting](https://doc.rust-lang.org/unstable-book/language-features/trait-upcasting.html)
    - [2.166. transparent_unions](https://doc.rust-lang.org/unstable-book/language-features/transparent-unions.html)
    - [2.167. trivial_bounds](https://doc.rust-lang.org/unstable-book/language-features/trivial-bounds.html)
    - [2.168. try_blocks](https://doc.rust-lang.org/unstable-book/language-features/try-blocks.html)
    - [2.169. type_alias_impl_trait](https://doc.rust-lang.org/unstable-book/language-features/type-alias-impl-trait.html)
    - [2.170. type_ascription](https://doc.rust-lang.org/unstable-book/language-features/type-ascription.html)
    - [2.171. type_changing_struct_update](https://doc.rust-lang.org/unstable-book/language-features/type-changing-struct-update.html)
    - [2.172. unboxed_closures](https://doc.rust-lang.org/unstable-book/language-features/unboxed-closures.html)
    - [2.173. unix_sigpipe](https://doc.rust-lang.org/unstable-book/language-features/unix-sigpipe.html)
    - [2.174. unsafe_pin_internals](https://doc.rust-lang.org/unstable-book/language-features/unsafe-pin-internals.html)
    - [2.175. unsized_fn_params](https://doc.rust-lang.org/unstable-book/language-features/unsized-fn-params.html)
    - [2.176. unsized_locals](https://doc.rust-lang.org/unstable-book/language-features/unsized-locals.html)
    - [2.177. unsized_tuple_coercion](https://doc.rust-lang.org/unstable-book/language-features/unsized-tuple-coercion.html)
    - [2.178. used_with_arg](https://doc.rust-lang.org/unstable-book/language-features/used-with-arg.html)
    - [2.179. wasm_abi](https://doc.rust-lang.org/unstable-book/language-features/wasm-abi.html)
    - [2.180. wasm_target_feature](https://doc.rust-lang.org/unstable-book/language-features/wasm-target-feature.html)
    - [2.181. with_negative_coherence](https://doc.rust-lang.org/unstable-book/language-features/with-negative-coherence.html)
    - [2.182. yeet_expr](https://doc.rust-lang.org/unstable-book/language-features/yeet-expr.html)

## 3. Library Features

- [3. Library Features](https://doc.rust-lang.org/unstable-book/library-features.html)
    - [3.1. absolute_path](https://doc.rust-lang.org/unstable-book/library-features/absolute-path.html)
    - [3.2. addr_parse_ascii](https://doc.rust-lang.org/unstable-book/library-features/addr-parse-ascii.html)
    - [3.3. alloc_error_hook](https://doc.rust-lang.org/unstable-book/library-features/alloc-error-hook.html)
    - [3.4. alloc_internals](https://doc.rust-lang.org/unstable-book/library-features/alloc-internals.html)
    - [3.5. alloc_layout_extra](https://doc.rust-lang.org/unstable-book/library-features/alloc-layout-extra.html)
    - [3.6. allocator_api](https://doc.rust-lang.org/unstable-book/library-features/allocator-api.html)
    - [3.7. arc_unwrap_or_clone](https://doc.rust-lang.org/unstable-book/library-features/arc-unwrap-or-clone.html)
    - [3.8. array_chunks](https://doc.rust-lang.org/unstable-book/library-features/array-chunks.html)
    - [3.9. array_error_internals](https://doc.rust-lang.org/unstable-book/library-features/array-error-internals.html)
    - [3.10. array_into_iter_constructors](https://doc.rust-lang.org/unstable-book/library-features/array-into-iter-constructors.html)
    - [3.11. array_methods](https://doc.rust-lang.org/unstable-book/library-features/array-methods.html)
    - [3.12. array_try_from_fn](https://doc.rust-lang.org/unstable-book/library-features/array-try-from-fn.html)
    - [3.13. array_try_map](https://doc.rust-lang.org/unstable-book/library-features/array-try-map.html)
    - [3.14. array_windows](https://doc.rust-lang.org/unstable-book/library-features/array-windows.html)
    - [3.15. array_zip](https://doc.rust-lang.org/unstable-book/library-features/array-zip.html)
    - [3.16. as_array_of_cells](https://doc.rust-lang.org/unstable-book/library-features/as-array-of-cells.html)
    - [3.17. assert_matches](https://doc.rust-lang.org/unstable-book/library-features/assert-matches.html)
    - [3.18. async_iter_from_iter](https://doc.rust-lang.org/unstable-book/library-features/async-iter-from-iter.html)
    - [3.19. async_iterator](https://doc.rust-lang.org/unstable-book/library-features/async-iterator.html)
    - [3.20. atomic_bool_fetch_not](https://doc.rust-lang.org/unstable-book/library-features/atomic-bool-fetch-not.html)
    - [3.21. atomic_from_mut](https://doc.rust-lang.org/unstable-book/library-features/atomic-from-mut.html)
    - [3.22. atomic_mut_ptr](https://doc.rust-lang.org/unstable-book/library-features/atomic-mut-ptr.html)
    - [3.23. backtrace_frames](https://doc.rust-lang.org/unstable-book/library-features/backtrace-frames.html)
    - [3.24. bench_black_box](https://doc.rust-lang.org/unstable-book/library-features/bench-black-box.html)
    - [3.25. bigint_helper_methods](https://doc.rust-lang.org/unstable-book/library-features/bigint-helper-methods.html)
    - [3.26. binary_heap_as_slice](https://doc.rust-lang.org/unstable-book/library-features/binary-heap-as-slice.html)
    - [3.27. binary_heap_drain_sorted](https://doc.rust-lang.org/unstable-book/library-features/binary-heap-drain-sorted.html)
    - [3.28. binary_heap_into_iter_sorted](https://doc.rust-lang.org/unstable-book/library-features/binary-heap-into-iter-sorted.html)
    - [3.29. binary_heap_retain](https://doc.rust-lang.org/unstable-book/library-features/binary-heap-retain.html)
    - [3.30. bound_as_ref](https://doc.rust-lang.org/unstable-book/library-features/bound-as-ref.html)
    - [3.31. bound_map](https://doc.rust-lang.org/unstable-book/library-features/bound-map.html)
    - [3.32. box_into_boxed_slice](https://doc.rust-lang.org/unstable-book/library-features/box-into-boxed-slice.html)
    - [3.33. box_into_inner](https://doc.rust-lang.org/unstable-book/library-features/box-into-inner.html)
    - [3.34. btree_drain_filter](https://doc.rust-lang.org/unstable-book/library-features/btree-drain-filter.html)
    - [3.35. btreemap_alloc](https://doc.rust-lang.org/unstable-book/library-features/btreemap-alloc.html)
    - [3.36. buf_read_has_data_left](https://doc.rust-lang.org/unstable-book/library-features/buf-read-has-data-left.html)
    - [3.37. build_hasher_simple_hash_one](https://doc.rust-lang.org/unstable-book/library-features/build-hasher-simple-hash-one.html)
    - [3.38. byte_slice_trim_ascii](https://doc.rust-lang.org/unstable-book/library-features/byte-slice-trim-ascii.html)
    - [3.39. c_size_t](https://doc.rust-lang.org/unstable-book/library-features/c-size-t.html)
    - [3.40. c_void_variant](https://doc.rust-lang.org/unstable-book/library-features/c-void-variant.html)
    - [3.41. can_vector](https://doc.rust-lang.org/unstable-book/library-features/can-vector.html)
    - [3.42. cell_leak](https://doc.rust-lang.org/unstable-book/library-features/cell-leak.html)
    - [3.43. cell_update](https://doc.rust-lang.org/unstable-book/library-features/cell-update.html)
    - [3.44. cfg_accessible](https://doc.rust-lang.org/unstable-book/library-features/cfg-accessible.html)
    - [3.45. cfg_eval](https://doc.rust-lang.org/unstable-book/library-features/cfg-eval.html)
    - [3.46. char_error_internals](https://doc.rust-lang.org/unstable-book/library-features/char-error-internals.html)
    - [3.47. char_indices_offset](https://doc.rust-lang.org/unstable-book/library-features/char-indices-offset.html)
    - [3.48. char_internals](https://doc.rust-lang.org/unstable-book/library-features/char-internals.html)
    - [3.49. coerce_unsized](https://doc.rust-lang.org/unstable-book/library-features/coerce-unsized.html)
    - [3.50. concat_bytes](https://doc.rust-lang.org/unstable-book/library-features/concat-bytes.html)
    - [3.51. concat_idents](https://doc.rust-lang.org/unstable-book/library-features/concat-idents.html)
    - [3.52. const_align_of_val](https://doc.rust-lang.org/unstable-book/library-features/const-align-of-val.html)
    - [3.53. const_align_of_val_raw](https://doc.rust-lang.org/unstable-book/library-features/const-align-of-val-raw.html)
    - [3.54. const_align_offset](https://doc.rust-lang.org/unstable-book/library-features/const-align-offset.html)
    - [3.55. const_alloc_error](https://doc.rust-lang.org/unstable-book/library-features/const-alloc-error.html)
    - [3.56. const_alloc_layout](https://doc.rust-lang.org/unstable-book/library-features/const-alloc-layout.html)
    - [3.57. const_arguments_as_str](https://doc.rust-lang.org/unstable-book/library-features/const-arguments-as-str.html)
    - [3.58. const_array_from_ref](https://doc.rust-lang.org/unstable-book/library-features/const-array-from-ref.html)
    - [3.59. const_array_into_iter_constructors](https://doc.rust-lang.org/unstable-book/library-features/const-array-into-iter-constructors.html)
    - [3.60. const_assert_type2](https://doc.rust-lang.org/unstable-book/library-features/const-assert-type2.html)
    - [3.61. const_assume](https://doc.rust-lang.org/unstable-book/library-features/const-assume.html)
    - [3.62. const_bigint_helper_methods](https://doc.rust-lang.org/unstable-book/library-features/const-bigint-helper-methods.html)
    - [3.63. const_black_box](https://doc.rust-lang.org/unstable-book/library-features/const-black-box.html)
    - [3.64. const_bool_to_option](https://doc.rust-lang.org/unstable-book/library-features/const-bool-to-option.html)
    - [3.65. const_borrow](https://doc.rust-lang.org/unstable-book/library-features/const-borrow.html)
    - [3.66. const_box](https://doc.rust-lang.org/unstable-book/library-features/const-box.html)
    - [3.67. const_btree_new](https://doc.rust-lang.org/unstable-book/library-features/const-btree-new.html)
    - [3.68. const_caller_location](https://doc.rust-lang.org/unstable-book/library-features/const-caller-location.html)
    - [3.69. const_cell_into_inner](https://doc.rust-lang.org/unstable-book/library-features/const-cell-into-inner.html)
    - [3.70. const_char_convert](https://doc.rust-lang.org/unstable-book/library-features/const-char-convert.html)
    - [3.71. const_clone](https://doc.rust-lang.org/unstable-book/library-features/const-clone.html)
    - [3.72. const_cmp](https://doc.rust-lang.org/unstable-book/library-features/const-cmp.html)
    - [3.73. const_convert](https://doc.rust-lang.org/unstable-book/library-features/const-convert.html)
    - [3.74. const_cow_is_borrowed](https://doc.rust-lang.org/unstable-book/library-features/const-cow-is-borrowed.html)
    - [3.75. const_cstr_methods](https://doc.rust-lang.org/unstable-book/library-features/const-cstr-methods.html)
    - [3.76. const_default_impls](https://doc.rust-lang.org/unstable-book/library-features/const-default-impls.html)
    - [3.77. const_deref](https://doc.rust-lang.org/unstable-book/library-features/const-deref.html)
    - [3.78. const_discriminant](https://doc.rust-lang.org/unstable-book/library-features/const-discriminant.html)
    - [3.79. const_eval_select](https://doc.rust-lang.org/unstable-book/library-features/const-eval-select.html)
    - [3.80. const_float_bits_conv](https://doc.rust-lang.org/unstable-book/library-features/const-float-bits-conv.html)
    - [3.81. const_float_classify](https://doc.rust-lang.org/unstable-book/library-features/const-float-classify.html)
    - [3.82. const_fmt_arguments_new](https://doc.rust-lang.org/unstable-book/library-features/const-fmt-arguments-new.html)
    - [3.83. const_fn_trait_ref_impls](https://doc.rust-lang.org/unstable-book/library-features/const-fn-trait-ref-impls.html)
    - [3.84. const_format_args](https://doc.rust-lang.org/unstable-book/library-features/const-format-args.html)
    - [3.85. const_heap](https://doc.rust-lang.org/unstable-book/library-features/const-heap.html)
    - [3.86. const_inherent_unchecked_arith](https://doc.rust-lang.org/unstable-book/library-features/const-inherent-unchecked-arith.html)
    - [3.87. const_int_unchecked_arith](https://doc.rust-lang.org/unstable-book/library-features/const-int-unchecked-arith.html)
    - [3.88. const_intoiterator_identity](https://doc.rust-lang.org/unstable-book/library-features/const-intoiterator-identity.html)
    - [3.89. const_intrinsic_forget](https://doc.rust-lang.org/unstable-book/library-features/const-intrinsic-forget.html)
    - [3.90. const_intrinsic_raw_eq](https://doc.rust-lang.org/unstable-book/library-features/const-intrinsic-raw-eq.html)
    - [3.91. const_io_structs](https://doc.rust-lang.org/unstable-book/library-features/const-io-structs.html)
    - [3.92. const_ip](https://doc.rust-lang.org/unstable-book/library-features/const-ip.html)
    - [3.93. const_ipv4](https://doc.rust-lang.org/unstable-book/library-features/const-ipv4.html)
    - [3.94. const_ipv6](https://doc.rust-lang.org/unstable-book/library-features/const-ipv6.html)
    - [3.95. const_is_char_boundary](https://doc.rust-lang.org/unstable-book/library-features/const-is-char-boundary.html)
    - [3.96. const_likely](https://doc.rust-lang.org/unstable-book/library-features/const-likely.html)
    - [3.97. const_maybe_uninit_array_assume_init](https://doc.rust-lang.org/unstable-book/library-features/const-maybe-uninit-array-assume-init.html)
    - [3.98. const_maybe_uninit_as_mut_ptr](https://doc.rust-lang.org/unstable-book/library-features/const-maybe-uninit-as-mut-ptr.html)
    - [3.99. const_maybe_uninit_assume_init](https://doc.rust-lang.org/unstable-book/library-features/const-maybe-uninit-assume-init.html)
    - [3.100. const_maybe_uninit_assume_init_read](https://doc.rust-lang.org/unstable-book/library-features/const-maybe-uninit-assume-init-read.html)
    - [3.101. const_maybe_uninit_uninit_array](https://doc.rust-lang.org/unstable-book/library-features/const-maybe-uninit-uninit-array.html)
    - [3.102. const_maybe_uninit_write](https://doc.rust-lang.org/unstable-book/library-features/const-maybe-uninit-write.html)
    - [3.103. const_maybe_uninit_zeroed](https://doc.rust-lang.org/unstable-book/library-features/const-maybe-uninit-zeroed.html)
    - [3.104. const_nonnull_new](https://doc.rust-lang.org/unstable-book/library-features/const-nonnull-new.html)
    - [3.105. const_nonnull_slice_from_raw_parts](https://doc.rust-lang.org/unstable-book/library-features/const-nonnull-slice-from-raw-parts.html)
    - [3.106. const_num_from_num](https://doc.rust-lang.org/unstable-book/library-features/const-num-from-num.html)
    - [3.107. const_ops](https://doc.rust-lang.org/unstable-book/library-features/const-ops.html)
    - [3.108. const_option](https://doc.rust-lang.org/unstable-book/library-features/const-option.html)
    - [3.109. const_option_cloned](https://doc.rust-lang.org/unstable-book/library-features/const-option-cloned.html)
    - [3.110. const_option_ext](https://doc.rust-lang.org/unstable-book/library-features/const-option-ext.html)
    - [3.111. const_pin](https://doc.rust-lang.org/unstable-book/library-features/const-pin.html)
    - [3.112. const_pointer_byte_offsets](https://doc.rust-lang.org/unstable-book/library-features/const-pointer-byte-offsets.html)
    - [3.113. const_pref_align_of](https://doc.rust-lang.org/unstable-book/library-features/const-pref-align-of.html)
    - [3.114. const_ptr_as_ref](https://doc.rust-lang.org/unstable-book/library-features/const-ptr-as-ref.html)
    - [3.115. const_ptr_is_null](https://doc.rust-lang.org/unstable-book/library-features/const-ptr-is-null.html)
    - [3.116. const_ptr_read](https://doc.rust-lang.org/unstable-book/library-features/const-ptr-read.html)
    - [3.117. const_ptr_sub_ptr](https://doc.rust-lang.org/unstable-book/library-features/const-ptr-sub-ptr.html)
    - [3.118. const_ptr_write](https://doc.rust-lang.org/unstable-book/library-features/const-ptr-write.html)
    - [3.119. const_raw_ptr_comparison](https://doc.rust-lang.org/unstable-book/library-features/const-raw-ptr-comparison.html)
    - [3.120. const_replace](https://doc.rust-lang.org/unstable-book/library-features/const-replace.html)
    - [3.121. const_result](https://doc.rust-lang.org/unstable-book/library-features/const-result.html)
    - [3.122. const_result_drop](https://doc.rust-lang.org/unstable-book/library-features/const-result-drop.html)
    - [3.123. const_reverse](https://doc.rust-lang.org/unstable-book/library-features/const-reverse.html)
    - [3.124. const_size_of_val](https://doc.rust-lang.org/unstable-book/library-features/const-size-of-val.html)
    - [3.125. const_size_of_val_raw](https://doc.rust-lang.org/unstable-book/library-features/const-size-of-val-raw.html)
    - [3.126. const_slice_first_last](https://doc.rust-lang.org/unstable-book/library-features/const-slice-first-last.html)
    - [3.127. const_slice_from_mut_ptr_range](https://doc.rust-lang.org/unstable-book/library-features/const-slice-from-mut-ptr-range.html)
    - [3.128. const_slice_from_ptr_range](https://doc.rust-lang.org/unstable-book/library-features/const-slice-from-ptr-range.html)
    - [3.129. const_slice_from_raw_parts_mut](https://doc.rust-lang.org/unstable-book/library-features/const-slice-from-raw-parts-mut.html)
    - [3.130. const_slice_from_ref](https://doc.rust-lang.org/unstable-book/library-features/const-slice-from-ref.html)
    - [3.131. const_slice_index](https://doc.rust-lang.org/unstable-book/library-features/const-slice-index.html)
    - [3.132. const_slice_ptr_len](https://doc.rust-lang.org/unstable-book/library-features/const-slice-ptr-len.html)
    - [3.133. const_slice_split_at_not_mut](https://doc.rust-lang.org/unstable-book/library-features/const-slice-split-at-not-mut.html)
    - [3.134. const_socketaddr](https://doc.rust-lang.org/unstable-book/library-features/const-socketaddr.html)
    - [3.135. const_str_from_utf8](https://doc.rust-lang.org/unstable-book/library-features/const-str-from-utf8.html)
    - [3.136. const_str_from_utf8_unchecked_mut](https://doc.rust-lang.org/unstable-book/library-features/const-str-from-utf8-unchecked-mut.html)
    - [3.137. const_swap](https://doc.rust-lang.org/unstable-book/library-features/const-swap.html)
    - [3.138. const_transmute_copy](https://doc.rust-lang.org/unstable-book/library-features/const-transmute-copy.html)
    - [3.139. const_type_id](https://doc.rust-lang.org/unstable-book/library-features/const-type-id.html)
    - [3.140. const_type_name](https://doc.rust-lang.org/unstable-book/library-features/const-type-name.html)
    - [3.141. const_unicode_case_lookup](https://doc.rust-lang.org/unstable-book/library-features/const-unicode-case-lookup.html)
    - [3.142. const_unsafecell_get_mut](https://doc.rust-lang.org/unstable-book/library-features/const-unsafecell-get-mut.html)
    - [3.143. const_weak_new](https://doc.rust-lang.org/unstable-book/library-features/const-weak-new.html)
    - [3.144. container_error_extra](https://doc.rust-lang.org/unstable-book/library-features/container-error-extra.html)
    - [3.145. control_flow_enum](https://doc.rust-lang.org/unstable-book/library-features/control-flow-enum.html)
    - [3.146. convert_float_to_int](https://doc.rust-lang.org/unstable-book/library-features/convert-float-to-int.html)
    - [3.147. core_intrinsics](https://doc.rust-lang.org/unstable-book/library-features/core-intrinsics.html)
    - [3.148. core_panic](https://doc.rust-lang.org/unstable-book/library-features/core-panic.html)
    - [3.149. core_private_bignum](https://doc.rust-lang.org/unstable-book/library-features/core-private-bignum.html)
    - [3.150. core_private_diy_float](https://doc.rust-lang.org/unstable-book/library-features/core-private-diy-float.html)
    - [3.151. cow_is_borrowed](https://doc.rust-lang.org/unstable-book/library-features/cow-is-borrowed.html)
    - [3.152. cstr_from_bytes_until_nul](https://doc.rust-lang.org/unstable-book/library-features/cstr-from-bytes-until-nul.html)
    - [3.153. cstr_internals](https://doc.rust-lang.org/unstable-book/library-features/cstr-internals.html)
    - [3.154. cursor_remaining](https://doc.rust-lang.org/unstable-book/library-features/cursor-remaining.html)
    - [3.155. deadline_api](https://doc.rust-lang.org/unstable-book/library-features/deadline-api.html)
    - [3.156. dec2flt](https://doc.rust-lang.org/unstable-book/library-features/dec2flt.html)
    - [3.157. default_free_fn](https://doc.rust-lang.org/unstable-book/library-features/default-free-fn.html)
    - [3.158. derive_clone_copy](https://doc.rust-lang.org/unstable-book/library-features/derive-clone-copy.html)
    - [3.159. derive_eq](https://doc.rust-lang.org/unstable-book/library-features/derive-eq.html)
    - [3.160. dir_entry_ext2](https://doc.rust-lang.org/unstable-book/library-features/dir-entry-ext2.html)
    - [3.161. discriminant_kind](https://doc.rust-lang.org/unstable-book/library-features/discriminant-kind.html)
    - [3.162. dispatch_from_dyn](https://doc.rust-lang.org/unstable-book/library-features/dispatch-from-dyn.html)
    - [3.163. div_duration](https://doc.rust-lang.org/unstable-book/library-features/div-duration.html)
    - [3.164. downcast_unchecked](https://doc.rust-lang.org/unstable-book/library-features/downcast-unchecked.html)
    - [3.165. drain_filter](https://doc.rust-lang.org/unstable-book/library-features/drain-filter.html)
    - [3.166. drain_keep_rest](https://doc.rust-lang.org/unstable-book/library-features/drain-keep-rest.html)
    - [3.167. duration_checked_float](https://doc.rust-lang.org/unstable-book/library-features/duration-checked-float.html)
    - [3.168. duration_constants](https://doc.rust-lang.org/unstable-book/library-features/duration-constants.html)
    - [3.169. duration_consts_float](https://doc.rust-lang.org/unstable-book/library-features/duration-consts-float.html)
    - [3.170. edition_panic](https://doc.rust-lang.org/unstable-book/library-features/edition-panic.html)
    - [3.171. entry_insert](https://doc.rust-lang.org/unstable-book/library-features/entry-insert.html)
    - [3.172. error_generic_member_access](https://doc.rust-lang.org/unstable-book/library-features/error-generic-member-access.html)
    - [3.173. error_in_core](https://doc.rust-lang.org/unstable-book/library-features/error-in-core.html)
    - [3.174. error_iter](https://doc.rust-lang.org/unstable-book/library-features/error-iter.html)
    - [3.175. error_reporter](https://doc.rust-lang.org/unstable-book/library-features/error-reporter.html)
    - [3.176. error_type_id](https://doc.rust-lang.org/unstable-book/library-features/error-type-id.html)
    - [3.177. exact_size_is_empty](https://doc.rust-lang.org/unstable-book/library-features/exact-size-is-empty.html)
    - [3.178. exclusive_wrapper](https://doc.rust-lang.org/unstable-book/library-features/exclusive-wrapper.html)
    - [3.179. exit_status_error](https://doc.rust-lang.org/unstable-book/library-features/exit-status-error.html)
    - [3.180. exitcode_exit_method](https://doc.rust-lang.org/unstable-book/library-features/exitcode-exit-method.html)
    - [3.181. extend_one](https://doc.rust-lang.org/unstable-book/library-features/extend-one.html)
    - [3.182. fd](https://doc.rust-lang.org/unstable-book/library-features/fd.html)
    - [3.183. fd_read](https://doc.rust-lang.org/unstable-book/library-features/fd-read.html)
    - [3.184. file_create_new](https://doc.rust-lang.org/unstable-book/library-features/file-create-new.html)
    - [3.185. file_set_times](https://doc.rust-lang.org/unstable-book/library-features/file-set-times.html)
    - [3.186. float_minimum_maximum](https://doc.rust-lang.org/unstable-book/library-features/float-minimum-maximum.html)
    - [3.187. float_next_up_down](https://doc.rust-lang.org/unstable-book/library-features/float-next-up-down.html)
    - [3.188. flt2dec](https://doc.rust-lang.org/unstable-book/library-features/flt2dec.html)
    - [3.189. fmt_helpers_for_derive](https://doc.rust-lang.org/unstable-book/library-features/fmt-helpers-for-derive.html)
    - [3.190. fmt_internals](https://doc.rust-lang.org/unstable-book/library-features/fmt-internals.html)
    - [3.191. fn_traits](https://doc.rust-lang.org/unstable-book/library-features/fn-traits.html)
    - [3.192. forget_unsized](https://doc.rust-lang.org/unstable-book/library-features/forget-unsized.html)
    - [3.193. format_args_nl](https://doc.rust-lang.org/unstable-book/library-features/format-args-nl.html)
    - [3.194. fs_try_exists](https://doc.rust-lang.org/unstable-book/library-features/fs-try-exists.html)
    - [3.195. future_join](https://doc.rust-lang.org/unstable-book/library-features/future-join.html)
    - [3.196. gen_future](https://doc.rust-lang.org/unstable-book/library-features/gen-future.html)
    - [3.197. generator_trait](https://doc.rust-lang.org/unstable-book/library-features/generator-trait.html)
    - [3.198. generic_assert_internals](https://doc.rust-lang.org/unstable-book/library-features/generic-assert-internals.html)
    - [3.199. get_mut_unchecked](https://doc.rust-lang.org/unstable-book/library-features/get-mut-unchecked.html)
    - [3.200. hash_drain_filter](https://doc.rust-lang.org/unstable-book/library-features/hash-drain-filter.html)
    - [3.201. hash_raw_entry](https://doc.rust-lang.org/unstable-book/library-features/hash-raw-entry.html)
    - [3.202. hash_set_entry](https://doc.rust-lang.org/unstable-book/library-features/hash-set-entry.html)
    - [3.203. hasher_prefixfree_extras](https://doc.rust-lang.org/unstable-book/library-features/hasher-prefixfree-extras.html)
    - [3.204. hashmap_internals](https://doc.rust-lang.org/unstable-book/library-features/hashmap-internals.html)
    - [3.205. hint_must_use](https://doc.rust-lang.org/unstable-book/library-features/hint-must-use.html)
    - [3.206. inplace_iteration](https://doc.rust-lang.org/unstable-book/library-features/inplace-iteration.html)
    - [3.207. int_error_internals](https://doc.rust-lang.org/unstable-book/library-features/int-error-internals.html)
    - [3.208. int_log](https://doc.rust-lang.org/unstable-book/library-features/int-log.html)
    - [3.209. int_roundings](https://doc.rust-lang.org/unstable-book/library-features/int-roundings.html)
    - [3.210. integer_atomics](https://doc.rust-lang.org/unstable-book/library-features/integer-atomics.html)
    - [3.211. internal_output_capture](https://doc.rust-lang.org/unstable-book/library-features/internal-output-capture.html)
    - [3.212. io_error_downcast](https://doc.rust-lang.org/unstable-book/library-features/io-error-downcast.html)
    - [3.213. io_error_more](https://doc.rust-lang.org/unstable-book/library-features/io-error-more.html)
    - [3.214. io_error_other](https://doc.rust-lang.org/unstable-book/library-features/io-error-other.html)
    - [3.215. io_error_uncategorized](https://doc.rust-lang.org/unstable-book/library-features/io-error-uncategorized.html)
    - [3.216. io_slice_advance](https://doc.rust-lang.org/unstable-book/library-features/io-slice-advance.html)
    - [3.217. ip](https://doc.rust-lang.org/unstable-book/library-features/ip.html)
    - [3.218. is_some_with](https://doc.rust-lang.org/unstable-book/library-features/is-some-with.html)
    - [3.219. is_sorted](https://doc.rust-lang.org/unstable-book/library-features/is-sorted.html)
    - [3.220. iter_advance_by](https://doc.rust-lang.org/unstable-book/library-features/iter-advance-by.html)
    - [3.221. iter_array_chunks](https://doc.rust-lang.org/unstable-book/library-features/iter-array-chunks.html)
    - [3.222. iter_collect_into](https://doc.rust-lang.org/unstable-book/library-features/iter-collect-into.html)
    - [3.223. iter_from_generator](https://doc.rust-lang.org/unstable-book/library-features/iter-from-generator.html)
    - [3.224. iter_intersperse](https://doc.rust-lang.org/unstable-book/library-features/iter-intersperse.html)
    - [3.225. iter_is_partitioned](https://doc.rust-lang.org/unstable-book/library-features/iter-is-partitioned.html)
    - [3.226. iter_next_chunk](https://doc.rust-lang.org/unstable-book/library-features/iter-next-chunk.html)
    - [3.227. iter_order_by](https://doc.rust-lang.org/unstable-book/library-features/iter-order-by.html)
    - [3.228. iter_partition_in_place](https://doc.rust-lang.org/unstable-book/library-features/iter-partition-in-place.html)
    - [3.229. iterator_try_collect](https://doc.rust-lang.org/unstable-book/library-features/iterator-try-collect.html)
    - [3.230. iterator_try_reduce](https://doc.rust-lang.org/unstable-book/library-features/iterator-try-reduce.html)
    - [3.231. layout_for_ptr](https://doc.rust-lang.org/unstable-book/library-features/layout-for-ptr.html)
    - [3.232. liballoc_internals](https://doc.rust-lang.org/unstable-book/library-features/liballoc-internals.html)
    - [3.233. libstd_sys_internals](https://doc.rust-lang.org/unstable-book/library-features/libstd-sys-internals.html)
    - [3.234. libstd_thread_internals](https://doc.rust-lang.org/unstable-book/library-features/libstd-thread-internals.html)
    - [3.235. linked_list_cursors](https://doc.rust-lang.org/unstable-book/library-features/linked-list-cursors.html)
    - [3.236. linked_list_remove](https://doc.rust-lang.org/unstable-book/library-features/linked-list-remove.html)
    - [3.237. linux_pidfd](https://doc.rust-lang.org/unstable-book/library-features/linux-pidfd.html)
    - [3.238. local_key_cell_methods](https://doc.rust-lang.org/unstable-book/library-features/local-key-cell-methods.html)
    - [3.239. log_syntax](https://doc.rust-lang.org/unstable-book/library-features/log-syntax.html)
    - [3.240. main_separator_str](https://doc.rust-lang.org/unstable-book/library-features/main-separator-str.html)
    - [3.241. map_entry_replace](https://doc.rust-lang.org/unstable-book/library-features/map-entry-replace.html)
    - [3.242. map_first_last](https://doc.rust-lang.org/unstable-book/library-features/map-first-last.html)
    - [3.243. map_many_mut](https://doc.rust-lang.org/unstable-book/library-features/map-many-mut.html)
    - [3.244. map_try_insert](https://doc.rust-lang.org/unstable-book/library-features/map-try-insert.html)
    - [3.245. maybe_uninit_array_assume_init](https://doc.rust-lang.org/unstable-book/library-features/maybe-uninit-array-assume-init.html)
    - [3.246. maybe_uninit_as_bytes](https://doc.rust-lang.org/unstable-book/library-features/maybe-uninit-as-bytes.html)
    - [3.247. maybe_uninit_slice](https://doc.rust-lang.org/unstable-book/library-features/maybe-uninit-slice.html)
    - [3.248. maybe_uninit_uninit_array](https://doc.rust-lang.org/unstable-book/library-features/maybe-uninit-uninit-array.html)
    - [3.249. maybe_uninit_write_slice](https://doc.rust-lang.org/unstable-book/library-features/maybe-uninit-write-slice.html)
    - [3.250. mem_copy_fn](https://doc.rust-lang.org/unstable-book/library-features/mem-copy-fn.html)
    - [3.251. mixed_integer_ops](https://doc.rust-lang.org/unstable-book/library-features/mixed-integer-ops.html)
    - [3.252. mutex_unlock](https://doc.rust-lang.org/unstable-book/library-features/mutex-unlock.html)
    - [3.253. mutex_unpoison](https://doc.rust-lang.org/unstable-book/library-features/mutex-unpoison.html)
    - [3.254. new_uninit](https://doc.rust-lang.org/unstable-book/library-features/new-uninit.html)
    - [3.255. nonnull_slice_from_raw_parts](https://doc.rust-lang.org/unstable-book/library-features/nonnull-slice-from-raw-parts.html)
    - [3.256. nonzero_bits](https://doc.rust-lang.org/unstable-book/library-features/nonzero-bits.html)
    - [3.257. nonzero_min_max](https://doc.rust-lang.org/unstable-book/library-features/nonzero-min-max.html)
    - [3.258. nonzero_ops](https://doc.rust-lang.org/unstable-book/library-features/nonzero-ops.html)
    - [3.259. numfmt](https://doc.rust-lang.org/unstable-book/library-features/numfmt.html)
    - [3.260. once_cell](https://doc.rust-lang.org/unstable-book/library-features/once-cell.html)
    - [3.261. one_sided_range](https://doc.rust-lang.org/unstable-book/library-features/one-sided-range.html)
    - [3.262. option_get_or_insert_default](https://doc.rust-lang.org/unstable-book/library-features/option-get-or-insert-default.html)
    - [3.263. option_result_contains](https://doc.rust-lang.org/unstable-book/library-features/option-result-contains.html)
    - [3.264. option_zip](https://doc.rust-lang.org/unstable-book/library-features/option-zip.html)
    - [3.265. panic_abort](https://doc.rust-lang.org/unstable-book/library-features/panic-abort.html)
    - [3.266. panic_always_abort](https://doc.rust-lang.org/unstable-book/library-features/panic-always-abort.html)
    - [3.267. panic_backtrace_config](https://doc.rust-lang.org/unstable-book/library-features/panic-backtrace-config.html)
    - [3.268. panic_can_unwind](https://doc.rust-lang.org/unstable-book/library-features/panic-can-unwind.html)
    - [3.269. panic_info_message](https://doc.rust-lang.org/unstable-book/library-features/panic-info-message.html)
    - [3.270. panic_internals](https://doc.rust-lang.org/unstable-book/library-features/panic-internals.html)
    - [3.271. panic_unwind](https://doc.rust-lang.org/unstable-book/library-features/panic-unwind.html)
    - [3.272. panic_update_hook](https://doc.rust-lang.org/unstable-book/library-features/panic-update-hook.html)
    - [3.273. path_file_prefix](https://doc.rust-lang.org/unstable-book/library-features/path-file-prefix.html)
    - [3.274. pattern](https://doc.rust-lang.org/unstable-book/library-features/pattern.html)
    - [3.275. peer_credentials_unix_socket](https://doc.rust-lang.org/unstable-book/library-features/peer-credentials-unix-socket.html)
    - [3.276. pin_deref_mut](https://doc.rust-lang.org/unstable-book/library-features/pin-deref-mut.html)
    - [3.277. pin_macro](https://doc.rust-lang.org/unstable-book/library-features/pin-macro.html)
    - [3.278. pointer_byte_offsets](https://doc.rust-lang.org/unstable-book/library-features/pointer-byte-offsets.html)
    - [3.279. pointer_is_aligned](https://doc.rust-lang.org/unstable-book/library-features/pointer-is-aligned.html)
    - [3.280. poll_ready](https://doc.rust-lang.org/unstable-book/library-features/poll-ready.html)
    - [3.281. portable_simd](https://doc.rust-lang.org/unstable-book/library-features/portable-simd.html)
    - [3.282. prelude_2024](https://doc.rust-lang.org/unstable-book/library-features/prelude-2024.html)
    - [3.283. print_internals](https://doc.rust-lang.org/unstable-book/library-features/print-internals.html)
    - [3.284. proc_macro_def_site](https://doc.rust-lang.org/unstable-book/library-features/proc-macro-def-site.html)
    - [3.285. proc_macro_diagnostic](https://doc.rust-lang.org/unstable-book/library-features/proc-macro-diagnostic.html)
    - [3.286. proc_macro_expand](https://doc.rust-lang.org/unstable-book/library-features/proc-macro-expand.html)
    - [3.287. proc_macro_internals](https://doc.rust-lang.org/unstable-book/library-features/proc-macro-internals.html)
    - [3.288. proc_macro_quote](https://doc.rust-lang.org/unstable-book/library-features/proc-macro-quote.html)
    - [3.289. proc_macro_span](https://doc.rust-lang.org/unstable-book/library-features/proc-macro-span.html)
    - [3.290. proc_macro_span_shrink](https://doc.rust-lang.org/unstable-book/library-features/proc-macro-span-shrink.html)
    - [3.291. proc_macro_tracked_env](https://doc.rust-lang.org/unstable-book/library-features/proc-macro-tracked-env.html)
    - [3.292. process_exitcode_internals](https://doc.rust-lang.org/unstable-book/library-features/process-exitcode-internals.html)
    - [3.293. process_internals](https://doc.rust-lang.org/unstable-book/library-features/process-internals.html)
    - [3.294. profiler_runtime_lib](https://doc.rust-lang.org/unstable-book/library-features/profiler-runtime-lib.html)
    - [3.295. provide_any](https://doc.rust-lang.org/unstable-book/library-features/provide-any.html)
    - [3.296. ptr_as_uninit](https://doc.rust-lang.org/unstable-book/library-features/ptr-as-uninit.html)
    - [3.297. ptr_internals](https://doc.rust-lang.org/unstable-book/library-features/ptr-internals.html)
    - [3.298. ptr_mask](https://doc.rust-lang.org/unstable-book/library-features/ptr-mask.html)
    - [3.299. ptr_metadata](https://doc.rust-lang.org/unstable-book/library-features/ptr-metadata.html)
    - [3.300. ptr_sub_ptr](https://doc.rust-lang.org/unstable-book/library-features/ptr-sub-ptr.html)
    - [3.301. ptr_to_from_bits](https://doc.rust-lang.org/unstable-book/library-features/ptr-to-from-bits.html)
    - [3.302. pub_crate_should_not_need_unstable_attr](https://doc.rust-lang.org/unstable-book/library-features/pub-crate-should-not-need-unstable-attr.html)
    - [3.303. raw_os_nonzero](https://doc.rust-lang.org/unstable-book/library-features/raw-os-nonzero.html)
    - [3.304. raw_slice_split](https://doc.rust-lang.org/unstable-book/library-features/raw-slice-split.html)
    - [3.305. raw_vec_internals](https://doc.rust-lang.org/unstable-book/library-features/raw-vec-internals.html)
    - [3.306. read_buf](https://doc.rust-lang.org/unstable-book/library-features/read-buf.html)
    - [3.307. receiver_trait](https://doc.rust-lang.org/unstable-book/library-features/receiver-trait.html)
    - [3.308. restricted_std](https://doc.rust-lang.org/unstable-book/library-features/restricted-std.html)
    - [3.309. result_contains_err](https://doc.rust-lang.org/unstable-book/library-features/result-contains-err.html)
    - [3.310. result_flattening](https://doc.rust-lang.org/unstable-book/library-features/result-flattening.html)
    - [3.311. result_option_inspect](https://doc.rust-lang.org/unstable-book/library-features/result-option-inspect.html)
    - [3.312. round_char_boundary](https://doc.rust-lang.org/unstable-book/library-features/round-char-boundary.html)
    - [3.313. rt](https://doc.rust-lang.org/unstable-book/library-features/rt.html)
    - [3.314. saturating_int_assign_impl](https://doc.rust-lang.org/unstable-book/library-features/saturating-int-assign-impl.html)
    - [3.315. saturating_int_impl](https://doc.rust-lang.org/unstable-book/library-features/saturating-int-impl.html)
    - [3.316. sealed](https://doc.rust-lang.org/unstable-book/library-features/sealed.html)
    - [3.317. seek_stream_len](https://doc.rust-lang.org/unstable-book/library-features/seek-stream-len.html)
    - [3.318. set_ptr_value](https://doc.rust-lang.org/unstable-book/library-features/set-ptr-value.html)
    - [3.319. setgroups](https://doc.rust-lang.org/unstable-book/library-features/setgroups.html)
    - [3.320. sgx_platform](https://doc.rust-lang.org/unstable-book/library-features/sgx-platform.html)
    - [3.321. slice_as_chunks](https://doc.rust-lang.org/unstable-book/library-features/slice-as-chunks.html)
    - [3.322. slice_concat_ext](https://doc.rust-lang.org/unstable-book/library-features/slice-concat-ext.html)
    - [3.323. slice_concat_trait](https://doc.rust-lang.org/unstable-book/library-features/slice-concat-trait.html)
    - [3.324. slice_flatten](https://doc.rust-lang.org/unstable-book/library-features/slice-flatten.html)
    - [3.325. slice_from_ptr_range](https://doc.rust-lang.org/unstable-book/library-features/slice-from-ptr-range.html)
    - [3.326. slice_group_by](https://doc.rust-lang.org/unstable-book/library-features/slice-group-by.html)
    - [3.327. slice_index_methods](https://doc.rust-lang.org/unstable-book/library-features/slice-index-methods.html)
    - [3.328. slice_internals](https://doc.rust-lang.org/unstable-book/library-features/slice-internals.html)
    - [3.329. slice_iter_mut_as_mut_slice](https://doc.rust-lang.org/unstable-book/library-features/slice-iter-mut-as-mut-slice.html)
    - [3.330. slice_partition_dedup](https://doc.rust-lang.org/unstable-book/library-features/slice-partition-dedup.html)
    - [3.331. slice_pattern](https://doc.rust-lang.org/unstable-book/library-features/slice-pattern.html)
    - [3.332. slice_ptr_get](https://doc.rust-lang.org/unstable-book/library-features/slice-ptr-get.html)
    - [3.333. slice_ptr_len](https://doc.rust-lang.org/unstable-book/library-features/slice-ptr-len.html)
    - [3.334. slice_range](https://doc.rust-lang.org/unstable-book/library-features/slice-range.html)
    - [3.335. slice_split_at_unchecked](https://doc.rust-lang.org/unstable-book/library-features/slice-split-at-unchecked.html)
    - [3.336. slice_swap_unchecked](https://doc.rust-lang.org/unstable-book/library-features/slice-swap-unchecked.html)
    - [3.337. slice_take](https://doc.rust-lang.org/unstable-book/library-features/slice-take.html)
    - [3.338. solid_ext](https://doc.rust-lang.org/unstable-book/library-features/solid-ext.html)
    - [3.339. sort_floats](https://doc.rust-lang.org/unstable-book/library-features/sort-floats.html)
    - [3.340. sort_internals](https://doc.rust-lang.org/unstable-book/library-features/sort-internals.html)
    - [3.341. split_array](https://doc.rust-lang.org/unstable-book/library-features/split-array.html)
    - [3.342. split_as_slice](https://doc.rust-lang.org/unstable-book/library-features/split-as-slice.html)
    - [3.343. std_internals](https://doc.rust-lang.org/unstable-book/library-features/std-internals.html)
    - [3.344. stdio_makes_pipe](https://doc.rust-lang.org/unstable-book/library-features/stdio-makes-pipe.html)
    - [3.345. stdsimd](https://doc.rust-lang.org/unstable-book/library-features/stdsimd.html)
    - [3.346. step_trait](https://doc.rust-lang.org/unstable-book/library-features/step-trait.html)
    - [3.347. str_internals](https://doc.rust-lang.org/unstable-book/library-features/str-internals.html)
    - [3.348. str_split_as_str](https://doc.rust-lang.org/unstable-book/library-features/str-split-as-str.html)
    - [3.349. str_split_inclusive_as_str](https://doc.rust-lang.org/unstable-book/library-features/str-split-inclusive-as-str.html)
    - [3.350. str_split_whitespace_as_str](https://doc.rust-lang.org/unstable-book/library-features/str-split-whitespace-as-str.html)
    - [3.351. strict_provenance_atomic_ptr](https://doc.rust-lang.org/unstable-book/library-features/strict-provenance-atomic-ptr.html)
    - [3.352. string_extend_from_within](https://doc.rust-lang.org/unstable-book/library-features/string-extend-from-within.html)
    - [3.353. string_remove_matches](https://doc.rust-lang.org/unstable-book/library-features/string-remove-matches.html)
    - [3.354. sync_unsafe_cell](https://doc.rust-lang.org/unstable-book/library-features/sync-unsafe-cell.html)
    - [3.355. tcp_linger](https://doc.rust-lang.org/unstable-book/library-features/tcp-linger.html)
    - [3.356. tcp_quickack](https://doc.rust-lang.org/unstable-book/library-features/tcp-quickack.html)
    - [3.357. tcplistener_into_incoming](https://doc.rust-lang.org/unstable-book/library-features/tcplistener-into-incoming.html)
    - [3.358. test](https://doc.rust-lang.org/unstable-book/library-features/test.html)
    - [3.359. thin_box](https://doc.rust-lang.org/unstable-book/library-features/thin-box.html)
    - [3.360. thread_id_value](https://doc.rust-lang.org/unstable-book/library-features/thread-id-value.html)
    - [3.361. thread_local_internals](https://doc.rust-lang.org/unstable-book/library-features/thread-local-internals.html)
    - [3.362. thread_spawn_unchecked](https://doc.rust-lang.org/unstable-book/library-features/thread-spawn-unchecked.html)
    - [3.363. trace_macros](https://doc.rust-lang.org/unstable-book/library-features/trace-macros.html)
    - [3.364. track_path](https://doc.rust-lang.org/unstable-book/library-features/track-path.html)
    - [3.365. transmutability](https://doc.rust-lang.org/unstable-book/library-features/transmutability.html)
    - [3.366. trusted_len](https://doc.rust-lang.org/unstable-book/library-features/trusted-len.html)
    - [3.367. trusted_random_access](https://doc.rust-lang.org/unstable-book/library-features/trusted-random-access.html)
    - [3.368. trusted_step](https://doc.rust-lang.org/unstable-book/library-features/trusted-step.html)
    - [3.369. try_find](https://doc.rust-lang.org/unstable-book/library-features/try-find.html)
    - [3.370. try_reserve_kind](https://doc.rust-lang.org/unstable-book/library-features/try-reserve-kind.html)
    - [3.371. try_trait_v2](https://doc.rust-lang.org/unstable-book/library-features/try-trait-v2.html)
    - [3.372. try_trait_v2_residual](https://doc.rust-lang.org/unstable-book/library-features/try-trait-v2-residual.html)
    - [3.373. try_trait_v2_yeet](https://doc.rust-lang.org/unstable-book/library-features/try-trait-v2-yeet.html)
    - [3.374. tuple_trait](https://doc.rust-lang.org/unstable-book/library-features/tuple-trait.html)
    - [3.375. type_name_of_val](https://doc.rust-lang.org/unstable-book/library-features/type-name-of-val.html)
    - [3.376. unchecked_math](https://doc.rust-lang.org/unstable-book/library-features/unchecked-math.html)
    - [3.377. unicode_internals](https://doc.rust-lang.org/unstable-book/library-features/unicode-internals.html)
    - [3.378. unix_chown](https://doc.rust-lang.org/unstable-book/library-features/unix-chown.html)
    - [3.379. unix_set_mark](https://doc.rust-lang.org/unstable-book/library-features/unix-set-mark.html)
    - [3.380. unix_socket_abstract](https://doc.rust-lang.org/unstable-book/library-features/unix-socket-abstract.html)
    - [3.381. unix_socket_ancillary_data](https://doc.rust-lang.org/unstable-book/library-features/unix-socket-ancillary-data.html)
    - [3.382. unix_socket_peek](https://doc.rust-lang.org/unstable-book/library-features/unix-socket-peek.html)
    - [3.383. unsize](https://doc.rust-lang.org/unstable-book/library-features/unsize.html)
    - [3.384. unwrap_infallible](https://doc.rust-lang.org/unstable-book/library-features/unwrap-infallible.html)
    - [3.385. unzip_option](https://doc.rust-lang.org/unstable-book/library-features/unzip-option.html)
    - [3.386. update_panic_count](https://doc.rust-lang.org/unstable-book/library-features/update-panic-count.html)
    - [3.387. utf16_extra](https://doc.rust-lang.org/unstable-book/library-features/utf16-extra.html)
    - [3.388. utf16_extra_const](https://doc.rust-lang.org/unstable-book/library-features/utf16-extra-const.html)
    - [3.389. utf8_chunks](https://doc.rust-lang.org/unstable-book/library-features/utf8-chunks.html)
    - [3.390. variant_count](https://doc.rust-lang.org/unstable-book/library-features/variant-count.html)
    - [3.391. vec_into_raw_parts](https://doc.rust-lang.org/unstable-book/library-features/vec-into-raw-parts.html)
    - [3.392. vec_split_at_spare](https://doc.rust-lang.org/unstable-book/library-features/vec-split-at-spare.html)
    - [3.393. waker_getters](https://doc.rust-lang.org/unstable-book/library-features/waker-getters.html)
    - [3.394. wasi_ext](https://doc.rust-lang.org/unstable-book/library-features/wasi-ext.html)
    - [3.395. windows_by_handle](https://doc.rust-lang.org/unstable-book/library-features/windows-by-handle.html)
    - [3.396. windows_c](https://doc.rust-lang.org/unstable-book/library-features/windows-c.html)
    - [3.397. windows_handle](https://doc.rust-lang.org/unstable-book/library-features/windows-handle.html)
    - [3.398. windows_net](https://doc.rust-lang.org/unstable-book/library-features/windows-net.html)
    - [3.399. windows_process_exit_code_from](https://doc.rust-lang.org/unstable-book/library-features/windows-process-exit-code-from.html)
    - [3.400. windows_process_extensions_async_pipes](https://doc.rust-lang.org/unstable-book/library-features/windows-process-extensions-async-pipes.html)
    - [3.401. windows_process_extensions_force_quotes](https://doc.rust-lang.org/unstable-book/library-features/windows-process-extensions-force-quotes.html)
    - [3.402. windows_process_extensions_main_thread_handle](https://doc.rust-lang.org/unstable-book/library-features/windows-process-extensions-main-thread-handle.html)
    - [3.403. windows_stdio](https://doc.rust-lang.org/unstable-book/library-features/windows-stdio.html)
    - [3.404. wrapping_int_impl](https://doc.rust-lang.org/unstable-book/library-features/wrapping-int-impl.html)
    - [3.405. wrapping_next_power_of_two](https://doc.rust-lang.org/unstable-book/library-features/wrapping-next-power-of-two.html)
    - [3.406. write_all_vectored](https://doc.rust-lang.org/unstable-book/library-features/write-all-vectored.html)
    - [3.407. yeet_desugar_details](https://doc.rust-lang.org/unstable-book/library-features/yeet-desugar-details.html)


## üü¢üîµThe WebAssembly System Interface (WASI)

- [Introduction](wasmtime/docs/introduction.md)
- [Tutorial](wasmtime/docs/tutorial.md)
  - [Creating `hello-world.wasm`](wasmtime/docs/tutorial-create-hello-world.md)
  - [Running `hello-world.wasm`](wasmtime/docs/tutorial-run-hello-world.md)
- [Examples](wasmtime/docs/examples.md)
  - [Markdown Parser](wasmtime/docs/examples-markdown.md)
  - [Debugging WebAssembly](wasmtime/docs/examples-debugging.md)
  - [Profiling WebAssembly](wasmtime/docs/examples-profiling.md)
    - [Profiling with Perf](wasmtime/docs/examples-profiling-perf.md)
    - [Profiling with VTune](wasmtime/docs/examples-profiling-vtune.md)
  - [Embedding in Rust](wasmtime/docs/examples-rust-embed.md)
    - [Hello, world!](wasmtime/docs/examples-rust-hello-world.md)
    - [Calculating the GCD](wasmtime/docs/examples-rust-gcd.md)
    - [Using Linear Memory](wasmtime/docs/examples-rust-memory.md)
    - [WASI](wasmtime/docs/examples-rust-wasi.md)
    - [Linking Modules](wasmtime/docs/examples-rust-linking.md)
    - [Debugging](wasmtime/docs/examples-rust-debugging.md)
    - [Using Multi-Value](wasmtime/docs/examples-rust-multi-value.md)
  - [Embedding in C](wasmtime/docs/examples-c-embed.md)
    - [Hello, World!](wasmtime/docs/examples-c-hello-world.md)
    - [Calculating the GCD](wasmtime/docs/examples-c-gcd.md)
    - [Using Linear Memory](wasmtime/docs/examples-c-memory.md)
    - [WASI](wasmtime/docs/examples-c-wasi.md)
    - [Linking Modules](wasmtime/docs/examples-c-linking.md)
    - [Debugging](wasmtime/docs/examples-c-debugging.md)
    - [Using Multi-Value](wasmtime/docs/examples-c-multi-value.md)
- [Using WebAssembly from your language](wasmtime/docs/lang.md)
  - [Rust](wasmtime/docs/lang-rust.md)
  - [C](wasmtime/docs/lang-c.md)
  - [Python](wasmtime/docs/lang-python.md)
  - [.NET](wasmtime/docs/lang-dotnet.md)
  - [Go](wasmtime/docs/lang-go.md)
  - [Bash](wasmtime/docs/lang-bash.md)
- [Using the `wasmtime` CLI](wasmtime/docs/cli.md)
  - [Installation](wasmtime/docs/cli-install.md)
  - [CLI Options](wasmtime/docs/cli-options.md)
  - [Cache Configuration](wasmtime/docs/cli-cache.md)
- [Writing WebAssembly](wasmtime/docs/wasm.md)
  - [Rust](wasmtime/docs/wasm-rust.md)
  - [C/C++](wasmtime/docs/wasm-c.md)
  - [AssemblyScript](wasmtime/docs/wasm-assemblyscript.md)
  - [WebAssembly Text Format (`*.wat`)](wasmtime/docs/wasm-wat.md)
- [Stability](stability.md)
  - [Release Process](wasmtime/docs/stability-release.md)
  - [Tiers of support](wasmtime/docs/stability-tiers.md)
  - [Platform Support](wasmtime/docs/stability-platform-support.md)
  - [Wasm Proposals Support](wasmtime/docs/stability-wasm-proposals-support.md)
- [Security](security.md)
  - [Disclosure Policy](wasmtime/docs/security-disclosure.md)
- [Contributing](contributing.md)
  - [Architecture](wasmtime/docs/contributing-architecture.md)
  - [Building](wasmtime/docs/contributing-building.md)
  - [Testing](wasmtime/docs/contributing-testing.md)
  - [Fuzzing](wasmtime/docs/contributing-fuzzing.md)
  - [CI](wasmtime/docs/contributing-ci.md)
  - [Cross Compiling](wasmtime/docs/contributing-cross-compiling.md)
  - [Coding Guidelines](wasmtime/docs/contributing-coding-guidelines.md)
  - [Development Process](wasmtime/docs/contributing-development-process.md)
  - [Release Process](wasmtime/docs/contributing-release-process.md)
  - [Implementing Wasm Proposals](wasmtime/docs/contributing-implementing-wasm-proposals.md)
  - [Governance](wasmtime/docs/contributing-governance.md)
  - [Code of Conduct](wasmtime/docs/contributing-coc.md)


## üü¢üîµThe `wasm-bindgen` Guide

[Introduction](wasm-bindgen/guide/src/introduction.md)

--------------------------------------------------------------------------------

- [Examples](wasm-bindgen/guide/src/examples/index.md)
  - [Hello, World!](wasm-bindgen/guide/src/examples/hello-world.md)
  - [Using `console.log`](wasm-bindgen/guide/src/examples/console-log.md)
  - [Small wasm files](wasm-bindgen/guide/src/examples/add.md)
  - [Without a Bundler](wasm-bindgen/guide/src/examples/without-a-bundler.md)
  - [Converting WebAssembly to JS](wasm-bindgen/guide/src/examples/wasm2js.md)
  - [Importing functions from JS](wasm-bindgen/guide/src/examples/import-js.md)
  - [Working with `char`](wasm-bindgen/guide/src/examples/char.md)
  - [js-sys: WebAssembly in WebAssembly](wasm-bindgen/guide/src/examples/wasm-in-wasm.md)
  - [web-sys: DOM hello world](wasm-bindgen/guide/src/examples/dom.md)
  - [web-sys: Closures](wasm-bindgen/guide/src/examples/closures.md)
  - [web-sys: `performance.now`](wasm-bindgen/guide/src/examples/performance.md)
  - [web-sys: using `fetch`](wasm-bindgen/guide/src/examples/fetch.md)
  - [web-sys: `canvas` hello world](wasm-bindgen/guide/src/examples/2d-canvas.md)
  - [web-sys: `canvas` Julia set](wasm-bindgen/guide/src/examples/julia.md)
  - [web-sys: WebAudio](wasm-bindgen/guide/src/examples/web-audio.md)
  - [web-sys: WebGL](wasm-bindgen/guide/src/examples/webgl.md)
  - [web-sys: WebSockets](wasm-bindgen/guide/src/examples/websockets.md)
  - [web-sys: WebRTC DataChannel](wasm-bindgen/guide/src/examples/webrtc_datachannel.md)
  - [web-sys: `requestAnimationFrame`](wasm-bindgen/guide/src/examples/request-animation-frame.md)
  - [web-sys: A Simple Paint Program](wasm-bindgen/guide/src/examples/paint.md)
  - [web-sys: WASM in Web Worker](wasm-bindgen/guide/src/examples/wasm-in-web-worker.md)
  - [Parallel Raytracing](wasm-bindgen/guide/src/examples/raytrace.md)
  - [WASM Audio Worklet](wasm-bindgen/guide/src/examples/wasm-audio-worklet.md)
  - [web-sys: A TODO MVC App](wasm-bindgen/guide/src/examples/todomvc.md)
- [Reference](wasm-bindgen/guide/src/reference/index.md)
  - [Deployment](wasm-bindgen/guide/src/reference/deployment.md)
  - [JS snippets](wasm-bindgen/guide/src/reference/js-snippets.md)
  - [Static JS Objects](wasm-bindgen/guide/src/reference/static-js-objects.md)
  - [Passing Rust Closures to JS](wasm-bindgen/guide/src/reference/passing-rust-closures-to-js.md)
  - [Receiving JS Closures in Rust](wasm-bindgen/guide/src/reference/receiving-js-closures-in-rust.md)
  - [`Promise`s and `Future`s](wasm-bindgen/guide/src/reference/js-promises-and-rust-futures.md)
  - [Iterating over JS Values](wasm-bindgen/guide/src/reference/iterating-over-js-values.md)
  - [Arbitrary Data with Serde](wasm-bindgen/guide/src/reference/arbitrary-data-with-serde.md)
  - [Accessing Properties of Untyped JS Values](wasm-bindgen/guide/src/reference/accessing-properties-of-untyped-js-values.md)
  - [Working with Duck-Typed Interfaces](wasm-bindgen/guide/src/reference/working-with-duck-typed-interfaces.md)
  - [Command Line Interface](wasm-bindgen/guide/src/reference/cli.md)
  - [Optimizing for Size](wasm-bindgen/guide/src/reference/optimize-size.md)
  - [Supported Rust Targets](wasm-bindgen/guide/src/reference/rust-targets.md)
  - [Supported Browsers](wasm-bindgen/guide/src/reference/browser-support.md)
  - [Support for Weak References](wasm-bindgen/guide/src/reference/weak-references.md)
  - [Support for Reference Types](wasm-bindgen/guide/src/reference/reference-types.md)
  - [Supported Types](wasm-bindgen/guide/src/reference/types.md)
    - [Imported JavaScript Types](wasm-bindgen/guide/src/reference/types/imported-js-types.md)
    - [Exported Rust Types](wasm-bindgen/guide/src/reference/types/exported-rust-types.md)
    - [`JsValue`](wasm-bindgen/guide/src/reference/types/jsvalue.md)
    - [`Box<[JsValue]>`](wasm-bindgen/guide/src/reference/types/boxed-jsvalue-slice.md)
    - [`*const T` and `*mut T`](wasm-bindgen/guide/src/reference/types/pointers.md)
    - [Numbers](wasm-bindgen/guide/src/reference/types/numbers.md)
    - [`bool`](wasm-bindgen/guide/src/reference/types/bool.md)
    - [`char`](wasm-bindgen/guide/src/reference/types/char.md)
    - [`str`](wasm-bindgen/guide/src/reference/types/str.md)
    - [`String`](wasm-bindgen/guide/src/reference/types/string.md)
    - [Number Slices](wasm-bindgen/guide/src/reference/types/number-slices.md)
    - [Boxed Number Slices](wasm-bindgen/guide/src/reference/types/boxed-number-slices.md)
    - [`Result<T, E>`](wasm-bindgen/guide/src/reference/types/result.md)
  - [`#[wasm_bindgen]` Attributes](wasm-bindgen/guide/src/reference/attributes/index.md)
    - [On JavaScript Imports](wasm-bindgen/guide/src/reference/attributes/on-js-imports/index.md)
      - [`catch`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/catch.md)
      - [`constructor`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/constructor.md)
      - [`extends`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/extends.md)
      - [`getter` and `setter`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/getter-and-setter.md)
      - [`final`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/final.md)
      - [`indexing_getter`, `indexing_setter`, and `indexing_deleter`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/indexing-getter-setter-deleter.md)
      - [`js_class = "Blah"`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/js_class.md)
      - [`js_name`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/js_name.md)
      - [`js_namespace`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/js_namespace.md)
      - [`method`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/method.md)
      - [`module = "blah"`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/module.md)
      - [`raw_module = "blah"`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/raw_module.md)
      - [`static_method_of = Blah`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/static_method_of.md)
      - [`structural`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/structural.md)
      - [`variadic`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/variadic.md)
      - [`vendor_prefix`](wasm-bindgen/guide/src/reference/attributes/on-js-imports/vendor_prefix.md)
    - [On Rust Exports](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/index.md)
      - [`constructor`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/constructor.md)
      - [`js_name = Blah`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/js_name.md)
      - [`readonly`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/readonly.md)
      - [`skip`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/skip.md)
      - [`start`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/start.md)
      - [`typescript_custom_section`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/typescript_custom_section.md)
      - [`getter` and `setter`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/getter-and-setter.md)
      - [`inspectable`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/inspectable.md)
      - [`skip_typescript`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/skip_typescript.md)
      - [`typescript_type`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/typescript_type.md)
      - [`getter_with_clone`](wasm-bindgen/guide/src/reference/attributes/on-rust-exports/getter_with_clone.md)

- [`web-sys`](wasm-bindgen/guide/src/web-sys/index.md)
  - [Using `web-sys`](wasm-bindgen/guide/src/web-sys/using-web-sys.md)
  - [Cargo Features](wasm-bindgen/guide/src/web-sys/cargo-features.md)
  - [Function Overloads](wasm-bindgen/guide/src/web-sys/function-overloads.md)
  - [Type Translations](wasm-bindgen/guide/src/web-sys/type-translations.md)
  - [Inheritance](wasm-bindgen/guide/src/web-sys/inheritance.md)
  - [Unstable APIs](wasm-bindgen/guide/src/web-sys/unstable-apis.md)

- [Testing with `wasm-bindgen-test`](wasm-bindgen/guide/src/wasm-bindgen-test/index.md)
  - [Usage](wasm-bindgen/guide/src/wasm-bindgen-test/usage.md)
  - [Writing Asynchronous Tests](wasm-bindgen/guide/src/wasm-bindgen-test/asynchronous-tests.md)
  - [Testing in Headless Browsers](wasm-bindgen/guide/src/wasm-bindgen-test/browsers.md)
  - [Continuous Integration](wasm-bindgen/guide/src/wasm-bindgen-test/continuous-integration.md)

- [Contributing to `wasm-bindgen`](wasm-bindgen/guide/src/contributing/index.md)
  - [Testing](wasm-bindgen/guide/src/contributing/testing.md)
  - [Internal Design](wasm-bindgen/guide/src/contributing/design/index.md)
    - [JS Objects in Rust](wasm-bindgen/guide/src/contributing/design/js-objects-in-rust.md)
    - [Exporting a function to JS](wasm-bindgen/guide/src/contributing/design/exporting-rust.md)
    - [Exporting a struct to JS](wasm-bindgen/guide/src/contributing/design/exporting-rust-struct.md)
    - [Importing a function from JS](wasm-bindgen/guide/src/contributing/design/importing-js.md)
    - [Importing a class from JS](wasm-bindgen/guide/src/contributing/design/importing-js-struct.md)
    - [Rust Type conversions](wasm-bindgen/guide/src/contributing/design/rust-type-conversions.md)
    - [Types in `wasm-bindgen`](wasm-bindgen/guide/src/contributing/design/describe.md)
  - [`js-sys`](wasm-bindgen/guide/src/contributing/js-sys/index.md)
    - [Testing](wasm-bindgen/guide/src/contributing/js-sys/testing.md)
    - [Adding More APIs](wasm-bindgen/guide/src/contributing/js-sys/adding-more-apis.md)
  - [`web-sys`](wasm-bindgen/guide/src/contributing/web-sys/index.md)
    - [Overview](wasm-bindgen/guide/src/contributing/web-sys/overview.md)
    - [Testing](wasm-bindgen/guide/src/contributing/web-sys/testing.md)
    - [Logging](wasm-bindgen/guide/src/contributing/web-sys/logging.md)
    - [Supporting More Web APIs](wasm-bindgen/guide/src/contributing/web-sys/supporting-more-web-apis.md)
  - [Publishing](wasm-bindgen/guide/src/contributing/publishing.md)
  - [Team](wasm-bindgen/guide/src/contributing/team.md)


## üü¢üîµ Compilers Principles
- Crafting Interpreters - A handbook for making programming languages http://www.craftinginter-preters.com/contents.html
- Compilers: Principles, Techniques, and Tools 2nd - Dragon book ÁºñËØëÂéüÁêÜÈæô‰π¶
- ÁºñËØëÂéüÁêÜÔºàÂìàÂ∑•Â§ßÔºâ https://www.bilibili.com/video/av17649289

- Table of Contents

- 1 Introduction
- 2 A Simple Syntax-Directed Translator
- 3 Lexical Analysis
- 4 Syntax Analysis
- 5 Syntax-Directed Translation
- 7 Run-Time Environments 427
- 8 Code Generation
- 9 Machine-Independent Optimizations
- 10 Instruction-Level Parallelism
- 11 Optimizing for Parallelism and Locality
- 12 Interprocedural Analysis
- A A Complete Front End
- B Finding Linearly Independent Solutions


- 1 Introduction
    - 1.1 Language Processors
        - 1.1.1 Exercises for Section 1.1
    - 1.2 The Structure of a Compiler
        - 1.2.1 Lexical Analysis
        - 1.2.2 Syntax Analysis
        - 1.2.3 Semantic Analysis
        - 1.2.4 Intermediate Code Generation
        - 1.2.5 Code Optimization
        - 1.2.6 Code Generation
        - 1.2.7 Symbol-Table Management
        - 1.2.8 The Grouping of Phases into Passes
        - 1.2.9 Compiler-Construction Tools
    - 1.3 The Evolution of Programming Languages
        - 1.3.1 The Move to Higher-level Languages
        - 1.3.2 Impacts on Compilers
        - 1.3.3 Exercises for Section 1.3
    - 1.4 The Science of Building a Compiler
        - 1.4.1 Modeling in Compiler Design and Implementation
        - 1.4.2 The Science of Code Optimization
    - 1.5 Applications of Compiler Technology
        - 1.5.1 Implementation of High-Level Programming Languages
        - 1.5.2 Optimizations for Computer Architectures
        - 1.5.3 Design of New Computer Architectures
        - 1.5.4 Program Translations
        - 1.5.5 Software Productivity Tools
    - 1.6 Programming Language Basics
        - 1.6.1 The Static/Dynamic Distinction
        - 1.6.2 Environments and States
        - 1.6.3 Static Scope and Block Structure
        - 1.6.4 Explicit Access Control
        - 1.6.5 Dynamic Scope
        - 1.6.6 Parameter Passing Mechanisms
        - 1.6.7 Aliasing
        - 1.6.8 Exercises for Section 1.6
    - 1.7 Summary of Chapter 1
    - 1.8 References for Chapter 1
- 2 A Simple Syntax-Directed Translator
    - 2.1 Introduction
    - 2.2 Syntax Definition
        - 2.2.1 Definition of Grammars
        - 2.2.2 Derivations
        - 2.2.3 Parse Trees
        - 2.2.4 Ambiguity
        - 2.2.5 Associativity of Operators
        - 2.2.6 Precedence of Operators
        - 2.2.7 Exercises for Section 2.2
    - 2.3 Syntax-Directed Translation
        - 2.3.1 Postfix Notation
        - 2.3.2 Synthesized Attributes
        - 2.3.3 Simple Syntax-Directed Definitions
        - 2.3.4 Tree Traversals
        - 2.3.5 Translation Schemes
        - 2.3.6 Exercises for Section 2.3
    - 2.4 Parsing
        - 2.4.1 Top-Down Parsing
        - 2.4.2 Predictive Parsing
        - 2.4.3 When to Use c-Productions
        - 2.4.4 Designing a Predictive Parser
        - 2.4.5 Left Recursion
        - 2.4.6 Exercises for Section 2.4
    - 2.5 A Translator for Simple Expressions
        - 2.5.1 Abstract and Concrete Syntax
        - 2.5.2 Adapting the Translation Scheme
        - 2.5.3 Procedures for the Nonterminals
        - 2.5.4 Simplifying the Translator
        - 2.5.5 The Complete Program
    - 2.6 Lexical Analysis
        - 2.6.1 Removal of White Space and Comments
        - 2.6.2 Reading Ahead
        - 2.6.3 Constants
        - 2.6.4 Recognizing Keywords and Identifiers
        - 2.6.5 A Lexical Analyzer
        - 2.6.6 Exercises for Section 2.6
    - 2.7 Symbol Tables
        - 2.7.1 Symbol Table Per Scope
        - 2.7.2 The Use of Symbol Tables
    - 2.8 Intermediate Code Generation
        - 2.8.1 Two Kinds of Intermediate Representations
        - 2.8.2 Construction of Syntax Trees
        - 2.8.3 Static Checking
        - 2.8.4 Three-Address Code
        - 2.8.5 Exercises for Section 2.8
    - 2.9 Summary of Chapter 2
- 3 Lexical Analysis
    - 3.1 The Role of the Lexical Analyzer
        - 3.1.1 Lexical Analysis Versus Parsing
        - 3.1.2 Tokens, Patterns, and Lexemes
        - 3.1.3 Attributes for Tokens
        - 3.1.4 Lexical Errors
        - 3.1.5 Exercises for Section 3.1
    - 3.2 Input Buffering
        - 3.2.1 Buffer Pairs
        - 3.2.2 Sentinels
    - 3.3 Specification of Tokens
    - 3.4 Recognition of Tokens
    - 3.5 The Lexical - Analyzer Generator Lex
        - 3.3.1 Strings and Languages
        - 3.3.2 Operations on Languages
        - 3.3.3 Regular Expressions
        - 3.3.4 Regular Definitions
        - 3.3.5 Extensions of Regular Expressions
        - 3.3.6 Exercises for Section 3.3
        - 3.4.1 Transition Diagrams
        - 3.4.2 Recognition of Reserved Words and Identifiers
        - 3.4.3 Completion of the Running Example
        - 3.4.4 Architecture of a Transition-Diagram-Based Lexical Analyzer
        - 3.4.5 Exercises for Section 3.4
        - 3.5.1 Use of Lex
        - 3.5.2 Structure of Lex Programs
        - 3.5.3 Conflict Resolution in Lex
        - 3.5.4 The Lookahead Operator
        - 3.5.5 Exercises for Section 3.5
    - 3.6 Finite Automata
        - 3.6.1 Nondeterministic Finite Automata
        - 3.6.2 Transition Tables
        - 3.6.3 Acceptance of Input Strings by Automata
        - 3.6.4 Deterministic Finite Automata
        - 3.6.5 Exercises for Section 3.6
    - 3.7 From Regular Expressions to Automata
        - 3.7.1 Conversion of an NFA to a DFA
        - 3.7.2 Simulation of an NFA
        - 3.7.3 Efficiency of NFA Simulation
        - 3.7.4 Construction of an NFA from a Regular Expression
        - 3.7.5 Efficiency of String- Processing Algorithms
        - 3.7.6 Exercises for Section 3.7
    - 3.8 Design of a Lexical-Analyzer Generator
        - 3.8.1 The Structure of the Generated Analyzer
        - 3.8.2 Pattern Matching Based on NFA's
        - 3.8.3 DFA's for Lexical Analyzers
        - 3.8.4 Implementing the Lookahead Operator
        - 3.8.5 Exercises for Section 3.8
    - 3.9 Optimization of DFA-Based Pattern Matchers
        - 3.9.1 Important States of an NFA
        - 3.9.2 Functions Computed From the Syntax Tree
        - 3.9.3 Computing nullable, jirstpos, and lastpos
        - 3.9.4 Computing Jollowpos
        - 3.9.5 Converting a Regular Expression Directly to a DFA
        - 3.9.6 Minimizing the Number of States of a DFA
        - 3.9.7 State Minimization in Lexical Analyzers
        - 3.9.8 Trading Time for Space in DFA Simulation
        - 3.9.9 Exercises for Section 3.9
    - 3.10 Summary of Chapter 3
    - 3.11 References for Chapter 3
- 4 Syntax Analysis
    - 4.1 Introduction
        - 4.1.1 The Role of the Parser
        - 4.1.2 Representative Grammars
        - 4.1.3 Syntax Error Handling
        - 4.1.4 Error-Recovery Strategies
    - 4.2 Context-Free Grammars
        - 4.2.1 The Formal Definition of a Context-Free Grammar
        - 4.2.2 Notational Conventions
        - 4.2.3 Derivations
        - 4.2.4 Parse Trees and Derivations
        - 4.2.5 Ambiguity
        - 4.2.6 Verifying the Language Generated by a Grammar
        - 4.2.7 Context-Free Grammars Versus Regular Expressions
        - 4.2.8 Exercises for Section 4.2
    - 4.3 Writing a Grammar
        - 4.3.1 Lexical Vers us Syntactic Analysis
        - 4.3.2 Eliminating Ambiguity
        - 4.3.3 Elimination of Left Recursion
        - 4.3.4 Left Factoring
        - 4.3.5 Non-Context-Free Language Constructs
        - 4.3.6 Exercises for Section 4.3
    - 4.4 Top-Down Parsing
        - 4.4.1 Recursive-Descent Parsing
        - 4.4.2 FIRST and FOLLOW
        - 4.4.3 LL(l) Grammars
        - 4.4.4 Nonrecursive Predictive Parsing
        - 4.4.5 Error Recovery in Predictive Parsing
        - 4.4.6 Exercises for Section 4.4
    - 4.5 Bottom-Up Parsing
        - 4.5.1 Reductions
        - 4.5.2 Handle Pruning
        - 4.5.3 Shift-Reduce Parsing
        - 4.5.4 Conflicts During Shift-Reduce Parsing
        - 4.5.5 Exercises for Section 4.5
    - 4.6 Introduction to LR Parsing: Simple LR
        - 4.6.1 Why LR Parsers?
        - 4.6.2 Items and the LR(O) Automaton
        - 4.6.3 The LR-Parsing Algorithm
        - 4.6.4 Constructing SLR-Parsing Tables
        - 4.6.5 Viable Prefixes
        - 4.6.6 Exercises for Section 4.6
    - 4.7 More Powerful LR Parsers
        - 4.7.1 Canonical LR(l) Items
        - 4.7.2 Constructing LR(l) Sets of Items
        - 4.7.3 Canonical LR(l) Parsing Tables
        - 4.7.4 Constructing LALR Parsing Tables
        - 4.7.5 Efficient Construction of LALR Parsing Tables
        - 4.7.6 Compaction of LR Parsing Tables
        - 4.7.7 Exercises for Section 4.7
    - 4.8 U sing Ambiguous Grammars
        - 4.8.1 Precedence and Associativity to Resolve Conflicts
        - 4.8.2 The "Dangling-Else" Ambiguity
        - 4.8.3 Error Recovery in LR Parsing
        - 4.8.4 Exercises for Section 4.8
    - 4.9 Parser Generators
        - 4.9.1 The Parser Generator Yacc
        - 4.9.2 Using Yacc with Ambiguous Grammars
        - 4.9.3 Creating Yacc Lexical Analyzers with Lex
        - 4.9.4 Error Recovery in Yacc
        - 4.9.5 Exercises for Section 4.9
    - 4.10 Summary of Chapter 4
    - 4.11 References for Chapter 4
- 5 Syntax-Directed Translation
    - 5.1 Syntax-Directed Definitions
        - 5.1.1 Inherited and Synthesized Attributes
        - 5.1.2 Evaluating an SDD at the Nodes of a Parse Tree
        - 5.1.3 Exercises for Section 5.1
    - 5.2 Evaluation Orders for SDD's
        - 5.2.1 Dependency Graphs
        - 5.2.2 Ordering the Evaluation of Attributes
        - 5.2.3 S-Attributed Definitions
        - 5.2.4 L-Attributed Definitions
        - 5.2.5 Semantic Rules with Controlled Side Effects
        - 5.2.6 Exercises for Section 5.2
    - 5.3 Applications of Syntax-Directed Translation
        - 5.3.1 Construction of Syntax Trees
        - 5.3.2 The Structure of a Type
        - 5.3.3 Exercises for Section 5.3
    - 5.4 Syntax-Directed Translation Schemes
        - 5.4.1 Postfix Translation Schemes
        - 5.4.2 Parser-Stack Implementation of Postfix SDT's
        - 5.4.3 SDT's With Actions Inside Productions
        - 5.4.4 Eliminating Left Recursion From SDT's
        - 5.4.5 SDT's for L-Attributed Definitions
        - 5.4.6 Exercises for Section 5.4
    - 5.5 Implementing L-Attributed SDD's
        - 5.5.1 Translation During Recursive-Descent Parsing
        - 5.5.2 On-The-Fly Code Generation
        - 5.5.3 L-Attributed SDD's and LL Parsing
        - 5.5.4 Bottom-Up Parsing of L-Attributed SDD's
        - 5.5.5 Exercises for Section 5.5
    - 5.6 Summary of Chapter 5
    - 5.7 References for Chapter 5
    - 6 Intermediate-Code Generation
    - 6.1 Variants of Syntax Trees
        - 6.1.1 Directed Acyclic Graphs for Expressions
        - 6.1.2 The Value-Number Method for Constructing DAG's
        - 6.1.3 Exercises for Section 6.1
    - 6.2 Three-Address Code
        - 6.2.1 Addresses and Instructions
        - 6.2.2 Quadruples
        - 6.2.3 Triples
        - 6.2.4 Static Single-Assignment Form
        - 6.2.5 Exercises for Section 6.2
    - 6.3 Types and Declarations
        - 6.3.1 Type Expressions
        - 6.3.2 Type Equivalence
        - 6.3.3 Declarations
        - 6.3.4 Storage Layout for Local Names
        - 6.3.5 Sequences of Declarations
        - 6.3.6 Fields in Records and Classes
        - 6.3.7 Exercises for Section 6.3
    - 6.4 Translation of Expressions
        - 6.4.1 Operations Within Expressions
        - 6.4.2 Incremental Thanslation
        - 6.4.3 Addressing Array Elements
        - 6.4.4 Thanslation of Array References
        - 6.4.5 Exercises for Section 6.4
    - 6.5 Type Checking
        - 6.5.1 Rules for Type Checking
        - 6.5.2 Type Conversions
        - 6.5.3 Overloading of Functions and Operators
        - 6.5.4 Type Inference and Polymorphic Functions
        - 6.5.5 An Algorithm for Unification
        - 6.5.6 Exercises for Section 6.5
    - 6.6 Control Flow
        - 6.6.1 Boolean Expressions
        - 6.6.2 Short-Circuit Code
        - 6.6.3 Flow-of-Control Statements
        - 6.6.4 Control-Flow Translation of Boolean Expressions
        - 6.6.5 A voiding Redundant Gotos
        - 6.6.6 Boolean Values and Jumping Code
        - 6.6.7 Exercises for Section 6.6
    - 6.7 Backpatching
        - 6.7.1 One-Pass Code Generation Using Backpatching
        - 6.7.2 Backpatching for Boolean Expressions
        - 6.7.3 Flow-of-Control Statements
        - 6.7.4 Break-, Continue-, and Goto-Statements
        - 6.7.5 Exercises for Section 6.7
    - 6.8 Switch-Statements
        - 6.8.1 Translation of Switch-Statements
        - 6.8.2 Syntax-Directed T h anslation of Switch-Statements
        - 6.8.3 Exercises for Section 6.8
    - 6.9 Intermediate Code for Procedures
    - 6.10 Summary of Chapter 6
    - 6.11 References for Chapter 6
- 7 Run-Time Environments 427
    - 7.1 Storage Organization
        - 7.1.1 Static Versus Dynamic Storage Allocation
    - 7.2 Stack Allocation of Space
        - 7.2.1 Activation Trees
        - 7.2.2 Activation Records
        - 7.2.3 Calling Sequences
        - 7.2.4 Variable-Length Data on the Stack
        - 7.2.5 Exercises for Section 7.2
    - 7.3 Access to Nonlocal Data on the Stack
        - 7.3.1 Data Access \Vithout Nested Procedures
        - 7.3.2 Issues With Nested Procedures
        - 7.3.3 A Language With Nested Procedure Declarations
        - 7.3.4 Nesting Depth
        - 7.3.5 Access Links
        - 7.3.6 Manipulating Access Links
        - 7.3.7 Access Links for Procedure Parameters
        - 7.3.8 Displays
        - 7.3.9 Exercises for Section 7.3
    - 7.4 Heap Management
        - 7.4.1 The Memory Manager
        - 7.4.2 The lVIemory Hierarchy of a Computer
        - 7.4.3 Locality in Programs
        - 7.4.4 Reducing Fragmentation
        - 7.4.5 Manual Deallocation Requests
        - 7.4.6 Exercises for Section 7.4
    - 7.5 Introduction to Garbage Collection
        - 7.5.1 Design Goals for Garbage Collectors
        - 7.5.2 Reachability
        - 7.5.3 Reference Counting Garbage Collectors
        - 7.5.4 Exercises for Section 7.5
    - 7.6 Introduction to Trace-Based Collection
        - 7.6.1 A Basic Mark-and-Sweep Collector
        - 7.6.2 Basic Abstraction
        - 7.6.3 Optimizing Mark-and-Sweep
        - 7.6.4 Mark-and-Compact Garbage Collectors
        - 7.6.5 Copying collectors
        - 7.6.6 Comparing Costs
        - 7.6.7 Exercises for Section 7.6
    - 7.7 Short-Pause Garbage Collection
        - 7.7.1 Incremental Garbage Collection
        - 7.7.2 Incremental Reachability Analysis
        - 7.7.3 Partial-Collection Basics
        - 7.7.4 Generational Garbage Collection
        - 7.7.5 The Train Algorithm
        - 7.7.6 Exercises for Section 7.7
    - 7.8 Advanced Topics in Garbage Collection
        - 7.8.1 Parallel and Concurrent Garbage Collection
        - 7.8.2 Partial Object Relocation
        - 7.8.3 Conservative Collection for Unsafe Languages
        - 7.8.4 Weak References
        - 7.8.5 Exercises for Section 7.8
    - 7.9 Summary of Chapter 7
    - 7.10 References for Chapter 7
- 8 Code Generation
    - 8.1 Issues in the Design of a Code Generator
        - 8.1.1 Input to the Code Generator
        - 8.1.2 The Target Program
        - 8.1.3 Instruction Selection
        - 8.1.4 Register Allocation
        - 8.1.5 Evaluation Order
    - 8.2 The Target Language
        - 8.2.1 A Simple Target Machine Model
        - 8.2.2 Program and Instruction Costs
        - 8.2.3 Exercises for Section 8.2
    - 8.3 Addresses in the Target Code
        - 8.3.1 Static Allocation
        - 8.3.2 Stack Allocation
        - 8.3.3 Run-Time Addresses for Names
        - 8.3.4 Exercises for Section 8.3
    - 8.4 Basic Blocks and Flow Graphs
        - 8.4.1 Basic Blocks
        - 8.4.2 Next-Use Information
        - 8.4.3 Flow Graphs
        - 8.4.4 Representation of Flow Graphs
        - 8.4.5 Loops
        - 8.4.6 Exercises for Section 8.4
    - 8.5 Optimization of Basic Blocks
        - 8.5.1 The DAG Representation of Basic Blocks
        - 8.5.2 Finding Local Common Subexpressions
        - 8.5.3 Dead Code Elimination
        - 8.5.4 The Use of Algebraic Identities
        - 8.5.5 Representation of Array References
        - 8.5.6 Pointer Assignments and Procedure Calls
        - 8.5.7 Reassembling Basic Blocks From DAG's
        - 8.5.8 Exercises for Section 8.5
    - 8.6 A Simple Code Generator
        - 8.6.1 Register and Address Descriptors
        - 8.6.2 The Code-Generation Algorithm
        - 8.6.3 Design of the Function getReg
        - 8.6.4 Exercises for Section 8.6
    - 8.7 Peephole Optimization
        - 8.7.2 Eliminating Unreachable Code
        - 8.7.3 Flow-of-Control Optimizations
        - 8.7.4 Algebraic Simplification and Reduction in Strength
        - 8.7.5 Use of Machine Idioms
    - 8.8 Register Allocation and Assignment
        - 8.8.1 Global Register Allocation
        - 8.8.3 Register Assignment for Outer Loops
        - 8.8.4 Register Allocation by Graph Coloring
        - 8.8.5 Exercises for Section 8.8
    - 8.9 Instruction Selection by Tree Rewriting
        - 8.9.1 Tree-Translation Schemes
        - 8.9.2 Code Ge n eration by Tiling an Input Tree
        - 8.9.3 Pattern Matching by Parsing
        - 8.9.4 Routines for Semantic Checking
        - 8.9.5 General Tree Matching
    - 8 Exercises for Section 8.9
    - 8.10 Optimal Code Generatipn for Expressions
        - 8.10.1 Ershov Numbers
        - 8.10.2 Generating Code From Labeled Expression Trees
        - 8.10.3 Evaluating Expressions with an Insufficient Supply of Registers
        - 8.10.4 Exercises for Section 8.10
    - 8.11 Dynamic Programming Code-Generation
        - 8.11.1 Contiguous Evaluation
        - 8.11.2 The Dynamic Programming Algorithm
        - 8.11.3 Exercises for Section 8.11
    - 8.12 Summary of Chapter 8
    - 8.13 References for Chapter 8
- 9 Machine-Independent Optimizations
    - 9.1 The Principal Sources of Optimization
        - 9.1.1 Causes of Redundancy
        - 9.1.2 A R unning Example: Quicksort
        - 9.1.3 Semantics-Preserving Transformations
        - 9.1.4 Global Common Sub expressions
        - 9.1.5 Copy Propagation
        - 9.1.6 Dead-Code Elimination
        - 9.1.7 Code Motion
        - 9.1.8 Induction Variables and Reduction in Strength
        - 9.1.9 Exercises for Section 9.1
    - 9.2 Introduction to Data-Flow Analysis
        - 9.2.1 The Data-Flow Abstraction
        - 9.2.2 The Data-Flow Analysis Schema
        - 9.2.3 Data-Flow Schemas on Basic Blocks
        - 9.2.4 Reaching Definitions
        - 9.2.5 Live-Variable Analysis
        - 9.2.6 Available Expressions
        - 9.2.7 Summary
        - 9.2.8 Exercises for Section 9.2
    - 9.3 Foundations of Data-Flow Analysis
        - 9.3.1 Semilattices
        - 9.3.2 Transfer Functions
        - 9.3.3 The Iterative Algorithm for General Frameworks
        - 9.3.4 Meaning of a Data-Flow Solution
        - 9.3.5 Exercises for Section 9.3
    - 9.4 Constant Propagation
        - 9.4.1 Data-Flow Values for the Constant-Propagation Framework
        - 9.4.2 The Meet for the Constant - Propagation Framework
        - 9.4.3 Transfer Functions for the Constant-Propagation Framework
        - 9.4.4 Monotonicity of the Constant-Propagation Framework
        - 9.4.5 Nondistributivity of the Constant-Propagation Framework 635
        - 9.4.6 Interpretation of the Results
        - 9.4.7 Exercises for Section 9.4
    - 9.5 Partial-Redundancy Elimination
        - 9.5.1 The Sources of Redundancy
        - 9.5.2 Can All Redundancy Be Eliminated?
        - 9.5.3 The Lazy-Code-Motion Problem
        - 9.5.4 Anticipation of Expressions
        - 9.5.5 The Lazy-Code-Motion Algorithm
        - 9.5.6 Exercises for Section 9.5
    - 9.6 Loops in Flow Graphs
        - 9.6.1 Dominators
        - 9.6.2 Depth-First Ordering
        - 9.6.3 Edges in a Depth-First Spanning Tree
        - 9.6.4 Back Edges and Reducibility
        - 9.6.5 Depth of a Flow Graph
        - 9.6.6 Natural Loops
        - 9.6.7 Speed of Convergence of Iterative Data-Flow Algorithms
        - 9.6.8 Exercises for Section 9.6
    - 9.7 Region-Based Analysis
        - 9.7.1 Regions
        - 9.7.2 Region Hierarchies for Reducible Flow Graphs
        - 9.7.3 Overview of a Region-Based Analysis
        - 9.7.4 Necessary Assumptions About Transfer Functions
        - 9.7.5 An Algorithm for Region-Based Analysis
        - 9.7.6 Handling Nonreducible Flow Graphs
        - 9.7.7 Exercises for Section 9.7
    - 9.8 Symbolic Analysis
        - 9.8.1 Affine Expressions of Reference Variables
        - 9.8.2 Data-Flow Problem Formulation
        - 9.8.3 Region-Based Symbolic Analysis
        - 9.8.4 Exercises for Section 9.8
    - 9.9 Summary of Chapter 9
    - 9.10 References for Chapter 9
- 10 Instruction-Level Parallelism
    - 10.1 Processor Architectures
        - 10.1.1 Instruction Pipelines and Branch Delays
        - 10.1.2 Pipelined Execution
        - 10.1.3 :Multiple Instruction Issue
    - 10.2 Code-Scheduling Constraints
        - 10.2.1 Data Dependence
        - 10.2.2 Finding Dependences Among Memory Accesses
        - 10.2.3 Tradeoff Between Register Usage and Parallelism
        - 10.2.4 Phase Ordering Between Register Allocation and Code Scheduling
        - 10.2.5 Control Dependence
        - 10.2.6 Speculative Execution Support
        - 10.2.7 A Basic Machine Model
        - 10.2.8 Exercises for Section 10.2
    - 10.3 Basic-Block Scheduling
        - 10.3.1 Data-Dependence Graphs
        - 10.3.2 List Scheduling of Basic Blocks
        - 10.3.3 Prioritized Topological Orders
        - 10.3.4 Exercises for Section 10.3
    - 10.4 Global Code Scheduling
        - 10.4.1 Primitive Code Motion
        - 10.4.2 Upward Code Motion
        - 10.4.3 Downward Code Motion
        - 10.4.4 Updating Data Dependences
        - 10.4.5 Global Scheduling Algorithms
        - 10.4.6 Advanced Code lVlotion Techniques
        - 10.4.7 Interaction with Dynamic Schedulers
    - 1004.8 Exercises for Section lOA
    - 10.5 Software Pipelining
        - 10.5.1 Introduction
        - 10.5.2 Software Pipelining of Loops
        - 10.5.3 Register Allocation and Code Generation
        - 10.5.4 Do-Across Loops
        - 10.5.5 Goals and Constraints of Software Pipelining
        - 10.5.6 A Software-Pipelining Algorithm
        - 10.5.7 Scheduling Acyclic Data-Dependence Graphs
        - 10.5.8 Scheduling Cyclic Dependence Graphs
        - 10.5.9 Improvements to the Pipelining Algorithms
        - 10.5.10 Modular Variable Expansion
        - 10.5.11 Conditional Statements
        - 10.5.12 Hardware Support for Software Pipelining
        - 10.5.13 Exercises for Section 10.5
    - 10.6 Summary of Chapter 10
    - 10.7 References for Chapter 10
- 11 Optimizing for Parallelism and Locality
    - 11.1 Basic Concepts
        - 11.1.1 Multiprocessors
        - 11.1.2 Parallelism in Applications
        - 11.1.3 Loop-Level Parallelism
        - 11.1.4 Data Locality
        - 11.1.5 Introduction to Affine Transform Theory
    - 11.2 Matrix Multiply: An In-Depth Example
        - 11.2.1 The Matrix-Multiplication Algorithm
        - 11.2.2 Optimizations
        - 11.2.3 Cache Interference
        - 11.2.4 Exercises for Section 11.2
    - 11.3 Iteration Spaces
        - 11.3.1 Constructing Iteration Spaces from Loop Nests
        - 11.3.2 Execution Order for Loop Nests
        - 11.3.3 Matrix Formulation of Inequalities
        - 11.3.4 Incorporating Symbolic Constants
        - 11.3.5 Controlling the Order of Execution
        - 11.3.6 Changing Axes
        - 11.3.7 Exercises for Section 11.3
    - 11.4 Affine Array Indexes
        - 11.4.1 Affine Accesses
        - 11.4.2 Affine and Nonaffine Accesses in Practice
        - 11.4.3 Exercises for Sec tion 11.4
    - 11.5 Data Reuse
        - 11.5.1 Types of Reuse
        - 11.5.3 Self-Spatial Reuse
        - 11.5.4 Group Reuse
        - 11.5.5 Exercises for Section 11.5
    - 11.6 Array Data-Dependence Analysis
        - 11.6.1 Definition of Data Dependence of Array Accesses
        - 11.6.2 Integer Linear Programming
        - 11.6.3 The GCD Test
        - 11.6.4 Heuristics for Solving Integer Linear Programs
        - 11.6.5 Solving General Integer Linear Programs
        - 11.6.6 Summary
        - 11.6.7 Exercises for Section 11.6
    - 11.7 Finding Synchronization-Free Parallelism
        - 11.7.1 An Introductory Example
        - 11.7.2 Affine Space Partitions
        - 11.7.6 Eliminating Empty Iterations
    - 11.8 Synchronization Between Parallel Loops
        - 11.8.1 A Constant Number of Synchronizations
        - 11.8.2 Program-Dependence Graphs
        - 11.8.3 Hierarchical Time
        - 11.8.4 The Parallelization Algorithm
        - 11.8.5 Exercises for Section 11.8
    - 11.9 Pipelining
        - 11.9.1 What is Pipelining?
        - 11.9.2 Successive Over-Relaxation ( SOR ) : An Example
        - 11.9.3 Fully Permutable Loops
        - 11.9.4 Pipelining Fully Permutable Loops
        - 11.9.5 General Theory
        - 11.9.6 Time-Partition Constraints
        - 11.9.7 Solving Time-Partition Constraints by Farkas' Lemma
        - 11.9.8 Code Transformations
        - 11.9.9 Parallelism With Minimum Synchronization
    - 11.10 Locality Optimizations
        - 11.10.1 Temporal Locality of Computed Data
        - 11.10.2 Array Contraction
        - 11.10.3 Partition Interleaving
        - 11.10.4 Putting it All Together
        - 11.10.5 Exercises for Secti on 11.10
    - 11.11 Other Uses of Affine Transforms
        - 11.11.1 Distributed memory machines
        - 11.11.2 M ulti-Instruction-Issue Processors
        - 11.11.3Vector and SIMD Instructions
        - 11.11.4 Prefetching
    - 11.12 Summary of Chapter 11
    - 11.13 References for Chapter 11
- 12 Interprocedural Analysis
    - 12.1 Basic Concepts
        - 12.1.1 Call Graphs
        - 12.1.2 Context Sensitivity
        - 12.1.3 Call Strings
        - 12.1.4 Cloning-Based Context-Sensitive Analysis
        - 12.1.5 Summary-Based Context-Sensitive Analysis
        - 12.1.6 Exercises for Section 12.1
    - 12.2 Why Interprocedural Analysis?
        - 12.2.1 Virtual Method Invocation
        - 12.2.2 Pointer Alias Analysis
        - 12.2.3 Parallelization
        - 12.2.4 Detection of Software Errors and Vulnerabilities
        - 12.2.5 SQL Injection
        - 12.2.6 Buffer Overflow
    - 12.3 A Logical Representation of Data Flow
        - 12.3.1 Introduction to Datalog
        - 12.3.2 Datalog Rules
        - 12.3.3 Intensional and Extensional Predicates
        - 12.3.4 Execution of Datalog Programs
        - 12.3.5 Incremental Evaluation of Datalog Programs
        - 12.3.6 Problematic Datalog Rules
        - 12.3.7 Exercises for Section 12.3
    - 12.4 A Simple Pointer - Analysis Algorithm
        - 12.4.1 Why is Pointer Analysis Difficult
        - 12.4.2 A Model for Pointers and References
        - 12.4.3 Flow Insensitivity
        - 12.4.4 The Formulation in Datalog
        - 12.4.5 Using Type Information
        - 12.4.6 Exercises for Section 12.4
    - 12.5 Context-Insensitive Interprocedural Analysis
        - 12.5.1 Effects of a Method Invocation
        - 12.5.2 Call Graph Discovery in Datalog
        - 12.5.3 Dynamic Loading and Reflection
        - 12.5.4 Exercises for Section 12.5
    - 12.6 Context-Sensitive Pointer Analysis
        - 12.6.1 Contexts and Call Strings
        - 12.6.2 Adding Context to Datalog Rules
        - 12.6.3 Additional Observations About Sensitivity
        - 12.6.4 Exercises for Section 12.6
    - 12.7 Datalog Implementation by BDD's
        - 12.7.1 Binary Decision Diagrams
        - 12.7.2 Transformations on BDD's
        - 12.7.3 Representing Relations by BDD's
        - 12.7.4 Relational Operations as BDD Operations
        - 12.7.5 Using BDD's for Points-to Analysis
        - 12.7.6 Exercises for Section 12.7
    - 12.8 Summary of Chapter 12
    - 12.9 References for Chapter 12
- A A Complete Front End
    - A.l The Source Language
    - A.2 Main
    - A.3 Lexical Analyzer
    - A.4 Symbol Tables and Types
    - A.5 Intermediate Code for Expressions
    - A.6 Jumping Code for Boolean Expressions
    - A.7 Intermediate Code for Statements
    - A.8 Parser
    - A.9 Creating the Front End
- B Finding Linearly Independent Solutions



## üü¢üîµ Structure and Interpretation of Computer Programs (SICP)
- Structure and Interpretation of Computer Programs 2nd, SICP https://mitpress.mit.edu/sites/default/files/sicp/index.html
- https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-4.html

Contents

    Foreword
    Preface to the Second Edition
    Preface to the First Edition
    Acknowledgments
    1  Building Abstractions with Procedures
        1.1  The Elements of Programming
            1.1.1  Expressions
            1.1.2  Naming and the Environment
            1.1.3  Evaluating Combinations
            1.1.4  Compound Procedures
            1.1.5  The Substitution Model for Procedure Application
            1.1.6  Conditional Expressions and Predicates
            1.1.7  Example: Square Roots by Newton's Method
            1.1.8  Procedures as Black-Box Abstractions
        1.2  Procedures and the Processes They Generate
            1.2.1  Linear Recursion and Iteration
            1.2.2  Tree Recursion
            1.2.3  Orders of Growth
            1.2.4  Exponentiation
            1.2.5  Greatest Common Divisors
            1.2.6  Example: Testing for Primality
        1.3  Formulating Abstractions with Higher-Order Procedures
            1.3.1  Procedures as Arguments
            1.3.2  Constructing Procedures Using Lambda
            1.3.3  Procedures as General Methods
            1.3.4  Procedures as Returned Values
    2  Building Abstractions with Data
        2.1  Introduction to Data Abstraction
            2.1.1  Example: Arithmetic Operations for Rational Numbers
            2.1.2  Abstraction Barriers
            2.1.3  What Is Meant by Data?
            2.1.4  Extended Exercise: Interval Arithmetic
        2.2  Hierarchical Data and the Closure Property
            2.2.1  Representing Sequences
            2.2.2  Hierarchical Structures
            2.2.3  Sequences as Conventional Interfaces
            2.2.4  Example: A Picture Language
        2.3  Symbolic Data
            2.3.1  Quotation
            2.3.2  Example: Symbolic Differentiation
            2.3.3  Example: Representing Sets
            2.3.4  Example: Huffman Encoding Trees
        2.4  Multiple Representations for Abstract Data
            2.4.1  Representations for Complex Numbers
            2.4.2  Tagged data
            2.4.3  Data-Directed Programming and Additivity
        2.5  Systems with Generic Operations
            2.5.1  Generic Arithmetic Operations
            2.5.2  Combining Data of Different Types
            2.5.3  Example: Symbolic Algebra
    3  Modularity, Objects, and State
        3.1  Assignment and Local State
            3.1.1  Local State Variables
            3.1.2  The Benefits of Introducing Assignment
            3.1.3  The Costs of Introducing Assignment
        3.2  The Environment Model of Evaluation
            3.2.1  The Rules for Evaluation
            3.2.2  Applying Simple Procedures
            3.2.3  Frames as the Repository of Local State
            3.2.4  Internal Definitions
        3.3  Modeling with Mutable Data
            3.3.1  Mutable List Structure
            3.3.2  Representing Queues
            3.3.3  Representing Tables
            3.3.4  A Simulator for Digital Circuits
            3.3.5  Propagation of Constraints
        3.4  Concurrency: Time Is of the Essence
            3.4.1  The Nature of Time in Concurrent Systems
            3.4.2  Mechanisms for Controlling Concurrency
        3.5  Streams
            3.5.1  Streams Are Delayed Lists
            3.5.2  Infinite Streams
            3.5.3  Exploiting the Stream Paradigm
            3.5.4  Streams and Delayed Evaluation
            3.5.5  Modularity of Functional Programs and Modularity of Objects
    4  Metalinguistic Abstraction
        4.1  The Metacircular Evaluator
            4.1.1  The Core of the Evaluator
            4.1.2  Representing Expressions
            4.1.3  Evaluator Data Structures
            4.1.4  Running the Evaluator as a Program
            4.1.5  Data as Programs
            4.1.6  Internal Definitions
            4.1.7  Separating Syntactic Analysis from Execution
        4.2  Variations on a Scheme -- Lazy Evaluation
            4.2.1  Normal Order and Applicative Order
            4.2.2  An Interpreter with Lazy Evaluation
            4.2.3  Streams as Lazy Lists
        4.3  Variations on a Scheme -- Nondeterministic Computing
            4.3.1  Amb and Search
            4.3.2  Examples of Nondeterministic Programs
            4.3.3  Implementing the Amb Evaluator
        4.4  Logic Programming
            4.4.1  Deductive Information Retrieval
            4.4.2  How the Query System Works
            4.4.3  Is Logic Programming Mathematical Logic?
            4.4.4  Implementing the Query System
    5  Computing with Register Machines
        5.1  Designing Register Machines
            5.1.1  A Language for Describing Register Machines
            5.1.2  Abstraction in Machine Design
            5.1.3  Subroutines
            5.1.4  Using a Stack to Implement Recursion
            5.1.5  Instruction Summary
        5.2  A Register-Machine Simulator
            5.2.1  The Machine Model
            5.2.2  The Assembler
            5.2.3  Generating Execution Procedures for Instructions
            5.2.4  Monitoring Machine Performance
        5.3  Storage Allocation and Garbage Collection
            5.3.1  Memory as Vectors
            5.3.2  Maintaining the Illusion of Infinite Memory
        5.4  The Explicit-Control Evaluator
            5.4.1  The Core of the Explicit-Control Evaluator
            5.4.2  Sequence Evaluation and Tail Recursion
            5.4.3  Conditionals, Assignments, and Definitions
            5.4.4  Running the Evaluator
        5.5  Compilation
            5.5.1  Structure of the Compiler
            5.5.2  Compiling Expressions
            5.5.3  Compiling Combinations
            5.5.4  Combining Instruction Sequences
            5.5.5  An Example of Compiled Code
            5.5.6  Lexical Addressing
            5.5.7  Interfacing Compiled Code to the Evaluator
    References
    List of Exercises
    Index



# üü°üü† Getting Started
- [The Rust Programming Language](https://doc.rust-lang.org/book/)
- [Rust by Example](https://doc.rust-lang.org/rust-by-example/index.html)
- [The rustc book](https://doc.rust-lang.org/rustc/what-is-rustc.html)
- [Guide to Rustc Development](https://rustc-dev-guide.rust-lang.org/about-this-guide.html)
- [The Rustonomicon - The Dark Arts of Unsafe Rust](https://doc.rust-lang.org/nightly/nomicon/index.html)
- [Futures Explained in 200 Lines of Rust](https://cfsamson.github.io/books-futures-explained/)
- [Green Threads Explained in 200 Lines of Rust](https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/)
- [Rust Language Cheat Sheet](https://cheats.rs)
- [Golang vs. Rust: Which Programming Language To Choose in 2021?](https://trio.dev/blog/golang-vs-rust)
- [Rust & Go & C++ ÊØîËæÉ](https://duzhi5368.github.io/2019/05/rustgoc--%E6%AF%94%E8%BE%83/)
- [Why Go Is Not Good](http://yager.io/programming/go.html)
- [The Rust Compilation Model Calamity](https://en.pingcap.com/blog/rust-compilation-model-calamity)
- [Rust ÁºñËØëÊ®°Âûã‰πãÊÆá](https://cloud.tencent.com/developer/article/1592954)
- [Rust ‰∏≠ÁöÑÂºÇÊ≠•ÁºñÁ®ã](https://huangjj27.github.io/async-book/01_getting_started/01_chapter.html)
- [Rust ÂºÇÊ≠•ÁºñÁ®ã](https://learnku.com/docs/async-book/2018/translation-notes/4798)
- [ÁªôÂàùÂ≠¶ËÄÖÁöÑRust‰∏≠ÊñáÊïôÁ®ã](https://rustcc.gitbooks.io/rustprimer/content/)
- [The Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)
- [The Embedded Rust Book](https://docs.rust-embedded.org/book/intro/index.html)
- [The Discovery book](https://docs.rust-embedded.org/discovery/index.html)
- [Why using Rust in the Linux kernel](https://lkml.org/lkml/2021/4/14/1023)

Rust ÊúÄÊó©ÊòØ Mozilla ÈõáÂëò Graydon Hoare ÁöÑ‰∏™‰∫∫È°πÁõÆÔºå‰ªé 2009 Âπ¥ÂºÄÂßãÔºåÂæóÂà∞‰∫Ü Mozilla Á†îÁ©∂Èô¢ÁöÑËµÑÂä©Ôºå2010 Âπ¥È°πÁõÆÂØπÂ§ñÂÖ¨Â∏É„ÄÇ

2010 ÔΩû2011 Âπ¥Èó¥ÂÆûÁé∞ÁöÑËá™‰∏æÔºå‰ªéÊ≠§‰ª•ÂêéÔºåRust ÁªèÂéÜ‰∫ÜÂ∑®Â§ßÁöÑËÆæËÆ°ÂèòÂåñÂíåÂèçÂ§çÔºàÂéÜÁ®ãÊûÅÂÖ∂Ëâ∞ËæõÔºâÔºåÁªà‰∫éÂú® 2015 Âπ¥ 5 Êúà 15Êó•ÂèëÂ∏É‰∫Ü 1.0 Áâà„ÄÇ

Âú®Ëøô‰∏™Á†îÂèëËøáÁ®ã‰∏≠ÔºåRust Âª∫Á´ã‰∫Ü‰∏Ä‰∏™Âº∫Â§ßÊ¥ªË∑ÉÁöÑÁ§æÂå∫ÔºåÂΩ¢Êàê‰∫Ü‰∏ÄÊï¥Â•óÂÆåÂñÑÁ®≥ÂÆöÁöÑÈ°πÁõÆË¥°ÁåÆÊú∫Âà∂ÔºåÁé∞Âú®Áî± Rust È°πÁõÆÂºÄÂèëËÄÖÁ§æÂå∫Áª¥Êä§ÔºåËøôÊòØÁúüÊ≠£ÁöÑÂº∫Â§ß‰πãÂ§Ñ„ÄÇ

Ëá™ 2015 Âπ¥ 5 Êúà 15 Êó• Rust ÁºñÁ®ãËØ≠Ë®ÄÊ†∏ÂøÉÂõ¢ÈòüÊ≠£ÂºèÂÆ£Â∏ÉÂèëÂ∏É Rust 1.0 ÁâàÊú¨‰ª•Êù•ÔºåÂÆÉ‰ºòÈõÖÁöÑËß£ÂÜ≥È´òÂπ∂ÂèëÂíåÈ´òÂÆâÂÖ®ÊÄßÁ≥ªÁªüÈóÆÈ¢òÁöÑËÉΩÂäõÔºåÂèóÂà∞‰∫ÜË∂äÊù•Ë∂äÂ§öÂºÄÂèëËÄÖÁöÑÂñúÁà±„ÄÇ

Rust Âú®Â∑•‰Ωú‰∏≠ÁöÑÂç†ÊØîÂç¥Ë∂äÊù•Ë∂äÈ´òÔºåRust Âú®ÂïÜ‰∏öÂ∫îÁî®‰∏äÊúâÁùÄ‰ª§‰∫∫ÊÉäËÆ∂ÁöÑÊàêÈïøÔºåÂåÖÊã¨‰∏Ä‰∫õ‰∫∫‰ª¨ËÄ≥ÁÜüËÉΩËØ¶ÁöÑÂÖ¨Âè∏Ôºö

- ‰∫öÈ©¨ÈÄäÔºöÁî® Rust ÊûÑÂª∫Â∑•ÂÖ∑Ôºõ
- FacebookÔºöÊ∫ê‰ª£Á†ÅÊéßÂà∂Â∑•ÂÖ∑ÔºåLibra Êï∞Â≠óË¥ßÂ∏ÅÈ°πÁõÆÔºåÊõ¥Âêç‰∏∫ DiemÔºåÁ∫Ø Rust ÂÆûÁé∞Ôºõ
- GoogleÔºö‰Ωú‰∏∫ Fuchsia Êìç‰ΩúÁ≥ªÁªüÈ°πÁõÆÁöÑ‰∏ÄÈÉ®ÂàÜÔºõ
- ÂæÆËΩØÔºöÂú®Êñ∞ÁöÑ Azure Áâ©ËÅîÁΩëÊ°ÜÊû∂‰∏≠ÈÉ®ÂàÜ‰ΩøÁî® RustÔºõ
- TwitterÔºöÁî® Rust ‰Ωú‰∏∫ÊûÑÂª∫Âõ¢ÈòüÊîØÊåÅÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇ

ÂÖ∂ÂÆÉ‰∏Ä‰∫õ Rust ÂºÄÂèëÁöÑÁü•ÂêçÈ°πÁõÆÔºö

- TiKV ÔºåRust ÂÆûÁé∞ÁöÑÂàÜÂ∏ÉÂºèKVÂ≠òÂÇ®ÔºåÊòØTiDBÁöÑÂü∫Á°Ä„ÄÇ
- Redox ÔºåRust ÂÆûÁé∞ÁöÑÊìç‰ΩúÁ≥ªÁªüÔºåËÉåÂêéÊòØSystem76ÂÖ¨Âè∏„ÄÇ
- tockOSÔºåRust ÂÆûÁé∞ÁöÑÂü∫‰∫é Cortex-M ÁöÑÂæÆÊéßÂà∂Âô®ÁöÑÂÆâÂÖ®ÂµåÂÖ•ÂºèÊìç‰ΩúÁ≥ªÁªü„ÄÇ
- Parity Âíå CITA Âå∫ÂùóÈìæÊ°ÜÊû∂ÔºåGavin Wood Êää Rust Â∏¶ËøõÂå∫ÂùóÈìæÔºåÊé®Âá∫‰ª•Â§™ÂùäÂÆ¢Êà∑Á´Ø ParityÔºåÊàêÂäüÂç†È¢Ü‰ª•Â§™ÂùäÁ§æÂå∫ÁöÑÂçäÂ£ÅÊ±üÂ±±„ÄÇ
- FirecrackerÔºå‰∫öÈ©¨ÈÄäÂá∫ÂìÅÁöÑ‰∏Ä‰∏™Âü∫‰∫é KVM ÁöÑËΩªÈáèÁ∫ß VMMÔºåÂèØ‰ª•Âú®Âá†ÂàÜ‰πã‰∏ÄÁßíÂÜÖÂêØÂä®ËôöÊãüÊú∫ÔºåÂÜÖÂ≠òÂç†Áî®Â∞ëÔºåÂèØ‰ª•ÂÆûÁé∞È´òÂØÜÂ∫¶‰∫ëÁéØÂ¢É„ÄÇ
- Mesalink TLS ÊòØÁôæÂ∫¶ÂÆâÂÖ®ÂÆûÈ™åÂÆ§Á†îÂèëÁöÑ‰∏ã‰∏Ä‰ª£‰º†ËæìÂ±ÇÂÆâÂÖ®Â∫ìÔºåÊ≠£ÂºèÊîØÊåÅ TLS 1.3 Âíå IPv6ÔºåÊîØÊåÅ CMake ÁºñËØëÔºåÊîØÊåÅ WindowsÔºåÂÆûÁé∞Áîü‰∫ßÁéØÂ¢ÉÂèØÁî®„ÄÇ
- alacrittyÔºåRust ÂÆûÁé∞ÁöÑË∑®Âπ≥Âè∞‰∏î GPU Âä†ÈÄüÁöÑÁªàÁ´ØÂ∑•ÂÖ∑„ÄÇ
- cityboundÔºå‰∏Ä‰∏™ Rust ÂÆûÁé∞ÁöÑÂ§öËßíËâ≤ÂüéÂ∏ÇÊ®°ÊãüÊ∏∏Êàè„ÄÇ
- AmethystÔºåRust ÂÆûÁé∞ÁöÑÊ∏∏ÊàèÂºïÊìéÔºåÈááÁî®‰∫Ü ECS Êû∂ÊûÑ„ÄÇ
- Rustsim ÁªÑÁªáÔºåËÅöÁÑ¶‰∫éÊèê‰æõÂêÑÁßçÊï∞ÂÄºÊ®°ÊãüÁöÑÂ∫ìÔºåÁî®‰∫éÁßëÂ≠¶ËÆ°ÁÆó„ÄÇÂåÖÊã¨ algaÔºàÊäΩË±°‰ª£Êï∞Â∫ìÔºâ/nalgebraÔºà Á∫øÊÄß‰ª£Êï∞Â∫ìÔºâ/ncollideÔºà2DÂíå3DÁöÑÁ¢∞ÊíûÊ£ÄÊµãÂ∫ìÔºâ/nphysicsÔºà2DÂíå3DÁöÑÁâ©ÁêÜÊ®°ÊãüÂ∫ìÔºâ„ÄÇ
- actix-webÔºå Âü∫‰∫é Actor Â∫ì Actix ÁöÑ Web Ê°ÜÊû∂ÔºåËøòÊúâ rocketÔºåRust ÂÆûÁé∞ÁöÑ MVC Ê°ÜÊû∂„ÄÇ
- DenoÔºåNode.js ‰πãÁà∂ÁöÑÊñ∞ÂùëÔºåTypeScript ËøêË°åÊó∂ÔºåÂÆåÂÖ®ÂÖºÂÆπÊµèËßàÂô® API„ÄÇ
- Xi-editorÔºåRust ÂíåÁé∞‰ª£ËΩØ‰ª∂Â∑•Á®ãÊûÑÂª∫ÁöÑÈ´òË¥®ÈáèÊñáÊú¨ÁºñËæëÂô®„ÄÇÊâÄÊúâÁöÑÊìç‰ΩúÈÉΩÂú® 16ms ÂÜÖÊèê‰∫§ÂíåÁªòÂà∂ÔºåÊ∞∏Ëøú‰∏ç‰ºöËÆ©‰Ω†Á≠âÂæÖ‰ªª‰Ωï‰∫ãÊÉÖ„ÄÇ
- Servo - independent, modular, embeddable web engine https://servo.org/

ÊØîËæÉ C++ Rust Golang ÁöÑ‰ºòÂäø‰∏éÂä£Âäø pros and consÔºåÁúãÁúãÊäïÁ•®Ôºö

    |            Pros of C++            |                Pros of Go               |                Pros of Rust               |
    |-----------------------------------|-----------------------------------------|-------------------------------------------|
    | 171 Performance                   | 513 High-performance                    | 122 Guaranteed memory safety              |
    | 91 Control over memory allocation | 376 Simple, minimal syntax              | 109 Fast                                  |
    | 87 Cross-platform                 | 343 Fun to write                        | 72 Open source                            |
    | 82 Fast                           | 289 Easy concurrency with goroutines    | 66 Minimal runtime                        |
    | 73 Object oriented                | 261 Fast compilation times              | 57 Pattern matching                       |
    | 53 Industry standard              | 183 Goroutines                          | 53 Type inference                         |
    | 41 Smart pointers                 | 173 Statically linked, simple to deploy | 51 Algebraic data types                   |
    | 32 Templates                      | 144 Simple compile build/run procedures | 46 Concurrent                             |
    | 16 Gui toolkits                   | 129 Backed by google                    | 43 Efficient C bindings                   |
    | 15 Raii                           | 125 Great community                     | 38 Practical                              |
    | 12 Generic programming            | 46 Garbage collection built-in          | 30 Best advances in languages in 20 years |
    | 11 Flexibility                    | 40 Built-in Testing                     | 22 Safe, fast, easy + friendly community  |
    | 10 Control                        | 36 Excellent tools - gofmt, godoc etc   | 22 Fix for C/C++                          |

Âú®È°πÁõÆÂèØÁª¥Êä§ÊÄß‰∏äÔºåGolang ÊØî Rust Ë¶ÅÂÅöÂæóÂ•ΩÔºåÂèØ‰ª•ËØ¥ÊòØÂü∫‰∫éÊé•Âè£ÁªÑÂêàÂºèÊÄùÊÉ≥ÔºåÂø´ÈÄüÈ´òÊïàÂèàÂ•ΩÁé©ÁöÑ C„ÄÇËÄå Rust ÊúÄÂ§ßÁöÑ‰ºòÁÇπÊòØÈ´òÊïàÁöÑÂºÄÂèëËøòÊê≠ÈÖç‰∏äÈ´òÂÆâÂÖ®ÊÄßÔºåËøô‰∏ÄÁÇπÈùûÂ∏∏Â•ΩÔºåÂèØ‰ª•ËØ¥ Rust ÊòØÈ´òÊïàÂÆâÂÖ®ÁâàÁöÑ C++„ÄÇ

Â¶ÇÊûúËøÖÈÄüÂú∞ÁºñËØë‰∏çÊòØ Rust ÁöÑÊ†∏ÂøÉËÆæËÆ°ÂéüÂàôÔºåÈÇ£‰πà Rust ÁöÑÊ†∏ÂøÉËÆæËÆ°ÂéüÂàôÊòØ‰ªÄ‰πàÂë¢Ôºü

Èô§‰∫Ü Rust ÁöÑÁºñËØëÊïàÁéáÊñπÈù¢ÁöÑ‰∏çË∂≥ÔºåRust Â∏¶Êù•ÁöÑÊòØÊõ¥Â§öÁöÑ‰ºòÁßÄÁöÑÊ†∏ÂøÉËÆæËÆ°ÂéüÂàôÔºö

- Practicality ÂÆûÁî®ÊÄß ÔºöÂÆÉÂ∫îËØ•ÊòØ‰∏ÄÁßçÂèØ‰ª•Âú®Áé∞ÂÆû‰∏ñÁïå‰∏≠‰ΩøÁî®ÁöÑËØ≠Ë®ÄÔºõ
- Pragmatism Âä°ÂÆûÔºöÂÆÉÂ∫îËØ•ÊòØÁ¨¶Âêà‰∫∫ÊÄßÂåñ‰ΩìÈ™åÔºåÂπ∂‰∏îËÉΩ‰∏éÁé∞ÊúâÁ≥ªÁªüÊñπ‰æøÈõÜÊàêÁöÑËØ≠Ë®ÄÔºõ
- Memory safety ÂÜÖÂ≠òÂÆâÂÖ®ÊÄßÔºöÂÆÉÂøÖÈ°ªÂä†Âº∫ÂÜÖÂ≠òÂÆâÂÖ®Ôºå‰∏çÂÖÅËÆ∏Âá∫Áé∞ÊÆµÈîôËØØÂíåÂÖ∂‰ªñÁ±ª‰ººÁöÑÂÜÖÂ≠òËÆøÈóÆËøùËßÑÊìç‰ΩúÔºõ
- Performance È´òÊÄßËÉΩ ÔºöÂÆÉÂøÖÈ°ªÊã•ÊúâËÉΩÂíå C++ ÊØîËÇ©ÁöÑÊÄßËÉΩÔºõ
- Concurrency È´òÂπ∂Âèë ÔºöÂÆÉÂøÖÈ°ª‰∏∫ÁºñÂÜôÂπ∂Âèë‰ª£Á†ÅÊèê‰æõÁé∞‰ª£ÂåñÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇ

Âè¶Â§ñÔºåGo ÁöÑËÆæËÆ°ÁõÆÁöÑÊòØ‰∏∫‰∫ÜËÆ©ÂºÄÂèëËÄÖËÉΩÂ§üËΩªÊùæÂú∞Âà∂‰ΩúÂø´ÈÄü„ÄÅÂÆâÂÖ®„ÄÅ‰ª•ÁΩëÁªú‰∏∫‰∏≠ÂøÉÁöÑ‰ª£Á†ÅÔºåÂπ∂Âú®ÂΩì‰ªäÁöÑÂ§öÊ†∏ CPU ‰∏äËé∑Áõä„ÄÇËøô‰ΩøÂæóËØ•ËØ≠Ë®ÄÂæóÂà∞‰∫ÜÊûÅÂ§ßÁöÑÂ∫îÁî®ÔºåÂ∞§ÂÖ∂ÊòØÂú®‰∫ëÁéØÂ¢É‰∏≠„ÄÇGo Êèê‰æõÂº∫Â§ßÁöÑË∑®Âπ≥Âè∞‰∫§ÂèâÁºñËØë„ÄÅ‰ºòÁßÄÁöÑÁΩëÁªúÂÆûÁé∞ÂíåÂä†ÂØÜÂ∫ì‰ª•ÂèäÂéüÁîüÁöÑÊñá‰ª∂ÂµåÂÖ•ÂäüËÉΩÔºåÂèàËÆ©ÂÖ∂È¢áÂèóÊÅ∂ÊÑèËΩØ‰ª∂ÂºÄÂèëËÄÖÁöÑÈùíÁùêÔºÅÂú®ËøáÂéªÂá†Âπ¥‰∏≠ÔºåÂú®Â∏ÇÈù¢‰∏äÂèëÁé∞ÁöÑÁî® Go ÁºñÂÜôÁöÑÊñ∞ÊÅ∂ÊÑèËΩØ‰ª∂Âá†‰πéÂ¢ûÂä†‰∫Ü 2000%„ÄÇËøô‰∫õÊÅ∂ÊÑèËΩØ‰ª∂‰∏≠ÊúâËÆ∏Â§öÊòØÈíàÂØπ Linux ÂíåÁâ©ËÅîÁΩëËÆæÂ§áÁöÑÂÉµÂ∞∏ÁΩëÁªúÔºå‰ª•ÂÆâË£ÖÂä†ÂØÜÁüøÊú∫ÊàñÂ∞ÜÂèóÊÑüÊüìÁöÑÊú∫Âô®Ê≥®ÂÜåÂà∞ DDoS ÂÉµÂ∞∏ÁΩëÁªú‰∏≠„ÄÇÊ≠§Â§ñÔºåÁî® Go ÁºñÂÜôÁöÑÂãíÁ¥¢ËΩØ‰ª∂‰ºº‰πé‰πüÂèòÂæóÊõ¥Âä†ÊôÆÈÅç„ÄÇ‰∏Ä‰∫õÁî® Go ÁºñÂÜôÁöÑËëóÂêçÂãíÁ¥¢ËΩØ‰ª∂ÊòØ Nefilim„ÄÅEKANS Âíå RobbinHoodÔºåËøô‰∫õÂãíÁ¥¢ËΩØ‰ª∂Áî®‰∫éÊâÄË∞ìÁöÑÂ§ßÂûãÁåéÁâ©ÊîªÂáª„ÄÇ


## ‚ö° Installation
- https://www.rust-lang.org/learn/get-started
- The Rust Programming Language https://doc.rust-lang.org/book/
- The Rust Programming Language [CN] https://kaisery.github.io/trpl-zh-cn/ch01-01-installation.html
- Rust Playground https://play.rust-lang.org/
- https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019
- https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/
- Bringing a great IDE experience to the Rust https://rust-analyzer.github.io
- Editor Features for VS Code https://rust-analyzer.github.io/manual.html#vs-code-2
- Rust Analyzer Releases https://github.com/rust-analyzer/rust-analyzer/releases

Âú® Linux Êàñ macOS ‰∏äÂÆâË£Ö rustupÔºåÊâìÂºÄÁªàÁ´ØÂπ∂ËæìÂÖ•Â¶Ç‰∏ãÂëΩ‰ª§Ôºö

    $ curl https://sh.rustup.rs -sSf | sh

Ê≠§ÂëΩ‰ª§‰∏ãËΩΩ‰∏Ä‰∏™ËÑöÊú¨Âπ∂ÂºÄÂßãÂÆâË£Ö rustup Â∑•ÂÖ∑ÔºåÂÆÉÊòØ Rust ÁâàÊú¨ÁÆ°ÁêÜÂ∑•ÂÖ∑ÔºåËøô‰ºöÂÆâË£ÖÊúÄÊñ∞Á®≥ÂÆöÁâà RustÔºåËøáÁ®ã‰∏≠ÂèØËÉΩ‰ºöÊèêÁ§∫‰Ω†ËæìÂÖ•ÂØÜÁ†Å„ÄÇ

Ê≠§ÂÆâË£ÖËÑöÊú¨Ëá™Âä®Â∞Ü Rust Âä†ÂÖ•Á≥ªÁªü PATH ÁéØÂ¢ÉÂèòÈáè‰∏≠ÔºåÂú®‰∏ã‰∏ÄÊ¨°ÁôªÂΩïÊó∂ÁîüÊïà„ÄÇÂ¶ÇÊûú‰Ω†Â∏åÊúõÁ´ãÂàªÂ∞±ÂºÄÂßã‰ΩøÁî® Rust ËÄå‰∏çÈáçÂêØÁªàÁ´ØÔºåÂú® shell ‰∏≠ËøêË°åÂ¶Ç‰∏ãÂëΩ‰ª§ÔºåÊâãÂä®Â∞Ü Rust Âä†ÂÖ•Á≥ªÁªü PATH ÂèòÈáè‰∏≠Ôºö

    $ source $HOME/.cargo/env

ÊàñËÄÖÔºåÂèØ‰ª•Âú® `~/.bash_profile` Êñá‰ª∂‰∏≠Â¢ûÂä†Â¶Ç‰∏ãË°åÔºö

    $ export PATH="$HOME/.cargo/bin:$PATH"

Âè¶Â§ñÔºå‰Ω†ÈúÄË¶Å‰∏Ä‰∏™ÊüêÁßçÁ±ªÂûãÁöÑÈìæÊé•Âô®ÔºàlinkerÔºâ„ÄÇÂæàÊúâÂèØËÉΩÂ∑≤ÁªèÂÆâË£ÖÔºå‰∏çËøáÂΩì‰Ω†Â∞ùËØïÁºñËØë Rust Á®ãÂ∫èÊó∂ÔºåÂç¥ÊúâÈîôËØØÊåáÂá∫Êó†Ê≥ïÊâßË°åÈìæÊé•Âô®ÔºåËøôÊÑèÂë≥ÁùÄ‰Ω†ÁöÑÁ≥ªÁªü‰∏äÊ≤°ÊúâÂÆâË£ÖÈìæÊé•Âô®Ôºå‰Ω†ÈúÄË¶ÅËá™Ë°åÂÆâË£Ö‰∏Ä‰∏™„ÄÇC ÁºñËØëÂô®ÈÄöÂ∏∏Â∏¶ÊúâÊ≠£Á°ÆÁöÑÈìæÊé•Âô®„ÄÇËØ∑Êü•Áúã‰Ω†‰ΩøÁî®Âπ≥Âè∞ÁöÑÊñáÊ°£Ôºå‰∫ÜËß£Â¶Ç‰ΩïÂÆâË£Ö C ÁºñËØëÂô®„ÄÇÂπ∂‰∏îÔºå‰∏Ä‰∫õÂ∏∏Áî®ÁöÑ Rust ÂåÖ‰æùËµñ C ‰ª£Á†ÅÔºå‰πüÈúÄË¶ÅÂÆâË£Ö C ÁºñËØëÂô®„ÄÇÂõ†Ê≠§Áé∞Âú®ÂÆâË£Ö‰∏Ä‰∏™ÊòØÂÄºÂæóÁöÑ„ÄÇ


Windows Á≥ªÁªü‰ΩøÁî® rustup Â∑•ÂÖ∑ÂÆâË£ÖÔºåÂâçÂæÄÂÆòÁΩëÂπ∂ÊåâÁÖßËØ¥ÊòéÂÆâË£Ö Rust„ÄÇ

```sh
# https://www.rust-lang.org/install.html
# Windows, download RUSTUP-INIT.EXE (32-BIT or 64-BIT)
curl -O https://static.rust-lang.org/rustup/dist/i686-pc-windows-msvc/rustup-init.exe
curl -O https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe
# Windows Subsystem for Linux
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Âú®ÂÆâË£ÖËøáÁ®ãÁöÑÊüê‰∏™Ê≠•È™§Ôºå‰Ω†‰ºöÊî∂Âà∞‰∏Ä‰∏™‰ø°ÊÅØËØ¥Êòé‰∏∫‰ªÄ‰πàÈúÄË¶ÅÂÆâË£Ö Visual Studio 2013 ÊàñÊõ¥Êñ∞ÁâàÊú¨ÁöÑ C++ build tools„ÄÇ

Visual Studio Êàñ C++  build tools ÂøÖÂÆöÂÆâË£ÖÂÖ∂‰∏ÄÔºåÂê¶Âàô‰∏çËÉΩÈìæÊé• Rust Á®ãÂ∫èÔºåÂª∫ËÆÆÂÆâË£Ö Visual Studio 2019 Á§æÂå∫Áâà„ÄÇÂêåÊó∂ÔºåWindows 10 Á≥ªÁªüÈúÄË¶ÅÂÆâË£Ö Windows 10 SDK (10.0.18362.0) Ëß£ÂÜ≥ advapi32.lib Ëøô‰∏™ÈóÆÈ¢òÁöÑ„ÄÇ


Â∞Ü‰ª•‰∏ãÁõÆÂΩïÂä†ÂÖ• PATH ÁéØÂ¢ÉÂèòÈáèÔºö

    %USERPROFILE%\.cargo\bin

    C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\amd64

    C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\bin\Hostx86\x86

rust1.16.0 Âú® VS2017 ‰∏ã‰∏çËÉΩÊ≠£Á°ÆËØÜÂà´Áõ∏ÂÖ≥ÁöÑ LIBÔºåÊâãÂä®Ê∑ªÂä† LIBÔºö

    C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\VC\Tools\MSVC\14.10.25017\lib\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.14393.0\um\x64;C:\Program Files (x86)\Windows Kits\10\Lib\10.0.14393.0\ucrt\x64

‰Ωô‰∏ãÈÉ®ÂàÜ‰ºö‰ΩøÁî®ËÉΩÂêåÊó∂ËøêË°å‰∫é cmd.exe Âíå PowerShell ÁöÑÂëΩ‰ª§„ÄÇÂ¶ÇÊûúÂ≠òÂú®ÁâπÂÆöÂ∑ÆÂºÇÔºåÊàë‰ª¨‰ºöËß£Èáä‰ΩøÁî®Âì™‰∏Ä‰∏™„ÄÇ

ÈÄöËøáÁâàÊú¨ÁÆ°ÁêÜÂ∑•ÂÖ∑ rustup ÂÆâË£Ö‰∫Ü Rust ‰πãÂêéÔºåÂæàÂÆπÊòìÊõ¥Êñ∞Âà∞ÊúÄÊñ∞ÁâàÊú¨„ÄÇÂú® shell ‰∏≠ËøêË°åÂ¶Ç‰∏ãÊõ¥Êñ∞ËÑöÊú¨Ôºö

    $ rustup update

‰∏∫‰∫ÜÂç∏ËΩΩ Rust Âíå rustupÔºåÂú® shell ‰∏≠ËøêË°åÂ¶Ç‰∏ãÂç∏ËΩΩËÑöÊú¨:

    $ rustup self uninstall

Ë¶ÅÊ£ÄÊü•ÊòØÂê¶Ê≠£Á°ÆÂÆâË£Ö‰∫Ü RustÔºåÊâìÂºÄ shell Âπ∂ËøêË°åÁºñËØëÂô®ÔºåÂ¶Ç‰∏ãË°åÔºö

    $ rustc --version

‰Ω†Â∫îËÉΩÁúãÂà∞Â∑≤ÂèëÂ∏ÉÁöÑÊúÄÊñ∞Á®≥ÂÆöÁâàÁöÑÁâàÊú¨Âè∑„ÄÅÊèê‰∫§ÂìàÂ∏åÂíåÊèê‰∫§Êó•ÊúüÔºåÊòæÁ§∫‰∏∫Â¶Ç‰∏ãÊ†ºÂºèÔºö

    rustc x.y.z (abcabcabc yyyy-mm-dd)

Ë¶ÅÂÆâË£Ö„ÄÅÂç∏ËΩΩÊàñËÆæÁΩÆÈªòËÆ§ Rust ÁâàÊú¨ÔºåÂ¶ÇÊûúÊú¨Âú∞‰∏çÂ≠òÂú®Â∞ÜËá™Âä®‰∏ãËΩΩÂÆâË£ÖÔºö

    rustup default stable
    rustup default nightly

    rustup toolchain list
    rustup toolchain uninstall nightly


Â¶ÇÊûúÂá∫Áé∞Ëøô‰∫õÂÜÖÂÆπÔºåRust Â∞±ÂÆâË£ÖÊàêÂäü‰∫ÜÔºÅÂ¶ÇÊûúÂπ∂Ê≤°ÊúâÁúãÂà∞Ëøô‰∫õ‰ø°ÊÅØÔºåÂπ∂‰∏î‰ΩøÁî®ÁöÑÊòØ WindowsÔºåËØ∑Ê£ÄÊü• Rust ÊòØÂê¶‰Ωç‰∫é %PATH% Á≥ªÁªüÂèòÈáè‰∏≠„ÄÇÂ¶ÇÊûú‰∏ÄÂàáÊ≠£Á°Æ‰ΩÜ Rust ‰ªç‰∏çËÉΩ‰ΩøÁî®ÔºåÊúâËÆ∏Â§öÂú∞ÊñπÂèØ‰ª•Ê±ÇÂä©„ÄÇÊúÄÁÆÄÂçïÁöÑÊòØ ‰Ωç‰∫é Rust ÂÆòÊñπ Discord ‰∏äÁöÑ #beginners È¢ëÈÅì„ÄÇÂú®ËøôÈáå‰Ω†ÂèØ‰ª•ÂíåÂÖ∂‰ªñ RustaceanÔºàRust Áî®Êà∑ÁöÑÁß∞Âè∑ÔºåÊúâËá™Âò≤ÊÑèÂë≥ÔºâËÅäÂ§©Âπ∂ÂØªÊ±ÇÂ∏ÆÂä©„ÄÇÂÖ∂ÂÆÉÁªôÂäõÁöÑËµÑÊ∫êÂåÖÊã¨Áî®Êà∑ËÆ∫ÂùõÂíå Stack Overflow„ÄÇ

|    Programs   |         Note         |
|---------------|----------------------|
| cargo-clippy  |                      |
| cargo-fmt     |                      |
| cargo-miri    |                      |
| cargo         | Project Manager      |
| clippy-driver |                      |
| ddoc          |                      |
| mdbook        |                      |
| rls           | Rust language server |
| rust-gdb      |                      |
| rust-lldb     |                      |
| rustc         | Rust Compiler        |
| rustdoc       | Rust Documentation   |
| rustfmt       | Source formatter     |
| rustup        | Toolchain installer  |
| wasm-pack     | WebAssebly packager  |

ÂÆâË£ÖÁ®ãÂ∫è‰πüËá™Â∏¶‰∏Ä‰ªΩÊñáÊ°£ÁöÑÊú¨Âú∞Êã∑Ë¥ùÔºåÂèØ‰ª•Á¶ªÁ∫øÈòÖËØª„ÄÇËøêË°å `rustup doc` Âú®ÊµèËßàÂô®‰∏≠Êü•ÁúãÊú¨Âú∞ÊñáÊ°£„ÄÇ

‰ªª‰ΩïÊó∂ÂÄôÔºåÂ¶ÇÊûú‰Ω†Êãø‰∏çÂáÜÊ†áÂáÜÂ∫ì‰∏≠ÁöÑÁ±ªÂûãÊàñÂáΩÊï∞ÁöÑÁî®ÈÄîÂíåÁî®Ê≥ïÔºåËØ∑Êü•ÈòÖÂ∫îÁî®Á®ãÂ∫èÊé•Âè£Ôºàapplication programming interfaceÔºåAPIÔºâÊñáÊ°£ÔºÅ


ÊÑüË∞¢ÂæÆËΩØÂºÄÊ∫êÂõ¢ÈòüÊâÄÂÅöÁöÑË¥°ÁåÆÔºåWindows WSL ÂèØ‰ª•È´òÊïà‰ΩøÁî® Linux Á≥ªÁªüÔºåÂºÄÂèëËÄÖÂèØ‰ª•‰ΩøÁî® VSCode Ë∏èÂπ≥Âè∞ÂºÄÂèëÂ∑•ÂÖ∑„ÄÇ

ÂêåÊó∂ÔºåServer Language Protocol ÊûÅÂ§ßÂú∞ÊèêÂçá‰∫ÜÁºñËæëÂô®ÁöÑÂºÄÂèë‰ΩìÈ™åÔºåRust ‰πüÁ¥ßË∑üÊ≠•‰ºêÔºåÊèê‰æõ‰∫Ü RLS - Rust Language ServerÔºåÂÆÉ‰ΩøÁî® Cargo Âíå Rust compiler (rustc) Áõ¥Êé•ÁªôÁºñËæëÂô®Êèê‰æõÂèÇÊï∞‰ø°ÊÅØ„ÄÇ

Âè¶Â§ñÔºåÊõ¥Âº∫Â§ßÁöÑÊòØ Rust AnalyzerÔºåÁõÆÂâçÊòØÊúÄÂ•ΩÁöÑÊâ©Â±ïÔºåÂÆÉÂ∞ÜÁºñËØëÂô®ÂâçÁ´Ø‰∏é Rust ËØ≠Ë®ÄÂàÜÁ¶ªÔºå‰∏çÈúÄË¶ÅÈÄöËøá Rust compiler (rustc) Áõ¥Êé•È´òÊïàÂú∞‰∏∫ÁºñËæëÂô®Êèê‰æõÈÄÇÂêàÁöÑËØ≠Ê≥ïÂàÜÊûê‰ø°ÊÅØ„ÄÇÊ≥®ÊÑèÔºåÂÆÉ‰∏éÂÆòÊñπÁöÑ Rust extension ÊúâÂÜ≤Á™ÅÔºåÂª∫ËÆÆÁ¶ÅÁî®„ÄÇ

Rust Analyzer Êèê‰æõ‰∏∞ÂØåÁöÑÂäüËÉΩÔºåÊØîÂ¶ÇÂú®ÁÆÄÂåñ‰ª£Á†ÅËæìÂÖ•ÊñπÊ≥ïÔºåÂèØ‰ª•ÈÄöËøáÂâçÁºÄËß¶ÂèëÂÖ≥ÈîÆÂ≠óÁöÑËá™Âä®ÂÆåÊàêÔºåfoo().if Âè•ÁÇπÂêéÈù¢ÁöÑÂÖ≥ÈîÆÂ≠óÁ°ÆÂÆö‰∫ÜÂ¶Ç‰ΩïËá™Âä®ÂÆåÊàêÔºåÂèÇËÄÉÂΩ¢ÂºèÂ¶Ç‰∏ãÔºö

    expr.if ‚Üí if expr {} or if let ‚Ä¶ {} for Option or Result
    expr.match ‚Üí match expr {}
    expr.while ‚Üí while expr {} or while let ‚Ä¶ {} for Option or Result
    expr.ref ‚Üí &expr
    expr.refm ‚Üí &mut expr
    expr.let ‚Üí let $0 = expr;
    expr.letm ‚Üí let mut $0 = expr;
    expr.not ‚Üí !expr
    expr.dbg ‚Üí dbg!(expr)
    expr.dbgr ‚Üí dbg!(&expr)
    expr.call ‚Üí (expr)

    pd ‚Üí eprintln!(" = {:?}", );
    ppd ‚Üí eprintln!(" = {:#?}", );


Ê†πÊçÆÂ∑•‰ΩúÁ≥ªÁªüÂÆâË£ÖË∞ÉËØïÂô®Êâ©Â±ïÔºö

- C/C++ (Windows)
- CodeLLDB (OS X / Linux)

Rust ÁõÆÂâçËøòÊèê‰æõ‰∫Ü rust-lldb Âíå rust-gdb ‰∏§‰∏™Ë∞ÉËØïÂ∑•ÂÖ∑ÔºåÂèØ‰ª•‰∏çËÉΩÂú® Windows ÂàÜÊîØ‰ΩøÁî®„ÄÇ

ÊâìÂºÄ VScode ÈÖçÁΩÆÔºåÊêúÁ¥¢ BreakpointsÔºåÂãæÈÄâ‰ª•‰∏ãÊù°ÁõÆÂç≥ÂèØ‰ª•Âú®‰ª£Á†Å‰∏≠‰∏ãÊñ≠ÁÇπÔºö

    Debug: Allow Breakpoints Eventywhere

ÈÖçÁΩÆ VSCode launch.json Áî®‰∫éË∞ÉËØïÔºåÂø´Êç∑ÈîÆ F5 ËøêË°åÔºö

```json
{
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
          "name": "Cargo Run!",
          "type": "cppvsdbg",
          "request": "launch",
          "stopAtEntry": true,
          "preLaunchTask": "cargo build",
          "program": "target\\debug\\output.exe",
          "args": ["run"],
          "cwd": "${workspaceFolder}",
          "environment": [],
          "console": "internalConsole"
        },
        {
            "name": "(OSX) Launch",
            "type": "lldb",
            "request": "launch",
            "program": "${workspaceRoot}/target/debug/foo",
            "args": [],
            "cwd": "${workspaceRoot}",
        }
    ]
}
```

ÈÖçÁΩÆ VSCode tasks.jsonÔºåÂø´Êç∑ÈîÆ Ctrl-Shift-B ÊâßË°åÔºåËá™Âä®ËøêË°åÊåáÂÆö isDefault ÂëΩ‰ª§ÈÖçÁΩÆÔºö

```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "type": "cargo",
            "subcommand": "build",
            "problemMatcher": [
                "$rustc"
            ],
            "group": "build",
            "label": "cargo build"
        },
        {
            "type": "cargo",
            "subcommand": "run",
            "problemMatcher": [
                "$rustc"
            ],
            "label": "cargo run",
            "group": {
                "kind": "build",
                "isDefault": true
            }
        }
    ]
}
```

## ‚ö° Cargo Tool
- [The Cargo Book](https://doc.rust-lang.org/cargo/)
- [Cargo cache](https://crates.io/crates/cargo-cache)
- [More about cargo](https://doc.rust-lang.org/book/ch14-00-more-about-cargo.html)
- [ÊåáÂÆö‰æùËµñÂèäÁâàÊú¨](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html)
- [The Manifest Format](https://doc.rust-lang.org/cargo/reference/manifest.html)
- [Workspaces](https://doc.rust-lang.org/cargo/reference/workspaces.html)
- [Environment Variables](https://doc.rust-lang.org/cargo/reference/environment-variables.html)
- [Build scripts](https://doc.rust-lang.org/cargo/reference/build-scripts.html)
- [VSCode launch.json Reference](https://code.visualstudio.com/docs/cpp/launch-json-reference)
- [rustc Command-line arguments](https://doc.rust-lang.org/rustc/command-line-arguments.html)
- [mdBook - Creates a book from markdown files](https://crates.io/crates/mdbook)

Cargo ÊòØ Rust ÁöÑÊûÑÂª∫Á≥ªÁªüÂíåÂåÖÁÆ°ÁêÜÂô®ÔºåËÉΩÂ§üËá™Âä®Â§ÑÁêÜ‰æùËµñÔºåÊñπ‰æøÈ°πÁõÆÁöÑÈáçÊñ∞ÊûÑÂª∫„ÄÇ

Cargo ÂëΩ‰ª§Âø´ÈÄüÂèÇËÄÉÔºö

    | Build Commands |    Manifest Commands    | Package Commands | Publishing Commands |
    |----------------|-------------------------|------------------|---------------------|
    | cargo bench    | cargo generate-lockfile | cargo init       | cargo login         |
    | cargo build    | cargo locate-project    | cargo install    | cargo owner         |
    | cargo check    | cargo metadata          | cargo new        | cargo package       |
    | cargo clean    | cargo pkgid             | cargo search     | cargo publish       |
    | cargo doc      | cargo tree              | cargo uninstall  | cargo yank          |
    | cargo fetch    | cargo update            |                  |                     |
    | cargo fix      | cargo vendor            |                  |                     |
    | cargo run      | cargo verify-project    |                  |                     |
    | cargo rustc    |                         |                  |                     |
    | cargo rustdoc  |                         |                  |                     |
    | cargo test     |                         |                  |                     |

Â¶ÇÊûúÈúÄË¶ÅÂú®Êú¨Âú∞Êü•ÈòÖÊñáÊ°£ÔºåÂèØ‰ª•ÊâßË°å‰ª•‰∏ãÂëΩ‰ª§Ôºö

    rustup doc

ÂÆâË£Ö Rust ÂêéÔºåÂÆâË£ÖÁõÆÂΩï‰∏ãÁöÑÊâÄÊúâÂ∑•ÂÖ∑Á®ãÂ∫èÁöÑÂäüËÉΩÈÉΩÂèØ‰ª•ÈÄöËøá Cargo ÂëΩ‰ª§Êù•‰ΩøÁî®Ôºå‰πüÂèØ‰ª•ÂÆâË£ÖÊñ∞ÁöÑÂ∑•ÂÖ∑ÔºåÂ¶Ç
cargo-cache ÂÆÉÂèØ‰ª•Â∏ÆÂä©ÁÆ°ÁêÜ $CARGO_HOME ÁõÆÂΩïÁºìÂ≠ò„ÄÇËøòÊúâ racer Â∑•ÂÖ∑ÔºåCode completion for RustÔºö

    cargo install cargo-cache
    cargo install racer

Cargo ÊòØÂ•ΩÁî®ÁöÑ Rust È°πÁõÆÁÆ°ÁêÜÂ∑•ÂÖ∑ÔºåÂÆÉÂèØ‰ª•Â§ÑÁêÜÂæàÂ§ö‰ªªÂä°ÔºåÊØîÂ¶ÇÊûÑÂª∫‰ª£Á†Å„ÄÅ‰∏ãËΩΩ‰æùËµñÂ∫ìÂπ∂ÁºñËØëËøô‰∫õÂ∫ì„ÄÇ‰ª£Á†Å
ÊâÄÈúÄË¶ÅÁöÑÂ∫ìÂè´ÂÅö‰æùËµñ dependenciesÔºåCargo ÂèØ‰ª•ÂæàÂ•ΩÂú∞ÁÆ°ÁêÜÂÆÉ‰ª¨„ÄÇ‰æãÂ¶ÇÔºåÊ∑ªÂä†‰æùËµñÊ®°ÂùóÔºö

    cargo add --features console,CanvasRenderingContext2d,Document,Element,HtmlCanvasElement,Window web-sys

Cargo ÊîØÊåÅÁöÑÁâπÊÄßÔºö

- conditional compilation options (usable through cfg attributes);
- optional dependencies, which enhance a package, but are not required; and
- clusters of optional dependencies, such as postgres-all, that would include 
  the postgres package, the postgres-macros package, and possibly other packages 
  (such as development-time mocking libraries, debugging tools, etc.).

Cargo Êèê‰æõÂõõÁßçÁºñËØëÈÖçÁΩÆ dev, release, test, bench ÂåÖÂê´‰∏çÂêåÁöÑ‰ºòÂåñ„ÄÅË∞ÉËØïÁ¨¶Âè∑ËÆæÁΩÆÔºåÁî®‰∫é‰∏çÂêåÁõÆÁöÑ„ÄÇ

‰∏Ä‰∫õÁ®ãÂ∫èÊàñÂåÖÂèØËÉΩË¶Å‰ΩøÁî®Èùû Rust ‰ª£Á†ÅÔºåÂ¶Ç C ËØ≠Ë®ÄÂ∫ìÔºåÈÇ£‰πàÂú®ÁºñËØëÊó∂‰ºöÈúÄË¶ÅÁºñËØëÁõ∏Â∫îÁöÑÊ∫ê‰ª£Á†ÅÔºåCargo ‰∏çÊâìÁÆó
ÊõøÊç¢ÈÇ£‰∫õÂ∑≤Áªè‰ºòÂåñÂ•ΩÁöÑÁºñËØëÂ∑•ÂÖ∑ÔºåËÄåÊòØÊèê‰æõÊûÑÂª∫ËÑöÊú¨ build.rs Êù•ËæÖÂä©ÊâßË°åÁºñËØëÔºåÂè™Ë¶ÅÂ∞ÜÂÆÉÊîæÂà∞È°πÁõÆÁõÆÂΩï‰∏ãÔºå
Âú®ÊûÑÂª∫Êó∂Âç≥ÂèØ‰ª•ÊâßË°åÔºö

    // Example custom build.rs script.
    fn main() {
        // Tell Cargo that if the given file changes, to rerun this build script.
        println!("cargo:rerun-if-changed=src/hello.c");
        // Use the `cc` crate to build a C file and statically link it.
        cc::Build::new()
            .file("src/hello.c")
            .compile("hello");
    }

‰ΩøÁî®ÊûÑÂª∫ËÑöÊú¨ÁöÑÁî®ÂÆûÁé∞ÁöÑÂäüËÉΩÂåÖÊã¨Ôºö

- Building a bundled C library.
- Finding a C library on the host system.
- Generating a Rust module from a specification.
- Performing any platform-specific configuration needed for the crate.

Cargo Áî® Workspaces ÁöÑÊ¶ÇÂøµÁÆ°ÁêÜÁùÄÈ°πÁõÆÁöÑ PackagesÔºåÂú®È°πÁõÆÈÖçÁΩÆÊñá‰ª∂ Cargo.toml ÊâÄÂú®ÁõÆÂΩïÂÆö‰πâ‰∫Ü
Root packageÔºåÂç≥ÈÖçÁΩÆÊñá‰ª∂‰∏≠ÁöÑ `[package]` Âå∫ÂÆö‰πâÁöÑÈ°∂Á∫ßÂåÖ„ÄÇ

Âú®ÈÖçÁΩÆÊñá‰ª∂‰∏≠ÔºåËøòÂèØ‰ª•Ê∑ªÂä† `[workspace]` ÂÆö‰πâÊõ¥Â§öÁöÑÂåÖÔºåÂÆÉ‰ª¨ÈÉΩÂèØ‰ª•Áúã‰ΩúÁã¨Á´ãÁöÑÂ∑•Á®ãÔºö

    [workspace]
    members = ["member1", "path/to/member2", "crates/*"]
    exclude = ["crates/foo", "path/to/other"]
    default-members = ["path/to/member2", "path/to/member3/foo"]

ÊúÄÁÆÄÂçïÁöÑ Rust Á®ãÂ∫èÔºåÊ≤°Êúâ‰ªª‰Ωï‰æùËµñ„ÄÇÊâÄ‰ª•Â¶ÇÊûú‰ΩøÁî® Cargo Êù•ÊûÑÂª∫ ‚ÄúHello, world!‚Äù È°πÁõÆÔºåÂ∞ÜÂè™‰ºöÁî®Âà∞
Cargo ÊûÑÂª∫‰ª£Á†ÅÁöÑÈÇ£ÈÉ®ÂàÜÂäüËÉΩ„ÄÇÊõ¥Â§çÊùÇÁöÑ Rust Á®ãÂ∫èÔºåÈúÄË¶ÅÊ∑ªÂä†‰æùËµñÈ°πÔºå‰ΩøÁî® Cargo ÂàôÊ∑ªÂä†‰æùËµñÈ°πÂ∞ÜÊõ¥ÂÆπÊòì„ÄÇ

Áî±‰∫éÁªùÂ§ßÂ§öÊï∞ Rust È°πÁõÆ‰ΩøÁî® CargoÔºåÊé•‰∏ãÊù•ÁöÑÊìç‰ΩúÂÅáËÆæ‰Ω†‰πü‰ΩøÁî® Cargo„ÄÇÂÆòÊñπÂÆâË£ÖÂåÖËá™Â∏¶‰∫Ü CargoÔºåÂ¶ÇÊûú
ÈÄöËøáÂÖ∂‰ªñÊñπÂºèÂÆâË£ÖÁöÑËØùÔºåÂèØ‰ª•Âú®ÁªàÁ´ØËæìÂÖ•Â¶Ç‰∏ãÂëΩ‰ª§Ê£ÄÊü•ÊòØÂê¶ÂÆâË£Ö‰∫Ü CargoÔºö

    $ cargo --version

Â¶ÇÊûú‰Ω†ÁúãÂà∞‰∫ÜÁâàÊú¨Âè∑ÔºåËØ¥ÊòéÂ∑≤ÂÆâË£ÖÔºÅÂê¶ÂàôÔºåÂ∫îËØ•Êü•ÁúãÁõ∏Â∫îÂÆâË£ÖÊñáÊ°£‰ª•Á°ÆÂÆöÂ¶Ç‰ΩïÂçïÁã¨ÂÆâË£Ö Cargo„ÄÇ

ÈÄöËøá‰ª•‰∏ãÂëΩ‰ª§ÂèØ‰ª•ÂàõÂª∫ÂèØÊâßË°åÁ®ãÂ∫è„ÄÅÂ∫ìÈ°πÁõÆÔºö

    cargo new hello_world --bin
    cargo new hello_world --lib

‰ΩøÁî® Cargo ÂàõÂª∫Êñ∞È°πÁõÆÔºåÂèØÂú®‰ªª‰ΩïÊìç‰ΩúÁ≥ªÁªü‰∏ãËøêË°å‰ª•‰∏ãÂëΩ‰ª§Êñ∞Âª∫Âêç‰∏∫ hello_cargo ÁöÑÈ°πÁõÆÔºö

    $ cargo new hello_cargo
    $ cd hello_cargo
    $ tree .
    .
    ‚îú‚îÄ‚îÄ Cargo.toml
    ‚îî‚îÄ‚îÄ src
        ‚îî‚îÄ‚îÄ main.rs

    1 directory, 2 files

ËøõÂÖ• hello_cargo ÁõÆÂΩïÂπ∂ÂàóÂá∫Êñá‰ª∂ÔºåÁõÆÂΩïÁªìÊûÑ‰∏≠ÂåÖÂê´ Cargo ÁîüÊàêÁöÑ‰∏§‰∏™Êñá‰ª∂Âíå‰∏Ä‰∏™ÁõÆÂΩïÔºö

- ‰∏Ä‰∏™ Cargo.toml Êñá‰ª∂Ôºõ
- ‰∏Ä‰∏™ src ÁõÆÂΩïÔºå‰ª•Âèä‰Ωç‰∫é src ÁõÆÂΩï‰∏≠ÁöÑ main.rs Êñá‰ª∂„ÄÇ
- Ê†πÁõÆÂΩï‰πüÂàùÂßãÂåñ‰∫Ü‰∏Ä‰∏™ git ‰ªìÂ∫ìÔºå‰ª•Âèä‰∏Ä‰∏™ .gitignore Êñá‰ª∂„ÄÇ

Ê≥®ÊÑèÔºöGit ÊòØ‰∏Ä‰∏™Â∏∏Áî®ÁöÑÁâàÊú¨ÊéßÂà∂Á≥ªÁªü version control system (VCS)„ÄÇÊâßË°å cargo new ÂëΩ‰ª§ÂèØ‰ª•
ÈÄöËøá --vcs ÂèÇÊï∞ÂàáÊç¢Âà∞ÂÖ∂ÂÆÉÁâàÊú¨ÊéßÂà∂Á≥ªÁªüÔºåÊàñËÄÖ‰∏ç‰ΩøÁî® VCS„ÄÇËøêË°å cargo new --help ÂèÇÁúãÂèØÁî®ÁöÑÈÄâÈ°π„ÄÇ

È°πÁõÆÈÖçÁΩÆÊñá‰ª∂ Cargo.toml

    [package]
    name = "hello_cargo"
    version = "0.1.0"
    authors = ["Your Name <you@example.com>"]
    edition = "2018"

    [dependencies]

Ëøô‰∏™Êñá‰ª∂‰ΩøÁî® TOML (Tom's Obvious, Minimal Language) Ê†ºÂºèÔºåËøôÊòØ Cargo ÈÖçÁΩÆÊñá‰ª∂ÁöÑÊ†ºÂºè„ÄÇ

Á¨¨‰∏ÄË°åÔºå[package]ÔºåÊòØ‰∏Ä‰∏™ÁâáÊÆµÔºàsectionÔºâÊ†áÈ¢òÔºåË°®Êòé‰∏ãÈù¢ÁöÑËØ≠Âè•Áî®Êù•ÈÖçÁΩÆ‰∏Ä‰∏™ÂåÖ„ÄÇÈöèÁùÄÊàë‰ª¨Âú®Ëøô‰∏™Êñá‰ª∂
Â¢ûÂä†Êõ¥Â§öÁöÑ‰ø°ÊÅØÔºåËøòÂ∞ÜÂ¢ûÂä†ÂÖ∂‰ªñÁâáÊÆµÔºàsectionÔºâ„ÄÇ

Êé•‰∏ãÊù•ÁöÑÂõõË°åËÆæÁΩÆ‰∫Ü Cargo ÁºñËØëÁ®ãÂ∫èÊâÄÈúÄÁöÑÈÖçÁΩÆÔºöÈ°πÁõÆÁöÑÂêçÁß∞„ÄÅÁâàÊú¨„ÄÅ‰ΩúËÄÖ‰ª•ÂèäË¶Å‰ΩøÁî®ÁöÑ Rust ÁâàÊú¨„ÄÇCargo 
‰ªéÁéØÂ¢ÉÂèòÈáè‰∏≠Ëé∑Âèñ‰Ω†ÁöÑÂêçÂ≠óÂíå email ‰ø°ÊÅØÔºåÊâÄ‰ª•Â¶ÇÊûúËøô‰∫õ‰ø°ÊÅØ‰∏çÊ≠£Á°ÆÔºåËØ∑‰øÆÊîπÂπ∂‰øùÂ≠òÊ≠§Êñá‰ª∂„ÄÇ

ÊúÄÂêé‰∏ÄË°å [dependencies] ÊòØÁΩóÂàóÈ°πÁõÆ‰æùËµñÁöÑÁâáÊÆµÂºÄÂßã„ÄÇÂú® Rust ‰∏≠Ôºå‰ª£Á†ÅÂåÖË¢´Áß∞‰∏∫ crates„ÄÇËøô‰∏™È°πÁõÆ
Âπ∂‰∏çÈúÄË¶ÅÂÖ∂‰ªñÁöÑ crateÔºå‰∏çËøáÂú®ÂêéÈù¢‰ºöÁî®Âà∞‰æùËµñÔºåÈÇ£Êó∂‰ºöÁî®Âæó‰∏äËøô‰∏™ÁâáÊÆµ„ÄÇ

Ê†πÊçÆ‰æùËµñÊâÄÂ≠òÂÇ®ÁöÑ‰ΩçÁΩÆÔºåÂèØ‰ª•Áî®‰∏çÂêåÁöÑÊñπÂºèÊåáÂÆöÔºåÂèÇËÄÉ [Cargo Reference - Specifying Dependencies](cargo/src/reference/specifying-dependencies.md)Ôºö

    [dependencies]
    hello_utils = { path = "hello_utils" }
    hello_utils = { path = "hello_utils", version = "0.1.0" }
    rand = { git = "https://github.com/rust-lang-nursery/rand" }
    rand = { git = "https://github.com/rust-lang-nursery/rand", branch = "next" }

ËøòÂèØ‰ª•Ê†πÊçÆÂπ≥Âè∞ËÆæÁΩÆ‰æùËµñÔºö

    [target.'cfg(windows)'.dependencies]
    winhttp = "0.4.0"

    [target.'cfg(unix)'.dependencies]
    openssl = "1.0.1"

    [target.'cfg(target_arch = "x86")'.dependencies]
    native = { path = "native/i686" }

    [target.'cfg(target_arch = "x86_64")'.dependencies]
    native = { path = "native/x86_64" }

Áé∞Âú®ÊâìÂºÄ src/main.rs ÁúãÁúãÔºö

Êñá‰ª∂Âêç: src/main.rs

    fn main() {
        println!("Hello, world!");
    }

Cargo ‰∏∫‰Ω†ÁîüÊàê‰∫Ü‰∏Ä‰∏™ ‚ÄúHello, world!‚Äù Á®ãÂ∫èÔºåÊ≠£Â¶ÇÊàë‰ª¨‰πãÂâçÁºñÂÜôÁöÑÁ§∫‰æãÔºÅÁõÆÂâç‰∏∫Ê≠¢Ôºå‰πãÂâçÈ°πÁõÆ‰∏é Cargo
ÁîüÊàêÈ°πÁõÆÁöÑÂå∫Âà´ÊòØ Cargo Â∞Ü‰ª£Á†ÅÊîæÂú® src ÁõÆÂΩïÔºåÂêåÊó∂È°πÁõÆÊ†πÁõÆÂΩïÂåÖÂê´‰∏Ä‰∏™ Cargo.toml ÈÖçÁΩÆÊñá‰ª∂„ÄÇ

Cargo ÊúüÊúõÊ∫êÊñá‰ª∂Â≠òÊîæÂú® src ÁõÆÂΩï‰∏≠„ÄÇÈ°πÁõÆÊ†πÁõÆÂΩïÂè™Â≠òÊîæ README„ÄÅlicense ‰ø°ÊÅØ„ÄÅÈÖçÁΩÆÊñá‰ª∂ÂíåÂÖ∂‰ªñË∑ü‰ª£Á†Å
Êó†ÂÖ≥ÁöÑÊñá‰ª∂„ÄÇ‰ΩøÁî® Cargo Â∏ÆÂä©‰Ω†‰øùÊåÅÈ°πÁõÆÂπ≤ÂáÄÊï¥Ê¥ÅÔºå‰∏ÄÂàá‰∫ï‰∫ïÊúâÊù°„ÄÇ

ÂØπ‰∫éÂ∑≤ÊúâÈ°πÁõÆÔºåÂèØ‰ª•Â∞ÜÂÖ∂ËΩ¨Âåñ‰∏∫‰∏Ä‰∏™ Cargo È°πÁõÆ„ÄÇÂè™ÈúÄÂ∞Ü‰ª£Á†ÅÊîæÂÖ• src ÁõÆÂΩïÔºåÂπ∂ÂàõÂª∫ Cargo.toml Êñá‰ª∂„ÄÇ
ÈÄöËøá Cargo ÊûÑÂª∫ÂíåËøêË°åÈ°πÁõÆÁ®ãÂ∫èÂæàÊñπ‰æøÔºåÂú®È°πÁõÆÁõÆÂΩï‰∏ãÔºåËæìÂÖ•‰∏ãÈù¢ÁöÑÂëΩ‰ª§Êù•ÊûÑÂª∫È°πÁõÆÔºö

    $ cargo build
    $ cargo build --release

ÂëΩ‰ª§‰ºöÂàõÂª∫‰∏Ä‰∏™ÂèØÊâßË°åÊñá‰ª∂ÔºåÂú® Windows ‰∏äÊòØ target\debug\hello_cargo.exeÔºå‰∏çÊòØÊîæÂú®ÁõÆÂâçÁõÆÂΩï‰∏ã„ÄÇ
ÂèØ‰ª•ÈÄöËøáËøô‰∏™ÂëΩ‰ª§ËøêË°åÂèØÊâßË°åÊñá‰ª∂Ôºö

    $ ./target/debug/hello_cargo 
    Hello, world!
    
Â¶ÇÊûú‰∏ÄÂàáÈ°∫Âà©ÔºåÁªàÁ´Ø‰∏äÂ∫îËØ•‰ºöÊâìÂç∞Âá∫ Hello, world!„ÄÇÈ¶ñÊ¨°ËøêË°å cargo build Êó∂Ôºå‰πü‰ºö‰Ωø Cargo Âú®È°πÁõÆ
Ê†πÁõÆÂΩïÂàõÂª∫‰∏Ä‰∏™Êñ∞Êñá‰ª∂ÔºöCargo.lock„ÄÇËøô‰∏™Êñá‰ª∂ËÆ∞ÂΩïÈ°πÁõÆ‰æùËµñÁöÑÂÆûÈôÖÁâàÊú¨ÔºåÈ°πÁõÆÊ≤°Êúâ‰æùËµñÔºåÂÖ∂ÂÜÖÂÆπÊØîËæÉÂ∞ë„ÄÇÊ∞∏Ëøú‰πü
‰∏çÈúÄË¶ÅÁ¢∞Ëøô‰∏™Êñá‰ª∂ÔºåËÆ© Cargo Â§ÑÁêÜÂÆÉÂ∞±Ë°å‰∫Ü„ÄÇ

ÂàöÂàö‰ΩøÁî® cargo build ÊûÑÂª∫‰∫ÜÈ°πÁõÆÔºåÂπ∂ËøêË°å‰∫ÜÁ®ãÂ∫èÔºå‰ΩøÁî® cargo run ÂëΩ‰ª§ÂèØ‰ª•ÂêåÊó∂ÁºñËØëÂπ∂ËøêË°åÔºö

    $ cargo run
        Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
         Running `target/debug/hello_cargo`
    Hello, world!

Ê≥®ÊÑèËøô‰∏ÄÊ¨°Âπ∂Ê≤°ÊúâÂá∫Áé∞Ë°®Êòé Cargo Ê≠£Âú®ÁºñËØë hello_cargo ÁöÑËæìÂá∫„ÄÇCargo ÂèëÁé∞Êñá‰ª∂Âπ∂Ê≤°ÊúâË¢´ÊîπÂèòÔºåÂ∞±Áõ¥Êé•
ËøêË°å‰∫Ü‰∫åËøõÂà∂Êñá‰ª∂„ÄÇÂ¶ÇÊûú‰øÆÊîπ‰∫ÜÊ∫êÊñá‰ª∂ÁöÑËØùÔºåCargo ‰ºöÂú®ËøêË°å‰πãÂâçÈáçÊñ∞ÊûÑÂª∫È°πÁõÆÔºåÂπ∂‰ºöÂá∫Áé∞ÂÉèËøôÊ†∑ÁöÑËæìÂá∫Ôºö

    $ cargo run
       Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
        Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
         Running `target/debug/hello_cargo`
    Hello, world!

ËøòÊèê‰æõ‰∫Ü‰∏Ä‰∏™Âè´ cargo check ÂëΩ‰ª§ÔºåÁî®Êù•Âø´ÈÄüÊ£ÄÊü•‰ª£Á†ÅÁ°Æ‰øùÂÖ∂ÂèØ‰ª•ÁºñËØëÔºå‰ΩÜÂπ∂‰∏ç‰∫ßÁîüÂèØÊâßË°åÊñá‰ª∂Ôºö

    $ cargo check
       Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
        Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs

ÈÄöÂ∏∏ cargo check Ë¶ÅÊØî cargo build Âø´ÂæóÂ§öÔºåÂÆÉÁúÅÁï•‰∫ÜÁîüÊàêÂèØÊâßË°åÊñá‰ª∂ÁöÑÊ≠•È™§ÔºåÂè™Êèê‰æõ‰ª£Á†ÅÊ£ÄÊü•ÂäüËÉΩÔºå
Áî®ÂÆÉÊåÅÁª≠Ê£ÄÊü•Á°Æ‰øù‰ª£Á†ÅÂèØ‰ª•ÈÄöËøáÁºñËØëÔºåÂèØ‰ª•Âä†ÈÄüÂºÄÂèëÔºåÂè™ÈúÄË¶ÅÂèØÊâßË°åÊñá‰ª∂Êó∂ÊâçËøêË°å cargo build„ÄÇ

ÂáÜÂ§áÂ•ΩÂèëÂ∏ÉÊó∂Ôºå‰ΩøÁî® `cargo build --release` Êù•‰ºòÂåñÁºñËØëÈ°πÁõÆ„ÄÇËøô‰ºöÂú® target/release ËÄå‰∏çÊòØÂú®
target/debug ÁõÆÂΩï‰∏ãÁîüÊàêÂèØÊâßË°åÊñá‰ª∂„ÄÇËøô‰∫õ‰ºòÂåñÂèØ‰ª•ËÆ© Rust ‰ª£Á†ÅËøêË°åÁöÑÊõ¥Âø´Ôºå‰∏çËøáÂêØÁî®Ëøô‰∫õ‰ºòÂåñ‰πüÈúÄË¶Å
Ê∂àËÄóÊõ¥ÈïøÁöÑÁºñËØëÊó∂Èó¥„ÄÇ

Ëøô‰πüÂ∞±ÊòØ‰∏∫‰ªÄ‰πà‰ºöÊúâ‰∏§Áßç‰∏çÂêåÁöÑÈÖçÁΩÆÔºö‰∏ÄÁßçÊòØ‰∏∫‰∫ÜÂºÄÂèëÔºå‰Ω†ÈúÄË¶ÅÁªèÂ∏∏Âø´ÈÄüÈáçÊñ∞ÊûÑÂª∫ÔºõÂè¶‰∏ÄÁßçÊòØ‰∏∫Áî®Êà∑ÊûÑÂª∫ÊúÄÁªàÁ®ãÂ∫èÔºå
ÂÆÉ‰ª¨‰∏ç‰ºöÁªèÂ∏∏ÈáçÊñ∞ÊûÑÂª∫ÔºåÂπ∂‰∏îÂ∏åÊúõÁ®ãÂ∫èËøêË°åÂæóË∂äÂø´Ë∂äÂ•Ω„ÄÇ

Â¶ÇÊûú‰Ω†Âú®ÊµãËØï‰ª£Á†ÅÁöÑËøêË°åÊó∂Èó¥ÔºåËØ∑Á°Æ‰øù‰ΩøÁî® target/release ‰∏ãÁöÑÂèØÊâßË°åÊñá‰ª∂ËøõË°åÊµãËØï„ÄÇ


ÂØπ‰∫éÁÆÄÂçïÈ°πÁõÆÔºå Cargo Âπ∂‰∏çÊØî rustc Êèê‰æõ‰∫ÜÊõ¥Â§öÁöÑ‰ºòÂäøÔºå‰∏çËøáÈöèÁùÄÂºÄÂèëÁöÑÊ∑±ÂÖ•ÔºåÁªàÂ∞ÜËØÅÊòéÂÖ∂‰ª∑ÂÄº„ÄÇÂØπ‰∫éÊã•Êúâ
Â§ö‰∏™ crate ÁöÑÂ§çÊùÇÈ°πÁõÆÔºå‰∫§Áªô Cargo Êù•ÂçèË∞ÉÊûÑÂª∫Â∞ÜÁÆÄÂçïÁöÑÂ§ö„ÄÇ

Âç≥‰æø hello_cargo È°πÁõÆÂçÅÂàÜÁÆÄÂçïÔºåÂÆÉÁé∞Âú®‰πü‰ΩøÁî®‰∫ÜÂæàÂ§öÂú®‰Ω†‰πãÂêéÁöÑ Rust ÁîüÊ∂ØÂ∞Ü‰ºöÁî®Âà∞ÁöÑÂÆûÁî®Â∑•ÂÖ∑„ÄÇÂÖ∂ÂÆûÔºå
Ë¶ÅÂú®‰ªª‰ΩïÂ∑≤Â≠òÂú®ÁöÑÈ°πÁõÆ‰∏äÂ∑•‰ΩúÊó∂ÔºåÂèØ‰ª•‰ΩøÁî®Â¶Ç‰∏ãÂëΩ‰ª§ÈÄöËøá Git Ê£ÄÂá∫‰ª£Á†ÅÔºåÁßªÂä®Âà∞ËØ•È°πÁõÆÁõÆÂΩïÂπ∂ÊûÑÂª∫Ôºö

    $ git clone someurl.com/someproject
    $ cd someproject
    $ cargo build



## ‚ö° Packages Crates Modules
- https://doc.rust-lang.org/book/ch14-00-more-about-cargo.html
- https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html
- https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
- https://doc.rust-lang.org/rust-by-example/mod.html
- https://doc.rust-lang.org/rust-by-example/crates.html
- https://users.rust-lang.org/t/what-is-the-difference-between-dylib-and-cdylib/28847
- [Publishing a Crate to Crates.io](https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html)
- [Travis CI Rust documentation](https://docs.travis-ci.com/user/languages/rust/)
- [Paths in Expressions](https://doc.rust-lang.org/stable/reference/paths.html#paths-in-expressions)
- [Linkage](https://doc.rust-lang.org/reference/linkage.html)
- [Modules](https://doc.rust-lang.org/stable/reference/items/modules.html)
- [rustc Command-line arguments](https://doc.rust-lang.org/rustc/command-line-arguments.html)
- [The Manifest Format](https://doc.rust-lang.org/cargo/reference/manifest.html)
- [Extern crate declarations](https://doc.rust-lang.org/reference/items/extern-crates.html)
- [The Rust Edition Guide - Path and module system changes](edition-guide/src/rust-2018/path-changes.md)

ÂΩìÂ∑•Á®ãÂ¢ûÈïøÂèòÂ§ßÔºåÂèØ‰ª•ÂàÜÊãÜÊàêÂ∞èÁöÑÊ®°ÂùóËøõË°åÁÆ°ÁêÜÔºåRust Êèê‰æõ‰∫ÜÂÆåÂñÑÁöÑ Cargo Workspaces Â∑•Á®ãÁÆ°ÁêÜÂäüËÉΩÔºå
ÊµãËØï„ÄÅÊåÅÁª≠ÈõÜÊàêÂäüËÉΩÔºåÈÖçÂêà Crates.io ÊâòÁÆ°Âπ≥Âè∞ÂèØ‰ª•Êñπ‰æøÂú∞‰∏é‰ªñ‰∫∫ÂàÜ‰∫´Ëá™Â∑±ÁöÑÊàêÊûúÔºåÊàñÂÖ±‰∫´‰ªñ‰∫∫ÁöÑÊàêÊûú„ÄÇ

Rust ‰ª£Á†ÅÁªÑÁªáÊñπÂºèÔºå‰ªéÂ§ßÂà∞Â∞èÁöÑÂêÑÁßç‰ª£Á†ÅÁªÑÁªáÊñπÂºèÂ¶Ç‰∏ãÔºö

- `Packages`: A Cargo feature that lets you build, test, and share crates
- `Crates`: A tree of modules that produces a `library` or `executable`
- `Modules` and `use`: Let you control the organization, scope, and privacy of paths
- `Paths`: A way of naming an item, such as a struct, function, or module

Cargo new ÂëΩ‰ª§Â∞±‰∏∫Â∑•Á®ãÁîüÊàê‰∏Ä‰∏™È°∂Â±ÇÂåÖÔºåÂú®ÈÖçÁΩÆÊñá‰ª∂ Cargo.toml `[package]` ÈÉ®ÂàÜÂÆö‰πâ„ÄÇÂ∑•Á®ãÂèØ‰ª•
ÂêåÊó∂Êã•Êúâ‰ª•‰∏ã‰∏§‰∏™‰∏ªË¶ÅÁöÑ‰ª£Á†ÅÊñá‰ª∂Ôºåcrate root filesÔºåÂç≥‰ª£Ë°®‰∏§‰∏™ crateÔºå‰∏Ä‰∏™Â∫ìÂíå‰∏Ä‰∏™ÂèØÊâßË°åÁ®ãÂ∫èÔºö

- src/main.rs  --   cargo new hello_world --bin
- src/lib.rs   --   cargo new hello_world --lib

‰ª•‰∏äÊòØ Rust ‰∏≠ÁöÑ‰∏§ÁßçÂü∫Êú¨Á®ãÂ∫èÔºå‰∫åËøõÂà∂ÂèØÊâßË°åÊñá‰ª∂ bin ÂíåÁ±ªÂ∫ì libÔºåÈªòËÆ§‰∏∫ rlib Êâ©Â±ïÂêçË°®Á§∫„ÄÇ

Cargo Áî® Workspaces ÁöÑÊ¶ÇÂøµÁÆ°ÁêÜÁùÄÈ°πÁõÆÁöÑ PackagesÔºåÂú®È°πÁõÆÈÖçÁΩÆÊñá‰ª∂ Cargo.toml ÊâÄÂú®ÁõÆÂΩïÂÆö‰πâ‰∫Ü
Root packageÔºåÂç≥ÈÖçÁΩÆÊñá‰ª∂‰∏≠ÁöÑ `[package]` Âå∫ÂÆö‰πâÁöÑÈ°∂Á∫ßÂåÖ„ÄÇ

Âú®ÈÖçÁΩÆÊñá‰ª∂‰∏≠ÔºåËøòÂèØ‰ª•Ê∑ªÂä† `[workspace]` ÂÆö‰πâÊõ¥Â§öÁöÑÂåÖÔºåÂÆÉ‰ª¨ÈÉΩÂèØ‰ª•Áúã‰ΩúÁã¨Á´ãÁöÑÂ∑•Á®ãÔºö

    [workspace]
    members = ["member1", "path/to/member2", "crates/*"]
    exclude = ["crates/foo", "path/to/other"]
    default-members = ["path/to/member2", "path/to/member3/foo"]


Âú® Cargo.toml ‰∏≠ÂèØ‰ª•ÈÖçÁΩÆÂèØÊâßË°åÁ®ãÂ∫èÂíåÂ∫ìÔºö

    [lib]
    name = "foobar"
    crate-type = ["rlib"]

    [[bin]]
    name = "demo"
    path = "src/bin/demo.rs"

    [[example]]
    name = "demo"
    path = "example/demo.rs"

Rust ÁºñËØëÁîüÊàêÁöÑÂ∫ìÊñá‰ª∂Á±ªÂûãÊúâ‰ª•‰∏ãËøô‰∫õÔºö

- **lib** ‚Äî Generates a library kind preferred by the compiler, currently defaults to rlib.
- **rlib** ‚Äî A Rust static library.
- **dylib** ‚Äî A Rust dynamic library.
- **cdylib** ‚Äî A native dynamic library.
- **staticlib** ‚Äî A native static library.
- **bin** ‚Äî A runnable executable program.
- **proc-macro** ‚Äî Generates a format suitable for a procedural macro library that may be loaded by the compiler.

Rust static library ÊòØÂπ≥Âè∞Êó†ÂÖ≥ÁöÑÁâπÂÆöÈùôÊÄÅ‰∏≠Èó¥Â∫ìÊ†ºÂºèÔºåÂèØ‰ª•‰æõÁ∫Ø Rust ‰ª£Á†ÅÈ°πÁõÆ‰πãÈó¥ÁöÑ‰æùËµñÂíåË∞ÉÁî®„ÄÇ
ÂÆÉÊòØ‰∏Ä‰∏™ÂΩíÊ°£Êñá‰ª∂ÔºåÂåÖÂê´ÂæàÂ§ö metadata ‰ø°ÊÅØÔºàÊØîÂ¶ÇÂèØËÉΩÁöÑ‰∏äÊ∏∏‰æùËµñ‰ø°ÊÅØÔºâÔºåÁî®Êù•ÂÅöÂêéÈù¢ÁöÑ linkage„ÄÇ

Âä®ÊÄÅËøûÊé•Â∫ìÊòØÂπ≥Âè∞Áõ∏ÂÖ≥ÁöÑÂ∫ìÔºåÊ†πÊçÆÂπ≥Âè∞‰ΩøÁî®‰∏çÂêåÊâ©Â±ïÂêçÔºåLinux ‰∏ä‰∏∫ .so, MacOS ‰∏ä‰∏∫ .dylib, Windows 
‰∏ä‰∏∫ .dll„ÄÇÂä®ÊÄÅÂ∫ì‰∏ç‰ºöË¢´ÈìæÊé•Âà∞ÁõÆÊ†áÊñá‰ª∂‰∏≠ÔºåÂè™ÊòØË¢´Á®ãÂ∫èÂä®ÊÄÅË∞ÉÁî®„ÄÇ

ËøáÁ®ãÂÆèÊòØÂº∫Â§ßÁöÑÁºñÁ®ãÂ∑•ÂÖ∑ÔºåÂÆÉÈÄöËøáÊèê‰æõÊäΩË±°ËØ≠Ê≥ïÊ†ëÁöÑÊï∞ÊçÆÁªìÊûÑÊù•ÂÆûÁé∞ÂêÑÁßçÂäüËÉΩÔºåÁÆÄÂåñÈÖçÁΩÆ proc-macro = trueÔºå
ËøôÁßç crate ÈáåÈù¢Â∞±ËÉΩÂØºÂá∫ËøáÁ®ãÂÆèÔºåË¢´ÂØºÂá∫ÁöÑËøáÁ®ãÂÆèÂèØ‰ª•Ë¢´ÂÖ∂ÂÆÉ crate ÂºïÁî®„ÄÇ


Âπ≥Âè∞ÂéüÁîüÂ∫ì‰∏ÄËà¨Êåá C ËßÑËåÉÂä®ÊÄÅÂ∫ìÔºåËøôÁßçÂä®ÊÄÅÂ∫ìÂèØ‰ª•Ë¢´ÂÖ∂ÂÆÉËØ≠Ë®ÄË∞ÉÁî®Ôºå‰πüÂ∞±ÊòØË∑®ËØ≠Ë®Ä FFI ‰ΩøÁî®ÔºåÂõ†‰∏∫Âá†‰πéÊâÄÊúâ
ËØ≠Ë®ÄÈÉΩÊúâÈÅµÂæ™ C ËßÑËåÉÁöÑ FFI ÂÆûÁé∞„ÄÇËøòÂåÖÊã¨ `staticlib` ÈùôÊÄÅÂ∫ìÔºåLinux Âíå MacOS ‰∏äÁºñËØë‰ºöÁîüÊàê .a 
Êñá‰ª∂ÔºåÊàñÂú® Windows ‰∏äÁîüÊàê .lib Êñá‰ª∂„ÄÇÁºñËØëÂô®‰ºöÊääÊâÄÊúâÂÆûÁé∞ÁöÑ Rust Â∫ì‰ª£Á†Å‰ª•Âèä‰æùËµñÁöÑÂ∫ì‰ª£Á†ÅÂÖ®ÈÉ®ÁºñËØë
Âà∞‰∏Ä‰∏™ÈùôÊÄÅÂ∫ìÊñá‰ª∂‰∏≠Ôºå‰πüÂ∞±ÊòØÂØπÂ§ñÁïå‰∏ç‰∫ßÁîü‰ªª‰Ωï‰æùËµñ‰∫Ü„ÄÇËøôÁâπÂà´ÈÄÇÂêàÂ∞Ü Rust ÂÆûÁé∞ÁöÑÂäüËÉΩÂ∞ÅË£ÖÂ•ΩÁªôÁ¨¨‰∏âÊñπÂ∫îÁî®‰ΩøÁî®„ÄÇ

Âú®Â∑•Á®ãÁõÆÂΩï‰∏ãÊúâ‰∏§‰∏™ÈªòËÆ§ÁöÑÁõÆÂΩïÔºö

- `/src/bin` ÈªòËÆ§Á®ãÂ∫èÁõÆÂΩï„ÄÇ
- `/src/examples` Á§∫ËåÉÁ®ãÂ∫èÈªòËÆ§Â≠òÊîæÁõÆÂΩï„ÄÇ

Ëøô‰∫õÁ®ãÂ∫èÂèØ‰ª•ÈÄöËøáÊåáÂÆö --bin Êàñ --example ÈÄâÈ°πÊù•ËøêË°åÔºåËÄå‰∏çÁî®Âú® Cargo.toml ‰∏≠ÈÖçÁΩÆÔºåÂ¶ÇÊûúÊòØÂÖ∂ÂÆÉ
ÁõÆÂΩï‰∏ãÁöÑÁ®ãÂ∫èÔºåÂ∞±ÈúÄË¶ÅÈÖçÁΩÆÊâçËÉΩÊ≠£Á°ÆÊâßË°å„ÄÇ

    cargo run --bin demo
    cargo run --example demo

Ëøô‰∫õÁõÆÂΩï‰ª£Á†Å‰ΩøÁî®Âêå‰∏ÄÂ•óÂ∑•Á®ãÈÖçÁΩÆÔºåÂç≥Â∑•Á®ãÊ†πÁõÆÂΩï‰∏ãÁöÑ Cargo.toml ÁöÑÈÖçÁΩÆÂØπËøô‰∫õÁ®ãÂ∫èÂêåÊ†∑ÊúâÊïà„ÄÇ

ÂÖ∂ÂÆÉËÆæÁΩÆÂèÇËÄÉ The Manifest Format„ÄÇ


Crates ÁªÑÁªáÁöÑÊòØÁõ∏ÂÖ≥ÁöÑÂáΩÊï∞ÔºåÂç≥ÂèØ‰ª•ÂΩì‰ΩúÂáΩÊï∞Â∫ìÁúãÂæÖ„ÄÇÂ¶ÇÂÖ•Èó®ÁåúÊï∞Â≠óÊ∏∏ÊàèÔºåÈÄöËøá `use rand::Rng;` Â∞Ü
rand::Rng ÂØºÂÖ•Âà∞ÂΩìÂâçÁöÑ‰ΩúÁî®ÂüüÂ∞±ÂèØ‰ª•‰ΩøÁî®Ôºå‰ΩÜÂÆÉÊú¨Ë∫´‰ªçÂ§Ñ‰∫éÂéüÊúâÁöÑ‰ΩúÁî®Âüü‰∏ã„ÄÇ

Crates ‰∏≠ÁöÑ‰ª£Á†ÅÂèØ‰ª•ÂàÜÊ®°ÂùóÁÆ°ÁêÜÔºå‰ª•‰æø‰∫éÂèØËØªÊÄßÂíåÈáçÁî®ÔºåÈÄöËøá `mod` ÂÖ≥ÈîÆÂ≠óÂÆö‰πâÔºåÂÖ≥ÈîÆÂ≠ó `pub` ÊéßÂà∂ËÆøÈóÆ„ÄÇ
Ê†πÊçÆËØ≠Ê≥ïÂÆö‰πâÔºåÊúâ‰∏§ÁßçÊ®°ÂùóÂÆö‰πâÂΩ¢ÂºèÔºå`mod IDENTIFIER;` ËøôÁßçÊõ¥Â∏∏Áî®ÔºåÂÆÉÂ∞ÜÊ®°ÂùóÂàÜËß£Âà∞ÂêÑ‰∏™Êñá‰ª∂ËøõË°åÁÆ°ÁêÜÔºö

      unsafe? mod IDENTIFIER ;
    | unsafe? mod IDENTIFIER {
        InnerAttribute*
        Item*
      }

‰æãÂ¶ÇÔºå‰∏Ä‰∏™Â∫ìÁ§∫ËåÉÔºåÂú®Êñá‰ª∂ÂÜÖÂÆö‰πâÊ®°ÂùóÔºåËøôÈáåÊ®°ÂùóÊ≤°ÊúâÂä† `pub` ÂâçÁºÄÔºåË°®Á§∫ÁßÅÊúâ‰∏çÂ§ñÈÉ®ËÆøÈóÆÔºåÂè™‰æõÁà∂Á∫ßËÆøÈóÆÔºö

```rust,ignore
// Filename: src/lib.rs
#[allow(unused)]
#[allow(dead_code)]
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

Ê≥®ÊÑèÔºåÊ®°ÂùóÂëΩÂêç‰ΩøÁî®ËõáÂΩ¢ËßÑÂàôÔºåËÄå‰∏çÊòØÈ©ºÂ≥∞ÂëΩÂêçËßÑÂàôÔºå‰∏§ËÄÖËØ¥ÊòéÂ¶Ç‰∏ãÔºö

- Snake case name Âç≥ÂÖ®Áî®Â∞èÂÜôÂ≠óÊØçÔºåÂçïÂ≠óÂàÜÈöîÁî®‰∏ãÂàíÁ∫øÔºåfile_name„ÄÅline_number„ÄÇ
- Camel case name ÂèòÈáèËµ∑ÂêçÂ≠óÈ¶ñÂ≠óÊØçÂ∞èÂÜôÔºåÂêéÈù¢ÂçïËØçÈ¶ñÂ≠óÊØçÂ§ßÂÜôÔºå‰æãÂ¶ÇÔºöfileName„ÄÅlineNumber„ÄÇ

Ëøô‰∏™Ê®°ÂùóÁªÑÁªá‰∏ãÁöÑ Crates Tree ÁªìÊûÑÂ¶Ç‰∏ãÔºåÈªòËÆ§ÈöêÂºèÊèê‰æõ‰∫Ü crate root Ê®°ÂùóÔºö

    crate
     ‚îî‚îÄ‚îÄ front_of_house
         ‚îú‚îÄ‚îÄ hosting
         ‚îÇ   ‚îú‚îÄ‚îÄ add_to_waitlist
         ‚îÇ   ‚îî‚îÄ‚îÄ seat_at_table
         ‚îî‚îÄ‚îÄ serving
             ‚îú‚îÄ‚îÄ take_order
             ‚îú‚îÄ‚îÄ serve_order
             ‚îî‚îÄ‚îÄ take_payment

Êúâ‰∫ÜËøô‰∏™ Crates TreeÔºåÂ∞±ÂèØ‰ª•ÈÄöËøáË∑ØÂæÑÊù•ÂºïÁî®ÂØπÂ∫îÁöÑÂáΩÊï∞‰∫ÜÔºåÂèØ‰ΩøÁî®ÁªùÂØπÊàñÁõ∏ÂØπË∑ØÂæÑÔºåÂ¶ÇÊûúÂú®Áõ∏ÂêåÊ®°Âùó‰∏≠
ËøòÂèØ‰ª•‰ΩøÁî® `super::` ËÆøÈóÆÁà∂Ê®°ÂùóÊàñ `self::` ËÆøÈóÆÂΩìÂâçÊ®°ÂùóÔºö

```rust,ignore
pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

Ê≥®ÊÑèÔºåÂÖ¨ÂºÄËÆøÈóÆÁöÑÂáΩÊï∞ÊàñÁ±ªÂûãÈúÄË¶ÅÂâçÁºÄ `pub` ÂÖ≥ÈîÆÂ≠óÔºåÁªìÊûÑ‰ΩìÊàêÂëò‰πãÁ±ª‰πüË¶ÅÂâçÁºÄ `pub` ÊâçÂèØ‰ª•ÂÖ¨ÂºÄËÆøÈóÆ„ÄÇ
Âú®Â§ñÈÉ®ÂºïÁî®Ê®°ÂùóÊó∂ÔºåÈÄöËøá `use` ÂÖ≥Á≥ªÂ≠óÂØºÂÖ•Âà∞ÂΩìÂâç‰ΩúÁî®ÂüüÔºåÂèØ‰ΩøÁî® `as` Ëµ∑Âà´ÂêçÔºö

```rust,ignore
use crate::front_of_house::hosting;
use std::io::Result as IoResult;

// Re-exporting Names with pub use
pub use crate::front_of_house::hosting;

// use std::cmp::Ordering;
// use std::io;
use std::{cmp::Ordering, io};

// bring all by *, the glob operator
use std::collections::*;
```

ÈúÄË¶Å‰ΩøÁî®Â§ñÈÉ®Ê®°ÂùóÔºåÂ∞±ÈÖçÁΩÆ Cargo.toml `[dependencies]`ÔºåÁÑ∂ÂêéÈÄöËøá Cargo ÂëΩ‰ª§ÂÆâË£Ö‰æùËµñ„ÄÇ 

Â¶ÇÊûúÊâÄÊúâÂáΩÊï∞ÈÉΩÂÆö‰πâÂú®Âêå‰∏Ä‰∏™Êñá‰ª∂‰∏≠ÔºåÂΩì‰ª£Á†ÅÂèòÂ§öÂêéÔºåÁõ¥Êé•ÊåâÊ®°ÂùóÂêçÁöÑÁªìÊûÑÊñ∞Âª∫‰ª£Á†ÅÊñá‰ª∂ÔºåÂç≥ÂèØÂÆåÊàêÊ®°ÂùóÂàÜÊãÜÔºö

    src/front_of_house/hosting.rs


‰ª•‰∏ãÊòØ‰∏§ÁßçÊ®°ÂùóÈ£éÊ†ºÁöÑÁõÆÂΩïÊ†ëÔºö

    src/
    +-- lib.rs
    +-- util.rs
    +-- util/
        +-- config.rs

    src/
    +-- lib.rs
    +-- util/
        +-- mod.rs
        +-- config.rs

|     Module Path     | Filesystem Path | File Contents |
|---------------------|-----------------|---------------|
| crate               | lib.rs          | mod util;     |
| crate::util         | util.rs         | mod config;   |
| crate::util::config | util/config.rs  |               |

Ê®°ÂùóË∑ØÂæÑ‰∏éÊñá‰ª∂Ë∑ØÂæÑÁöÑÂÖ≥Á≥ªËØ¥ÊòéÂ¶Ç‰∏ãÔºö

- lib.rs Êñá‰ª∂ÂÆö‰πâÁßÅÊúâÊ®°Âùó `mod util;` ÂØπÂ∫î uitl.rsÔºåÈÄöËøá `util::` ÊàñËÄÖ `crate::util::` ÂëΩÂêçÁ©∫Èó¥ÂéªËÆøÈóÆÊ®°ÂùóÂÜÖÂÆπÔºõ
- util.rs Êñá‰ª∂ÂÆö‰πâÁßÅÊúâÊ®°Âùó `mod config;` ÂØπÂ∫î util/config.rsÔºåÊâÄ‰ª•Âú® lib.rs ‰∏≠‰∏çÂèØ‰ª•ËÆøÈóÆ `util::config` Ê®°ÂùóÔºåÈô§ÈùûÂÆÉÂÆö‰πâ‰∏∫ `pub`„ÄÇ

ÂΩìÊ®°ÂùóÁõÆÂΩï‰∏ãÂåÖÂê´ `mod.rs` Êó∂ÔºåÁõÆÂΩïÂêçÂç≥Á≠â‰ª∑‰∫éÊ®°ÂùóÂêçÔºåÂØπ‰∫é‰∏äÈù¢ÁöÑ `crate::util` Ê®°ÂùóÔºåÂèØ‰ª•ÂàõÂª∫
‰∏Ä‰∏™ `util/mod.rs` Êñá‰ª∂Ôºå‰ΩÜ‰∏çËÉΩÂêåÊó∂Â≠òÂú®ÂíåÁõÆÂΩïÂêåÂêçÁöÑ `util.rs`„ÄÇ


Â∫ìÈ°πÁõÆÁºñËØëÂêéÂ∞±ÂèØ‰ª•Ë¢´ÂÖ∂ÂÆÉÈ°πÁõÆÂºïÁî®Ôºö

    cargo build --release
       Compiling hello_world v0.1.0 (path\to\rust\lib)
        Finished release [optimized] target(s) in 0.64s

Âè™ÈúÄË¶ÅÈÖçÁΩÆ‰∏Ä‰∏ã‰æùËµñÔºö

    [dependencies]
    hello_world = { path = "../hello_world" }

Ëøô‰∫õÊ®°ÂùóÁºñËØëÂêéÁîüÊàêÁöÑ lib ËæìÂá∫Â∞±Áß∞‰πã‰∏∫ CratesÔºå‰π†ÊÉØ‰∏äÈÅøÂÖçÂºïÂÖ•ËøáÂ§öÁöÑÂêçËØçÔºåÂèØ‰ª•Âè´ÂÅöÊ®°ÂùóÔºåÊòØÂÖ±‰∫´ÂèëÂ∏É
ÁöÑÊ®°Âùó„ÄÇÂèØ‰ª•ÈÄöËøá crates.io Á§æÂå∫ÔºåÂèØ‰ª•‰∏é‰∏ñÁïåÂàÜ‰∫´‰Ω†ÁöÑ CratesÔºå‰ΩøÁî® Cargo ÊâìÂåÖ„ÄÅÂèëÂ∏ÉÂëΩ‰ª§‰∏äËΩΩÊâòÁÆ°„ÄÇ

ÂèëÂ∏É Crates Êó∂Ë¶ÅÊ≥®ÊÑèÔºåÂèëÂ∏ÉÊòØÂ∏∏È©ªÔºåÂç≥Ê∞∏Ëøú‰∏çËÉΩË¶ÜÁõñÂêåÁâàÊú¨ÔºåÂπ∂‰∏îÊó†Ê≥ïÂà†Èô§‰ª£Á†ÅÔºå‰ΩÜÊòØÔºåÂèØ‰ª•ÂèëÂ∏ÉÁöÑÁâàÊú¨Êï∞Èáè
Ê≤°ÊúâÈôêÂà∂„ÄÇËÄåÂêçÂ≠óÂàôÈááÂèñÂÖàÁî®ÂÖàÂæóÂéüÂàôÔºå‰Ω†‰∏çËÉΩ‰ΩøÁî®Âà´‰∫∫Â∑≤ÁªèÁî®ËøáÁöÑÂêçÂ≠ó„ÄÇ

‰Ω†ÈúÄË¶ÅÂú® crates.io Ê≥®ÂÜå‰∏Ä‰∏™Â∏êÊà∑ÔºåËé∑Âèñ API TokenÔºåÂπ∂ËøêË°å cargo login ÂëΩ‰ª§ËÅîÈÄöË¥¶Âè∑Âç≥ÂèØ„ÄÇ

Âè¶Â§ñÔºåRust ËøòÊúâ Extern crate Â£∞ÊòéÁöÑËØ≠Ê≥ïÔºö

    extern crate std as ruststd;

ÂèØ‰ª•Áî®Êù•Â∞ÜÊåáÂÆöÁöÑ Crate ÈìæÊé•Âà∞ÂΩìÂâçÁöÑÂ∫ì‰∏≠ÔºåÂêåÊó∂ÔºåÂÆÉÂØºÂÖ•Ê®°Âùó‰∏ãÁöÑÊâÄÊúâÈ°πÂà∞ÂΩìÂâçÂ∫ì„ÄÇ


Cargo ‰∏ãËΩΩÊ∫êÂèØ‰ª•ÊåâÈúÄË¶ÅËøõË°åÈÖçÁΩÆÔºå‰πüÂèØ‰ª•ÈÖçÁΩÆÊú¨Âú∞Ê∫ê„ÄÇÂ§ßÈôÜÁî®Êà∑ÂèØËÉΩÂõ†‰∏∫ÁΩëÁªúÂéüÂõ†ÂØºËá¥ÂëΩ‰ª§Âç°Ê≠ªÔºö

    Blocking waiting for file lock on package cache

Ëøô‰∏™ÈóÆÈ¢ò‰πüÂèØËÉΩÊòØ Cargo.lock Ë¢´ÂÖ∂‰ªñÁ®ãÂ∫èÁã¨Âç†ÊâìÂºÄÔºå‰∏ÄËà¨ÂÖ≥ÊéâÈÇ£‰∏™Á®ãÂ∫èÂ∞±Ë°å„ÄÇËøòÊúâ‰∏Ä‰∏™ÂèØËÉΩÊòØÁºìÂ≠òÁõÆÂΩï‰∏ãÁöÑ 
`~/.cargo/.package_cache` Ë¢´Âä†ÈîÅÈòªÂ°ûÔºåÂà†Èô§ÂÆÉÂèØ‰ª•Ëß£ÂÜ≥„ÄÇ

Ê≥®ÂÜåÊ∫êÊú¨Ë∫´Êèê‰æõ git Á¥¢ÂºïÔºåËØ•Â≠òÂÇ®Â∫ìÂåπÈÖç crates.io Á¥¢ÂºïÊ†ºÂºèÔºåÂèØ‰ª•ÊåáÁ§∫ Cargo ‰ªéÂì™Èáå‰∏ãËΩΩ‰æùËµñÂåÖ„ÄÇ
Cargo Ê∫êÊúâ‰∏§ÁßçÈÖçÁΩÆÊñπÂºèÔºåÂÖ®Â±ÄÈÖçÁΩÆÈúÄË¶ÅÂàõÂª∫ $HOME/.cargo/config Êñá‰ª∂ÔºåTOML Ê†ºÂºèÔºåÁÑ∂ÂêéÂú®ÈÖçÁΩÆÊñá‰ª∂
ÂÜÖÂÜôÂÖ•ÈÖçÁΩÆÂÜÖÂÆπ„ÄÇÂú®È°πÁõÆ‰∏≠ÔºåÈúÄË¶ÅÂú® Cargo.toml ÂêåÁ∫ßÁõÆÂΩïÂàõÂª∫ `.cargo/config` Êñá‰ª∂„ÄÇ

‰ª•‰∏ãÂõΩÂÜÖÊ∫êÈÖçÁΩÆÈïúÂÉèÈÖçÁΩÆ‰∏Ä‰∏™Âç≥ÂèØÔºåÊó†ÈúÄÂÖ®ÈÉ®Ôºö

    [source.crates-io]
    registry = "https://github.com/rust-lang/crates.io-index"

    # ‰∏≠ÂõΩÁßëÂ≠¶ÊäÄÊúØÂ§ßÂ≠¶
    [source.ustc]
    registry = "https://mirrors.ustc.edu.cn/crates.io-index"
    # or use git protocol
    # registry = "git://mirrors.ustc.edu.cn/crates.io-index"

    # ‰∏äÊµ∑‰∫§ÈÄöÂ§ßÂ≠¶
    [source.sjtu]
    registry = "https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index/"

    # Ê∏ÖÂçéÂ§ßÂ≠¶
    [source.tuna]
    registry = "https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git"

    # rustccÁ§æÂå∫
    [source.rustcc]
    registry = "https://code.aliyun.com/rustcc/crates.io-index.git"

ÂçèËÆÆÊé®Ëçê‰ΩøÁî® gitÔºå‰ΩÜÂØπ‰∫é HTTPS Âíå git ÂçèËÆÆÔºå‰∏ÄËà¨ÂêÑÈïúÂÉèÊ∫êÈÉΩÊîØÊåÅÔºåÂπ∂‰∏îÊòØÂèØ‰ª•‰∫íÊç¢ÁöÑ„ÄÇ

Cargo ËøêË°åÂèó package cache Êñá‰ª∂ÈîÅÂÆöÂΩ±ÂìçÔºåÂèØ‰ª•Â∞ùËØïÂà†Èô§ `~/.cargo/.package-cache` Êñá‰ª∂„ÄÇ
Cargo ÂèØ‰ª•Âíå Travis CI Êàñ GitLab CI Á≠âÊåÅÁª≠ÈõÜÊàêÂ∑•ÂÖ∑‰∏ÄËµ∑Â∑•‰Ωú„ÄÇ

ÊµãËØïÂ∫ì‰∏é Travis CI ÁöÑÈÖçÁΩÆÊñá‰ª∂ .travis.ymlÔºö

    language: rust
    rust:
      - stable
      - beta
      - nightly
    matrix:
      allow_failures:
        - rust: nightly

ÊµãËØïÂ∫ì‰∏é GitLab CI ÁöÑÈÖçÁΩÆÊñá‰ª∂ .gitlab-ci.ymlÔºö

    stages:
      - build

    rust-latest:
      stage: build
      image: rust:latest
      script:
        - cargo build --verbose
        - cargo test --verbose

    rust-nightly:
      stage: build
      image: rustlang/rust:nightly
      script:
        - cargo build --verbose
        - cargo test --verbose
      allow_failure: true


## ‚ö° HelloWorldüîÜüîÖ
- [The Rust Programming Language](https://doc.rust-lang.org/book/ch01-00-getting-started.html)
- [The Rust Programming Language zh_CN](https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html)
- [ÂàùËØÜ Rust](https://wudaijun.com/2020/02/rust-basic/)
- [2.101. lang_items](https://doc.rust-lang.org/unstable-book/language-features/lang-items.html)
- [The Rust Programming Language - Basic Rust Literacy - Accepting Command Line Arguments](ch12-01-accepting-command-line-arguments.md)

Rust Âπ∂‰∏çÂÖ≥ÂøÉ‰ª£Á†ÅÁöÑÂ≠òÊîæ‰ΩçÁΩÆÔºå‰∏çËøáÂª∫ËÆÆÂú®Â∑•‰ΩúÁõÆÂΩï‰∏≠Ôºå‰ΩøÁî® cargo Â∑•ÂÖ∑ÂàõÂª∫Â∑•Á®ãÁõÆÂΩïÔºåÂ≠òÊîæÊâÄÊúâÈ°πÁõÆ„ÄÇ

ÊâìÂºÄÁªàÁ´ØÂπ∂ËæìÂÖ• cargo new ÂëΩ‰ª§ÂàõÂª∫‰∏Ä‰∏™Â∑•Á®ãÔºåÂÆÉ‰ºöËá™Âä®ÊåâÁªôÂÆöÁöÑÂ∑•Á®ãÂêçÂàõÂª∫ÁõÆÂΩïÔºåÂπ∂ÂåÖÂê´‰∏ÄÊÆµÁ§∫ËåÉ‰ª£Á†Å„ÄÇ

    cargo new demo

    cd demo
    cargo build
    cargo run
    cargo check

Ê∫êÊñá‰ª∂ÂëΩÂêç‰∏∫ `main.rs`ÔºåRust Ê∫êÊñá‰ª∂ÊÄªÊòØ‰ª• .rs Êâ©Â±ïÂêçÁªìÂ∞æ„ÄÇÊñá‰ª∂ÂêçÂåÖÂê´Â§ö‰∏™ÂçïËØçÔºå‰ΩøÁî®‰∏ãÂàíÁ∫øÂàÜÈöî„ÄÇ
‰æãÂ¶ÇÂëΩÂêç‰∏∫ hello_world.rsÔºåËÄå‰∏çÊòØ helloworld.rs„ÄÇCargo ÂëΩ‰ª§ÂèØ‰ª•ÁîüÊàêÂ∑•Á®ã„ÄÅÁºñËØëÊàñËÄÖÊâßË°åÁ®ãÂ∫è„ÄÇ

Â∑•Á®ãÂåÖÂê´ÈÖçÁΩÆÊñá‰ª∂ Cargo.tomlÔºö

    [package]
    name = "hello_cargo"
    version = "0.1.0"
    authors = ["Your Name <you@example.com>"]
    edition = "2018"

    [dependencies]

Áé∞Âú®ÊâìÂºÄÂàöÂàõÂª∫ÁöÑÁ§∫‰æãÔºåÊñá‰ª∂Âêç: main.rs

    fn main() {
        println!("Hello, world!");
    }

‰øùÂ≠òÊñá‰ª∂ÔºåÂπ∂ÂõûÂà∞ÁªàÁ´ØÁ™óÂè£„ÄÇÂú® Linux Êàñ macOS ‰∏äÔºåËæìÂÖ• rustc ÁºñËØëÂëΩ‰ª§ÔºåÁºñËØëÂπ∂ËøêË°åÊñá‰ª∂Ôºö

    $ rustc main.rs
    $ ./main
    Hello, world!

Âú® Windows ‰∏äÔºåËæìÂÖ•ÂëΩ‰ª§ .\main.exeÔºåËÄå‰∏çÊòØ ./mainÔºö

    > rustc main.rs
    > .\main.exe
    Hello, world!

‰∏çÁÆ°‰ΩøÁî®‰ΩïÁßçÊìç‰ΩúÁ≥ªÁªüÔºåÁªàÁ´ØÂ∫îËØ•ÊâìÂç∞Â≠óÁ¨¶‰∏≤ Hello, world!„ÄÇ

ÁÆÄÂçïÁ®ãÂ∫èÈ°πÁõÆÁºñËØë‰ΩøÁî® rustc ÊòØÊ≤°ÈóÆÈ¢òÁöÑÔºå‰ΩÜÊòØ cargo Ëøô‰∏™Â∑•ÂÖ∑ÁÆ°ÁêÜÈ°πÁõÆÊõ¥Êñπ‰æøÔºåÂπ∂ËÆ©‰ª£Á†ÅÊòì‰∫éÂàÜ‰∫´„ÄÇÂ¶ÇÊûú
‰Ω†Êúâ C/C++ ËÉåÊôØÔºåÂèØ‰ª•ÂèëÁé∞Ëøô‰∏é gcc Âíå clang Á±ª‰ºº„ÄÇÁºñËØëÊàêÂäüÂêéÔºåRust ‰ºöËæìÂá∫‰∏Ä‰∏™‰∫åËøõÂà∂ÁöÑÂèØÊâßË°åÊñá‰ª∂„ÄÇ


Á®ãÂ∫è‰∏≠ main() ÊòØ‰∏Ä‰∏™Á®ãÂ∫èÂÖ•Âè£ÂáΩÊï∞ÔºöÂú®ÂèØÊâßË°åÁöÑ Rust Á®ãÂ∫è‰∏≠ÔºåÂÆÉÊÄªÊòØÊúÄÂÖàËøêË°åÁöÑ‰ª£Á†Å„ÄÇÊ≥®ÊÑè main ÂáΩÊï∞
Ê≤°ÊúâÂèÇÊï∞‰πüÊ≤°ÊúâËøîÂõûÂÄº„ÄÇÂ¶ÇÊûúÊúâÂèÇÊï∞ÁöÑËØùÔºåÂÆÉ‰ª¨ÁöÑÂêçÁß∞Â∫îËØ•Âá∫Áé∞Âú® () Êã¨Âè∑‰∏≠„ÄÇ

ËøòÈ°ªÊ≥®ÊÑèÔºåÂáΩÊï∞‰ΩìË¢´ÂåÖË£πÂú® {} Ëä±Êã¨Âè∑‰∏≠ÔºåÊâÄÊúâÂáΩÊï∞‰ΩìÈÉΩË¶ÅÁî®Ëä±Êã¨Âè∑ÂåÖË£πËµ∑Êù•„ÄÇ‰∏ÄËà¨Êù•ËØ¥ÔºåÂ∞ÜÂ∑¶Ëä±Êã¨Âè∑‰∏éÂáΩÊï∞Â£∞Êòé
ÁΩÆ‰∫éÂêå‰∏ÄË°åÂπ∂‰ª•Á©∫Ê†ºÂàÜÈöîÔºåÊòØËâØÂ•ΩÁöÑ‰ª£Á†ÅÈ£éÊ†º„ÄÇ

Â¶ÇÊûú‰Ω†Â∏åÊúõÂú® Rust È°πÁõÆ‰∏≠‰øùÊåÅ‰∏ÄÁßçÊ†áÂáÜÈ£éÊ†ºÔºårustfmt ‰ºöÂ∞Ü‰ª£Á†ÅÊ†ºÂºèÂåñ‰∏∫ÁâπÂÆöÁöÑÈ£éÊ†º„ÄÇRust Âõ¢ÈòüËÆ°ÂàíÊúÄÁªà
Â∞ÜËØ•Â∑•ÂÖ∑ÂåÖÂê´Âú®Ê†áÂáÜ Rust ÂèëË°åÁâà‰∏≠ÔºåÂ∞±ÂÉè rustc„ÄÇ

Âú® main() ÂáΩÊï∞‰∏≠‰ª£Á†ÅÂÆåÊàêËøô‰∏™ÁÆÄÂçïÁ®ãÂ∫èÁöÑÊâÄÊúâÂ∑•‰ΩúÔºöÂú®Â±èÂπï‰∏äÊâìÂç∞ÊñáÊú¨„ÄÇ

ËøôÈáåÊúâÂõõ‰∏™ÈáçË¶ÅÁöÑÁªÜËäÇÈúÄË¶ÅÊ≥®ÊÑèÔºö

- È¶ñÂÖà Rust ÁöÑÁº©ËøõÈ£éÊ†º‰ΩøÁî® 4 ‰∏™Á©∫Ê†ºÔºåËÄå‰∏çÊòØ 1 ‰∏™Âà∂Ë°®Á¨¶ÔºàtabÔºâ„ÄÇ
- Á¨¨‰∫åÔºåprintln! Ë∞ÉÁî®‰∫Ü‰∏Ä‰∏™ Rust ÂÆèÔºàmacroÔºâ,Áé∞Âú®Âè™ÈúÄËÆ∞‰ΩèÔºåÁ¨¶Âè∑ÂêéÂá∫Áé∞ ! Â∞±ÊÑèÂë≥ÁùÄË∞ÉÁî®ÁöÑÊòØÂÆèËÄå‰∏çÊòØÊôÆÈÄöÂáΩÊï∞„ÄÇ
- Á¨¨‰∏âÔºå"Hello, world!" ÊòØ‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤„ÄÇËøô‰∏™Â≠óÁ¨¶‰∏≤‰Ωú‰∏∫‰∏Ä‰∏™ÂèÇÊï∞‰º†ÈÄíÁªô println!ÔºåÂ≠óÁ¨¶‰∏≤Â∞ÜË¢´ÊâìÂç∞Âà∞Â±èÂπï‰∏ä„ÄÇ
- Á¨¨ÂõõÔºå‰ª£Á†ÅË°å‰ª•ÂàÜÂè∑ÁªìÂ∞æÔºà;ÔºâÔºåËøô‰ª£Ë°®‰∏Ä‰∏™Ë°®ËææÂºèÁöÑÁªìÊùüÂíå‰∏ã‰∏Ä‰∏™Ë°®ËææÂºèÁöÑÂºÄÂßã„ÄÇÂ§ßÈÉ®ÂàÜ Rust ‰ª£Á†ÅË°å‰ª•ÂàÜÂè∑ÁªìÂ∞æ„ÄÇ

Rust ÂíåÂÖ∂‰ªñËØ≠Ë®ÄÁöÑ main ÂáΩÊï∞‰∏çÂêåÔºåÊ≤°ÊúâÂÖ•ÂèÇÊàñËøîÂõûÂÄºÔºåÈúÄË¶Å‰ΩøÁî®‰∏ìÈó®ÁöÑÂáΩÊï∞Â§ÑÁêÜÂÖ•ÂèÇÂíåËøîÂõûÂÄº„ÄÇ

    fn main() {
        for arg in std::env::args()
        {
            println!(arg);
        }

        std::process::exit(0);
    }

ÈÄöËøáËøõÁ®ãÈÄÄÂá∫ÂáΩÊï∞ exit ÁªôÁ≥ªÁªü‰∏Ä‰∏™ËøîÂõûÂÄº„ÄÇ

    let args: Vec<String> = env::args().collect();

Ë¶ÅÁÇπÔºö

- `Vec<String>` Â≠óÁ¨¶‰∏≤ÂêëÈáèÔºåÂºïÁî® args() ËøîÂõûÁöÑ Args ÁªìÊûÑ‰ΩìÈõÜÂêàÔºõ
- `&args[0]` ÂÄüÁî®ÂèÇÊï∞ÂºïÁî®ÔºåÂõ†‰∏∫Â§ñÈÉ®‰º†ÂÖ•ÁöÑ String ÊâÄÊúâÊùÉ‰∏çËÉΩËΩ¨ÁßªÔºõ
- `{:?}` ÊâìÂç∞Ê®°Êùø‰ΩøÁî®ÈÄöÈÖçÁ¨¶Âè∑ÊâìÂç∞Â§ö‰∏™ÂÄºÔºõ



Èô§Ê≠§‰πãÂ§ñÔºåÊ†áÂáÜÂ∫ì‰∏≠ÁöÑÊüê‰∫õ type„ÄÅtrait„ÄÅfunction„ÄÅmacro Á≠âÁ≠âÂÆûÂú®Â§™Â∏∏Áî®ÔºåÂõ†Ê≠§Ê†áÂáÜÂ∫ìÊèê‰æõÈªòËÆ§Ê®°Âùó
std::preludeÔºåÂú®Ëøô‰∏™Ê®°Âùó‰∏≠ÂØºÂá∫‰∫Ü‰∏Ä‰∫õÊúÄÂ∏∏ËßÅÁöÑÁ±ªÂûã„ÄÅtrait Á≠âÔºåÁºñËØëÂô®‰ºöËá™Âä®‰∏∫Áî®Êà∑ÂêØÁî®ÔºåÁõ∏ÂΩì‰∫éÔºö

    use std::prelude::*;

ËøôÊ†∑ÔºåÊ†áÂáÜÂ∫ìÈáåÈù¢ÁöÑËøô‰∫õÊúÄÈáçË¶ÅÁöÑÁ±ªÂûã„ÄÅtrait Á≠âÂêçÂ≠óÂ∞±ÂèØ‰ª•Áõ¥Êé•‰ΩøÁî®ÔºåËÄåÊó†È°ªÊØèÊ¨°ÈÉΩÂÜôÂÖ®Áß∞ÊàñËÄÖ use ËØ≠Âè•„ÄÇ

Â¶ÇÊûú‰Ω†ÁÜüÊÇâÂä®ÊÄÅËØ≠Ë®ÄÔºåÂ¶Ç Ruby„ÄÅPython Êàñ JavaScriptÔºåÂàôÂèØËÉΩ‰∏ç‰π†ÊÉØÂ∞ÜÁºñËØëÂíåËøêË°åÂàÜ‰∏∫‰∏§‰∏™ÂçïÁã¨ÁöÑÊ≠•È™§„ÄÇ
Rust ÊòØ‰∏ÄÁßçÈ¢ÑÁºñËØëÈùôÊÄÅÁ±ªÂûãÔºàahead-of-time compiledÔºâËØ≠Ë®ÄÔºåËøôÊÑèÂë≥ÁùÄ‰Ω†ÂèØ‰ª•ÁºñËØëÁ®ãÂ∫èÔºåÂπ∂Â∞ÜÂèØÊâßË°å
Êñá‰ª∂ÈÄÅÁªôÂÖ∂‰ªñ‰∫∫Ôºå‰ªñ‰ª¨ÁîöËá≥‰∏çÈúÄË¶ÅÂÆâË£Ö Rust Â∞±ÂèØ‰ª•ËøêË°å„ÄÇ


Êé•‰∏ãÊù•Ôºå‰∫ÜËß£‰∏Ä‰∫õ Rust ÊúÄÊúâÁâπËâ≤ÁöÑÂäüËÉΩÔºö

- Mutable & immutable Êï∞ÊçÆÁöÑÂèØ‰øÆÊîπ‰∏é‰∏çÂèØ‰øÆÊîπÔºåÂØπÂ∫î &mut T Âíå &T ‰∏§‰∏™ÂºïÁî®ÊñπÂºèÔºõ
- Ownership Êï∞ÊçÆÁöÑÊâÄÊúâÊùÉÁÆ°ÁêÜÔºåÂØπÂ∫îÊâÄÊúâÊùÉÁöÑÂá∫ÂÄüÂíåËΩ¨Áßª‰∏§ÁßçÊÉÖÂÜµÔºõ
- Memory allocation and lifetime ÂèòÈáèÁöÑÂÜÖÂ≠òÂàÜÈÖç‰∏éÁîüÂëΩÂë®ÊúüÔºõ
- Traits & Polymorphism Èù¢ÂêëÂØπË±°ÁºñÁ®ãÁöÑÊé•Âè£„ÄÅÁªßÊâø‰∏éÂ§öÊÄÅÔºõ
- Procedural Macros Âº∫Â§ßÁöÑÂÆèÁ®ãÂ∫èÁºñÁ®ãÔºåÂèØ‰ª•ÂØπ Rust ‰ª£Á†ÅÂÅöËØ≠Ê≥ïÊ†ëÂ§ÑÁêÜÔºõ

Rust Êèê‰æõ‰∫Ü‰∏ÄÁßçÊé•Âè£Á±ªÂûã TraitsÔºåÊÑèÊÄù‰∏∫ÂØπË±°ÁöÑÁâπË¥®ÔºåÁõ∏ÂΩì‰∫éÂÖ∂ÂÆÉËØ≠Ë®Ä‰∏≠ÁöÑ interface Êé•Âè£Á±ªÂûã„ÄÇÂÖàÂÆö‰πâ
Trait Êé•Âè£ÊâÄÂÖ∑ÊúâÁöÑÂ∏∏Èáè„ÄÅÊñπÊ≥ï‰ª•ÂèäÁ±ªÂûãÔºåÁÑ∂ÂêéÔºå‰∏∫ÈúÄË¶ÅËøôÁßçÊé•Âè£ÂäüËÉΩÁöÑÁ±ªÂûãÂÆûÁé∞ÂÆÉÔºå‰ΩøÂæóËØ•Á±ªÂûãÂÖ∑Â§áËØ• Trait
ÁöÑÂäüËÉΩÔºåÊòØÁªÑÂêà(composite)ÁöÑÊñπÂºè„ÄÇ

Êé•Âè£ÈÄöÂ∏∏ÂíåÂ§öÊÄÅËÅîÁ≥ªÔºåÈÄöËøáÊé•Âè£ÁöÑÁªßÊâø(inheritance)Ôºå‰ΩøÂæóÂÆûÁé∞Âêå‰∏Ä‰∏™ Trait Êé•Âè£ÁöÑÁ±ªÂûãÈÉΩÊúâÂêåÁßçÊÄßË¥®Ôºå
ËÄåËøô‰∫õÁ±ªÂûãÂèàÈÄöËøáÊé•Âè£ÁöÑÁà∂Â≠êÂÖ≥Á≥ªÂÖ∑Êúâ‰∫ÜÂ§öÊÄÅÊÄßÔºåÂèØ‰ª•ËøõË°å is a Âà§Êñ≠ÂÖ∂ÊâÄÊúâÁ±ªÂûã„ÄÇ

Rust Á±ªÂûãÁ≥ªÁªü‰ΩøÁî®ÁöÑÊòØÈ∏≠Â≠êÊ®°Âûã(Duck Typing)ÔºåÂç≥Âè™Ë¶ÅÂè´Ëµ∑Êù•ÂÉèÈ∏≠Â≠êÔºåÂÆÉÂ∞±ÂèØ‰ª•ÂΩìÊàêÈ∏≠Â≠êÊù•‰ΩøÁî®„ÄÇ‰πüÂ∞±ÊòØËØ¥Ôºå
ÁúüÊ≠£ÈúÄË¶ÅÁöÑ‰∏çÊòØÈ∏≠Â≠êÔºåËÄåÊòØÂÉèÈ∏≠Â≠ê‰∏ÄÊ†∑ÁöÑ‰∏úË•ø„ÄÇ

Rust ÁöÑÁ±ªÂûãÁ≥ªÁªüÂü∫‰∫éÁªÑÂêàÊÄùÁª¥Ôºå‰∏çÂÉè C++/Java ÈÄöËøáÁ±ª‰ª•ÂèäÁªßÊâøÂ±ÇÊ¨°ÁªìÊûÑÊù•ÂåÖË£ÖÔºåÁªÑÂêàÊñπÂºèÊòØÂáΩÊï∞ÂºèÁºñÁ®ã‰∏≠
ÂÆûÁé∞Èù¢ÂêëÂØπË±°ÁºñÁ®ãÁöÑ‰∏ÄÁßçÊúâÊïàÊâãÊÆµ„ÄÇÂπ∂‰∏îÔºåÁªÑÂêàÊñπÂºèÊØîÁ±ªÂ∞ÅË£ÖÁªßÊâøÊñπÂºèÊõ¥ËÉΩË°®ËææÁúüÂÆû‰∏ñÁïå„ÄÇ

ÊØîÂ¶ÇÔºåÁúüÂÆû‰∏ñÁïå‰∏≠ÁöÑÈ∏üÁ±ªÔºåÂÆÉ‰ºöÈ£ûÔºåÈÇ£‰πàÂÆö‰πâÁ±ª Bird ÂåÖÂê´‰∫Ü‰∏Ä‰∏™ fly ÊñπÊ≥ïÔºåÁ™ÅÁÑ∂Êúâ‰∏ÄÂ§©ÈúÄË¶ÅÊ∑ªÂä†È∏µÈ∏üËøô‰∏™
Á±ªÂûãÔºåÁ´üÁÑ∂ÂèëÁé∞ÔºåË°®ËææÈ∏µÈ∏üËøôÁßç‰∏ç‰ºöÈ£ûÁöÑÈ∏üÊó∂ÔºåÂ∞±ÈúÄË¶ÅÂ•ΩÂ•ΩÈáçÊñ∞ËÆæËÆ°Á±ªÁöÑÁªßÊâøÂÖ≥Á≥ª„ÄÇËÄåÁªÑÂêà traits ÁâπË¥®Êé•Âè£
Â∞±‰∏çÂ≠òÂú®ËøôÁöÑÈóÆÈ¢ò„ÄÇRust ÁöÑÁªìÊûÑ‰Ωì‰πü‰ΩøÁî®Á±ª‰ººÁöÑÊñπÂºèÔºåÈúÄË¶Å‰ªÄ‰πàÊñπÊ≥ïÂ∞±‰ΩøÁî® impl ÂÖ≥ÈîÆÂ≠óÊâ©Â±ïÁõ∏Â∫îÁöÑÊñπÊ≥ï„ÄÇ


Êé•‰∏ãÊù•Ëß£Êûê‰∏Ä‰∏ã**ÊâÄÊúâÊùÉ**Ê¶ÇÂøµÔºåÂíåÂêÑÁßçÂ§ÑÁêÜÊñπÂºèÔºö

- `shared reference` ÂÖ±‰∫´Âá∫ÂÄüÊâÄÊúâÊùÉ &TÔºåÂ¶Ç `let a = &b;`ÔºåÂ∞Ü b Âá∫ÂÄüÂà∞ aÔºõ
- `mutable reference` ÂèØÂèòÂá∫ÂÄüÊâÄÊúâÊùÉ &mut TÔºåÂ¶Ç `let a = &mut b;`ÔºåÈÄöËøá a ÂèØ‰ª•‰øÆÊîπ b ÁöÑÊï∞ÊçÆÔºõ
- `ownership move` ËΩ¨ÁßªÊâÄÊúâÊùÉÔºåÂ¶Ç `let a = b;`ÔºåÊâÄÊúâÊùÉÁî± b ËΩ¨ÁßªÁªô aÔºõ

Ê≥®ÊÑèÔºåÊ†áÈáèÊï∞ÊçÆÁ±ªÂûãÔºåÂ¶ÇÊï∞ÂÄº„ÄÅÂ≠óÁ¨¶„ÄÅÂ∏ÉÂ∞îÁ≠âÈªòËÆ§Êúâ Copy trait Ë°å‰∏∫Ôºå‰πüÂ∞±‰∏ç‰ºöÊúâÊâÄÊúâÊùÉËΩ¨Áßª„ÄÇ

ÊâÄÊúâÊùÉ `Ownership` Ê¶ÇÂøµÊòØËæÉÊñ∞Â•áÁöÑËßÇÂøµÔºåÊòØ Rust Èõ∂ÊàêÊú¨ÊäΩË±°‰∏≠ÂæàÈáçË¶ÅÁöÑ‰∏Ä‰∏™ÁªÑÊàêÔºåÈõ∂ÊàêÊú¨ÊäΩË±°Âç≥ÊòØÊ≤°Êúâ
‰ΩøÁî®ÁöÑÂäüËÉΩÂ∞±‰∏ç‰ºöÂ∏¶Êù•Á°¨‰ª∂ËµÑÊ∫êÊ∂àËÄó„ÄÇÊâÄÊúâÊùÉÊåáÂá∫ÊØè‰∏Ä‰∏™ÂÄºÔºàÂÜÖÂ≠òÊï∞ÊçÆËµÑÊ∫êÔºâÊüê‰∏ÄÊó∂ÂàªÂè™ËÉΩË¢´‰∏Ä‰∏™ÂèòÈáèÊã•ÊúâÔºåÂèòÈáè
Âç≥‰∏∫ ownerÔºåË∂ÖÂá∫‰ΩúÁî®ÂüüÂêéÔºåÂÄº‰ºöË¢´ÈîÄÊØÅÔºåÂç≥ÊØè‰∏™ËµÑÊ∫êÂºïÁî®ÈÉΩÊúâÁõ∏Â∫îÁöÑÁîüÂëΩÂë®ÊúüÔºåÂú®ÁºñËØëÊúüÂç≥ÂÆåÊàêÈùôÊÄÅËµÑÊ∫êÁÆ°ÁêÜÔºå
‰∏çÂøÖÂú®Á®ãÂ∫èËøêË°åÊó∂Âä®ÊÄÅÂõûÊî∂ËµÑÊ∫ê„ÄÇ

ÊâÄÊúâÊùÉ Ownership ÊòØ Rust ÁöÑÁâπËâ≤ÔºåÈÄöËøáÂ∞ÜÂèòÈáè‰∏éÂÜÖÂ≠òÊï∞ÊçÆÁöÑÊâÄÊúâÊùÉÁªëÂÆöÔºåÂèØ‰ª•ÂÆûÁé∞ÈùôÊÄÅÂûÉÂúæÂõûÊî∂Êú∫Âà∂Ôºå‰ªéËÄå
ÈÅøÂÖç‰∫ÜËøêË°åÊó∂ÁöÑÂûÉÂúæÂõûÊî∂Â∑•‰Ωú„ÄÇÂ£∞ÊòéÂèòÈáèÊó∂Ôºå‰ΩøÁî® let Â£∞ÊòéÂè™ËØªÂèòÈáèÔºåË°®Á§∫‰∏çÂèØ‰ª•ÈÄöËøáÂÆÉ‰øÆÊîπÂÜÖÂ≠òÊï∞ÊçÆ„ÄÇÈúÄË¶Å‰øÆÊîπ
ÂÜÖÂ≠òÁöÑÂèòÈáèÂ£∞Êòé‰∏∫ let mutÔºåËøôÂèØ‰ª•ËÆ©ÂèòÈáèÊã•ÊúâÁõ∏Â∫îÂÜÖÂ≠òÁöÑÊâÄÊúâÊùÉÔºåÂπ∂‰∏îÂêéÁª≠ÂèØ‰ª•Âá∫ÂÄüÂÖ∂Êã•ÊúâÁöÑÊâÄÊúâÊùÉÔºåÊàñËÄÖÂ∞Ü
ÊâÄÊúâÊùÉËΩ¨‰∫§ÔºàmoveÔºâÁªôÂÖ∂ÂÆÉÂèòÈáè„ÄÇ

‰∏ãË°®ÂàóÂá∫ Rust vs. C++ ËØ≠Ë®Ä‰∏âÁßç‰º†ÂèÇÊñπÂºèÂ£∞ÊòéÊñπÂºèÔºåÊ≥®ÊÑè Rust Âè™ÊúâÊ†áÈáèÊâçÊòØ‰º†ÂÄºÊñπÂºèÔºö

| ‰º†ÂèÇÊñπÂºè |     Rust Â£∞Êòé     |      C/C++ Â£∞Êòé      |
|----------|-------------------|----------------------|
| ‰º†ÂÄº     | fn foo(x: T)      | void foo(T x)        |
| Âè™ËØªÂºïÁî® | fn foo(x: &T)     | void foo(const T &x) |
| ËØªÂÜôÂºïÁî® | fn foo(x: &mut T) | void foo(T &x)       |

‰∏ãË°®ÁªôÂá∫‰∫Ü‰∏âÁßç‰º†ÂèÇÊñπÂºèÁöÑÂáΩÊï∞Ë∞ÉÁî®ÊñπÂºèÔºö

| ‰º†ÂèÇÊñπÂºè |  rust Ë∞ÉÁî®  | c++ Ë∞ÉÁî® |
|----------|-------------|----------|
| ‰º†ÂÄº     | foo(x)      | foo(x)   |
| Âè™ËØªÂºïÁî® | foo(&x)     | foo(&x)  |
| ËØªÂÜôÂºïÁî® | foo(&mut x) | foo(&x)  |

ÂèØ‰ª•ÁúãÂá∫ÔºåÂõ†‰∏∫ const ÂÖ≥ÈîÆÂ≠óÁöÑ‰ΩøÁî®ÂèØ‰ª•Âá∫Áé∞Âú®ÂáΩÊï∞Â§öÂ§ÑÔºåC++ Ë∞ÉÁî®ÂΩ¢ÂºèÊó†Ê≥ïÁÆÄÊ¥ÅË°®Ëææ‰º†ÂèÇÁ±ªÂûãÔºåË°®ËææÂºèÊ∑∑‰π±„ÄÇ
ËÄåÂâçË∫´ C ËØ≠Ë®ÄË°®ËææËÉΩÂäõÊõ¥ÊòØ‰∏çË∂≥ÔºåRust ÂàôÊîπËøõ‰∫ÜËøô‰∫õËØ≠Ê≥ïÈóÆÈ¢òÔºåÂ£∞ÊòéÂíåË∞ÉÁî®ÂΩ¢ÂºèÂÆåÂÖ®ÂØπÂ∫îÔºåËØ≠Ê≥ï„ÄÅËØ≠‰πâÊõ¥ÁÆÄÊòé„ÄÇ


ÊâÄ‰ª•ÔºåÂú® Rust Á®ãÂ∫è‰ª£Á†Å‰∏≠ÔºåÂèòÈáè‰πãÈó¥ÁöÑËµãÂÄº‰∏çÂÜçÊòØÁÆÄÂçïÁöÑ = ËøêÁÆóÁ¨¶Êìç‰ΩúÔºåÂÖ≥ÈîÆÊòØÊ∂âÂèä‰∫ÜÊâÄÊúâÊùÉÁöÑÂ§ÑÁêÜÊñπÂºè„ÄÇ
Âπ∂‰∏îÔºåËøòÊúâ mutable & immutable Â±ûÊÄßÔºåÂè™ÊúâÂèØÂèòÁöÑÂ£∞ÊòéÊñπÂºè‰∏ãÔºåÂèòÈáèÊâçÂèØ‰ª•ËøõË°åÂ§öÊ¨°ËµãÂÄºÔºåÊàñËÄÖ‰ΩøÁî®
ÂèØÂèòÂºïÁî®Ôºö

```rust
    // Immutable variable
    let a;
    a = 1;
    // a = 2;
    // ^^^^^ cannot assign twice to immutable variable
    
    // Mutable variable
    let mut b: i32 = 2;
    b = 3;
    println!("a + b = {}", a + b);
```

ÂèòÈáè‰∏éÊâÄÊúâÊùÉÁöÑÁªìÂêàÔºåËøò‰ΩøÂæóÂèòÈáèÁöÑÁîüÂëΩÂë®ÊúüÊõ¥ÂÆπÊòìÁÆ°ÁêÜÔºåÂú®‰∏çÂêåÂÜÖÂ≠òÂå∫ÁöÑÂèòÈáèÔºåÂ†ÜÔºàHeapÔºâ‰∏éÊ†àÔºàStackÔºâÔºå
ÂèòÈáèÁöÑÁîüÂ≠òÊúüÂ∞±‰∏çÁõ∏Âêå„ÄÇ‰ΩçÁΩÆÊ†à‰∏äÁöÑÂèòÈáèÔºåÂè™Ë¶ÅÂáΩÊï∞Ë∞ÉÁî®ËøîÂõûÔºå‰æø‰ºöÈáäÊîæÊéâÊ†àÂÜÖÂ≠òÔºåÂπ∂ÈîÄÊØÅÂÖ∂‰∏≠ÁöÑÂèòÈáèÔºåËøô‰∫õÂèòÈáè
Â∞±Êó†Ê≥ïËøîÂõûÂà∞ÂáΩÊï∞Â§ñÈÉ®ÔºåÂπ∂Ë¢´‰∏çÂêàÊ≥ïÂú∞‰ΩøÁî®„ÄÇËÄåËøôÁßçÈóÆÈ¢òÂú® C/C++ ËØ≠Ë®Ä‰∏äÔºåÈùûÂ∏∏ÂÆπÊòìÂá∫Áé∞ÔºåÂπ∂‰∏îÊñ∞ÊâãÊ†πÊú¨‰∏ç‰ºö
Ê≥®ÊÑèÂà∞ËøôÁßçÈóÆÈ¢òÊúâ‰ªÄ‰πàÂêéÊûú„ÄÇ

    fn main() {
      let i = 3; // Lifetime for `i` starts. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      { //                                                   ‚îÇ
          let borrow1 = &i; // `borrow1` lifetime starts. ‚îÄ‚îÄ‚îê‚îÇ
          println!("borrow1: {}", borrow1); //              ‚îÇ‚îÇ
      } // `borrow1 ends. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
      { //                                                   ‚îÇ
          let borrow2 = &i; // `borrow2` lifetime starts. ‚îÄ‚îÄ‚îê‚îÇ
          println!("borrow2: {}", borrow2); //              ‚îÇ‚îÇ
      } // `borrow2` ends. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
    } // Lifetime ends. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


ÊâÄÊúâÊùÉÂè™Âú®ÂèòÈáèÂ≠òÊ¥ªÊó∂ÊúâÊïàÔºåÂΩìÂèòÈáèË∂ÖÂá∫‰ΩúÁî®ÂüüÂêéÔºåÂ¶ÇÂÖ±Êã¨Âè∑‰ΩúÁî®Âüü„ÄÅÂáΩÊï∞‰ΩúÁî®ÂüüÁ≠âÁ≠âÔºåÂèòÈáèÂ∞±Â§±Êïà‰∫ÜÔºåÊâÄÊúâÊùÉ‰πü
‰∏ÄÂπ∂Ê∂àÂ§±„ÄÇÂΩìÂèòÈáèÊã•ÊúâÊâÄÊúâÊùÉÊó∂ÔºåÂèØ‰ª•ÈÄöËøáÊåáÂÆöËØ≠Ê≥ïÁßªÂä®ÂíåÂá∫ÂÄü(Moves and Borrowing)ÁªôÂÖ∂ÂÆÉÂèòÈáè‰ΩøÁî®„ÄÇ

ÊâÄÊúâÊùÉËßÑÂÆöÔºåÂú®‰ΩøÁî®ÂºïÁî®Êó∂ÔºåÊúâ‰∏§Êù°Á∫¶ÊùüÔºö

- ‰∏çËÉΩÂêåÊó∂‰ΩøÁî® mutable & immutable ÂºïÁî®ÔºåÈÅøÂÖçÊï∞ÊçÆËØªÂÜôÂπ∂ÂèëÊâßË°åÔºõ
- ‰∏çËÉΩÂ≠òÂú®Â§ö‰∏™ mutable ÂºïÁî®ÔºåÈÅøÂÖçÊï∞ÊçÆÁ´û‰∫âÔºõ

Ëøô‰∏§Êù°Á∫¶ÊùüÂèØ‰ª•Áªô Rust Á®ãÂ∫èÁºñËØë‰ºòÂåñÂ∏¶Êù•ÊûÅÂ§ßÁöÑÂ•ΩÂ§ÑÔºåÂÆÉ‰ª¨ÈÅøÂÖç‰∫ÜÁºñËØëÊúüÂ∞±Âá∫Áé∞ `data races`ÔºåËøôÁßçÁ±ª‰ºº
Â§öÁ∫øÁ®ãÁöÑ `race condition` Áä∂ÂÜµÔºåÂèëÁîüÂú®‰ª•‰∏ãÊÉÖÂΩ¢ÔºåËÄå Rust ÂèØ‰ª•Âú®ÁºñËØëÊúüÂ∞±ÂèëÁé∞ËøôÁßçÈóÆÈ¢òÔºö

- ÂêåÊó∂ÊúâÂ§ö‰∏™ÊåáÈíàËÆøÈóÆÁõ∏ÂêåÊï∞ÊçÆ„ÄÇ
- Ëá≥Â∞ëÊúâ‰∏Ä‰∏™ÊåáÈíàÂú®ËøõË°åÂÜôÂÖ•Êìç‰Ωú„ÄÇ
- Ê≤°ÊúâÂêåÊ≠•Êú∫Âà∂Êù•Á∫¶ÊùüÊï∞ÊçÆËÆøÈóÆ„ÄÇ

ÂâçÈù¢ËØ¥ÂèòÈáèË∂ÖÂá∫‰ΩúÁî®ÂüüÂ∞±‰ºöÂ§±ÊïàÔºåÂêåÊó∂ Rust ‰ºöÊâßË°å‰∏Ä‰∏™ `drop()` ÂáΩÊï∞Êù•ÂÅöÊ∏ÖÁêÜÂ∑•‰Ωú„ÄÇÂÅáËÆæÊ≤°ÊúâÂÆûÁé∞ÊâÄÊúâÊùÉ
ÊäΩË±°Êú∫Âà∂ÔºåÂú®ÂèòÈáèÁõ∏‰∫íËµãÂÄºÂêéÔºåÂ∞±‰ºöÊåáÂêëÂêå‰∏ÄÂùóÂÜÖÂ≠òÔºåÂÆÉ‰ª¨Â§±ÊïàÊó∂Â∞Ü‰ºöÊúâ‰∏§‰∏™ `drop()` ÂáΩÊï∞Ë¢´Ë∞ÉÁî®ÔºåËøôÂ∞±‰ºö
ÂØπÂêå‰∏ÄÂÜÖÂ≠òÂú∞ÂùÄÊâßË°å‰∏§Ê¨° `free()` Êìç‰ΩúÔºåÁ†¥ÂùèÂÜÖÂ≠òÁªìÊûÑ„ÄÇ

ÈÄöËøáÊâÄÊúâÊùÉÊú∫Âà∂ÔºåÊó∂ÂàªÂè™Êúâ‰∏Ä‰∏™ÂèòÈáèÂºïÁî®Âêå‰∏ÄÂÜÖÂ≠òÂú∞ÂùÄÔºåÊ∞∏Ëøú‰∏ç‰ºöÂá∫Áé∞ÈáçÂ§çÈáäÊîæÂêå‰∏ÄÂÜÖÂ≠òÁöÑÈîôËØØ„ÄÇ

Â¶ÇÊûú‰∏Ä‰∏™Á±ªÂûãÁöÑ‰ªª‰ΩïÈÉ®ÂàÜÂÆûÁé∞‰∫Ü Drop traitÔºåÂàôÊó†Ê≥ï‰ΩøÁî® Copy trait„ÄÇ

ÊâÄÊúâÊ†áÈáèÁ±ªÂûãÈÉΩËÉΩ‰ΩøÁî® Copy traitÔºåÁ±ªÂûãÊúâÂ¶Ç‰∏ãËøô‰∫õÔºåÂåÖÂê´ÊâÄÊúâÂéüÂßãÂÄºÁ±ªÂΩ¢ÔºåÈô§‰∫ÜÂ≠óÁ¨¶‰∏≤Ôºö

- All the integer types, such as `u32`.
- The Boolean type, `bool`, with values true and false.
- All the floating point types, such as `f64`.
- The character type, `char`.
- ËøòÊúâÂåÖÂê´‰ª•‰∏äÁ±ªÂûãÁöÑÂÖÉÁªÑ TuplesÔºå‰æãÂ¶Ç (i32, i32)

ÁâπÂà´Âú∞ÔºåÂØπ‰∫éÊ†áÈáèÊï∞ÊçÆÁ±ªÂûãÂç≥Èô§‰∫ÜÂ≠óÁ¨¶‰∏≤‰ª•Â§ñÁöÑÂéüÂßãÁ±ªÂûãÔºåÂ¶ÇÊï∞ÂÄº„ÄÅÂ≠óÁ¨¶„ÄÅÂ∏ÉÂ∞îÁ≠âÂú®ÂáΩÊï∞‰πãÈó¥‰º†ÈÄíÊó∂Ôºå‰ºöÊåâÂÄº‰º†ÈÄíÔºå
‰ºöËøõË°å Copy trait Êìç‰ΩúÔºå‰πüÂ∞±‰∏ç‰ºöÊúâÊâÄÊúâÊùÉËΩ¨Áßª„ÄÇËôΩÁÑ∂Ôºå‰ΩøÁî®ÂºïÁî®ÊàñËÄÖÂèØÂèòÂºïÁî®ÁöÑÊñπÂºè‰º†ÈÄíÂèÇÊï∞Êâç‰∏ç‰ºö‰º†ÂÄºÔºå
‰ΩÜËøô‰∏§ÁßçÊÉÖÂÜµ‰∏ãÊâÄÊúâÊùÉÂè™ÊúâÂá∫ÂÄüÔºåÊ≤°ÊúâÁßªÂä®„ÄÇÈô§Èùû‰ΩøÁî®ÂÖ∂ÂÆÉÊñπÂºèÔºåÁÆ°ÁêÜÊ†áÈáèÁöÑÊâÄÊúâÊùÉÔºå‰æãÂ¶Ç Box ÊåáÈíàÔºö

```rust
    let a = Box::new(123);
    let c = a; // a moved
    println!("a move into c {}", c);
    // println!("move {}", a);
    //                      ^ value borrowed here after move
```

println! ÂÆèÂè™ÂÄüÁî®ÊâÄÊúâÊùÉÔºå‰∏ç‰ºöËΩ¨ÁßªÂèÇÊï∞ÁöÑÊâÄÊúâÊùÉ„ÄÇ

Rust Êèê‰æõ‰∫Ü unsafe ÁâπÊÄßÔºåÈÄöËøáÊô∫ËÉΩÊåáÈíàÔºåSmart PointersÔºåÁÆÄÂåñ‰∫ÜÂØπ Heap ÂÜÖÂ≠òÁöÑ‰ΩøÁî®„ÄÇÂÜÖÂ≠òË£ÖÁÆ±‰ΩøÁî®
std::boxed::Box ÊàñËÄÖ alloc::boxed::Box Êô∫ËÉΩÊåáÈíàÔºö

```rust
    let five = 5;           // 5 in Stack memory
    let five = Box::new(5); // 5 in Heap memory
```

ËøòÊúâ Rc<T>ÔºåWeak<T> ÂèØ‰ª•‰ΩøÁî®ÂÜÖÂ≠òÂ≠òÂú®Â§ö‰∏™ÊâÄÊúâÊùÉÔºåÂú®‰∏çÂêåÁöÑ‰ΩçÁΩÆ‰ΩøÁî®„ÄÇÈÄöÂ∏∏ÊÉÖÂÜµ‰∏ãÔºåÂèØ‰ª•ÂæàÂáÜÁ°ÆÁöÑÁü•ÈÅìÂèòÈáè
Êã•ÊúâÊüê‰∏™ÂÄºÔºåÈªòËÆ§ÁöÑÊâÄÊúâÊùÉÊú∫Âà∂ÂèØ‰ª•ÂæàÂ•ΩÂú∞ÁÆ°ÁêÜ„ÄÇ‰ΩÜÊòØÂú®Êúâ‰∫õÊÉÖÂÜµ‰∏ãÔºå‰∏Ä‰∏™ÂèòÈáèÂèØËÉΩ‰ºöÈúÄË¶ÅÊúâÂ§ö‰∏™ÊâÄÊúâËÄÖ„ÄÇ‰æãÂ¶ÇÔºå
Graphs Êï∞ÊçÆÁªìÊûÑ‰∏≠ÔºåÂ§ö‰∏™ËæπÂèØËÉΩÊåáÂêëÁõ∏ÂêåÁöÑÁªàÁÇπÔºåËäÇÁÇπ‰ªéÊ¶ÇÂøµ‰∏äËÆ≤‰∏∫ÊåáÂêëÂÆÉÁöÑÂêÑÊù°ËæπÊâÄÊã•Êúâ„ÄÇËÄåÂºïÁî®ËÆ°Êï∞Âô®Âç≥ÂèØ‰ª•
Á±ªÂûãÊù•Êª°Ë∂≥Â§öÊâÄÊúâÊùÉÁöÑÈúÄË¶ÅÔºåÂºïÁî®ËÆ°Êï∞ Reference counting (RC) ‰πüÊòØ‰º†ÁªüÁöÑÂÜÖÂ≠òÂõûÊî∂ÊäÄÊúØÔºåÂ¶Ç Python Â∞±
‰ΩøÁî®ÂºïÁî®ËÆ°Êï∞Âô®Êù•ÁÆ°ÁêÜÂÜÖÂ≠òÁöÑÂõûÊî∂„ÄÇ


    use std::env::{args, Args};

    fn main() {
        let mut _args: Args = args();
        let _arg0: Option<String> = _args.nth(0);
        let _argc: usize = _args.len();
        println!("Hello Rust, argc {}, args[0] is {}", _argc, _arg0.unwrap());
    }


ÂèòÈáèÁöÑÁîüÂëΩÂë®ÊúüËøòÂèØ‰ª•ËøõË°åÊòæÂºèÊ†áÊ≥®ÔºåExplicit annotationÔºåÈÄöËøáÊ†áÊ≥®ÂèØ‰ª•ÊîπÂèòÈªòËÆ§ÁöÑÁîüÂ≠òÂë®ÊúüÔºå‰ΩøÂæóË¢´
‰æùËµñÁöÑÂèòÈáèÂèØ‰ª•ÁîüÂ≠òÊõ¥ÈïøÁöÑÊó∂Èó¥„ÄÇ‰æãÂ¶ÇÔºåÂØøÂëΩË°®Á§∫Ê≥ïÔºàÊ≥®Ôºö'a: 'bÔºåË°®Á§∫ÊúâÊïàÊúü a > bÔºâÔºåÂèàÂ¶Ç 'static ÈùôÊÄÅ
ÂèòÈáèÊ†áÊ≥®ÔºåË°®Á§∫ÈùôÊÄÅÊúâÊïàÊúüÔºåÂç≥‰∏ç‰æùËµñ‰ªª‰ΩïÈáè„ÄÇ

ÁîüÂëΩÂë®ÊúüÊ≥®Ëß£ÁöÑËØ≠Ê≥ïÊ†ºÂºèÂ¶Ç‰∏ãÔºåÂâçÁºÄ‰∏Ä‰∏™ apostropheÔºö

- `&i32` Â∏∏ËßÑËØ≠Ê≥ïË°®Á§∫ÂºïÁî®Ôºõ
- `&'a i32` Â∏¶ÊúâÊòæÂºèÁîüÂëΩÂë®ÊúüË°®Á§∫ÁöÑÂºïÁî®Ôºõ
- `&'a mut i32` Â∏¶ÊúâÊòæÂºèÁîüÂëΩÂë®ÊúüÁöÑÂèØÂèòÂºïÁî®Ôºõ

ÈÄöÂ∏∏ÔºåÂçï‰∏™ÁöÑÁîüÂëΩÂë®ÊúüÊ†áÊ≥®Êú¨Ë∫´ÊòØÊ≤°‰ªÄ‰πàÊÑè‰πâÁöÑÔºåÂõ†‰∏∫ Rust Âè™ÈúÄË¶ÅÈÄöËøáÂÆÉÊù•‰∫ÜËß£Â§ö‰∏™ÂºïÁî®‰πãÈó¥ÁöÑÁîüÂëΩÂë®ÊúüÂÖ≥Á≥ª„ÄÇ

ÊØîÂ¶ÇÔºå‰ª•‰∏ãÁ§∫ËåÉ‰∏≠Êúâ‰∏§‰∏™ `longest()` ÂáΩÊï∞ÔºåÂÖ∂‰∏≠‰∏Ä‰∏™Â∏¶ÊúâÁîüÂëΩÂë®ÊúüÊ†áÊ≥®‰ø°ÊÅØÁöÑÁâàÊú¨ÊâçÂèØ‰ª•Ê≠£Â∏∏Â∑•‰ΩúÔºö

```rust,ignore
// normal reference version
// error[E0106]: missing lifetime specifier
// = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
//                              ‚Üì expected named lifetime parameter
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}

// lifetime annotated version
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```



ÂºÄÂèëÂ∑•ÂÖ∑Â¶ÇÊûúÈÖçÁΩÆ‰∫Ü Rust Analyzer Âíå  Language Server Protocol (LSP)ÔºåÈÇ£‰πàÂèØ‰ª•Âú®ÂáΩÊï∞„ÄÅÁªìÊûÑ‰Ωì
ÂâçÂ§¥‰ΩøÁî®‰∏Ä‰∫õÊ†áÊ≥®Êù•Á¶ÅÊ≠¢ÊòæÁ§∫Ë≠¶Âëä‰ø°ÊÅØÔºåÈÅøÂÖçÂú®ÁºñËØëÊó∂Âá∫Áé∞ËøáÂ§öÁöÑÂÜÖÂÆπÔºå‰æãÂ¶ÇÔºö

- #[allow(dead_code)] Ë°®Á§∫ÂÖÅËÆ∏Ê≠ª‰ª£Á†ÅÔºåÂç≥‰ΩøÁî®‰ª£Á†ÅÂ≠òÂú®Ê≤°Êúâ‰ΩøÁî®ÁöÑÂ≠óÊÆµ„ÄÅÂèòÈáè„ÄÅÂáΩÊï∞‰πü‰∏ç‰ºöËß¶ÂèëË≠¶Âëä‰ø°ÊÅØ„ÄÇ
- #[allow(unused_variables)] Ë°®Á§∫ÂÖÅËÆ∏Â≠òÂú®Ê≤°Êúâ‰ΩøÁî®ÁöÑÂèòÈáèÔºå‰πüÂèØ‰ª•Áõ¥Êé•Â∞ÜÂèòÈáèÊîπÂêç‰∏∫ _ ÂºÄÂ§¥„ÄÇ

ÂÖ∑‰ΩìÂèÇËÄÉ Guide to Rustc Development - Analysis - Errors and Lints

Rust Êúâ‰∏ÄÂ•óÁã¨ÁâπÁöÑÂ§ÑÁêÜÂºÇÂ∏∏ÊÉÖÂÜµÁöÑÊú∫Âà∂ÔºåÂÆÉÂπ∂‰∏çÂÉèÂÖ∂ÂÆÉËØ≠Ë®Ä‰∏≠ÁöÑ try Êú∫Âà∂ÔºåÊàñ Exception Á±ªÊù•Ë°®Á§∫ÈîôËØØ„ÄÇ
ÂáΩÊï∞‰∏≠ÁöÑËøîÂõûÂÄºÂíåÂáΩÊï∞ÁöÑËøêË°åÁä∂ÊÄÅÁõ∏ÂÖ≥ÔºåÈÄöÂ∏∏ÂíåÈîôËØØÂ§ÑÁêÜÁõ∏ÁªìÂêà„ÄÇ

Rust ÁöÑÂàÜÂ±ÇÈîôËØØÂ§ÑÁêÜÊ®°ÂºèÔºåÂ¶Ç‰∏ãÔºåÔºö

- Â¶ÇÊûúÂêàÁêÜÊúüÊúõÁº∫Â§±ÔºåÂàô‰ΩøÁî® `Option<T>`„ÄÇ
- Â¶ÇÊûúÈîôËØØÂèØ‰ª•ÂêàÁêÜÂú∞Â§ÑÁêÜÔºåÂàô‰ΩøÁî® `Result<T, E>`„ÄÇ
- Â¶ÇÊûúÈîôËØØÊó†Ê≥ïÂêàÁêÜÂú∞Â§ÑÁêÜÔºåÁ∫øÁ®ã panics„ÄÇ
- Â¶ÇÊûúÂèëÁîüÁÅæÈöæÊÄßÁöÑÈîôËØØÔºåÁ®ãÂ∫èÂ∞±‰ºö‰∏≠Ê≠¢„ÄÇ

Rust Á®ãÂ∫è‰∏≠‰∏ÄËà¨‰ºöÂá∫Áé∞‰∏§ÁßçÈîôËØØÔºö

- ÂèØÊÅ¢Â§çÈîôËØØÔºåÂØπÂ∫îËøîÂõû Result<T, E>„ÄÇ
- ‰∏çÂèØÊÅ¢Â§çÈîôËØØÔºåÂØπÂ∫î panic! ÂÆèÔºåÂÆÉ‰ºöË∞ÉÁî®ÁºñËØëÂô®Êèê‰æõÁöÑ‰ª£Á†ÅÁªàÊ≠¢Á®ãÂ∫èËøêË°å„ÄÇ

ÊâÄ‰ª•ÔºåÂáΩÊï∞Êúâ‰∏§‰∏™Â∏∏ËßÅÁöÑËøîÂõûÁ±ªÂûãÔºö

    pub enum Option<T> {
        None,
        Some(T),
    }

    pub enum Result<T, E> {
       Ok(T),
       Err(E),
    }

ÊâÄÊúâÂèØËÉΩÂèëÁîüÈîôËØØÁöÑÂáΩÊï∞ÈÉΩ‰ºöËøîÂõû‰∏Ä‰∏™Ê†áÂáÜÁöÑ `Result<T, E>` Êûö‰∏æÁ±ªÂûãÔºåÂÆÉÊúâ‰∏§‰∏™Ê≥õÂûãÂèÇÊï∞ÔºåÂàÜÂà´Áî®‰∫é‰∏§‰∏™ÂèñÂÄºÔºö

- `Ok(value)` Ë°®Á§∫Êìç‰ΩúÊàêÂäüÁöÑÊàêÂëòÔºåÂåÖË£Ö‰∫Ü‰∏Ä‰∏™ `T` ÂûãÂÄºÔºõ
- `Err(why)` Ë°®Á§∫Êìç‰ΩúÂ§±Ë¥•ÁöÑÊàêÂëòÔºåÈÄöÂ∏∏Âíå panic ÂÖ≥ËÅîÔºåÂåÖË£Ö‰∫Ü‰∏Ä‰∏™ `E` ÂûãÂÄºÔºåËøô‰∏™ÂÄºÈÄöÂ∏∏ÂåÖÂê´Âá∫ÈîôÁöÑÂèÇËÄÉ‰ø°ÊÅØÔºõ

ÁªìÂêàÊ®°ÂºèÂåπÈÖçÔºåÂèØ‰ª•ÂØπÂáΩÊï∞ÂèØËÉΩÂá∫Áé∞ÁöÑÂÄºËøõË°åÂà§Êñ≠Ôºö

    if let Ok(some_value) = fun() {
        // do something with some_value
    }

Ë∞ÉÁî®‰∏Ä‰∏™ËøîÂõûÂÄº‰∏∫ Result Á±ªÂûãÁöÑÂáΩÊï∞ÔºåÈÇ£‰πàÂ∞±ÈúÄË¶ÅÂ§ÑÁêÜÂèØËÉΩÁöÑ‰∏§ÁßçÁä∂ÊÄÅÔºåOk ÊàñËÄÖ ErrÔºåÂ¶ÇÊûúÂèØ‰ª•ÂÅáÂÆöÂáΩÊï∞
Ê∞∏Ëøú‰∏ç‰ºöÂá∫ÈîôÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•Áõ¥Êé•Ë∞ÉÁî® unwrap() ÊñπÊ≥ïÊ∂àË¥πÊéâËøîÂõûÂÄºÔºåÊàñËÄÖ‰Ωú‰∏∫ÂΩìÂâçÂáΩÊï∞ÁöÑËøîÂõûÂÄº„ÄÇResult ÂøÖÈúÄ
Ë¶Å‰ΩúÂá∫Â§ÑÁêÜÔºåÁâπÂà´ÊòØÂèØËÉΩÂá∫ÈîôÁöÑÊÉÖÂÜµÔºåÂê¶Âàô Rust Â∞±‰∏ç‰ºöÂÖÅËÆ∏Á®ãÂ∫èÈùôÈªòÂú∞ÈÄöËøáÁºñËØëÔºåÂπ∂ÁªôÂá∫‰∏Ä‰∏™Ë≠¶ÂëäÔºö

    warning: unused `Result` that must be used

‰∏ÄËà¨ÂáΩÊï∞ÁöÑËøîÂõûÂÄºÂú®ÊúÄÂêé‰∏ÄË°åÔºåÂèØ‰ª•‰∏çÂÜô return ÂíåÁªìÂ∞æÁöÑÂàÜÂè∑ÔºåÂõ†‰∏∫ÂêéÈù¢Ê≤°ÊúâÊõ¥Â§öÁöÑËØ≠Âè•‰∫Ü„ÄÇ



## ‚ö° Printing ÊâìÂç∞‰ø°ÊÅØ
- https://doc.rust-lang.org/rust-by-example/hello/print.html
- https://doc.rust-lang.org/std/fmt/

ÊâìÂç∞‰ø°ÊÅØ‰ΩøÁî®ÁöÑÊòØÂú® std::fmt Ê®°ÂùóÂÆö‰πâÁöÑÂÆèÔºö

- `format!`: write formatted text to String
- `print!`: same as `format!` but the text is printed to the console (`io::stdout`).
- `println!`: same as `print!` but a newline is appended.
- `eprint!`: same as `format!` but the text is printed to the standard error (`io::stderr`).
- `eprintln!`: same as `eprint!` but a newline is appended.

‰ª• println!() ‰∏∫‰æãÔºåÂÆÉË∞ÉÁî®ÁöÑÊòØ io ÁöÑÊâìÂç∞ÂáΩÊï∞Ôºö

    /// # Examples
    ///
    /// ```
    /// println!(); // prints just a newline
    /// println!("hello there!");
    /// println!("format {} arguments", "some");
    /// let local_variable = "some";
    /// println!("format {local_variable} arguments");
    /// ```
    #[macro_export]
    #[stable(feature = "rust1", since = "1.0.0")]
    #[cfg_attr(not(test), rustc_diagnostic_item = "println_macro")]
    #[allow_internal_unstable(print_internals, format_args_nl)]
    macro_rules! println {
        () => {
            $crate::print!("\n")
        };
        ($($arg:tt)*) => {{
            $crate::io::_print($crate::format_args_nl!($($arg)*));
        }};
    }

Ê†ºÂºèÂåñÊ®°ÊùøÂèÇËÄÉÔºö

- `{}` Áõ¥Êé•ÊâìÂç∞Â≠óÁ¨¶‰∏≤
- `{0}` ÊåáÂÆöÂèÇÊï∞ÁºñÂè∑
- `{name}` ÊåáÂÆöÂëΩÂêçÂèÇÊï∞
- `{:#?}` ÁæéÂåñË∞ÉËØï‰ø°ÊÅØÔºåÂÜíÂè∑ÂêéÈù¢ÁöÑË°®Á§∫Ê†ºÂºèÂåñÂèÇÊï∞
    - `#?` - pretty-print the Debug formatting
    - `#x` - precedes the argument with a 0x
    - `#X` - precedes the argument with a 0x
    - `#b` - precedes the argument with a 0b
    - `#o` - precedes the argument with a 0o
    - ? ‚áí Debug
    - x? ‚áí Debug with lower-case hexadecimal integers
    - X? ‚áí Debug with upper-case hexadecimal integers
    - b ‚áí Binary
    - o ‚áí Octal
    - p ‚áí Pointer ÊâìÂç∞ÊåáÈíàÊåáÂêëÂú∞ÂùÄ
    - x ‚áí LowerHex
    - X ‚áí UpperHex
    - e ‚áí LowerExp
    - E ‚áí UpperExp

‰ΩøÁî®Á§∫ËåÉÔºö

- println!("the PI is {:.2}", 3.141);
- println!("{:?} months in a year.", 12);
- println!("{1:?} {0:?} is the {actor:?} name.", "Slater", "Christian", actor="actor's");
- format!("{}", foo) -> "3735928559"
- format!("0x{:X}", foo) -> "0xDEADBEEF"
- format!("0o{:o}", foo) -> "0o33653337357"
- assert_eq!(format!("Hello {{}}"), "Hello {}");

ÂèòÈáè‰πãÊâÄ‰ª•‰ºöÊåâÊ†ºÂºèÊâìÂç∞Âá∫Êù•ÔºåÊòØÂõ†‰∏∫ÂÆûÁé∞‰∫ÜÁõ∏Â∫îÁöÑ Traits ÂØπË±°ÊñπÊ≥ïÔºåÂèÇËÄÉ 10. Generic Types, Traits, and Lifetimes Á´†ËäÇÁöÑÂÜÖÂÆπÔºö

- `fmt::Debug`: Uses the `{:?}` marker. Format text for debugging purposes.
- `fmt::Display`: Uses the `{}` marker. Format text in a more elegant, user friendly fashion.
- `fmt::Binary`: Uses the `{:b}` marker. Format text in binary form.
- `LowerExp`    e formatting.
- `LowerHex`    x formatting.
- `Octal`   o formatting.
- `Pointer` p formatting.
- `UpperExp`    E formatting.
- `UpperHex`    X formatting.
- `Write`   A trait for writing or formatting into Unicode-accepting buffers or streams.

Á§∫ËåÉÔºåÂÆûÁé∞ `fmt::Display` Trait ÂØπË±°ÁöÑ `fmt()` ÊñπÊ≥ïÔºåËøòÊúâÈÄöËøáÂÖÉÁºñÁ®ãÁªßÊâøÂÆûÁé∞ `Debug`Ôºö

```rust,ignore
#![allow(unused)]
use std::fmt::Display;
use std::fmt::Formatter;
use std::fmt::Result;

fn announce(value: impl Display) {
    println!("Behold! {}!", value);
}

#[derive(Debug)]
struct List(i32, i32, i32);

impl Display for List {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        write!(f, "{{ 1st: {}, 2nd: {}, 3rd: {} }}", self.0, self.1, self.2)
    }
}

fn main() {
   let nums = List(40, 41, 42);
   announce(nums);
}
```


‰∏∫Ê≥õÂûãÂÆûÁé∞ Display Á±ªÂûãË∞ÉËØïÊñπÊ≥ïÔºö

```rust,ignore
use std::fmt;
use std::fmt::Display;
use std::fmt::Formatter;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
fn main() {
    // let pair = Pair{ x:1, y:2};
    let pair = Pair::new( 1, 2 );
    println!("The largest char is {}", pair);
}
```

‰ª•‰∏äÁ§∫ËåÉÔºå‰∏çËÉΩË∞ÉÁî®ÂÆûÁé∞ÁöÑ Display `fmt()` ÊñπÊ≥ïÔºåÊú™Áü•ÂéüÁî±„ÄÇ

    2  |     println!("The largest char is {}", pair);
       |                                        ^^^^ `Pair<{integer}>` cannot be formatted with the default formatter



## ‚ö° Guessing Game
- https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html
- https://doc.rust-lang.org/book/ch06-00-enums.html
- https://docs.rs/rand/0.7.3/rand/index.html#traits
- C++ Â∑•Á®ãÂ∏àÁöÑ Rust ËøÅÁßª‰πãË∑Ø https://zhuanlan.zhihu.com/p/75385189

Êé•‰∏ãÊù•ÁöÑÁåúÊï∞Â≠óÁ§∫ËåÉ‰∫ÜÊõ¥Â§öÁöÑÂÜÖÂÆπÔºåÊñá‰ª∂Âêç: src/main.rs

```rust,ignore
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
  println!("Guess the number!");

  let secret_number = rand::thread_rng().gen_range(1, 100);

  loop {
    println!("Please input your guess.");
    let mut guess = String::new();

    io::stdin()
      .read_line(&mut guess)
      .expect("Failed to read line");
    
    let guess: u32 = match guess.trim().parse() {
      Ok(num) => num,
      Err(_) => continue,
    };

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
      Ordering::Less => println!("To small!"),
      Ordering::Greater => println!("Too large!"),
      Ordering::Equal => {
        println!("That is it!");
        break;
      }
    }
  }
}
```

Áé∞Âú®Á®ãÂ∫èÂºÄÂßãÂèòÂæóÊúâÊÑèÊÄù‰∫ÜÔºÅËøô‰∏ÄÂ∞èË°å‰ª£Á†ÅÂèëÁîü‰∫ÜÂæàÂ§ö‰∫ã„ÄÇ

Ë¶ÅÁÇπÔºö

- `prelude` Ê®°ÂùóÔºåÈªòËÆ§ÂØºÂÖ•ÁöÑÊ®°ÂùóÔºõ
- `rand::Rng` ‰æùËµñ‰∫ÜÊñ∞Ê®°ÂùóÔºåÈúÄË¶ÅÂú® Cargo.toml ÈÖçÁΩÆÁõ∏Â∫î‰æùËµñÔºõ
- `std::io` ËæìÂÖ•ËæìÂá∫Ê®°ÂùóÔºåËøôÈáåÁî®Êù•ËØªÂèñÁî®Êà∑ËæìÂÖ•ÁöÑÂ≠óÁ¨¶‰∏≤Ôºõ
- `std::cmp::Ordering` ÊØîËæÉÊ®°ÂùóÔºåÂºïÂÖ•ÊØîËæÉÊûö‰∏æÈáèÔºåÁªìÂêà match Ê®°ÂºèÂåπÈÖçËøîÂõûÊàñÊâßË°åÊåáÂÆöÂÜÖÂÆπÔºõ
- Â≠óÁ¨¶‰∏≤ÂØπË±°ÂÆû‰æãÂåñÔºå`String::new();`ÔºåÂπ∂Ë∞ÉÁî®Â≠óÁ¨¶Á±ªÂûãÊñπÊ≥ï `trim()` `parse()` ËøõË°åÊ∏ÖÁêÜÂíåËΩ¨Êç¢Á±ªÂûãÔºõ
- ‰ø°ÊÅØÊâìÂç∞Ê®°Êùø‰ΩøÁî®‰∫Ü `{}` ‰Ωú‰∏∫ÂèòÈáèÂç†‰ΩçÁ¨¶ÔºåÂú®ËæìÂá∫Â≠óÁ¨¶‰∏≤Êó∂Ë¢´ÁúüÊ≠£ÁöÑÂÜÖÂÆπÊõøÊç¢ÔºåÂÖ∂‰∏≠ÊÑüÂèπÂè∑Ë°®Á§∫ÊòØ‰∏Ä‰∏™ÂÆèÔºåËÄå‰∏çÊòØÂáΩÊï∞Ôºõ
- `&` Êìç‰ΩúÁ¨¶Âè∑ÂèñÂØπË±°ÂºïÁî®Ôºõ
- `match` Êìç‰ΩúÊâßË°åÊ®°ÂºèÂåπÈÖçÔºåÂπ∂ËøîÂõûÁõ∏Â∫îÁöÑÂÄºÔºõ

Cargo.toml

    [dependencies]
    rand = "0.5.5"

ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÔºåRust Â∞Ü `prelude` Ê®°Âùó‰∏≠Â∞ëÈáèÁöÑÁ±ªÂûãÂºïÂÖ•Âà∞ÊØè‰∏™Á®ãÂ∫èÁöÑ‰ΩúÁî®Âüü‰∏≠„ÄÇÂ¶ÇÊûúÈúÄË¶ÅÁöÑÁ±ªÂûã‰∏çÂú® prelude ‰∏≠Ôºå‰Ω†ÂøÖÈ°ª‰ΩøÁî® `use` ËØ≠Âè•ÊòæÂºèÂú∞Â∞ÜÂÖ∂ÂºïÂÖ•‰ΩúÁî®Âüü„ÄÇ`std::io` Â∫ìÊèê‰æõÂæàÂ§öÊúâÁî®ÁöÑÂäüËÉΩÔºåÂåÖÊã¨Êé•Êî∂Áî®Êà∑ËæìÂÖ•ÁöÑÂäüËÉΩ„ÄÇ

ÂèØÂèòÈáè‰∏é‰∏çÂèØÂèòÈáèÂÆö‰πâÊñπÂºèÔºö

Rust

    let foo = 5; // immutable
    let mut bar = 5; // mutable
    bar = foo

C++

    int number = 0;
    const int const_number = -100;
    number = const_number;

ËøôÈáåÂèØ‰ª•ÁúãÂà∞ÔºåÂú® Rust ‰∏≠ÔºåÂèòÈáèÈªòËÆ§ÊòØ‰∏çÂèØÂèòÁöÑÔºåÈô§ÈùûÂä†‰∫Ü `mut` ÂÖ≥ÈîÆÂ≠óÔºå‰ΩÜÊòØÂÆÉ‰ª¨ÈÉΩÂ±û‰∫éÂèòÈáè„ÄÇ

Rust ÁöÑÂ∏∏ÈáèÂÆö‰πâ‰ΩøÁî®ÂÖ≥ÈîÆÂ≠ó `const`ÔºåÂπ∂‰∏îÈúÄË¶ÅÊåáÂÆöÊï∞ÊçÆÁ±ªÂûã„ÄÇÂ∏∏ÈáèÂèØ‰ª•Âú®‰ªª‰ΩïËåÉÂõ¥ÂÜÖÂÆö‰πâÔºåÂπ∂‰∏îÂèØ‰ª•Âú®Â§ö‰∏™‰ª£Á†ÅÂùó‰∏≠‰ΩøÁî®ÔºåÁªôÂ∏∏ÈáèËµãÂÄºÊó∂ÂΩìÁÑ∂Ë¶Å‰ΩøÁî®Â∏∏ÈáèË°®ËææÂºèÔºå‰∏çËÉΩ‰ΩøÁî®ÂáΩÊï∞ÁöÑËøîÂõûÂÄºÊàñËÄÖÊòØËÆ°ÁÆóÂºè„ÄÇ

Ê≥®ÊÑèËøôÊòØ‰∏Ä‰∏™ let ËØ≠Âè•ÔºåÁî®Êù•ÂàõÂª∫ ÂèòÈáèÔºàvariableÔºâÔºåÂπ∂ÊääÂÆÉÁªëÂÆöÂà∞Á≠âÂè∑Âè≥‰æßÁöÑÂÄº‰∏ä„ÄÇÂú®ÂèòÈáèÂêçÂâç‰ΩøÁî® mut Êù•‰Ωø‰∏Ä‰∏™ÂèòÈáèÂèØÂèòÔºåÂç≥ `mutable`ÔºåÂú® Rust ‰∏≠ÔºåÂèòÈáèÈªòËÆ§ÊòØ‰∏çÂèØÂèòÁöÑ `immutable`ÔºåÂèòÈáè‰∏éÂèØÂèòÊÄßÈÉ®ÂàÜËØ¶ÁªÜËÆ®ËÆ∫Ëøô‰∏™Ê¶ÇÂøµ„ÄÇ

String::new Ëøô‰∏™ÂáΩÊï∞‰ºöËøîÂõû‰∏Ä‰∏™ String ÁöÑÊñ∞ÂÆû‰æã„ÄÇString ÊòØ‰∏Ä‰∏™Ê†áÂáÜÂ∫ìÊèê‰æõÁöÑÂ≠óÁ¨¶‰∏≤Á±ªÂûãÔºåÂÆÉÊòØ UTF-8 ÁºñÁ†ÅÁöÑÂèØÂ¢ûÈïøÊñáÊú¨Âùó„ÄÇ `::` ËØ≠Ê≥ïË°®Êòé new ÊòØ String Á±ªÂûãÁöÑ‰∏Ä‰∏™`ÂÖ≥ËÅîÂáΩÊï∞` associated function„ÄÇÂÖ≥ËÅîÂáΩÊï∞ÊòØÈíàÂØπÁ±ªÂûãÂÆûÁé∞ÁöÑÔºåÂú®Ëøô‰∏™‰æãÂ≠ê‰∏≠ÊòØ StringÔºåËÄå‰∏çÊòØ String ÁöÑÊüê‰∏™ÁâπÂÆöÂÆû‰æã„ÄÇ‰∏Ä‰∫õËØ≠Ë®Ä‰∏≠ÊääÂÆÉÁß∞‰∏∫ ÈùôÊÄÅÊñπÊ≥ï static method„ÄÇ

`read_line` Ëé∑ÂèñÁî®Êà∑Âú®Ê†áÂáÜËæìÂÖ•‰∏≠ÈîÆÂÖ•ÂÜÖÂÆπÔºåÂ∞ÜÂÖ∂Â≠òÂÖ•‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤‰∏≠ÔºåÂõ†Ê≠§ÂÆÉÈúÄË¶ÅÂ≠óÁ¨¶‰∏≤‰Ωú‰∏∫ÂèÇÊï∞„ÄÇËøô‰∏™Â≠óÁ¨¶‰∏≤ÂèÇÊï∞Â∫îËØ•ÊòØÂèØÂèòÁöÑÔºå‰ª•‰æø read_line Â∞ÜÁî®Êà∑ËæìÂÖ•ÈôÑÂä†‰∏äÂéª„ÄÇ

`&` Ë°®Á§∫Ëøô‰∏™ÂèÇÊï∞ÊòØ‰∏Ä‰∏™ ÂºïÁî®ÔºàreferenceÔºâÔºåÂÆÉÂÖÅËÆ∏Â§öÂ§Ñ‰ª£Á†ÅËÆøÈóÆÂêå‰∏ÄÂ§ÑÊï∞ÊçÆÔºåËÄåÊó†ÈúÄÂú®ÂÜÖÂ≠ò‰∏≠Â§öÊ¨°Êã∑Ë¥ù„ÄÇÂºïÁî®ÊòØ‰∏Ä‰∏™Â§çÊùÇÁöÑÁâπÊÄßÔºåRust ÁöÑ‰∏Ä‰∏™‰∏ªË¶Å‰ºòÂäøÂ∞±ÊòØÂÆâÂÖ®ËÄåÁÆÄÂçïÁöÑÊìçÁ∫µÂºïÁî®„ÄÇÂÆåÊàêÂΩìÂâçÁ®ãÂ∫èÂπ∂‰∏çÈúÄË¶Å‰∫ÜËß£Â¶ÇÊ≠§Â§öÁªÜËäÇ„ÄÇ

ÁªìÂêà match ÊµÅÁ®ãÊéßÂà∂ÔºåÊ†πÊçÆÂáΩÊï∞ÁöÑËøîÂõû `Result<T, E>` Êûö‰∏æÂÄº Ok or Err Â§ÑÁêÜÊΩúÂú®ÁöÑÈîôËØØÔºö

    .expect("Failed to read line");

Êûö‰∏æ‰∏é match Ê®°ÂºèÂåπÈÖçËØ≠Ê≥ïÊòØ‰∏™Êñ∞Â•áÁâπÊÄßÔºåÂæàÂÉè Erlang ÁöÑÊ®°ÂºèÂåπÈÖç„ÄÇ



## ‚ö° Windows Resource(ICO) 
- https://crates.io/crates/winres
- https://docs.rs/winres/0.1.11/winres/

Âú® Windows Âπ≥Âè∞Ôºå‰ΩøÁî® winres Ê®°ÂùóÊù•Â§ÑÁêÜËµÑÊ∫êÊï∞ÊçÆÔºåÁîüÊàê Windows resource (.rc) Êñá‰ª∂Áî®‰∫é Microsoft rc.exe ÁºñËØëÂô®ÊàñËÄÖ GNU windres.exe„ÄÇ

ÈúÄË¶ÅÈ¢ÑÂÖàÂÆâË£Ö‰ª•‰∏ã‰ªª‰∏ÄÂ∑•ÂÖ∑Ôºö

- rc.exe from the Windows SDK
- windres.exe and ar.exe from minGW64

Âú®ÊûÑÂª∫ËÑöÊú¨ build.rs ‰∏≠‰ΩøÁî® `WindowsResorce::compile()` ÊñπÊ≥ïÔºåÂÆÉ‰ºöÁºñËØëËµÑÊ∫êÔºåÂπ∂ÊåáÂØº Cargo ÈìæÊé•ËµÑÊ∫êÂà∞Á®ãÂ∫èÊñá‰ª∂„ÄÇ

```rust,ignore
// Example
if cfg!(target_os = "windows") {
    let mut res = winres::WindowsResource::new();
    res.set_icon("test.ico")
       .set("InternalName", "TEST.EXE")
       // manually set version 1.0.0.0
       .set_version_info(winres::VersionInfo::PRODUCTVERSION, 0x0001000000000000);
    res.compile()?;
}
```

Âú®Ëá™Âä®ÊûÑÂª∫ËÑöÊú¨ build.rs ‰∏≠ÁªôÁ®ãÂ∫èËÆæÁΩÆ‰∏Ä‰∏™ÂõæÊ†áÔºåÂèÇËÄÉ deno cli Â∑•Á®ãÔºö

```rust,ignore
  #[cfg(target_os = "windows")]
  {
    let mut res = winres::WindowsResource::new();
    res.set_icon("deno.ico");
    res.set_language(winapi::um::winnt::MAKELANGID(
      winapi::um::winnt::LANG_ENGLISH,
      winapi::um::winnt::SUBLANG_ENGLISH_US,
    ));
    res.compile().unwrap();
  }
```

ÂèØ‰ª•Âú® Cargo.toml ÈÖçÁΩÆÂêÑ‰∏™Âπ≥Âè∞ÁöÑ‰æùËµñÔºå‰ª•‰∏ãÊëòÂèñÂÖ≥‰∫é Windows ËµÑÊ∫êÁõ∏ÂÖ≥ÈÉ®ÂàÜÔºö

```rust,ignore
[target.'cfg(windows)'.build-dependencies]
winapi = "0.3.9"
winres = "0.1.11"

[target.'cfg(windows)'.dependencies]
fwdansi = "1.1.0"
winapi = { version = "0.3.9", features = ["knownfolders", "mswsock", "objbase", "shlobj", "tlhelp32", "winbase", "winerror", "winsock2"] }

[target.'cfg(unix)'.dependencies]
nix = "0.19.1"

[target.'cfg(unix)'.dev-dependencies]
exec = "0.3.1" # Used in test_raw_tty

[package.metadata.winres]
# This section defines the metadata that appears in the deno.exe PE header.
OriginalFilename = "deno.exe"
LegalCopyright = "¬© Deno contributors & Deno Land Inc. MIT licensed."
ProductName = "Deno"
FileDescription = "A secure runtime for JavaScript and TypeScript."
```


## ‚ö° mdBook ÁîµÂ≠ê‰π¶Ê°ÜÊû∂
- [mdbook - Creates a book from markdown](https://crates.io/crates/mdbook)
- [Crate mdbook](https://docs.rs/mdbook/0.4.7/mdbook/)
- [mdbook User Guide](https://rust-lang.github.io/mdBook/)
- [mdBook Documentation](https://rust-lang.github.io/mdBook/)
- [mdbook-katex Êï∞Â≠¶ÂÖ¨ÂºèÊèí‰ª∂](https://github.com/lzanini/mdbook-katex)
- [LaTex functions](https://katex.org/docs/supported.html)
- [MathJax](https://www.mathjax.org/)
- [EPUB generator](https://crates.io/crates/mdbook-epub)
- [Syntax Highlighting](https://highlightjs.org/)
- [Handlebars - a simple templating language](https://handlebarsjs.com/guide/)

The Rust Programming Language ÂÆòÊñπËøôÊú¨ÁîµÂ≠ê‰π¶Êú¨Ë∫´Â∞±ÊòØ‰∏Ä‰∏™ Cargo Â∑•Á®ãÔºåÂú® listings ÁõÆÂΩï‰∏ãÊèê‰æõÁöÑÈÖçÂ•ó‰ª£Á†Å„ÄÇ

Âè¶Â§ñÔºåsrc ÁõÆÂΩïÊòØÁîµÂ≠ê‰π¶ÊñáÊ°£Ôºå‰ΩøÁî®Á±ª‰ºº Gitbook ÁöÑ mdBook Ê°ÜÊû∂ÔºåÁõÆÂâçÁâàÊú¨ mdbook-0.4.7„ÄÇ

ÊîØÊåÅÂäüËÉΩÔºö

- Âø´Êç∑ÈîÆÊîØÊåÅ
- ÂÖ≥ÈîÆÂ≠óÊêúÁ¥¢
- ‰∏ªÈ¢òÊ†∑Âºè
- ÈõÜÊàêËØ≠Ê≥ïÈ´ò‰∫Æ Highlight.js
- ÈõÜÊàêÊï∞Â≠¶ÂÖ¨Âºè MathJax
- Ê®°ÊùøÈõÜÊàê Handlebars

ÂÆâË£Ö‰ΩøÁî®Ôºö

    git clone git@github.com:rust-lang/mdBook
    git clone git@github.com:rust-lang/book

    cargo install mdbook [--vers version-num]
    mdbook build

ÂÆâË£ÖÂêé‰ºöÁºñËØëÁîüÊàê mdbook ÂëΩ‰ª§ÔºåÊâßË°å mdbook build ÁºñËØëÈ°πÁõÆÂ∞±ÂèØ‰ª•Âú® book ÁõÆÂΩïÁîüÊàêÁîµÂ≠ê‰π¶„ÄÇ

ÂÖ∂ÂÆÉÂëΩ‰ª§Ôºö

- mdbook watch ÁõëËßÜ markdown Êñá‰ª∂ÔºåËá™Âä®ÈáçÊñ∞ÁîüÊàê„ÄÇ
- mdbook serve ÂêØÂä®Êú¨Âú∞ÂºÄÂèëÊúçÂä°Âô®ÔºåÂπ∂ÁõëËßÜÊñá‰ª∂ÊîπÂä®ÔºåWeb ÊúçÂä°ÈªòËÆ§Âú∞ÂùÄ http://localhost:3000Ôºå‰∏ªÊú∫„ÄÅÁ´ØÂè£ÂèØ‰ª•ÈÖçÁΩÆ `--port <port>`„ÄÇ
- mdbook clean Ê∏ÖÁêÜÁîüÊàêÊñá‰ª∂„ÄÇ
- mdbook init --theme ÂàùÂßãÂåñÊ®°ÊùøÊñá‰ª∂„ÄÇ

Âú® Cargo Â∑•Á®ãÊ†πÁõÆÂΩï‰∏≠ÔºåÂèØ‰ª•ÂàõÂª∫‰∏Ä‰∏™ rust-toolchain Êñá‰ª∂Êù•ÊåáÂÆöÂ∑•Á®ã‰ΩøÁî®ÁöÑ Rust Â∑•ÂÖ∑ÈìæÁâàÊú¨ÔºåÂ¶ÇÔºö

    1.50.0

ËøôÊ†∑ÔºåÂ∞±ÈúÄË¶ÅÂÆâË£ÖÁõ∏Â∫îÁöÑÂ∑•ÂÖ∑ÈìæÊâçËÉΩÁªßÁª≠Êìç‰ΩúÔºåÂê¶ÂàôÊèêÁ§∫ÈîôËØØÊ∂àÊÅØÔºö

    >rustup default stable
    info: using existing install for 'stable-x86_64-pc-windows-msvc'
    info: default toolchain set to 'stable-x86_64-pc-windows-msvc'

      stable-x86_64-pc-windows-msvc unchanged - rustc 1.44.0 (49cae5576 2020-06-01)

    error: invalid channel name '1.50' in '\\?\home\book-master\rust-toolchain'
    error: caused by: invalid toolchain name: '1.50'

È°πÁõÆÁªìÊûÑÁîüÊàêÔºö

    mdbook init <directory>

    book-test/
    ‚îú‚îÄ‚îÄ book
    ‚îî‚îÄ‚îÄ src
        ‚îú‚îÄ‚îÄ title-page.md
        ‚îú‚îÄ‚îÄ foreword.md
        ‚îú‚îÄ‚îÄ chapter_01.md
        ‚îú‚îÄ‚îÄ appendix-00.md
        ‚îî‚îÄ‚îÄ SUMMARY.md

ÁîüÊàêÊó∂Ôºåmd Êñá‰ª∂‰ºöÂ§ÑÁêÜÊàê HTML ÂµåÂÖ•Âà∞ handlebars Ê®°ÊùøÊñá‰ª∂ index.hbsÔºå‰Ω†ÂèØ‰ª•Âú®Â∑•Á®ãÁõÆÂΩï‰∏≠ÂàõÂª∫Ëá™Â∑±ÁöÑÊ®°ÊùøÊñá‰ª∂Êù•ÊõøÊç¢ÂÆÉÔºåËÄå‰∏çÊòØ‰ΩøÁî® mdBook Ëá™Â∏¶ÁöÑ„ÄÇ

Âú®Â∑•Á®ãÊ†πÁõÆÂΩï‰∏ãÂàõÂª∫ theme ÁõÆÂΩïÔºåÂπ∂‰∏îÂèØ‰ª•ÂàõÂª∫‰ª•‰∏ãÊñá‰ª∂ÊõøÊç¢ÈªòËÆ§ÁöÑÊ®°ÊùøÊñá‰ª∂Ôºö

- `index.hbs` is the handlebars template.
- `head.hbs` is appended to the HTML `<head>` section.
- `header.hbs` content is appended on top of every book page.
- `css/` contains the CSS files for styling the book.
    - `css/chrome`.css is for UI elements.
    - `css/general`.css is the base styles.
    - `css/print`.css is the style for printer output.
    - `css/variables`.css contains variables used in other CSS files.
- `book.js` is mostly used to add client side functionality, like hiding / un-hiding the sidebar, changing the theme, ...
- `highlight.js` is the JavaScript that is used to highlight code snippets, you should not need to modify this.
- `highlight.css` is the theme used for the code highlighting.
- `favicon.svg` and favicon.png the favicon that will be used. The SVG version is used by newer browsers.

Ê®°Êùø‰∏≠ÂΩìÂâç‰∏ä‰∏ãÊñáÂØπË±°Êèê‰æõÁöÑÊï∞ÊçÆÔºö

- `<html lang="{{ language }}">` ËØ≠Ë®ÄÔºåÈªòËÆ§ÂÄº‰∏∫ en„ÄÇ
- `title` Ê†áÈ¢òÔºåÁ≠â‰ª∑ `{{ chapter_title }} - {{ book_title }}`„ÄÇ
- `book_title` Title of the book, as specified in book.toml
- `chapter_title` Title of the current chapter, as listed in SUMMARY.md
- `path` Relative path to the original markdown file from the source directory
- `content` This is the rendered markdown.
- `path_to_root` ÂΩìÂâçÊñá‰ª∂Âà∞È°πÁõÆÊ†πÁõÆÂΩïÁöÑÁõ∏ÂØπË∑ØÂæÑ„ÄÇ
- `chapters` ‰∏Ä‰∏™Â≠óÂÖ∏Êï∞ÊçÆÊï∞ÁªÑÔºå{{chapters.[0].name}} ËÆøÈóÆÊï∞ÊçÆÔºå{"section": "...", "name": "...", "path": "dir/markdown.md"}
- `{{#toc}}{{/toc}}` ÈÄöËøá toc Êö¥Èú≤ÁõÆÂΩï„ÄÇ
- ÈÄöËøá previous Âíå next helpers Êö¥Èú≤‰∏ä‰∏ãÁ´†ËäÇÈìæÊé• link Âíå name„ÄÇ

SUMMARY.md Êñá‰ª∂Áî®Êù•ÂëäËØâ mdBook ÂëΩ‰ª§ÈúÄË¶ÅÂåÖÂê´‰ΩøÁî®Á´†ËäÇÂÜÖÂÆπÊñá‰ª∂ÔºåÂÆÉÊú¨Ë∫´Â∞±Áõ∏ÂΩì‰∫éÈ°µÈù¢‰∏äÁöÑÁõÆÂΩï„ÄÇ

ÂÆÉÊúâÂõ∫ÂÆöÁöÑÁõÆÂΩïÈìæÊé•ÁªìÊûÑÔºö

- `# Title` Âç≥ markdown ‰∏ÄÁ∫ßÊ†áÈ¢ò # ÂÆö‰πâÔºåËøôÈÉ®ÂàÜ‰∏ç‰ºöÂá∫Áé∞Âú®ÁîüÊàêÈ°µÈù¢‰∏≠ÔºåÂè™ÊòØËÆ©‰Ω†ÁúãËµ∑Êù•Êõ¥ÊúâÊù°ÁêÜ„ÄÇ
- `# Part Title` ÂàÜÂç∑Ê†áÈ¢òÔºåÂèØÈÄâÔºåÂç≥Âú®Ê≠£ÂºèÁ´†ËäÇ‰∏≠Âá∫Áé∞ÁöÑ‰∏ÄÁ∫ßÊ†áÈ¢òÔºå‰ºöÂú®ÁõÆÂΩï‰∏≠ÊòæÁ§∫Ôºå‰ΩÜÊ≤°ÊúâË∂ÖÁ∫ßÈìæÊé•ÂäüËÉΩ„ÄÇ
- Prefix Chapter Ê≠£ÂºèÂÜÖÂÆπÁ´†ËäÇÂºÄÂßãÂâçÁöÑÈÉ®ÂàÜÔºåÂ¶Ç forewords, preface, introductions Á≠âÔºå‰∏çËÉΩÂµåÂ•óÔºåÂπ∂‰∏îÂè™ËÉΩÂú®Êï∞Â≠óÁºñÂè∑Á´†ËäÇÂÜÖÂÆπ‰πãÂâç„ÄÇ
- Numbered Chapter Ê≠£ÂºèÁ´†ËäÇÔºå‰ΩøÁî®Êï∞Â≠óÁºñÂè∑ÔºåÂèØÂ§öÁ∫ßÂµåÂ•óÔºåÂèØ‰ª•‰ΩøÁî® `-` Êàñ `*` Ë°®Á§∫‰∏Ä‰∏™Êï∞Â≠óÁºñÂè∑„ÄÇ
- Suffix Chapter ÈôÑÂΩïÂÜÖÂÆπÔºåÂú®Ê≠£ÂºèÁ´†ËäÇÂêéÈù¢„ÄÇ
- `---` Separators ÂèØÈÄâÁöÑÂàÜÈöîÁ¨¶Âè∑„ÄÇ
- `[Draft chapters]()` ËçâÁ®øÁ´†ËäÇÔºåÊ≥®ÊÑèÁ©∫ÂúÜÊã¨Âè∑Ë°®Á§∫Ëøô‰∏™Êù°ÁõÆÊ≤°ÊúâÂÜÖÂÆπÔºåÂç≥ËçâÁ®øÁä∂ÊÄÅÔºåÂú®È°µÈù¢ÊòæÁ§∫Ôºå‰ΩÜÊ≤°ÊúâÈìæÊé•ÂäüËÉΩ„ÄÇ

SUMMARY.md ÂÜÖÂÆπÂèÇËÄÉÔºö

    # Title

    [Title of the Chapter](relative/path/to/forewords.md)
    [Title of another Chapter](relative/path/to/preface.md)

    # Getting started

    - [Getting Started](getting-started.md)
        - [Installation](installation.md)
        - [Hello, World!](hello-world.md)
        - [Hello, Cargo!](hello-cargo.md)

    - [Programming a Guessing Game](guessing-game-tutorial.md)

    # Basic Concepts

    - [Common Programming Concepts](common-programming-concepts.md)
        - [Variables and Mutability](variables-and-mutability.md)
        - [Data Types](data-types.md)
        - [Functions](how-functions-work.md)
        - [Comments](comments.md)
        - [Control Flow](control-flow.md)

    - [Understanding Ownership](understanding-ownership.md)
        - [What is Ownership?](what-is-ownership.md)
        - [References and Borrowing](references-and-borrowing.md)
        - [The Slice Type](slices.md)

    - [Using Structs to Structure Related Data](structs.md)
        - [Defining and Instantiating Structs](defining-structs.md)
        - [An Example Program Using Structs](example-structs.md)
        - [Method Syntax](method-syntax.md)

    - [Enums and Pattern Matching](enums.md)
        - [Defining an Enum](defining-an-enum.md)
        - [The `match` Control Flow Operator](match.md)
        - [Concise Control Flow with `if let`](if-let.md)

    ## Separators
    ---

    ## Draft chapters are chapters without a file and thus content
    - [Draft chapter]()

    ## Appendix (appendix-00.md)

    [A - Keywords](appendix-01-keywords.md)
    [B - Operators and Symbols](appendix-02-operators.md)
    [C - Derivable Traits](appendix-03-derivable-traits.md)
    [D - Useful Development Tools](appendix-04-useful-development-tools.md)
    [E - Editions](appendix-05-editions.md)
    [F - Translations of the Book](appendix-06-translation.md)
    [G - How Rust is Made and ‚ÄúNightly Rust‚Äù](appendix-07-nightly-rust.md)

ÂèÇËÄÉÈÖçÁΩÆ book.tomlÔºö

    [book]
    title = "The Rust Programming Language"
    author = "Steve Klabnik and Carol Nichols, with Contributions from the Rust Community"
    description = "The example book covers examples."
    src = "src"
    language = "en"

    [output.html]
    additional-css = ["ferris.css", "theme/2018-edition.css"]
    additional-js = ["ferris.js"]
    git-repository-url = "https://github.com/rust-lang/book"
    theme = "my-theme"
    default-theme = "light"
    preferred-dark-theme = "navy"
    mathjax-support = true

    [output.linkcheck]  # enable the "mdbook-linkcheck" renderer

    [build]
    build-dir = "book"
    create-missing = false

    # plugins
    [preprocessor.katex]

ÂÖ∂‰∏≠Ôºå[output.html] Êèê‰æõÁöÑÈÖçÁΩÆÈ°πÁõÆËøòÊúâÂæàÂ§öÔºåÂÖ∑‰ΩìÂèÇËÄÉÊñáÊ°£„ÄÇ

ÂèØ‰ª•Âú® markdown Êñá‰ª∂‰∏≠ÂåÖÂê´‰ª£Á†ÅÊñá‰ª∂ÂÜÖÂÆπÔºåANCHOR: here ÊòØÂèØÈÄâÂàÜÈöîÊ†áËÆ∞ÔºåÊ†áËÆ∞ÂèØ‰ª•ÂµåÂ•óÔºö

    ```rust,noplayground
    {{#rustdoc_include ../listings/ch17-oop/listing-17-02/src/lib.rs:here}}
    {{#include ../listings/ch17-oop/listing-17-02/src/lib.rs}}
    ```

Âè¶Â§ñËøòÂèØ‰ª•‰ΩøÁî®Ë°åÂè∑ÔºåÈúÄË¶ÅÊòæÁ§∫Âì™‰∫õË°åÂ∞±ÊåáÂÆöÔºåËÄå rustdoc_include ÊñπÂºèÊåáÂÆöÁöÑË°åÂè∑ÊòØ‰ª•ÊäòÂè†ÊñπÂºèÊòæÁ§∫ÁöÑÔºö

    ```rust,noplayground
    {{#rustdoc_include ../listings/ch17-oop/listing-17-02/src/lib.rs:1}}
    {{#include ../listings/ch17-oop/listing-17-02/src/lib.rs:1}}
    // ...
    {{#include ../listings/ch17-oop/listing-17-02/src/lib.rs:5}}
    ```

Âà©Áî® play.rust-lang.org Êèê‰æõÁöÑÂú®Á∫øÁºñËØëËÉΩÂäõÔºåÂèØ‰ª•Âú®È°µÈù¢ÈÖçÁΩÆ playground ‰ª•Ëé∑ÂæóÂú®È°µÈù¢‰∏≠ÊâßË°å‰ª£Á†ÅÁöÑÂäüËÉΩ„ÄÇ

ÊàñËÄÖÁõ¥Êé•Âú®È°µÈù¢‰∏≠ÂµåÂÖ•‰ª£Á†Å‰πü‰∏ÄÊ†∑ÔºåËÆæÁΩÆ ignore ‰∏çÊèê‰æõËøêË°åÂäüËÉΩÔºö

    ```rust
    fn main() {
        println!("Hello, world!");
    }
    ```

    {{#playground file.rs}}

    ```rust,ignore
        println!("Hello, world!");
    ```

ÈÖçÁΩÆÂèØÊâßË°å‰ª£Á†Å‰∏∫ÂèØÁºñËæëÁä∂ÊÄÅÔºåÈªòËÆ§‰ΩøÁî® Ace editorÔºåÂèØ‰ª•ÈÄöËøá editor ÊåáÂÆöÔºö

    [output.html.playground]
    editable = true
    editor = "/path/to/editor"

ÁÑ∂ÂêéÂú®‰ª£Á†ÅÂùó‰∏≠ËÆæÁΩÆ editableÔºö

    ```rust,editable
    fn main() {
        let number = 5;
        print!("{}", number);
    }
    ```

ÂèÇËÄÉ‰ª£Á†ÅÊñá‰ª∂Ôºö

```rust,ignore
    pub struct AveragedCollection {
        list: Vec<i32>,
        average: f64,
    }

    // ANCHOR: here
    fn main() {
        println!("Hello, world!");
    }
    // ANCHOR_END: here
```

mdBook ÂÜÖÁΩÆ‰∫Ü LaTeXTÔºåÂè™ÈúÄË¶ÅÈÖçÁΩÆ mathjax-support Â∞±ÂèØ‰ª•ÊâìÂºÄÊï∞Â≠¶ÂÖ¨ÂºèÊîØÊåÅÔºö

    [output.html]
    mathjax-support = true

Inline equations `\\(` and `\\)`Ôºö

    \\( \int x dx = \frac{x^2}{2} + C \\)

Block equations `\\[` and `\\]`Ôºö

    \\[ \mu = \frac{1}{N} \sum_{i=0} x_i \\]





## ‚ö° Basic Concepts & Data Types
- https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html
- Lexical structure https://doc.rust-lang.org/stable/reference/lexical-structure.html
- Rust Language Cheat Sheet https://cheats.rs

Âü∫Á°ÄÊ¶ÇÂøµÈÉ®ÂàÜËß£Êûê‰ª•‰∏ãÂÜÖÂÆπÔºö

- Variables and Mutability ÂèòÈáè‰∏éÂèØÂèòÊÄß
- Data Types Âü∫Êú¨Êï∞ÊçÆÁ±ªÂûã
- Functions ÂáΩÊï∞
- Comments Ê≥®Ëß£
- Control Flow ÊµÅÁ®ãÊéßÂà∂


### üü¢üîµ Comments & Doc
- Documentation https://cheats.rs/#documentation
- Making Useful Documentation Comments https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html
- https://doc.rust-lang.org/stable/rust-by-example/meta/doc.html
- https://doc.rust-lang.org/stable/reference/comments.html


Rust ‰ΩøÁî® C++ ‰∏ÄÊ†∑ÁöÑÊ≥®Ëß£ËØ≠Ê≥ïÔºåÂçïÂè•Ê≥®Ëß£ÂíåÂùóÊ≥®Ëß£‰∏§ÁßçÔºö

```rust,ignore
/**
 * Some comments...
 */
fn main() {
    let lucky_number = 7; // I‚Äôm feeling lucky today
}
```

ÂèØ‰ª•‰ΩøÁî® /// Êù•ËÆæÁΩÆÊ≥®Ëß£ÊñáÊ°£ÔºåÁªìÂêà cargo doc ÂëΩ‰ª§ÁîüÊàêÊñáÊ°£Ôºö

```rust,ignore
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

Èô§‰∫ÜÊîØÊåÅ Markdowm ÁöÑËØ≠Ê≥ïÔºå‰ª•‰∏äËÆæÁΩÆ‰∫Ü‰∏ÄÊù°Ê†áÈ¢ò `# Examples`ÔºåËøòÊúâ‰ª•‰∏ãÂá†‰∏™ÂàÜÂå∫ÂäüËÉΩÔºö

- `Panics`: È¢ÑÊµãË∞ÉÁî®ÂáΩÊï∞‰ºöÂºïËµ∑ panicÔºåË∞ÉÁî®ËÄÖÂ∫îËØ•Á°ÆËÆ§Á®ãÂ∫è‰∏çËØ•Ë∞ÉÁî®Â¶ÇÊûú‰∏çÊÉ≥Á®ãÂ∫è panic„ÄÇ
- `Errors`: ÊèèËø∞ÂáΩÊï∞ÁöÑËøîÂõûÁöÑÈîôËØØ‰ø°ÊÅØÔºå‰ª•ÂèäÂèØËÉΩÂØºËá¥Ëøô‰∫õÈîôËØØËøîÂõûÁöÑÊù°‰ª∂ÔºåËøôÊ†∑ÂØπË∞ÉÁî®ÊñπÂæàÊúâÂ∏ÆÂä©„ÄÇ
- `Safety`: Â¶ÇÊûúÂáΩÊï∞Ë∞ÉÁî®‰∏çÂÆâÂÖ®ÔºåÈÇ£‰πàÂ∫îËØ•Ëß£Èáä‰∏∫‰ªÄ‰πàÂáΩÊï∞‰∏çÂÆâÂÖ®ÔºåÂπ∂Ê∂µÁõñÂáΩÊï∞ÊúüÊúõË∞ÉÁî®ËÄÖÊîØÊåÅÁöÑ‰∏çÂèòÈáè„ÄÇ

Rust ‰∏≠ÁöÑ Outer comment Âç≥ÊòØÂú® cargo doc ÁºñËØëÂêé‰ºöÂá∫Áé∞Âú®ÊñáÊ°£‰∏≠ÁöÑÊ≥®Ëß£ÔºåInner doc comments ÂàôÊòØ‰∏çÈúÄË¶ÅË¢´ÊèêÂèñÂà∞ÊñáÊ°£ÁöÑÊ≥®Ëß£ÔºåÂåÖÊã¨ `///`„ÄÅ `//!` Âíå `/**` Âá†ÁßçÂΩ¢Âºè„ÄÇ

```rust,ignore
#![allow(unused)]
//! A doc comment that applies to the implicit anonymous module of this crate

pub mod outer_module {

    //!  - Inner line doc
    //!! - Still an inner line doc (but with a bang at the beginning)

    /*!  - Inner block doc */
    /*!! - Still an inner block doc (but with a bang at the beginning) */

    //   - Only a comment
    ///  - Outer line doc (exactly 3 slashes)
    //// - Only a comment

    /*   - Only a comment */
    /**  - Outer block doc (exactly) 2 asterisks */
    /*** - Only a comment */

    pub mod inner_module {}

    pub mod nested_comments {
        /* In Rust /* we can /* nest comments */ */ */

        // All three types of block comments can contain or be nested inside
        // any other type:

        /*   /* */  /** */  /*! */  */
        /*!  /* */  /** */  /*! */  */
        /**  /* */  /** */  /*! */  */
        pub mod dummy_item {}
    }

    pub mod degenerate_cases {
        // empty inner line doc
        //!

        // empty inner block doc
        /*!*/

        // empty line comment
        //

        // empty outer line doc
        ///

        // empty block comment
        /**/

        pub mod dummy_item {}

        // empty 2-asterisk block isn't a doc block, it is a block comment
        /***/

    }

    /* The next one isn't allowed because outer doc comments
       require an item that will receive the doc */

    /// Where is my item?
}
```

Within Doc Comments Explanation

    ```...```       Include a doc test (doc code running on cargo test).
    ```X,Y ...```   Same, and include optional configurations; with X, Y being ...
        rust        Make it explicit test is written in Rust; implied by Rust tooling.
        -           Compile test. Run test. Fail if panic. Default behavior.
        should_panic    Compile test. Run test. Execution should panic. If not, fail test.
        no_run          Compile test. Fail test if code can't be compiled, Don't run test.
        compile_fail    Compile test but fail test if code can be compiled.
        ignore          Do not compile. Do not run. Prefer option above instead.
        edition2018     Execute code as Rust '18; default is '15.
    #               Hide line from documentation (``` # use x::hidden; ```).
    [`S`]           Create a link to struct, enum, trait, function, ‚Ä¶ S.
    [`S`](crate::S) Paths can also be used, in the form of markdown links.


### üü¢üîµ Variables and Mutability ÂèòÈáè‰∏éÂèØÂèòÊÄß
- https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html
- https://doc.rust-lang.org/std/keyword.const.html

ÂâçÈù¢Â∑≤ÁªèËß£ÊûêËøá Variables and Mutability Ê¶ÇÂøµÔºåÂÆÉ‰ª¨ÈÉΩÊòØÂèòÈáèÔºåËÄåÂ∏∏Èáè‰ΩøÁî® const ÂÆö‰πâ„ÄÇ

```rust,ignore
fn main() {
    let foo = "x"; // immutable
    let foo = "y"; // override or shadowing
    // cannot assign twice to immutable variable `foo`
    // foo = "y";

    let bar;       // mutable
    bar = foo;

    println!("foo: {}", foo);
    
    const C: u32 = 100_000;
    const MAX_POINTS: u32 = 100_000;
    const HELLO: &str = "Hello, world!";
    static WORLD: &str = "Hello, world!";
    // let c: String = "it is a constant".to_owned();

    println!("foo: {} bar: {}, constant: {}", foo, bar, C);
}
```

Ê≥®ÊÑèÔºå‰ª•‰∏ä‰ª£Á†ÅÁöÑ foo ÂèòÈáèËµãÂÄºÂà∞ bar Êó∂ÔºåÊòØ‰º†ÈÄíÊñπÂºèÔºåÊ≤°ÊúâÂèëÁîüÊâÄÊúâÊùÉËΩ¨ÁßªÔºå‰∏çÂÉè String ÂØπË±°„ÄÇ

Âú® Rust ‰∏≠ÔºåÂèòÈáèÈªòËÆ§ÊòØ‰∏çÂèØÂèòÁöÑÔºåÈô§ÈùûÂä†‰∫Ü `mut` ÂÖ≥ÈîÆÂ≠ó‰ΩøÂèòÈáèÂÖ∑ÊúâÂèØÂèòÊÄßÔºå‰ΩÜÊòØÂÆÉ‰ª¨ÈÉΩÂ±û‰∫éÂèòÈáè„ÄÇ

Âú®ÂèòÈáèÂêçÂâç‰ΩøÁî® mut Êù•‰Ωø‰∏Ä‰∏™ÂèòÈáèÂèØÂèòÔºåÂç≥ `mutable`ÔºåÂú® Rust ‰∏≠ÔºåÂèòÈáèÈªòËÆ§ÊòØ‰∏çÂèØÂèòÁöÑ `immutable`„ÄÇ

Rust Áî® `let` ËØ≠Âè•Êù•ÂàõÂª∫ÂèòÈáèÔºåÂπ∂ÁªëÂÆöÂà∞Á≠âÂè∑Âè≥‰æßÁöÑÂÄº‰∏äÔºåÊ≥®ÊÑèÁªëÂÆöËøô‰∏™Âä®‰ΩúÔºåÂèÇËÄÉÁîüÂëΩÂë®ÊúüÈÉ®ÂàÜÂÜÖÂÆπ„ÄÇ

ÂèòÈáèÂèØ‰ª•Ë¢´Ë¶ÜÁõñÔºåÂç≥ shadowingÔºåÂÆÉ‰∏çÂêå‰∫éÂ∞ÜÂèòÈáèËÆæ‰∏∫ÂèØÂèòÂèòÈáè„ÄÇÂ¶ÇÊûú‰∏ç‰ΩøÁî® `let` ‰∏∫ÂèòÈáèÈáçÊñ∞ËµãÂÄºÔºå‰ºöÂæóÂà∞ÁºñËØëÈîôËØØÔºå‰ΩÜÊòØ‰ΩøÁî® `let` ‰∏∫Âêå‰∏ÄÂèòÈáèÈáçÊñ∞ËµãÂÄºÂèØ‰ª•Ë¶ÜÁõñ‰πãÂâçÁöÑÂèòÈáèÔºåË¶ÜÁõñÁâπÊÄßËÆ©ÂèòÈáèÂèØ‰ª•ÊîπÂèò„ÄÇ

Ë¶ÜÁõñÁöÑÂ•ΩÂ§ÑÊòØÂèØ‰ª•ËÆ©Êàë‰ª¨ÈÅøÂÖç‰∫éËµ∑‰∏çÂêåÁöÑÂèòÈáèÂêçÔºåÂèØ‰ª•Áõ¥Êé•Â§çÁî®‰πãÂâçÁöÑÂèòÈáèÂêçÔºåÂêåÊó∂‰∏çÂøÖÂÖ≥ÂøÉÂèòÈáèÁ±ªÂûãÁöÑÊõ¥ÊîπÔºå‰πüÊõ¥È´òÊïàÂíå‰æø‰∫éÁêÜËß£„ÄÇ


Rust ÁöÑÂ∏∏ÈáèÂÆö‰πâ‰ΩøÁî®ÂÖ≥ÈîÆÂ≠ó `const`ÔºåÂπ∂‰∏îÈúÄË¶ÅÊåáÂÆöÊï∞ÊçÆÁ±ªÂûã„ÄÇÂ∏∏ÈáèÂèØ‰ª•Âú®‰ªª‰ΩïËåÉÂõ¥ÂÜÖÂÆö‰πâÔºåÂπ∂‰∏îÂèØ‰ª•Âú®Â§ö‰∏™‰ª£Á†ÅÂùó‰∏≠‰ΩøÁî®ÔºåÁªôÂ∏∏ÈáèËµãÂÄºÊó∂ÂΩìÁÑ∂Ë¶Å‰ΩøÁî®Â∏∏ÈáèË°®ËææÂºèÔºå‰∏çËÉΩ‰ΩøÁî®ÂáΩÊï∞ÁöÑËøîÂõûÂÄºÊàñËÄÖÊòØËÆ°ÁÆóÂºè„ÄÇ

Rust Â∏∏ÈáèÂëΩÂêçËßÑËåÉÊòØÔºöÂÖ®Â≠óÊØçÂ§ßÂÜôÔºåÂçïËØçÈó¥‰ª•‰∏ãÂàíÁ∫øÂàÜÈöîÔºåÊï∞Â≠óÁ±ªÂûã‰∏∫‰∫ÜÊñπ‰æøÈòÖËØª‰πüÂèØ‰ª•‰ΩøÁî®‰∏ãÂàíÁ∫øÂàÜÂâ≤„ÄÇ

‰∏∫Êï¥‰∏™Á®ãÂ∫è‰∏≠‰ΩøÁî®ÁöÑÂÄºËÆæ‰∏∫Â∏∏ÈáèÔºåÊúâÂà©‰∫é‰º†ÈÄíËØ•ÂÄºÁöÑÂê´‰πâÁªôÊú™Êù•ÁöÑ‰ª£Á†ÅÁª¥Êä§‰∫∫Âëò„ÄÇ‰ΩøÁî®Â∏∏Èáè‰æø‰∫é‰øÆÊîπÔºåÂè™ÈúÄ‰øÆÊîπ‰∏Ä‰∏™Â∏∏ÈáèÔºå‰æøÂèØÊõ¥Êñ∞Á®ãÂ∫è‰∏≠ÊâÄÊúâ‰ΩøÁî®ËØ•Â∏∏ÈáèÁöÑÂÄº„ÄÇ

ÂèòÈáè‰∏éÂ∏∏ÈáèÁöÑÂºÇÂêåÊØîËæÉÔºö

- Áõ∏ÂêåÁÇπÔºöÈÉΩ‰∏çÂèØÂèò
- ‰∏çÂêåÁÇπÔºö
    - Â∏∏Èáè‰∏çÊòØÈªòËÆ§‰∏çÂèØÂèòÔºåËÄåÊòØ‰∏ÄÁõ¥‰∏ç‰ºöÊîπÂèò„ÄÇ
    - ÂèòÈáè‰ΩøÁî® `let` Â£∞ÊòéÔºåÂ∏∏Èáè‰ΩøÁî® `const` Â£∞ÊòéÔºå‰∏îÂøÖÈ°ªÊåáÂÆöÂ∏∏ÈáèÁöÑÁ±ªÂûã„ÄÇ
    - Â∏∏ÈáèÂèØ‰ª•Âú®‰ªªÊÑè‰ΩúÁî®ÂüüÈáåÂ£∞Êòé„ÄÇ
    - Â∏∏ÈáèÂè™ËÉΩËÆæÁΩÆ‰∏∫Â∏∏ÈáèË°®ËææÂºèÔºåËÄå‰∏çËÉΩËÆæÁΩÆ‰∏∫ÂáΩÊï∞Ë∞ÉÁî®ÁöÑÁªìÊûúÊàñÂè™ËÉΩÂú®ËøêË°åÊó∂ËÆ°ÁÆóÁöÑ‰ªª‰ΩïÂÖ∂‰ªñÂÄº„ÄÇ


### üü¢üîµ Data Types Âü∫Êú¨Êï∞ÊçÆÁ±ªÂûã
- https://doc.rust-lang.org/book/ch03-02-data-types.html
- https://doc.rust-lang.org/stable/reference/types.html
- https://doc.rust-lang.org/stable/reference/types/tuple.html
- https://doc.rust-lang.org/stable/reference/types/array.html
- https://doc.rust-lang.org/rust-by-example/types.html
- https://doc.rust-lang.org/std/iter/trait.IntoIterator.html#impl-IntoIterator-23
- https://doc.rust-lang.org/stable/std/primitive.unit.html
- [Rust Language Cheat Sheet](https://cheats.rs/#strings-chars)
- [Tokens](https://doc.rust-lang.org/stable/reference/tokens.html)

Rust Á®ãÂ∫èÊØè‰∏™ÂèòÈáè„ÄÅÈ°πÂíåÂÄºÈÉΩÊúâ‰∏Ä‰∏™Á±ªÂûãÔºåÁ±ªÂûãÂÆö‰πâ‰∫Ü‰øùÂ≠òËØ•ÂÄºÁöÑÂÜÖÂ≠òÂ¶Ç‰ΩïËß£ÈáäÔºå‰ª•ÂèäÂèØ‰ª•ÂØπËØ•ÂÄºÊâßË°å‰ªÄ‰πàÊìç‰Ωú„ÄÇ

‰ª•‰∏ãÊòØÊñáÊ°£ÁªôÂá∫ÁöÑÁ±ªÂûãÂàóË°®Ôºö

-  types:
    - `Boolean` ‚Äî `true` or `false`
    - `Numeric` ‚Äî integer and float
    - `Textual` ‚Äî `char` and `str`
    - `Never` ‚Äî `!` ‚Äî a type with no values
- Sequence types:
    - `Tuple`
    - `Array`
    - `Slice`
- User-defined types:
    - `Struct`
    - `Enum`
    - `Union`
- Function types:
    - `Functions`
    - `Closures`
- Pointer types:
    - `References`
    - `Raw pointers`
    - `Function pointers`
- Trait types:
    - `Trait objects`
    - `Impl trait`


‰ªª‰ΩïËØ≠Ë®ÄÈÉΩÊúâÂü∫Êú¨Êï∞ÊçÆÁ±ªÂûãÂíåÂ§çÂêàÊï∞ÊçÆÁ±ªÂûãÔºåRust ‰πü‰∏ç‰æãÂ§ñÔºö

- `bool` Â∏ÉÂ∞îÂÄºÔºåtrue or false„ÄÇ
- `[u/i][8/16/32/64/128]` Êó†Á¨¶Âè∑„ÄÅÁ¨¶Âè∑Êï¥Êï∞„ÄÇ
- `usize` `isize` Â§ßÂ∞èÂèñÂÜ≥‰∫éÁ®ãÂ∫èËøêË°åÊó∂Êú∫Âô®ÁöÑÂ≠óÈïøÁöÑÊï¥ÂûãÔºåÊúâÂèØËÉΩ‰∏∫ 4 Â≠óËäÇÊàñ 8 Â≠óËäÇ„ÄÇ
- `f[32/64]` ÊµÆÁÇπÊï∞ÔºåÈªòËÆ§ÁöÑÊµÆÁÇπÁ±ªÂûãÊòØ `f64`ÔºåÂÆÉ‰ª¨ÈÅµÂæ™ IEEE-754 ËßÑËåÉ„ÄÇ
- `char` Â≠óÁ¨¶ÔºåRust Á≥ªÁªü‰ΩøÁî® UnicodeÔºåÊâÄ‰ª•‰∏Ä‰∏™Â≠óÁ¨¶Âç† 4 Â≠óËäÇÔºåÈÄöËøá `std::mem::size_of::<char>()` Á°ÆËÆ§„ÄÇ
- `str` Â≠óÁ¨¶‰∏≤ÊòØ‰∏ÄÁßçÂàáÁâáÁ±ªÂûãÔºåÂàáÁâáÁ±ªÂûãÂú®ÁºñËØëÊúüÈó¥ÂøÖÈ°ªÊòØÂºïÁî®Á±ªÂûãÔºåÂèØÁ°ÆÂÆöÂ§ßÂ∞èÁöÑ„ÄÇ

ÊØèÁßçÊï¥ÂûãÂè™ËÉΩË£Ö‰∏ãÂõ∫ÂÆöÂ§ßÂ∞èÁöÑÊï∞Â≠óÔºåË∂ÖÂá∫‰∫ÜÊï¥ÂûãÁöÑËåÉÂõ¥Âàô‰ºöÂèëÁîüÊ∫¢Âá∫ÔºåÁºñËØëÊúü Rust ÊäõÂá∫‰∏Ä‰∏™ÈîôËØØÊåáÁ§∫Êï∞ÊçÆÊ∫¢Âá∫„ÄÇ


Rust ÊîØÊåÅÊúâÁ¨¶Âè∑Êï¥Êï∞ÂíåÊó†Á¨¶Âè∑Êï¥Êï∞Ôºö

    |  Length | Signed | Unsigned |
    |---------|--------|----------|
    | 8-bit   | i8     | u8       |
    | 16-bit  | i16    | u16      |
    | 32-bit  | i32    | u32      |
    | 64-bit  | i64    | u64      |
    | 128-bit | i128   | u128     |
    | arch    | isize  | usize    |

Â¶ÇÊûúÊ≤°ÊúâÊåáÂÆöÊï∞ÊçÆÁ±ªÂûãÔºåRust ÈªòËÆ§‰ΩøÁî® i32ÔºåËøô‰∏™Á±ªÂûãÈÄöÂ∏∏ÊòØÊÄßËÉΩÊúÄÂ•ΩÁöÑ„ÄÇ


Rust Á≥ªÁªü‰∏≠Â∞ÜÂçï‰∏ÄÁöÑÂÄºÁß∞‰∏∫ Scalar Types ÊàñÂéüÂßãÁ±ªÂûãÔºåÂ¶Ç integers, floating-point numbers,
Booleans, characters Á≠âÂü∫Á°ÄÊï∞ÊçÆÁ±ªÂûã„ÄÇ

ÊØîËæÉ‰∏Ä‰∏ãÂü∫Êú¨Êï∞ÊçÆÁ±ªÂûãÁöÑ‰∏é C++ ËØ≠Ê≥ïÂ∑ÆÂºÇÔºö

C++

    bool boolean = true;
    std::uint8_t u8 = 0;
    std::int16_t i16 = 0;
    std::size_t size = 0;
    float real = 0;
    double precise_real = 0;
    char character = 'A';
    const char* c_string = "Hello, world";
    std::string string = "Hello, world";

Rust

    let boolean: bool = true;
    let uint8: u8 = 0;
    let int16: i16 = 0;
    let size: usize = 0;
    let real: f32 = 0;
    let precise_real: f64 = 0;
    let character: char = 'üòª';
    let str_ref: &str = "Hello, world";
    let string: String = "Hello, world".to_owned();

    // Suffixed literals
    let mut _mutable_integer = 7i32;

    // `NanoSecond` is a new name for `u64`.
    type NanoSecond = u64;

    // Use an attribute to silence warning.
    #[allow(non_camel_case_types)]
    type u64_t = u64;

Rust ÁÆÄÂåñ‰∫ÜÁ±ªÂûãÂêçÂ≠óË°®ËææÔºåÂπ∂‰∏î‰ΩøÁî®Á±ª‰ºº TypeScript ‰∏ÄÊ†∑ÁöÑÁ±ªÂûãÂ£∞ÊòéËØ≠Ê≥ïÊ†ºÂºèÔºåÂú®ÂÜíÂè∑ÂêéÈù¢ÂÆöÊï∞ÊçÆÁ±ªÂûã„ÄÇ

Numbers ÁöÑÂá†ÁßçË°®Á§∫Ôºö

    | Number literals* |   Example   |
    |------------------|-------------|
    | Decimal integer  | 98_222      |
    | Hex integer      | 0xff        |
    | Octal integer    | 0o77        |
    | Binary integer   | 0b1111_0000 |
    | Byte(u8)         | b‚ÄôA‚Äô        |
    | Floating-point   | 123.0E+77   |

ÂçÅËøõÂà∂‰∏≠ _ ‰∏ÄËà¨Ë¢´ÂΩì‰ΩúÂçÉÂàÜÁ¨¶„ÄÇ

Âçï‰ΩçÁ±ªÂûãÊòØÊØîËæÉÁâπÊÆäÁöÑÔºåË°®Á§∫‰∏∫ `()` Á±ªÂûãÔºå‰πü‰ªÖÊúâ‰∏Ä‰∏™ÂÄº `()`ÔºåÁî®Êù•Ë°®Á§∫Ê≤°ÊúâÂÖ∂ÂÆÉÊúâÊÑè‰πâÁöÑËøîÂõûÂÄº„ÄÇÈÄöÂ∏∏ÊòØ
ÂáΩÊï∞ÁöÑÈöêÂºèËøîÂõûÂÄºÔºåÂç≥Ê≤°ÊúâÊåáÂÆöËøîÂõûÂÄº `-> ...` ÁöÑÂáΩÊï∞‰ºöËá™Âä®ËøîÂõûÁöÑÂÄº„ÄÇ

ÂèÇËÄÉÂ¶Ç‰∏ãÔºö

```rust,ignore
fn return_unit_long() -> () {}
fn return_unit_short() {}

fn returns_i64() -> i64 {
    1i64
}
fn returns_unit() {
    1i64;
}

let is_i64 = {
    returns_i64()
};
let is_unit = {
    returns_i64();
};
```

Rust Êúâ‰∏§ÁßçÂéüÂßãÂ§çÂêàÁ±ªÂûãÔºåTuples Âíå ArrayÔºö

```rust,ignore
fn main() {
    // let a = [3; 5];
    // let a = [3, 3, 3, 3, 3];
    // let a: [i32; 5] = [1, 2, 3, 4, 5 ];
    let months = [
        "January", "February", "March", // Spring
        "April", "May", "June",         // Summer
        "July", "August", "September",  // Fall & Winter
        "October", "November", "December"];

    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;

    println!("a is: {:?} {:?}", months, (five_hundred, six_point_four, one));
}
```

Êï∞ÁªÑ‰ΩøÁî® `[T; _]` Êàñ `[T]` ÂÆö‰πâÔºå‰∏ãÂàíÁ∫øÂèØ‰ª•ÊåáÂÆö‰∏Ä‰∏™ÈïøÂ∫¶ÔºåÂÖ∂‰∏≠Êï∞ÁªÑË°®Ëææ `[Value; len]` ÊòØÈÄöËøá
ÂÆèÂÆö‰πâÂÆûÁé∞‰∏Ä‰∏™ÂÆöÈïøÊï∞ÁªÑÔºåÂøÖÈ°ªÂú®Â£∞ÊòéÊó∂ÊåáÂÆöÁ±ªÂûãÂíåÂ§ßÂ∞è„ÄÇ

Êï∞ÁªÑÁöÑÂºïÁî®ÂèØ‰ª•Áõ¥Êé• for Êûö‰∏æÔºåËøôÁßçÊñπÂºèÈïøÂ∫¶ÈôêÂà∂‰∏∫ std::array::LengthAtMost32 ÔºåÂõ†‰∏∫ `&[T; N]`
Á±ªÂûãÈªòËÆ§ÂÆûÁé∞ÁöÑ IntoIterator Âè™Êèê‰æõ‰∫ÜËøô‰∏™ÈïøÂ∫¶ÁöÑÂÆûÁé∞Ôºå‰ΩøÁî® `iter()` ÊñπÊ≥ïËé∑ÂèñÊï∞ÁªÑÂØπË±°‰∏äÁöÑËø≠‰ª£Âô®
ËøõË°åÊûö‰∏æÂàô‰∏çÂèóÊï∞ÁªÑÈïøÂ∫¶ÈôêÂà∂„ÄÇ

```rust,ignore
let arr = [1; 33];
// println!("LengthAtMost32: {:?}", arr);
// for i in &arr {
//     print!("{}", i);
// }
for (index, value) in arr.iter().enumerate() {
    print!("{}-{}", index, value);
}
```

Êü•ÁúãËø≠‰ª£Âô®ÊñáÊ°£ÂÖ∂‰∏≠‰∏§Êù°ÂÆûÁé∞Ôºö

    impl<'a, T, const N: usize> IntoIterator for &'a [T; N]
    impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N]


Êï∞ÁªÑÂèØ‰ª•ÈÄöËøá‰∏ãÊ†áËÆøÈóÆÂÖÉÁ¥†ÔºåËøáÁïåËÆøÈóÆ‰∏çËÉΩÂú®ÁºñËØëÊúüÊ£ÄÊü•Âá∫Êù•Ôºå‰ΩÜËøêË°åÊó∂‰ºöÂá∫Èîô `index out of bounds`„ÄÇ

Rust ÁöÑÁ±ªÂûãÁ≥ªÁªüÊòØÂ§çÊùÇÁöÑÔºåÈô§‰∫ÜËøô‰∫õÂü∫Êú¨Á±ªÂûãÔºåËøòÊúâÂÖ∂ÂÆÉÈ´òÁ∫ßÁ±ªÂûãÔºåÂèÇËÄÉ Advanced Features„ÄÇÂç≥‰Ωø‰∏Ä‰∫õ
Ê†πÊú¨Êó†ËøîÂõûÂÄºÁöÑÊÉÖÂÜµÔºåÊØîÂ¶ÇÁ∫øÁ®ãÂ¥©Ê∫É„ÄÅbreak Êàñ continue Á≠âË°å‰∏∫Ôºå‰πüÁ∫≥ÂÖ•Á±ªÂûãÁ≥ªÁªüÔºåÂè´ÂÅö never Á±ªÂûã„ÄÇ 


Rust Ê≤°ÊúâËøêË°åÊó∂ÁöÑ GC Ë°å‰∏∫ÔºåÂÜÖÂ≠òÈ¶ñÂÖàÁî±ÁºñËØëÂô®Êù•ÂàÜÈÖçÔºåRust ‰ª£Á†ÅË¢´ÁºñËØë‰∏∫ LLVM IRÔºåÂÖ∂‰∏≠Êê∫Â∏¶Êù•ÂÜÖÂ≠ò
ÂàÜÈÖçÁöÑ‰ø°ÊÅØ„ÄÇÁºñËØëÂÖ∂ÈúÄË¶Å‰∫ãÂÖàÁõ¥Âà∞Á±ªÂûãÁöÑÂ§ßÂ∞èÔºåÊâçËÉΩÂàÜÈÖçÂêàÁêÜÁöÑÂÜÖÂ≠òÔºå

Rust ‰∏≠ÁªùÂ§ßÈÉ®ÂàÜÁ±ªÂûãÈÉΩÊòØÂú®ÁºñËØëÊúüÂèØÁ°ÆÂÆöÂ§ßÂ∞èÁöÑÁ±ªÂûãÔºåÂ¶ÇÂéüÁîüÁ±ªÂûãÊï¥Êï∞Á±ªÂûã u32 Âõ∫ÂÆöÊòØ 4 ‰∏™Â≠óËäÇÔºåÂèØ‰ª•Âú®
ÁºñËØëÊúüÁ°ÆÂÆöÂ§ßÂ∞èÁöÑÁ±ªÂûã„ÄÇ

Rust ‰∏≠‰πüÊúâ DST - Dynamic Sized type ÊØîÂ¶ÇÔºåÂ≠óÁ¨¶‰∏≤Â≠óÈù¢ÈáèÁ±ªÂûã strÔºåÊ≥®ÊÑè‰∏çÊòØ &str„ÄÇÁºñËØëÂô®‰∏çËÉΩ
‰∫ãÂÖàÁü•ÈÅìÁ®ãÂ∫è‰∏≠‰ºöÂá∫Áé∞‰ªÄ‰πàÊ†∑ÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÊâÄ‰ª•ÂØπ‰∫éÁºñËØëÂô®Êù•ËØ¥Ôºåstr Á±ªÂûãÁöÑÂ§ßÂ∞èÊòØÊó†Ê≥ïÁ°ÆÂÆöÁöÑÔºå‰πüÊó†Ê≥ïËøõË°åÊõ¥ÊîπÔºå
Â∞±ÂÉèÂ∏∏Èáè‰∏ÄÊ†∑„ÄÇisize Âíå usize ‰πüÊòØÊ†πÊçÆÁ®ãÂ∫èËøêË°åÂπ≥Âè∞Â∑ÆÂºÇÂ§ßÂ∞è‰∏çÂêåÔºå‰∏éÁºñËØëÊúüËøêË°åÁöÑÊú∫Âô®Êó†ÂÖ≥„ÄÇ



### üü¢üîµ Type Conversions Á±ªÂûãËΩ¨Êç¢
- https://doc.rust-lang.org/rust-by-example/conversion/try_from_try_into.html
- https://doc.rust-lang.org/rust-by-example/conversion/string.html
- The Rustonomicon - Type Conversions https://doc.rust-lang.org/nightly/nomicon/conversions.html

Primitives Casting

```rust,ignore
let decimal = 65.4321_f32;

// Error! No implicit conversion
// let integer: u8 = decimal;

// Explicit conversion
let integer = decimal as u8;
let character = integer as char;

// Error! There are limitations in conversion rules. A float cannot be directly converted to a char.
// let character = decimal as char;

// 1000 already fits in a u16
println!("1000 as a u16 is: {}", 1000 as u16);

// literal out of range for `u8`
// println!("1000 as a u8 is : {}", 1000 as u8);

// -1 + 256 = 255
println!("  -1 as a u8 is : {}", (-1i8) as u8);

// Unless it already fits, of course.
println!(" 128 as a i16 is: {}", 128 as i16);

// Since Rust 1.45, the `as` keyword performs a *saturating cast* when casting from float to int.  
// If the floating point value exceeds the upper bound or is less than the lower bound, the returned value will be equal to the bound crossed.

// 300.0 is 255
println!("300.0 is {}", 300.0_f32 as u8);
// -100.0 as u8 is 0
println!("-100.0 as u8 is {}", -100.0_f32 as u8);
// nan as u8 is 0
println!("nan as u8 is {}", f32::NAN as u8);

// This behavior incures a small runtime cost and can be avoided with unsafe methods, however the results might overflow and return **unsound values**. Use these methods wisely:
unsafe {
    // 300.0 is 44
    println!("300.0 is {}", 300.0_f32.to_int_unchecked::<u8>());
    // -100.0 as u8 is 156
    println!("-100.0 as u8 is {}", (-100.0_f32).to_int_unchecked::<u8>());
    // nan as u8 is 0
    println!("nan as u8 is {}", f32::NAN.to_int_unchecked::<u8>());
}
```

ÊâÄÊúâÂéüÂßãÊï∞ÊçÆÁ±ªÂûãÈÉΩÂÆûÁé∞‰∫Ü `to_string` ÊñπÊ≥ïÔºåËøôÊòØÈÄöËøá Blanket Implementations ÂÆûÁé∞ ToString Êèê‰æõÁöÑÊñπÊ≥ïÔºö

```rust,ignore
#[stable(feature = "rust1", since = "1.0.0")]
impl<T: fmt::Display + ?Sized> ToString for T {
    // A common guideline is to not inline generic functions. However,
    // removing `#[inline]` from this method causes non-negligible regressions.
    // See <https://github.com/rust-lang/rust/pull/74852>, the last attempt
    // to try to remove it.
    #[inline]
    default fn to_string(&self) -> String {
        use fmt::Write;
        let mut buf = String::new();
        buf.write_fmt(format_args!("{}", self))
            .expect("a Display implementation returned an error unexpectedly");
        buf
    }
}
```

‰ªéÂ≠óÁ¨¶ËΩ¨Êç¢Êï∞ÂÄºÔºå‰ΩøÁî® FromStr Trait Êèê‰æõÁöÑ `from_str(src: &str)` ÊñπÊ≥ïÔºåÊîØÊåÅÂ≠óÁ¨¶‰∏≤Ê†ºÂºèÔºö

- '3.14'
- '-3.14'
- '2.5E10', or equivalently, '2.5e10'
- '2.5E-10'
- '5.'
- '.5', or, equivalently, '0.5'
- 'inf', '-inf', 'NaN'

```rust,ignore
use std::str::FromStr;

let s = "5";
let x = i32::from_str(s).unwrap();

assert_eq!(5, x);
```

‰ªé str Ëß£ÊûêÊï∞ÂÄºÔºö

```rust,ignore
let four: u32 = "4".parse().unwrap();
assert_eq!(4, four);

// Using the 'turbofish' instead of annotating four:
let four = "4".parse::<u32>();
assert_eq!(Ok(4), four);

let nope = "j".parse::<u32>();
assert!(nope.is_err());
```

Conversion between `str` and  `String`

```rust,ignore
let s = String::from("foo");
assert_eq!("foo", s.as_str());

let my_str = "bar";
let my_string = String::from(my_str);
```

ÈÄöËøá Trait Êâ©Â±ïÔºåÂæàÂÆπÊòìÂÆûÁé∞Ëá™ÂÆö‰πâÁ±ªÂûãÁöÑËΩ¨Êç¢ÔºåÂè™ÈúÄË¶ÅÂÆûÁé∞ `std::convert::From`: 

```rust,ignore
use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From<i32> for Number {
    fn from(item: i32) -> Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!("My number is {:?}", num);
}
```

ÂÆûÁé∞ËΩ¨Êç¢Êé•Âè£  `std::convert`Ôºö

```rust,ignore
pub trait Into<T> {
    pub fn into(self) -> T;
}
pub trait From<T> {
    pub fn from(T) -> Self;
}
```

Á§∫ËåÉ Number Á±ªÂûãÁöÑËΩ¨Êç¢ÊñπÊ≥ïÂÆûÁé∞Ôºö

```rust,ignore
use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl Into<i32> for Number {
    fn into(self) -> i32 {
        self.value
    }
}
impl From<i32> for Number {
    fn from(value: i32) -> Self {
        Number { value }
    }
}
// impl Into<Number> for i32 {
//     fn into(self) -> Number {
//         Number{value:self}
//     }
// }

fn main() {
    let int = 5;
    // Try removing the type declaration
    let num: Number = int.into(); // exec Form<i32> for Number
    let val: i32 = num.into();    // exec Into<i32> for Number
    let num= Number::from(int);   // exec Form<i32> for Number
    
    // no conversion
    let num= Number::from(Number{value:int});
}
```

ÂÆÉ‰ª¨‰∫í‰∏∫ÈÄÜËΩ¨Êç¢ÔºåÂ∞ΩÈáèÈÅøÂÖçÂéªÂÆûÁé∞ Into ËÄåÊòØÂÆûÁé∞ FromÔºåÂõ†‰∏∫ÂÆûÁé∞ From Â∞±Ëá™Âä®‰∏ÄÊèΩÂ≠êÂÆûÁé∞ IntoÔºåËøôÂæóÁõä‰∫éÊ†áÂáÜÂ∫ìÁöÑ blanket implementation„ÄÇ

Âú®Ê≥õÂûãÂáΩÊï∞‰∏äÁªëÂÆöÊó∂ÔºåÊõ¥ÈÄÇÂêà‰ΩøÁî® Into ËÄå‰∏çÊòØ FromÔºåÂè™Ë¶ÅÁ°Æ‰øùÂÆûÁé∞ Into ÁöÑÁ±ªÂûãÂ∞±ÂèØ‰ª•‰ΩøÁî®„ÄÇ

Á§∫ËåÉ‰ª£Á†ÅË∞ÉÁî® i32.into() ÊñπÊ≥ïÊâßË°åËΩ¨Êç¢ÔºåËøôÈáå‰∏∫ Number Á±ªÂûãÂÆûÁé∞‰∫Ü `From<i32>` ËΩ¨Êç¢Êé•Âè£ÔºåÊâÄ‰ª•‰ºöÊâßË°å from() ÊñπÊ≥ïÂ∞Ü i32 ËΩ¨Êç¢‰∏∫ Number Á±ªÂûã„ÄÇ

Á±ª‰ººÁöÑÁ±ªÂûãËΩ¨Êç¢Êâ©Â±ïÊñπÊ≥ïÔºö

- std::convert::TryFrom try_from();
- std::convert::TryInto try_into();

TryInto Âíå TryForm ÁöÑÂ∑ÆÂà´Âú®‰∫éÂÆÉ‰ª¨ÂèØ‰ª•ÂÖÅËÆ∏ËΩ¨Êç¢Â§±Ë¥•ÔºåËÄå From Âíå Into ‰∏çÂÖÅËÆ∏„ÄÇ




### üü¢üîµ Control Flow ÊµÅÁ®ãÊéßÂà∂
- https://doc.rust-lang.org/book/ch03-05-control-flow.html
- https://doc.rust-lang.org/stable/reference/expressions/if-expr.html
- https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html
- https://doc.rust-lang.org/reference/expressions/if-expr.html
- Range Expressions https://doc.rust-lang.org/stable/reference/expressions/range-expr.html
- Rust by Example - Flow of Control https://doc.rust-lang.org/stable/rust-by-example/flow_control.html

Rust ÁöÑÊµÅÁ®ãÊéßÂà∂ÂåÖÊã¨Ôºö

- if Êù°‰ª∂ÊéßÂà∂ÔºåÂåÖÊã¨ if letÔºõ
- loop Âæ™ÁéØÔºõ
- while Âæ™ÁéØÔºåÂåÖÊã¨ while letÔºõ
- for Âæ™ÁéØÔºåÂåÖÊã¨ for rangeÔºõ
- match Ê®°ÂºèÂåπÈÖçÔºõ

ÁªèÂÖ∏ if-else ËØ≠Ê≥ïÔºåÊ≥®ÊÑèÊù°‰ª∂ÈÉ®ÂàÜ‰∏ç‰ΩøÁî®Êã¨Âè∑Ôºö

```rust,ignore
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

‰ΩøÁî® if let ËØ≠Ê≥ïÁöÑÊù°‰ª∂‰∏≠ÂèØ‰ª•‰ΩøÁî®ËµãÂÄºËØ≠Ê≥ïÔºö

```rust,ignore
let mut count = 0;
if let state = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
```

Èô§‰∫ÜÁªèÂÖ∏ if-else ËØ≠Ê≥ïÔºåËøòÂèØ‰ª•ÂÉè‰∏âÂÖÉËøêÁÆóÁ¨¶‰∏ÄÊ†∑‰ΩøÁî® if ËØ≠Âè•Ôºö

```rust,ignore
fn main() {
    let number = 0;
    let number = if number>0 { 5 } else { 6 };
    println!("The value of number is: {}", number);
}
```

ËøôÁßç if ËØ≠Ê≥ïÂÆûÁé∞Êù°‰ª∂Ê®°ÂºèÂåπÈÖçËµãÂÄºÔºåËØ≠Âè•ÂùóÂèØ‰ª•ËøîÂõûÂÄºÊòØ Lisp ËØ≠Ë®ÄÈ¶ñÂÖàÂºïÂÖ•ÁöÑÁâπÊÄßÔºö

```rust,ignore
let (status_line, filename) = if buffer.starts_with(get) {
    ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
} else {
    ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")
};
```

Ê≥®ÊÑèÔºåRust ‰∏çÂØπÊù°‰ª∂ÈÉ®ÂàÜËøõË°åÁ±ªÂûãËΩ¨Êç¢ÔºåÂõ†Ê≠§Ë°®Ëææ‰∏≠ÈúÄË¶Å‰∏Ä‰∏™ bool ÂÄº‰Ωú‰∏∫Âà§Êñ≠Êù°‰ª∂Ôºå‰ΩøÁî®ÂÖ∂ÂÆÉÂÄºÊòØ‰∏ÄÁßçÈîôËØØ„ÄÇ

Rust ÁöÑÊï∞ÁªÑÂØπË±°ÊòØÂèØËø≠‰ª£ÁöÑÔºåÂè™ÈúÄË¶ÅÈÄöËøá `itor()` ÊñπÊ≥ïËé∑ÂèñÁõ∏Â∫îÁöÑËø≠‰ª£Âô®Âç≥ÂèØÔºö

```rust,ignore
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("the value is: {}", element);
    }
}
```

Rust ÊîØÊåÅ Range ËØ≠Ê≥ïÔºåÂØπÂ∫îÊ®°Âùó std::ops::RangeÔºö

    let s = String::from("hello world");
    let hello = &s[0..5];   // std::ops::Range<{integer}>
    let world = &s[6..=10]; // std::ops::RangeInclusive<{integer}>
    let slice = &s[..2];    // std::ops::RangeTo<{integer}>
    let slice = &s[3..];    // std::ops::RangeFrom<{integer}>

ÂèØ‰ª•‰ΩøÁî®‰ª•‰∏ãÊñπÂºèÁîüÊàêÊï∞ÁªÑÔºå`rev()` ÂáΩÊï∞ÂèçËΩ¨Ëø≠‰ª£È°∫Â∫èÔºö

```rust,ignore
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```

Range ÁöÑÊ†ºÂºèÊòØ `a..[b]`Ôºå‰∏äÈù¢‰æãÂ≠êÂä†Êã¨Âè∑ÊòØÂõ†‰∏∫Ë¶Å‰ΩøÁî®Ëø≠‰ª£Âô®ÁöÑÂèçËΩ¨ÊñπÊ≥ïÔºåb ÊòØÂèØ‰ª•ÁúÅÁï•ÁöÑ„ÄÇ

```rust,ignore
fn main() {
    for element in 1.. {
        println!("the value is: {}",  element);
    }
}

‰ΩøÁî® loop Âæ™ÁéØÔºåÂèØ‰ª•ÈÄöËøá `break` ËØ≠Âè•ËøîÂõû‰∏Ä‰∏™ÂÄºÔºåÂπ∂‰Ωú‰∏∫ËØ≠Âè•Ë°®ËææÂºèËµãÂÄºÁªôÂèòÈáèÔºö

```rust,ignore
fn main() {
    loop {
        println!("loop once!");
        break;
    }
            
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
```

‰ΩøÁî® while Êù°‰ª∂Âæ™ÁéØÔºö

```rust,ignore
fn main() {
    let mut number = 3;
    while number != 0 {
        println!("{}!", number);
        number -= 1;
    }
    println!("LIFTOFF!!!");
}
```



## ‚ö° Features ÁâπËâ≤Ê¶ÇÂøµ
- crate tree https://zhuanlan.zhihu.com/p/105181947
- Introducing MIR https://blog.rust-lang.org/2016/04/19/MIR.html
- „ÄåÂèØËßÜÂåñ„ÄçRustËØ≠Ë®ÄÁºñËØëÂô®ÂçÅÂπ¥ÂèòËøÅ https://www.bilibili.com/video/av43956267/

Rust internal compiler pipelineÔºö

- Rust Sources
    - Parsing & Desugaring
- HIR - High-level intermediate representation
    - Type checking
- MIR - Middle-level intermediate representation
    - Borrow checking
    - Optimization
- LLVM IR - Low-level Machine intermediate representation
    - Optimization
- Machine Code

Rust ÊòØ‰∏ÄÈó®ÁºñËØëÂûãËØ≠Ë®ÄÔºåÂú® Rust ÁöÑ‰∏ñÁïåÈáåÔºåÁã¨Á´ãÂÆåÊàêÁºñËØëÁöÑÊúÄÂ∞èÂçïÂÖÉÂè´ÂÅö crateÔºåÂÆÉÊòØ cargo ÁÆ°ÁêÜÁöÑÊúÄÂ∞èÁªìÊûÑÔºå‰πüÊòØ rustc ÁÆ°ÁêÜÁöÑÊúÄÂ§ßÁöÑÁªìÊûÑ„ÄÇ

ÊØî crate Â§ßÁöÑÁªìÊûÑ‰æùÊ¨°ÊòØ package Âíå workspaceÔºåËøô‰∫õÊòØ cargo Â§ÑÁêÜÁöÑ„ÄÇ

Rustc ÂëΩ‰ª§ÊØèÊ¨°ÊâßË°å‰ªé‰∏Ä‰∏™ crate ÁöÑÊúÄÂ§ñÂ±ÇÁöÑÊ∫êÊñá‰ª∂ÁîüÊàêÁõÆÊ†áÊñá‰ª∂Ôºåcrate Áî±Ëá≥Â∞ë‰∏Ä‰∏™Ê∫êÊñá‰ª∂ÁªÑÊàêÔºåÈÄöÂ∏∏Ê∫êÊñá‰ª∂Êâ©Â±ïÂêç‰∏∫ rs„ÄÇ

crate ÊåâÊ†ëÁä∂ÁªìÊûÑÁÆ°ÁêÜÔºåÊ†ë‰∏äÁöÑËäÇÁÇπÁß∞‰∏∫ itemÔºåÁ±ªÂûãÊúâÂ§öÁßç„ÄÇÁºñËØëÂô®ËØªÊáÇ‰Ω†Êèê‰æõÁöÑËøôÊ£µÊ†ëÔºåÁÑ∂ÂêéÊääÂÆÉÁîüÊàê crate Á±ªÂûãÊâÄÊåáÂÆöÁöÑÊ†ºÂºèÁöÑÁõÆÊ†áÊñá‰ª∂„ÄÇÊúÄÂ∏∏Áî®ÁöÑÊòØ rlib Âíå bin ‰∏§ÁßçÔºåÂàÜÂà´ÊòØÂèØÈáçÁî®ÁöÑ Rust ÈùôÊÄÅÂ∫ìÊñá‰ª∂ÂíåÂèØÊâßË°åÁ®ãÂ∫è„ÄÇ

Á¨¨‰∏ÄÁ±ªÊù°ÁõÆÂ∞±ÊòØÊ®°ÂùóÊù°ÁõÆÔºåÂÆÉÊòØÂÆÉÊòØÁî®Êù•ÁªÑÁªáÂÖ∂‰ªñÊù°ÁõÆÁöÑÔºåÁ±ª‰ººÊñá‰ª∂Â§πÂ±ÇÁ∫ß„ÄÇ‰∏ÄÁßçÂÜôÊ≥ïÊòØÂÜÖÂÆπÁõ¥Êé•ÂÜôÂú®Ëä±Êã¨Âè∑ÂÜÖ„ÄÇÂè¶‰∏ÄÁßçÂÜôÊ≥ïÊòØÁî±ÂÆÉÊ†πÊçÆ‰∏ÄÂ•óËßÑÂàôÊåáÂêëÁ£ÅÁõò‰∏äÁöÑÂè¶‰∏Ä‰∏™Êñá‰ª∂Ôºå‰Ωú‰∏∫ÂÆÉÁöÑÂÜÖÂÆπ„ÄÇ

Á¨¨‰∫åÁ±ªÊù°ÁõÆÁî®Êù•ÂÆö‰πâ‰∏Ä‰∫õÁî®Êà∑ÂÆö‰πâÁ±ªÂûãÔºö‰∏ªË¶ÅÊúâÁªìÊûÑ‰ΩìÂÆö‰πâ„ÄÅÊûö‰∏æ‰ΩìÂÆö‰πâ„ÄÅËÅîÂêà‰ΩìÂÆö‰πâËøôÂá†Áßç„ÄÇÁªìÊûÑ‰Ωì„ÄÅÊûö‰∏æ‰Ωì„ÄÅËÅîÂêà‰ΩìÊòØRustÈáåÁöÑ‰∏âÁßçÁî®Êà∑ÂÆö‰πâÁ±ªÂûã„ÄÇË¶ÅÊ≥®ÊÑèÔºåÁî±‰∫éRustÈáåÂØπÊ≥õÂûãÁöÑÂπøÊ≥õ‰ΩøÁî®Ôºà‰∏âÂè•‰∏çÁ¶ªÊ≥õÂûãÔºâÔºåÁªìÊûÑ‰ΩìÂÆö‰πâ„ÄÅÊûö‰∏æ‰ΩìÂÆö‰πâ„ÄÅËÅîÂêà‰ΩìÂÆö‰πâËøô‰∫õÂÆö‰πâÂá∫Êù•ÁöÑÁ±ªÂûãÂú®ÈùûÊ≥õÂûãÁöÑÊÉÖÂÜµ‰∏ãÊòØ‰∏Ä‰∏™ÂÖ∑‰ΩìÁ±ªÂûãÔºåÊØîÂ¶ÇStringÔºåÂú®Ê≥õÂûãÁöÑÊÉÖÂÜµ‰∏ãÂàôÊòØ‰∏ÄÊóèÂÖ∑‰ΩìÁ±ªÂûãÔºåÁ±ª‰ººVec<T>ËøôÊ†∑ÔºåÂÖ∂‰∏≠TÊòØÊ≥õÂûãÂèÇÊï∞Ôºå‰ª£ÂÖ•‰∏çÂêåÁöÑÊ≥õÂûãÂèÇÊï∞ÁöÑ‚ÄúÂèñÂÄº‚ÄùÂ∞±‰ºöÂæóÂà∞‰∏çÂêåÁöÑÂÖ∑‰ΩìÁ±ªÂûã„ÄÇ‰∏çÁÆ°ÊòØÂì™ÁßçÔºåÊï¥‰∏™ÂÆö‰πâÈÉΩÊòØ‰∏Ä‰∏™Êù°ÁõÆÔºåÊòØ‰∏Ä‰∏™Êï¥‰Ωì„ÄÇ

Á¨¨‰∏âÁ±ªÊù°ÁõÆ‰πüÊúâÂÆö‰πâÁ±ªÂûãÁöÑÊïàÊûúÔºå‰ΩÜÊòØÂÆö‰πâÂá∫Êù•ÁöÑÂ∞±‰∏çÁÆóÊòØÁî®Êà∑ÂÆö‰πâÁ±ªÂûã‰∫Ü„ÄÇÈ¶ñÂÖàÊòØÁ±ªÂûãÂà´ÂêçÂÆö‰πâÊù°ÁõÆÔºåÂÆÉÂÆö‰πâ‰∏Ä‰∏™Á±ªÂûãÂà´ÂêçÔºà‰πüÊîØÊåÅÊ≥õÂûãÔºâÊåáÂêëÂÖ∂‰ªñÂÖ∑‰ΩìÁ±ªÂûã„ÄÇÂè¶Â§ñÂ∞±ÊòØÂáΩÊï∞ÂÆö‰πâÊù°ÁõÆÔºà‰æùÁÑ∂ÊîØÊåÅÊ≥õÂûãÔºâÔºåÂÆÉ‰ºöËá™Âä®‰∫ßÁîü‰∏Ä‰∏™Áã¨ÁâπÁöÑÂáΩÊï∞Êù°ÁõÆÂÜÖÁΩÆÁ±ªÂûãÔºåÂú®Ë°®ËææÂºè‰∏≠ÂÜôËøô‰∏™ÂáΩÊï∞ÁöÑÂêçÁß∞Â∞±ÂèØ‰ª•ÊãøÂà∞Ëøô‰∏™Á±ªÂûãÁöÑÂÄº„ÄÇ

Á¨¨ÂõõÁ±ªÊù°ÁõÆ‰ºöÂ£∞Êòé‰ΩúÁî®Âüü‰∏∫ÂÖ®Â±ÄÁöÑÂÄºÔºå‰∏éÂáΩÊï∞ÂÆö‰πâÊù°ÁõÆÊúâ‰∫õÁ±ª‰ºº‰πãÂ§Ñ„ÄÇÈ¶ñÂÖàÊòØÂ∏∏Êï∞ÂÆö‰πâÊù°ÁõÆÔºåÊåáÂÆöÂêçÁß∞„ÄÅÁ±ªÂûãÂíå‰∏Ä‰∏™Â∏∏Êï∞Ë°®ËææÂºèÂêéÔºå‰Ω†Â∞±ÂèØ‰ª•Âú®Ë°®ËææÂºè‰∏≠Áî®Ëøô‰∏™ÂêçÁß∞ÂºïÁî®Ëøô‰∏™ÂÄº‰∫Ü„ÄÇÁÑ∂ÂêéÊòØÈùôÊÄÅÂÆö‰πâÊù°ÁõÆÔºåÂÆÉ‰∏éÂ∏∏Êï∞ÂÆö‰πâÊù°ÁõÆÁöÑÂå∫Âà´ÊòØÂÆÉÁöÑÂÄºÂÖ∑Êúâ‰∏Ä‰∏™ÂÖ®Â±ÄÁöÑÂ≠òÂÇ®‰ΩçÁΩÆÔºå‰ªéËÄåËÉΩÂ§üË°®ËææÁä∂ÊÄÅÂèòÂåñÔºåÂèØ‰ª•Á±ªÊØîÂÖ∂‰ªñËØ≠Ë®Ä‰∏≠ÁöÑÂÖ®Â±ÄÂèòÈáè„ÄÇ

Á¨¨‰∫îÁ±ªÊù°ÁõÆ‰∏éÁâπË¥®(trait)Á≥ªÁªüÁõ∏ÂÖ≥„ÄÇÁâπË¥®Êù°ÁõÆÁî®Êù•ÂÆö‰πâ‰∏Ä‰∏™ÁâπË¥®ÔºåÁâπË¥®‰∏çÊòØÁ±ªÂûãÔºåÊòØ‰∏ÄÁßçÂèØ‰ª•‰∏éÁ±ªÂûãÂª∫Á´ãËÅîÁ≥ªÁöÑÊäΩË±°Êé•Âè£ÔºåÊäΩË±°Êé•Âè£Âê´ÊúâÂÖ≥ËÅîÊù°ÁõÆÔºåÁõÆÂâçÂÖ±‰∏âÁßçÔºåÂÖ≥ËÅîÂ∏∏Êï∞Êù°ÁõÆÂ∞±Á±ª‰ººÂ∏∏Êï∞ÂÆö‰πâÊù°ÁõÆÔºåÂÖ≥ËÅîÁ±ªÂûãÂà´ÂêçÊù°ÁõÆÂ∞±Á±ª‰ººÁ±ªÂûãÂà´ÂêçÂÆö‰πâÊù°ÁõÆÔºåÂÖ≥ËÅîÊñπÊ≥ïÊù°ÁõÆÊúâÁÇπÂÉèÂáΩÊï∞ÂÆö‰πâÊù°ÁõÆÔºå‰ΩÜÁ®çÂæÆÊúâÁÇπÂå∫Âà´„ÄÇ

Á¨¨ÂÖ≠Á±ªÊù°ÁõÆÁß∞‰∏∫ÂÆûÁé∞Êù°ÁõÆ„ÄÇÂÆûÁé∞ÂàÜ‰∏∫Âõ∫ÊúâÂÆûÁé∞ÂíåÁâπË¥®ÂÆûÁé∞‰∏§Áßç„ÄÇÂÆûÁé∞Êù°ÁõÆÂÜôËµ∑Êù•ÁöÑÊ†ºÂºèÂæàÁâπÂà´ÔºåÊúâÁÇπÂÉèÊüê‰∫õÊü•ËØ¢ËØ≠Ë®ÄÔºåÂü∫Êú¨‰∏äÊòØ‚ÄúÂØπ‰∫éÊª°Ë∂≥ÊüêÊüêÊù°‰ª∂ÁöÑÊüêÊüêÁ±ªÂûã(ÂíåÊüêÊüêÁâπË¥®)ÔºåÊèê‰æõÂ¶Ç‰∏ãÁöÑÂÖ≥ËÅîÊù°ÁõÆÂÆö‰πâ‚ÄùÁöÑÁªìÊûÑ„ÄÇËøô‰∏™ÊØîËæÉÂ§çÊùÇÔºåÂêéÈù¢Êàë‰ª¨‰ºöËØ¶ÁªÜËÆ≤„ÄÇ

Á¨¨‰∏ÉÁ±ªÊù°ÁõÆÁî®Êù•ÂÆûÁé∞ÂØºÂÖ•ÂäüËÉΩ„ÄÇÂØºÂÖ•Êúâ‰∏âÁßçÔºå‰∏ÄÁßçÊòØÂØºÂÖ•ÂÖ∂‰ªñÁöÑÁõí(crate)Âà∞ÂÖ®Â±ÄÁ©∫Èó¥‰∏≠ÔºåÁß∞‰∏∫Â§ñÈÉ®Áõí(extern crate)Êù°ÁõÆ„ÄÇ‰∏ÄÁßçÊòØÂª∫Á´ã‰∏Ä‰∏™‚ÄúÈìæÊé•‚ÄùÔºåÁß∞‰∏∫ÂºïÁî®Â£∞ÊòéÊù°ÁõÆÔºåÁ±ª‰ººÁ£ÅÁõò‰∏äÁöÑÁ¨¶Âè∑ÈìæÊé•ÊàñËÄÖÂø´Êç∑Êñá‰ª∂ÔºåÂΩ¢Êàê‚ÄúÂÆÉËôΩÁÑ∂ÂÖ∂ÂÆûÂÆö‰πâ‰∏çÊòØÂú®ËøôÁöÑÔºå‰ΩÜÊòØ‰ªø‰ΩõÂ∞±Âú®ËøôÈáå‚ÄùÁöÑÊïàÊûú„ÄÇËøô‰∏™ÊïàÊûúÂú®rustÈáåÂæàÈáçË¶ÅÔºåÂêéÈù¢Ëøò‰ºöÂèçÂ§çËØ¥Âà∞„ÄÇÂè¶‰∏ÄÁßçÊòØÂ§ñÈÉ®ÂÆö‰πâÂùóÊù°ÁõÆÔºåÂÆÉÁî®Êù•ÂåÖÂê´ÂÖ∂‰ªñËØ≠Ë®ÄÔºàÁõÆÂâçÊòØCËØ≠Ë®ÄÔºâÂú®Â§ñÈÉ®Êèê‰æõÁöÑÂÆö‰πâÔºåÁõÆÂâçÊúâ‰∏§ÁßçÔºåÂ§ñÈÉ®ÈùôÊÄÅÊù°ÁõÆÂ∞±Á±ª‰ººÈùôÊÄÅÊù°ÁõÆÔºåÂ§ñÈÉ®ÂáΩÊï∞Êù°ÁõÆÂ∞±Á±ª‰ººÂáΩÊï∞ÂÆö‰πâÊù°ÁõÆ„ÄÇ


### üü¢üîµ Zero-cost Abstraction Èõ∂ÊàêÊú¨ÊäΩË±°
- Diesel - Safe, Extensible ORM https://diesel.rs
- Zero-cost abstractions in Rust https://carette.xyz/posts/zero_cost_abstraction/
- Rust‰∏≠ÁöÑÈõ∂ÊàêÊú¨ÊäΩË±°Ôºà‰∏ÄÔºâ https://zhuanlan.zhihu.com/p/109517672
- Rust‰∏≠ÁöÑÈõ∂ÊàêÊú¨ÊäΩË±°Ôºà‰∫åÔºâ https://zhuanlan.zhihu.com/p/109189186

ÂΩì‰Ω†ÁºñÁ®ãÁöÑÊó∂ÂÄôÔºåÈ°πÁõÆË∂äÊù•Ë∂äÂ§çÊùÇÔºåÈÄöÂ∏∏‰Ω†‰ºöÂ¢ûÂä†ÊäΩË±°Êù•ËÆ©È°πÁõÆÂÆπÊòìÁª¥Êä§Âπ∂Â¢ûÂä†ÂäüËÉΩ„ÄÇ

‰Ωú‰∏∫ÂºÄÂèëËÄÖÔºå‰Ω†ËÇØÂÆöÂ∏åÊúõ‰Ω†ÁöÑÊäΩË±°‰∏çË¶ÅÂú®ËøêË°åÊó∂Â¢ûÂä†ÊàêÊú¨ÔºåÊâÄ‰ª•ÔºåÊúâ‰∏§‰∏™ÂéüÂàôÊòØÔºö

- È°πÁõÆÁöÑÂèØËØªÊÄßÂíåÊòìÁÆ°ÁêÜÊÄßÊØîÂ§çÊùÇÁöÑÊâãÂÜô‰ºòÂåñÊõ¥ÈáçË¶ÅÔºõ
- ‰ΩÜËá≥Â∞ëËÉΩÂú®ËøêË°åÊó∂ÂèëÊå•ÈùûÂ∏∏ËâØÂ•ΩÁöÑÊÄßËÉΩÔºõ

Á°ÆÂÆûÔºåÊîπËøõ‰ª£Á†ÅÂèØËØªÊÄß‰ºöÈôêÂà∂‰ºòÂåñÂíåÂÜÖÂ≠òÂºÄÈîÄÔºåÂπ∂Èó¥Êé•ËøüÊªûËøêË°åÊó∂ÁöÑÊÄßËÉΩ„ÄÇ

Èõ∂ÊàêÊú¨ÊäΩË±°Êù•Ëá™ C++ÔºåÁî±ÂÖ∂ÂàõÂßã‰∫∫ Bjarne Stroustrup ÂÆö‰πâÔºåÂç≥ C++ ÁöÑÂÆûÁé∞ÈÅµÂæ™Èõ∂ÂºÄÈîÄÂéüÂàôÔºö‰Ω†‰∏ç‰ΩøÁî®ÁöÑÔºå‰Ω†‰∏çË¥üÊãÖÊàêÊú¨„ÄÇÊõ¥Ëøõ‰∏ÄÊ≠•Ôºö‰Ω†‰ΩøÁî®ÁöÑÔºå‰Ω†‰πüÊ≤°Ê≥ïÊõ¥‰ºòÂåñ„ÄÇ

ÊÄªÁªì‰ªñËØ¥ÁöÑÔºö

- ‰Ω†‰∏ç‰ΩøÁî®ÁöÑÂäüËÉΩÔºå‰Ω†‰∏çÊâøÊãÖÈ¢ùÂ§ñÂºÄÈîÄÔºõ
- È´òÂ±ÇÁöÑÊäΩË±°‰ºöË¢´ÁºñËØëÊàêÊú∫Âô®‰ª£Á†ÅÔºåËøô‰∫õ‰ª£Á†ÅÂæàÈöæÊõ¥Ëøõ‰∏ÄÊ≠•‰ºòÂåñÔºõ

Rust ÊúÄ‰∏ªË¶ÅÁöÑÊäΩË±°ÔºàÊàñËÄÖËØ¥Ê†áÂáÜÂ∫ìÔºâ‰∏ç‰ºöÂ¢ûÂä†ËøêË°åÊó∂ÊàêÊú¨ÔºåËøôÊòØ Rust Èõ∂ÊàêÊú¨ÊäΩË±°Ê†∏ÂøÉÂéüÂàôÔºåÂ∞§ÂÖ∂ÂØπ‰∏ãÈù¢ÁöÑËøô‰∫õÁâπÊÄßÔºö

- ÁºñËØëÊó∂ÂÜÖÂ≠òÊ£ÄÊü•ÔºåÂü∫‰∫é borrowing and ownership ÂÆûÁé∞ÈùôÊÄÅÂûÉÂúæÂõûÊî∂Êú∫Âà∂„ÄÇRust ‰∏çÂú®ËøêË°åÊó∂ÈÄöËøáÂºïÁî®ËÆ°Êï∞Ê£ÄÊü•ÁöÑÊñπÂºèÂõûÊî∂ÂÜÖÂ≠òÔºåËÄåÊòØÂú®ÁºñËØëÊó∂ËøΩË∏™Ê£ÄÊü•ÁîüÂëΩÂë®ÊúüÔºåËøô‰ΩøÂæóÁ®ãÂ∫èËøêË°åÈùûÂ∏∏È´òÊïà„ÄÇ
- Ownership and borrowing
- traits ÊòØÈùûÂ∏∏ËÆ©‰∫∫Âç∞Ë±°Ê∑±ÂàªÁöÑÂäüËÉΩÔºåÁî®Êù•ÊãìÂ±ï‰Ω†ÁöÑÁ±ªÂûã„ÄÇ
- generics Ê≥õÂûã
- Iterator and closure APIs
- Async/await and Futures
- Unsafe and the module boundary
- ËøòÊúâÂÖ∂ÂÆÉ

Èõ∂ÊàêÊú¨ÊäΩË±°ÂæàÂ•ΩÂú∞Ëß£Èáä‰∫Ü Diesel Ëøô‰∏™ÈóªÂêçÁöÑ Rust ORM Ê°ÜÊû∂ÊÄßËÉΩË¶ÅÊØî raw postgress Âø´ 30%„ÄÇ

Áî®‰∏§‰∏™‰æãÂ≠êÊù•Ëß£Èáä Rust ‰∏≠ÁöÑÈõ∂ÊàêÊú¨ÊäΩË±°ÔºåÊ±ÇÊâÄÊúâÂ∞è‰∫é n ÁöÑÂ•áÊï∞Ëá™ÁÑ∂Êï∞Âíå„ÄÇ

‰∏§‰∏™ÁâàÊú¨ÁöÑ‰ª£Á†ÅÔºåÁ¨¨‰∏Ä‰∏™ÊòØÈÄöÂ∏∏ÁöÑÊäΩË±°ÁâàÊú¨ÔºåÁ¨¨‰∫å‰∏™ÊòØÊâãÂÜô‰ºòÂåñÁâàÊú¨Ôºö

```rust,ignore
fn sum_odd_numbers(n: u64) -> u64 {
    let mut acc = 0;
    for element in 0.. {
        if element >= n {
            break;
        }
        if element.is_odd() {
            acc += element;
        }
    }
    acc
}

fn sum_odd_numbers(n: u64) -> u64 {
    (0..)
        .take_while(|element| element < &n)
        .filter(|n| n.is_odd())
        .fold(0, |sum, element| sum + element)
}
```

‰∏ãÈù¢‰∏ÄÊÆµËß£Èáä‰∫ÜÁ¨¨‰∫å‰∏™ÂáΩÊï∞ÂºèÁºñÁ®ãÔºåÂÆÉ‰ºº‰πéÊõ¥ÂÆπÊòìËØªÊáÇÔºåÂàÜËß£ÂÆÉÂèØËÉΩ‰ΩúÂá∫ÈîôËØØÁöÑÂÅáÂÆöÔºö

- ÂàõÂª∫Áî± 0 ÂºÄÂßãÁöÑËø≠‰ª£Âô®Ôºõ
- ÂèñÂá∫ÊâÄÊúâÂ∞è‰∫é n ÁöÑÂÖÉÁ¥†ÔºåÂ¶ÇÊûúÊòæÂºèÁªôÂá∫ n ÂÄºÔºåÁºñËØëÂô®ÂèØ‰ª•Âú®ÁºñËØëÊúüÁªôÂá∫ÊúÄÁªàÁöÑÊï∞Â≠óÔºåÂπ∂‰øùÂ≠òÂú®ÂèØÊâßË°åÊñá‰ª∂‰∏≠Ôºõ
- Âæ™ÁéØÊâÄÊúâÂÖÉÁ¥†ÔºåÂèñÂá∫Â•áÊï∞ÔºåÂ≠òÊîæÂà∞Âè¶‰∏Ä‰∏™Êï∞ÁªÑ‰∏≠Ôºõ
- Âæ™ÁéØÊâÄÊúâÂÖÉÁ¥†ÔºåËÆ°ÁÆóÂ•áÊï∞ÁöÑÊÄªÂíåÔºåËøîÂõûÊúÄÁªàÂÄºÔºõ
- ÁªìÊûúÊòØÔºå‰∏∫‰∫ÜÊ±ÇÂíåËÆ°ÁÆóÔºåÂàÜÈÖç‰∫ÜÂ•ΩÂá†‰∏™Êï∞ÁªÑ„ÄÇ

Â•ΩÂú® Rust ‰∏ç‰ºöËøôÊ†∑ÂÅöÔºåÁºñËØëÂô®‰ºöÂÉèÁ¨¨‰∏Ä‰∏™ÁâàÊú¨ÈÇ£Ê†∑ÂÅö„ÄÇ

‰∏ãË°®ÊòØÂú® Intel Core i5 (3 GHz, 6 cores * 2 threads / core) ÁöÑË∑ëÂàÜÁªìÊûúÔºåÊòæÁ§∫‰∫Ü 10 Ê¨°‰∏çÂêå n ÂÄºÊâßË°åÊó∂Èó¥ÁöÑ‰∏≠ÂÄºÔºö

Benchmarks

    | Version |     n      | Hand-optimized execution time | Abstracted version execution time |
    |---------|------------|-------------------------------|-----------------------------------|
    | Debug   | 100        | 0,02s                         | 0,01s                             |
    | Debug   | 100000     | 0,02s                         | 0,03s                             |
    | Debug   | 100000000  | 2,97s                         | 6,59s (x2.22)                     |
    | Debug   | 1000000000 | 29,61s                        | 65,16s (x2.20)                    |
    | ‚Äî‚Äî‚Äî     | ‚Äî‚Äî‚Äî‚Äî       | ‚Äî‚Äî‚Äì                           | ‚Äî‚Äî‚Äì                               |
    | Release | 100        | 0,00s                         | 0,00s                             |
    | Release | 100000     | 0,00s                         | 0,00s                             |
    | Release | 100000000  | 0,03s                         | 0,03s                             |
    | Release | 1000000000 | 0,26s                         | 0,26s                             |

Compile time consequences

    | Version | Hand-written optimized |   Abstracted  |
    |---------|------------------------|---------------|
    | Debug   | 0,01s                  | 0,01s         |
    | ‚Äî‚Äî‚Äî     | ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî               | ‚Äî‚Äî‚Äî‚Äî          |
    | Release | 5,80s                  | 8,19s (x1.41) |

ÈÄöËøáÊï∞ÊçÆÂèØ‰ª•ÂæóÂá∫ÁªìËÆ∫ÔºåÁªìËøá release ‰ºòÂåñÈÖçÁΩÆÁºñËØëÁöÑÊúÄÁªàÁ®ãÂ∫èËøêË°åÊòØÊó†Â∑ÆÂà´ÁöÑÔºåÂè™ÊòØÂú®ÁºñËØëÁ®ãÂ∫èÊó∂ÔºåÊäΩË±°ÁâàÊú¨Ëä±ÈîÄÊõ¥Â§öÁöÑ‰ºòÂåñÊó∂Èó¥ÔºåÂç≥‰ΩøÊòØÂ¶ÇÊ≠§ÁÆÄÂçïÁöÑÁ®ãÂ∫è„ÄÇ

ÁÑ∂ËÄåÔºåÂΩì‰Ω†ÈúÄË¶ÅÊäΩË±°ÁöÑÊó∂ÂÄôÔºå‰∏çË¶ÅÁäπË±´„ÄÇÂú® Rust ‰∏≠‰Ω†Ê∞∏Ëøú‰∏çÈúÄË¶ÅÂÖàËøõË°åÊâãÂÜô‰ºòÂåñÔºåËÄåÂ∫îËØ•ËÄÉËôëÊäΩË±°ÊÄß„ÄÅÊû∂ÊûÑÂíåËÆæËÆ°„ÄÅ‰ª£Á†ÅÂèØËØªÊÄßÔºåÂç≥‰Ωø‰Ω†ÂçÅÂàÜÂú®ÊÑèËøêË°åÊó∂ÊÄßËÉΩ„ÄÇ



### üü¢üîµ Ownership ÊâÄÊúâÊùÉ
- ÂºïÁî®ÁöÑÁîüÂëΩÂë®Êúü https://www.bilibili.com/video/BV1hp4y1k7SV?p=49
- Understanding Ownership https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html
- Guide to Rustc Development 44. The borrow checker https://rustc-dev-guide.rust-lang.org/borrow_check.html
- The Rustonomicon - The Dark Arts of Unsafe Rust https://doc.rust-lang.org/nomicon/meet-safe-and-unsafe.html
- https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html
- https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html
- https://doc.rust-lang.org/stable/std/boxed/struct.Box.html
- Smart Pointers https://doc.rust-lang.org/book/ch15-00-smart-pointers.html
- https://doc.rust-lang.org/nomicon/ownership.html

ÊâÄÊúâÊùÉÊòØ Rust ÊúÄÁã¨ÁâπÁöÑÁâπÊÄßÔºåÂÆÉÂÆûÁé∞‰∫Ü‰∏çÈúÄË¶ÅÂûÉÂúæÊî∂ÈõÜÂô®ÁöÑÊÉÖÂÜµ‰∏ã‰øùËØÅÂÜÖÂ≠òÂÆâÂÖ®„ÄÇÂõ†Ê≠§Ôºå‰∫ÜËß£ÊâÄÊúâÊùÉÂú® Rust ‰∏≠ÁöÑ‰ΩúÁî®ÊòØÂæàÈáçË¶ÅÁöÑ„ÄÇ

ËØ≠Ê≥ï‰∏äÔºåRust ÂèÇËÄÉ‰∫Ü C++Ôºå‰ΩÜ‰∏ç‰∏çÂÉè Go or C++ÔºåÂπ∂Ê≤°Êúâ garbage collectionÔºåÁõ∏Âèç Rust ÁöÑÂÜÖÂ≠òÂÆâÂÖ®ÁÆ°ÁêÜÈÄöËøáÊâÄÊúâÊùÉ‰∏é borrow checker ÁöÑÊ†∏ÂøÉÊ¶ÇÂøµÔºåÂÆûÁé∞‰∫ÜÂú®ÈùôÊÄÅÁºñËØëÊúüÂØπÂºïÁî®ÁöÑÁîüÂëΩÂë®ÊúüÁöÑËøΩË∏™ÔºåËÄå‰∏çÈúÄË¶ÅÂú®ËøêË°åÊó∂ËøõË°åÈ¢ùÂ§ñÁöÑÂûÉÂúæÂõûÊî∂ÔºåËøôÁõ∏ÂΩì‰∫éÁõ¥Êé•ÊèêÂçá‰∫ÜËøêË°åÊïàÁéá„ÄÇ

Rust `Ownership` Ê¶ÇÂøµÊòØËæÉÊñ∞Â•áÁöÑËßÇÂøµÔºåÊòØ Rust Èõ∂ÊàêÊú¨ÊäΩË±°‰∏≠ÂæàÈáçË¶ÅÁöÑ‰∏Ä‰∏™ÁªÑÊàêÔºåÂÆÉÊåáÂá∫ÊØè‰∏Ä‰∏™ÂÄºÊüê‰∏ÄÊó∂ÂàªÂè™ËÉΩË¢´‰∏Ä‰∏™ÂèòÈáèÊã•ÊúâÔºåÂç≥ ownerÔºåË∂ÖÂá∫‰ΩúÁî®ÂüüÂêéÔºåÂÄº‰ºöË¢´ÈîÄÊØÅÔºåÂç≥ÊØè‰∏™ÂºïÁî®ÈÉΩÊúâÁõ∏Â∫îÁöÑÁîüÂëΩÂë®Êúü„ÄÇ


Âú® C/C++ ËØ≠Ë®Ä‰∏≠ÔºåStack Âíå Heap ÊòØÂæàÂ∏∏Áî®ÁöÑÊ¶ÇÂøµÔºåÂÆÉ‰ª¨ÈÉΩÊòØÁ®ãÂ∫èËøêË°åÊó∂ÂèØ‰ª•‰ΩøÁî®ÁöÑÂÜÖÂ≠òÁ©∫Èó¥„ÄÇ

ÈÄöÂ∏∏ËØ¥ÁöÑË∞ÉÁî®Â†ÜÊ†àÊåáÁöÑÂ∞±ÊòØ StackÔºåÂÆÉÊòØÂú®Á°¨‰ª∂Â±ÇÂÆûÁé∞ÁöÑ‰∏Ä‰∏™ LIFO - Last in, first out Êï∞ÊçÆÁªìÊûÑÔºåÈÄöËøá CPU ÁöÑ `pop` `push` Êåá‰ª§Êìç‰Ωú„ÄÇËøô‰∫õÊåá‰ª§ÊéßÂà∂ÁùÄ CPU ÂÜÖÈÉ®ÁöÑ‰∏Ä‰∏™Â†ÜÊ†àÊåáÈíàÂØÑÂ≠òÂô® SP - Stack PointerÔºåÂú®Á®ãÂ∫èËøêË°åÊó∂ÔºåÂßãÁªàÊåáÂêë Stack È°∂ÈÉ®Ôºå‰ºöÈöèÁùÄÂáΩÊï∞Ë∞ÉÁî®„ÄÅËøîÂõûËΩ¨Áßª„ÄÇ

ÂØπÊØî Stack Âíå Heap ÂÜÖÂ≠òÔºö 

- Stack ÂÜÖÂ≠òËÆøÈóÆÊõ¥Âø´ÔºåÊúâÂØÑÂ≠òÂô®Áõ¥Êé•ÂèØËææÔºåÈÄöÂ∏∏Âú®Á®ãÂ∫èÁºñËØëÂêéÂ∞±Áü•ÈÅìË¶Å‰ΩøÁî®Â§öÂ§ßÁöÑ Stack ÂÜÖÂ≠òÔºõ
- ËÄåÂ†ÜÂÜÖÂ≠òÔºåÊõ¥Â§öÊòØÁî±ÂºÄÂèëËÄÖ‰∏ªÂä®Áî≥ËØ∑Ë∞ÉÈÖçÔºåÈÄöËøá `malloc()` `free()` Á≠âÂáΩÊï∞Âä®ÊÄÅÂÜÖÂ≠òÂàÜÈÖçÁöÑÊåáÈíàÁÆ°ÁêÜÔºåÂÖ∏ÂûãÁöÑÂ∞±ÊòØ‰ΩøÁî® `new` ÂÖ≥ÈîÆÂ≠óÊù•‰∏∫ÂÆû‰æãÁî≥ËØ∑ÂÜÖÂ≠ò„ÄÇ

Âú® Rust ‰∏≠ÔºåË∑üË∏™‰ª£Á†ÅÁöÑÂì™‰∫õÈÉ®ÂàÜÊ≠£Âú®‰ΩøÁî®Â†ÜÂÜÖÂ≠òÔºåÊúÄÂ∞èÂåñÂ†Ü‰∏äÈáçÂ§çÊï∞ÊçÆÁöÑÊï∞ÈáèÔºåÊ∏ÖÁêÜÂ†Ü‰∏äÊú™‰ΩøÁî®ÁöÑÊï∞ÊçÆ‰ª•ÈÅøÂÖçÁ©∫Èó¥ËÄóÂ∞ΩÔºåËøô‰∫õÈÉΩÊòØÊâÄÊúâÊùÉÊâÄË¶ÅËß£ÂÜ≥ÁöÑÈóÆÈ¢ò„ÄÇ

‰∏ÄÊó¶ÊÇ®‰∫ÜËß£‰∫ÜÊâÄÊúâÊùÉÔºåÂ∞±‰∏çÈúÄË¶ÅÁªèÂ∏∏ËÄÉËôëÂ†ÜÊ†àÂíåÂ†ÜÔºå‰ΩÜÊòØÁü•ÈÅìÁÆ°ÁêÜÂ†ÜÊï∞ÊçÆÊòØÊâÄÊúâÊùÉÂ≠òÂú®ÁöÑÂéüÂõ†ÊúâÂä©‰∫éËß£ÈáäÂÆÉ‰∏∫‰ªÄ‰πà‰ª•ËøôÁßçÊñπÂºèÂ∑•‰Ωú„ÄÇ

ÂΩìÁÑ∂ÔºåRust Êèê‰æõ‰∫Ü unsafe ÁâπÊÄßÔºåËøòÊúâ std::boxed::Box alloc::boxed::Box Âç≥ Smart Pointers Ëøô‰∫õÊ®°ÂùóÊèê‰æõÁöÑÂØπË±°ÔºåÁÆÄÂåñÂØπ Heap ÂÜÖÂ≠òÁöÑ‰ΩøÁî®„ÄÇ

    let five = 5;           // 5 in Stack memory
    let five = Box::new(5); // 5 in Heap memory

ËøôÈáåÂ∞±Êù•Ëß£ÊûêÊâÄÊúâÊùÉÁöÑÂá†ÁßçÂ§ÑÁêÜÊñπÂºèÔºö

- `shared reference` &T ÂÖ±‰∫´Âá∫ÂÄüÔºåÂ¶Ç `let a = &b;`ÔºåÂ∞Ü b Âá∫ÂÄüÂà∞ aÔºõ
- `mutable reference` &mut T ÂèØÂèòÂá∫ÂÄüÔºåÂ¶Ç `let a = &mut b;`ÔºåÂ∞Ü b ÂèØÂèòÂºïÁî®Âá∫ÂÄüÂà∞ aÔºåÂç≥ÈÄöËøá a Â∞±ÂèØ‰ª•‰øÆÊîπ b ÁöÑÊï∞ÊçÆÔºõ
- `ownership move` ËΩ¨ÁßªÊâÄÊúâÊùÉÔºåÂ¶Ç `let a = b;`ÔºåÊâÄÊúâÊùÉÁî± b ËΩ¨ÁßªÁªô aÔºõ

Ëä±Êã¨Âè∑Âú® Rust ‰∏≠ÈÄöÂ∏∏ÊòØÂèòÈáè‰ΩúÁî®ÂüüÈöîÁ¶ªÁöÑÊ†áÂøóÔºåÈô§‰∫ÜËä±Êã¨Âè∑‰ª•Â§ñÔºåËøòÊúâÂÖ∂‰ªñÁöÑ‰∏Ä‰∫õÊÉÖÂÜµ‰ºö‰Ωø Ownership ÂèëÁîüÂèòÂåñ„ÄÇ

ÂÖàÊù•‰∏Ä‰∏™ÁÆÄÂçïÁöÑÁ§∫ËåÉÔºåÂæàÊòéÊòæ `a` `b` ÈÉΩÂú®‰ΩøÁî® Stack ÂÜÖÂ≠òÔºö

```rust,ignore
fn main() {
    let a; 
    {
        let b = 1;
        a = &b;
    }
    println!("a: {}", a);
}
```

ÁºñËØëÂá∫ÈîôÊèêÁ§∫ÂèòÈáè `b` ‰∏çÂ§üÈïøÂØøÔºö

    error[E0597]: `b` does not live long enough
     --> src\main.rs:5:13
      |
    5 |         a = &b;
      |             ^^ borrowed value does not live long enough
    6 |     }
      |     - `b` dropped here while still borrowed
    7 |     println!("a: {}", a);
      |                       - borrow later used here

Âõ†‰∏∫ `a` ÂÄüÂÄº `b` Áî®‰∫éËä±Êã¨Âè∑‰ΩúÁî®ÂüüÂ§ñÁöÑÊâìÂç∞ËæìÂá∫ËØ≠Âè•Ôºå‰ΩÜ `b` Ë∂ÖÂá∫‰ΩúÁî®ÂüüÂêéÂ∞±ÁªìÊùüÁîüÂëΩ‰∫ÜÔºåËøôÊó∂ borrow checker Ëµ∑‰ΩúÁî®Ê£ÄÊü•Âà∞ÈîôËØØÁöÑÂ≠òÂú®„ÄÇ

Ê≥®ÊÑèÔºåÂ§ñÂÄüËøô‰∏™Ê¶ÇÂøµÔºåÂ∞±ÊòØ `a` ÂºïÁî® `b` ÁöÑÂÄº„ÄÇ

ËôΩÁÑ∂ÔºåËØ≠Âè•Âùó‰∏≠Áªô `a` ËµãÂÄºÁöÑÊòØ‰∏Ä‰∏™ÂºïÁî®Ôºå‰ΩÜÊòØÔºåÂºïÁî®ÁöÑÂØπË±°Âú®Ë∂ÖÂá∫ËØ≠Âè•ÂùóÂêéÂ∞±Â§±Êïà‰∫ÜÔºåÂºïÁî®Â§Ñ‰∫éÊÇ¨Á©∫Áä∂ÊÄÅ Dangling References„ÄÇ


Êï∞ÂÄºÂèòÈáèÁöÑËµãÂÄºÊòØÂÄºÊã∑Ë¥ùÔºåÂ¶ÇÊûúÊòØÂ≠óÁ¨¶‰∏≤ÂèòÈáèËµãÂÄºÔºåÊÉÖÂÜµÂ∞±ÁªùÁÑ∂‰∏çÂêå„ÄÇËøôÊòØÂÖàËØ¥ÂéüÂõ†ÔºöÂØπ‰∫éËæÉÂ§ßÁöÑÂØπË±°Êù•ËØ¥ÔºåÁõ¥Êé•Â§çÂà∂ÊòØÈùûÂ∏∏Êµ™Ë¥πÁ©∫Èó¥ÂíåÊó∂Èó¥ÁöÑÔºåÂõ†Ê≠§Ë¶ÅÁõ¥Êé•ÂºïÁî®ËÄå‰∏çÊòØÂ§çÂà∂„ÄÇ

ÂØπ‰∫éÁÆÄÂçïÊï∞ÊçÆÁ±ªÂûãÔºåÂ¶ÇÊï∞ÂÄºÁöÑÊï∞ÊçÆÈÉΩÊòØÂ≠òÂÇ®Âú®Ê†àÂÜÖÂ≠ò‰∏≠ÔºåËá™Âä®ÁÆ°ÁêÜ„ÄÇËÄåÂÉè String Êàñ‰∏Ä‰∫õËá™ÂÆö‰πâÁöÑÂ§çÊùÇÊï∞ÊçÆÁªìÊûÑÔºåÂÖ∂Êï∞ÊçÆÂàôÂ≠òÂÇ®Âú®Â†ÜÂÜÖÂ≠ò‰∏≠„ÄÇ ËôΩÁÑ∂ÔºåÂ†ÜÊ†àÁöÑËØ¥Ê≥ïÊòØËøûËµ∑Êù•Âè´Ôºå‰ΩÜÊòØ‰ªñ‰ª¨Âå∫Âà´ÂæàÂ§ß„ÄÇÂú® C++ ÁöÑÁºñÁ®ãÊ¶ÇÂøµ‰∏≠ÔºåHeap Âíå Stack ÂÜÖÂ≠òÂàÜÈÖçÊú∫Âà∂‰∏çÂêåÔºåStack ÂÜÖÂ≠òÁî±ÁºñËØëÂô®Ëá™Âä®ÂàÜÈÖçÁÆ°ÁêÜÔºåËÄå Heap ÂÜÖÂ≠òÂàôË¶ÅÊâãÂä®Áî≥ËØ∑ÔºåÂÖ∏ÂûãÁöÑÂ∞±ÊòØÈÄöËøá `new` ÂÖ≥ÈîÆÂ≠óÊù•ÂàÜÈÖç„ÄÇ

Â≠óÁ¨¶‰∏≤ÁöÑÂÄºÊòØÂàÜÈÖçÂú®Â†ÜÁ©∫Èó¥ÁöÑÔºåÂ≠óÁ¨¶‰∏≤ÂèòÈáèÊòØÊ≠§Á©∫Èó¥ÁöÑ‰∏Ä‰∏™ÂºïÁî®ÔºåÂåÖÊã¨‰∏Ä‰∏™ÊåáÂêëÂ†ÜÁ©∫Èó¥ÁöÑÊåáÈíà„ÄÇÂΩì‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ËµãÂÄºÁªôÂè¶‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÔºåÂ†ÜÁ©∫Èó¥ÁöÑÂÄºÂπ∂Ê≤°ÊúâË¢´Â§çÂà∂ÔºåÂè™ÊòØËΩ¨Áßª‰∫ÜÊâÄÊúâÊùÉÔºåÂèòÈáèÁöÑ owner Âèò‰∏∫Êé•Êî∂ËµãÂÄºÁöÑÂèòÈáèÔºåÂéüÂèòÈáèÂ∞ÜÂ§±ÂéªÂØπÊ≠§ÂÜÖÂ≠òÁ©∫Èó¥ÁöÑÊâÄÊúâÊùÉÔºÅÁ¶ªÂºÄ‰ΩúÁî®ÂüüÊó∂ÔºåÂéüÂèòÈáè‰πü‰ºöË¢´Ëá™Âä®Ê∏ÖÁêÜ„ÄÇ

ËøôÂ∞±ÊòØ Ownership Âú®ÂèòÂåñÔºåOwnership ‰ªé‰∏Ä‰∏™ÂèòÈáèÁßªÂä®Âà∞Âè¶‰∏Ä‰∏™ÂèòÈáè„ÄÇ

Â¶Ç‰∏ãÈù¢‰∏§ÊÆµ‰ª£Á†ÅÔºö

    let x = 5;
    let y = x;
    println!("x: {}", x);

    let s1 = String::from("hello");
    let s2 = s1;
    println!("s1: {}", s1);

Á¨¨‰∏ÄÊÆµ‰ª£Á†ÅÊòØÊ≠£Á°ÆÁöÑÔºåÂØπ‰∫éÁ¨¨‰∫åÊÆµ‰ª£Á†ÅÔºåÊåâ C++/C ËØ≠Ë®ÄÁöÑÈÄªËæëÂ∫îËØ•‰πüÊòØÊ≠£Á°ÆÔºå‰ΩÜÂÆûÈôÖ‰∏ä Rust Âπ∂‰∏çÊòØËøôÊ†∑ÂÅöÁöÑ„ÄÇ

    error[E0382]: borrow of moved value: `s1`
     --> src\main.rs:8:31
      |
    6 |     let s1 = String::from("hello");
      |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
    7 |     let s2 = s1;
      |              -- value moved here
    8 |     println!("s1: {} s2: {}", s1, s2);
      |                               ^^ value borrowed here after move

ÈîôËØØÊèêÁ§∫Ôºå`s1` Âõ†‰∏∫Ê≤°ÊúâÂÆûÁé∞ Copy trait ‰ºöÂºïËµ∑ÊâÄÊúâÊùÉÁßªÂä®ÔºåÂç≥ÊâÄÊúâÊùÉÁßªÂä®ÂèëÁîüÂú®Áªô `s2` ËµãÂÄºÁöÑËØ≠Âè•‰∏äÔºåËΩ¨Áßª‰∫ÜÊâÄÊúâÊùÉÂêé `s1` Â∞±Â§±Ê¥ª‰∏çËÉΩÂÜç‰ΩøÁî®‰∫Ü„ÄÇ

`String::from()` ÊñπÊ≥ïÂêéÈù¢ÂÆûÁé∞‰∫Ü Heap ÂÜÖÂ≠òÁöÑÁî≥ËØ∑ÂíåÈáäÊîæÔºåÂú®Â≠óÁ¨¶‰∏≤Èó¥ËøõË°åËµãÂÄºÊó∂ÔºåÂ∞±‰ºöÂ∞ÜÊåáÈíàÂú∞ÂùÄËΩ¨‰∫§Âá∫ÂéªÔºåËÄå‰∏çÊòØÂ§çÂà∂ÂêåÊ†∑ÁöÑÂ≠óÁ¨¶ÂÜÖÂÆπ„ÄÇ

ÁÆÄÂåñ‰∏äÈù¢ String ÂØπË±°ÁöÑÂ±ûÊÄßÂ¶Ç‰∏ãÔºö

    |   Prop  |  value  |                 heap memory
    |---------|---------|                 ---------------------
    | pointer | address | ========> index | 0 | 1 | 2 | 3 | 4 |
    | length  | 5       |           value | h | e | l | l | o |
    | capcity | 5       |

Âú®ÊâßË°å `s12 = s1` ËµãÂÄºÊó∂ÔºåÂ∞±ÊòØÂú®Êã∑Ë¥ù String ÂØπË±°ÁöÑÂ±ûÊÄßÔºåÂç≥ pointer ÊåáÈíàÂíåÂ≠óÁ¨¶‰∏≤ÈïøÂ∫¶Á≠âÁ≠âÂ±ûÊÄßÔºå‰ΩÜÊòØÂÜÖÂÆπËøòÊòØÊåáÂêëÂêå‰∏ÄÂùóÂÜÖÂ≠òÂú∞ÂùÄÔºåÂπ∂Ê≤°ÊúâÂØπÂ≠óÁ¨¶‰∏≤ÂÜÖÂ≠òËøõË°åÂ§çÂà∂ÔºåËøôÂ∞±ÊòØ shallow copyÔºåÁõ∏ÂØπ‰∫é deep copy„ÄÇ

Rust Ê∞∏Ëøú‰∏ç‰ºöËøõË°åÈªòËÆ§ÁöÑÊ∑±Êã∑Ë¥ùÔºåÈô§ÈùûÊèê‰æõ‰∏Ä‰∏™ Copy traitÔºåÂ¶ÇÊûú‰∏Ä‰∏™Á±ªÂûãÊúâÂÆûÁé∞ Copy traitÔºåÂàôÂèØ‰ª•Áõ¥Êé•ÈÄöËøáËµãÂÄºÊù•‰º†ÈÄíÂÄº„ÄÇÁ±ª‰ººÊï∞ÂÄºÂèòÈáèÁöÑ‰º†ÈÄíÊñπÂºèÔºåÊú¨Ë¥®Â∞±ÊòØÂú® Stack ‰∏≠Â§çÂà∂ÂèòÈáèÊâÄÁªëÂÆöÁöÑÂÄº„ÄÇ

ÂØπ‰∫éÂ≠óÁ¨¶‰∏≤ÂØπË±°ÔºåÂèØ‰ª•‰ΩøÁî®ÂÖ∂ `clone()` ÊñπÊ≥ïÊù•Áé∞ÂÆûÂ§çÂà∂Ôºö

    let s1 = String::from("hello");
    let s2 = s1.clone();

ÂâçÈù¢ËØ¥‰∫ÜÂèòÈáèË∂ÖÂá∫‰ΩúÁî®ÂüüÂ∞±Â§±ÊïàÔºåÂêåÊó∂ Rust ‰ºöÊâßË°å‰∏Ä‰∏™ `drop()` ÂáΩÊï∞Êù•ÂÅöÊ∏ÖÁêÜÂ∑•‰ΩúÔºåÂ¶ÇÊûúÊ≤°ÊúâÊâÄÊúâÊùÉÊäΩË±°Êú∫Âà∂ÔºåÂú®Â≠óÁ¨¶‰∏≤ËµãÂÄºÂêéÔºå`s1` Âíå `s2` ÊåáÂêëÂêå‰∏ÄÂùóÂÜÖÂ≠òÔºåÂú®ÂÆÉ‰ª¨Â§±ÊïàÊó∂Â∞Ü‰ºöÊúâ‰∏§‰∏™ `drop()` ÂáΩÊï∞Ë¢´Ë∞ÉÁî®ÔºåËøôÂ∞±‰ºöÂØπÂêå‰∏ÄÂÜÖÂ≠òÂú∞ÂùÄÊâßË°å‰∏§Ê¨° `free()` Êìç‰ΩúÔºåÁ†¥ÂùèÂÜÖÂ≠òÁªìÊûÑ„ÄÇ

ÈÄöËøáÊâÄÊúâÊùÉÊú∫Âà∂ÔºåÊó∂ÂàªÂè™Êúâ‰∏Ä‰∏™ÂèòÈáèÂºïÁî®Âêå‰∏ÄÂÜÖÂ≠òÂú∞ÂùÄÔºåÊ∞∏Ëøú‰∏ç‰ºöÂá∫Áé∞ÈáçÂ§çÈáäÊîæÂêå‰∏ÄÂÜÖÂ≠òÁöÑÈîôËØØ„ÄÇ

Â¶ÇÊûú‰∏Ä‰∏™Á±ªÂûãÁöÑ‰ªª‰ΩïÈÉ®ÂàÜÂÆûÁé∞‰∫Ü Drop traitÔºåÂàôÊó†Ê≥ï‰ΩøÁî® Copy trait„ÄÇËÉΩ‰ΩøÁî® Copy trait ÁöÑÁ±ªÂûãÊúâÔºö

- All the integer types, such as `u32`.
- The Boolean type, `bool`, with values true and false.
- All the floating point types, such as `f64`.
- The character type, `char`.
- ËøòÊúâÂåÖÂê´‰ª•‰∏äÁ±ªÂûãÁöÑÂÖÉÁªÑ TuplesÔºå‰æãÂ¶Ç (i32, i32) implements Copy, but (i32, String) does not.


### üü¢üîµ Borrowing ÂÄüÁî®ÊâÄÊúâÊùÉ
- https://doc.rust-lang.org/beta/rust-by-example/scope/borrow.html
- https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html
- Guide to Rustc Development 44. The borrow checker https://rustc-dev-guide.rust-lang.org/borrow_check.html
- A Practical Intro to Macros in Rust 1.0 https://danielkeep.github.io/practical-intro-to-macros.html

ÊéåÊè°Âü∫Êú¨Ê¶ÇÂøµÂêéÔºåÂÜçÊù•ÁúãÁúãÂáΩÊï∞‰∏éÊâÄÊúâÊùÉÁöÑËÅîÁ≥ª„ÄÇ

ÂÆòÊñπÁîµÂ≠ê‰π¶Âú® Understanding Ownership Á´†ËäÇÁªôÂá∫ÁöÑËøôÊÆµÁ§∫ËåÉÂæàÊ∏ÖÊô∞ÁöÑËß£Êûê‰∫Ü Ownership and Functions ÁöÑÂÖ≥Á≥ªÔºö 

```rust,ignore
fn main() {
    let s = String::from("hello");  // s comes into scope
    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope
    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it‚Äôs okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

ÂØπ‰∫éÂØπË±°Á±ªÂûãÔºåËøõÂÖ•ÂáΩÊï∞ÁöÑËøáÁ®ãÊúâÁÇπÁ±ª‰ººÂØπË±°ÁöÑËµãÂÄºËøáÁ®ãÔºåÊâÄÊúâÊùÉËΩ¨Áßª‰∫Ü„ÄÇÊâÄÊúâÊùÉÁßª‰∫§Áªô‰∫ÜÂáΩÊï∞ÂÜÖÈÉ®ÁöÑÂØπÂ∫îÂèòÈáèÔºåÂΩìÂáΩÊï∞ËøîÂõûÔºåÂÖ∂ÂÜÖÈÉ®ÂèòÈáèË∂ÖÂá∫‰ΩúÁî®ÂüüÂ∞±Â§±ÊïàÔºåÂπ∂‰∏î `drop()` ÊâßË°å‰∫ÜÂÜÖÂ≠òÊ∏ÖÁêÜ„ÄÇ

ÂØπ‰∫éÂéüÂßãÂÄºÁ±ªÁ±ªÂûãÔºåËøõÂÖ•ÂáΩÊï∞ÁöÑËøáÁ®ã‰πüÂ∞±ÊòØÂú® Stack Â§çÂà∂Êï∞ÊçÆÁöÑËøáÁ®ãÔºåËøîÂõûÊó∂Âè™ÊòØË∞ÉÁî®Â†ÜÊ†àÁöÑÊÅ¢Â§çÔºå‰∏çÁî®Ê∂âÂèä Heap ÂÜÖÂ≠òÁöÑÊ∏ÖÁêÜ„ÄÇ

‰∏∫‰∫ÜÈÅøÂÖçÊâÄÊúâÊùÉÁöÑËΩ¨ÁßªÔºåÂèØ‰ª•ÂºïÁî®‰º†ÈÄíÂèÇÊï∞ÔºåÂç≥Âú®ÂèÇÊï∞ÂàóË°®‰∏≠Âä†ÂºïÁî®Êìç‰ΩúÁ¨¶Âè∑ `&String`ÔºåÁÑ∂ÂêéË∞ÉÁî®Êó∂‰πüÊõ¥Êîπ‰∏∫‰ºö‰º†ÂÖ•ÂºïÁî® `&s`ÔºåÂºïÁî®ÂØπË±°ÂÖÅËÆ∏‰ΩøÁî®ÂØπË±°ÁöÑÂÄºÔºå‰ΩÜ‰∏çËé∑ÂèñÊâÄÊúâÊùÉ„ÄÇ

ËøôÁßçËé∑ÂèñÂºïÁî®‰Ωú‰∏∫ÂáΩÊï∞ÂèÇÊï∞Âè´ÂÅöÂÄüÁî®ÔºåReferences and BorrowingÔºåËøô‰∏™Áß∞Ë∞ìÂæàÊÅ∞ÂΩìÔºå‰æãÂ¶Ç‰∏Ä‰∏™‰∫∫ÂÄüÁî®‰∫ÜÊüêÊ†∑‰∏úË•øÔºå‰ªéÂì™ÈáåÂÄüÊù•ËøòÈúÄË¶ÅËøòÂõûÂéª„ÄÇ

ÂÄüÊù•ÁöÑ‰∏úË•øÂèØ‰ª•‰ΩøÁî®Ôºå‰ΩÜÊòØ‰∏çËÉΩÊçüÂùèÊàñ‰øÆÊîπ„ÄÇÂ¶ÇÊûúÊÉ≥Â∞ùËØï‰øÆÊîπÂÄüÁî®ÂèòÈáèÔºå‰ºöÊó†Ê≥ïÁºñËØë„ÄÇÂ¶ÇÊûúÈúÄË¶Å‰øÆÊîπ‰∏Ä‰∏™ÂºïÁî®ÁöÑÂÄºÔºåÈúÄË¶Å‰º†ÈÄí‰∏Ä‰∏™ÂèØÂèòÂºïÁî®Ôºö`&mut s`

ÊåâÂÄüÁî®ÊâÄÊúâÊùÉÊñπÂºèÊù•ÈáçÂÜôÂâçÈù¢ÁöÑ‰ª£Á†ÅÔºåÊ≥®ÊÑè‰øÆÊîπÂèØÂèòÂºïÁî®Êó∂Ôºå‰πüÂÉè C++ ‰∏ÄÊ†∑‰ΩøÁî®ÊòüÂè∑ËøõË°åËß£ÂºïÁî®Ôºö

```rust,ignore
fn main() {
    let mut s = String::from("hello");
    takes_ownership(&mut s);
    println!("{}", s);
}

fn takes_ownership(some_string: &mut String) {
    println!("{}", some_string);
    *some_string = String::from("news");
}
```

Âú®‰ΩøÁî®ÂºïÁî®Êó∂ÔºåÊ≥®ÊÑè‰∏§Êù°Á∫¶ÊùüÔºö

- ‰∏çËÉΩÂêåÊó∂‰ΩøÁî® mutable & immutable ÂºïÁî®ÔºåÈÅøÂÖçÊï∞ÊçÆËØªÂÜôÂπ∂ÂèëÊâßË°åÔºõ
- ‰∏çËÉΩÂ≠òÂú®Â§ö‰∏™ mutable ÂºïÁî®ÔºåÈÅøÂÖçÊï∞ÊçÆÁ´û‰∫âÔºõ

Ëøô‰∏§Êù°Á∫¶ÊùüÂèØ‰ª•Áªô Rust Á®ãÂ∫èÁºñËØë‰ºòÂåñÂ∏¶Êù•ÊûÅÂ§ßÁöÑÂ•ΩÂ§ÑÔºåÂÆÉ‰ª¨ÈÅøÂÖç‰∫ÜÁºñËØëÊúüÂ∞±Âá∫Áé∞ `data races`ÔºåËøôÁßçÁ±ª‰ººÂ§öÁ∫øÁ®ãÁöÑ `race condition` Áä∂ÂÜµÔºåÂèëÁîüÂú®‰ª•‰∏ãÊÉÖÂΩ¢Ôºö

- ÂêåÊó∂ÊúâÂ§ö‰∏™ÊåáÈíàËÆøÈóÆÁõ∏ÂêåÊï∞ÊçÆ„ÄÇ
- Ëá≥Â∞ëÊúâ‰∏Ä‰∏™ÊåáÈíàÂú®ËøõË°åÂÜôÂÖ•Êìç‰Ωú„ÄÇ
- Ê≤°ÊúâÂêåÊ≠•Êú∫Âà∂Êù•Á∫¶ÊùüÊï∞ÊçÆËÆøÈóÆ„ÄÇ

```rust,ignore
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
let r3 = &mut s; // BIG PROBLEM
// error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable

println!("{}, {}, and {}", r1, r2, r3);
```

```rust,ignore
let mut s = String::from("hello");

let r1 = &mut s; // first mutable borrow occurs here
let r2 = &mut s; // second mutable borrow occurs here
// error[E0499]: cannot borrow `s` as mutable more than once at a time

println!("{}, {}", r1, r2);
```

ÊúâË∂£ÁöÑÊòØÔºåRust ÁºñËØëÂô®ÂèØ‰ª•ÂæàÊô∫ËÉΩÂú∞Âà§Êñ≠Âá∫Ôºå‰Ω†ÁöÑ‰ª£Á†ÅÊúâÊ≤°ÊúâÂú®ÂêåÊó∂‰ΩøÁî® mutable & immutable ÂºïÁî®„ÄÇ

‰ª•‰∏ã‰ª£Á†ÅÊòØÊ≠£Á°ÆÁöÑÔºåÂõ†‰∏∫‰∏§ÁßçÊñπÂºèÊ≤°ÊúâÂêåÊó∂‰ΩøÁî®Ôºö

```rust,ignore
let mut s = String::from("hello");

let r1 = &s; // no problem
let r2 = &s; // no problem
println!("{} and {}", r1, r2);
// r1 and r2 are no longer used after this point

let r3 = &mut s; // no problem
println!("{}", r3);
```

ÊÇ¨Á©∫ÂºïÁî® Dangling References ÂâçÈù¢Â∑≤ÁªèËß£ÊûêËøáÔºåÂΩìÂºïÁî®Ë∂ÖÂá∫‰ΩúÁî®ÂüüÂêéÔºåÂØπÂ∫îÁöÑÂÄºÂ∞±Â§±Êïà‰∏çËÉΩË¢´‰ΩøÁî®‰∫ÜÔºö

```rust,ignore
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");
    &s
}
```

Âú®ÂáΩÊï∞‰∏≠ËøîÂõû‰∏Ä‰∏™Â±ÄÈÉ®ÂèòÈáèÁöÑÂºïÁî®ÊòØ‰∏çÂèØË°åÁöÑÔºåÈÇ£‰πàË¶ÅËøîÂõûÂ±ÄÈÉ®ÂèòÈáèÔºåË¶Å‰πàËøõË°å CopyÔºåË¶Å‰πàÁßªÂä®ÊâÄÊúâÊùÉ„ÄÇËÄåÂØπ‰∫é StringÔºåÂÆÉÊòØÊ≤°ÊúâÂÆûÁé∞ Copy ÁâπÊÄßÁöÑÔºåÂ∞±ÈúÄË¶ÅËá™Â∑±Â§ÑÁêÜ„ÄÇ

Ëß£ÂÜ≥ÊñπÊ≥ïÂ∞±ÊòØ‰∏ç‰ΩøÁî®ÂºïÁî®ËøîÂõûÔºö

```rust,ignore
fn main() {
    let reference_to_nothing = no_dangle();
}

fn no_dangle() -> String {
    let s = String::from("hello");
    s
}
```

ÂíåËøîÂõûÂºïÁî®ÊñπÂºèÁöÑÂ∑ÆÂà´Âú®‰∫éÔºåÊ≤°Êúâ‰ΩøÁî®ÂºïÁî®ÁöÑËøîÂõûÊñπÂºèÂú®ÂáΩÊï∞ÁªìÊùüÊó∂ÔºåÂ§±ÊïàÁöÑÂè™ÊòØ `s` ÂèòÈáèÔºåËÄåÊâÄÊúâÊùÉÂ∑≤ÁªèËΩ¨ÁßªÔºåÂÖ∂ÊâÄÊåáÂêëÁöÑÂ≠óÁ¨¶‰∏≤ÂÜÖÂÆπ‰æùÁÑ∂ÊúâÊïà„ÄÇ

ËÄÉËôë‰∏Ä‰∏ãÂºïÁî®‰∏éÊâÄÊúâÊùÉÁöÑÂÖ≥Á≥ªÔºåËøô‰πüËÆ∏‰ºöÊòØÈöæ‰ª•ÁêÜËß£ÁöÑ„ÄÇ

Âú® Rust Á≥ªÁªüÁöÑÊâÄÊúâÊùÉÊäΩË±°Ê¶ÇÂøµ‰∏≠ÔºåÊâÄÊúâÊùÉÊòØÈíàÂØπÂÜÖÂ≠ò‰∏≠‰øùÂ≠òÁöÑÊï∞ÊçÆÔºå‰πüÂ∞±ÊòØ values ÊèêÂá∫Êù•ÁöÑ„ÄÇÂèòÈáè‰πüÊòØ‰∏Ä‰∏™ÊäΩË±°Ê¶ÇÂøµÔºåÂÆÉÈúÄË¶ÅÁªëÂÆö‰∏Ä‰∏™ÂÄºÔºåÂç≥Âç†ÊúâÂÄºÁöÑ OwnershipÔºåËøôÊ†∑ÁöÑÂèòÈáèÂ∞±ÊòØ‰∏Ä‰∏™ Owner„ÄÇ

ËÄåÂºïÁî®Ëøô‰∏ÄÊ¶ÇÂøµÔºåÂèØ‰ª•Â∞ÜÂÖ∂ÁêÜËß£‰∏∫ÂØπÂÜÖÂ≠òÊï∞ÊçÆÁöÑÁõ¥Êé•Êìç‰ΩúÔºåÂâ•Á¶ª‰∫ÜÂèòÈáè„ÄÅÊâÄÊúâÊùÉËøô‰∫õÊ¶ÇÂøµÔºå‰πüÂ∞±‰∏çÊ∂âÂèäÊâÄÊúâÊùÉÂ±ÇÈù¢‰∏äÁöÑÊìç‰Ωú„ÄÇ


### üü¢üîµ Slices ÂàáÁâáÁ±ªÂûã‰∏éÊâÄÊúâÊùÉ
- https://doc.rust-lang.org/book/ch04-03-slices.html
- Range Expressions https://doc.rust-lang.org/stable/reference/expressions/range-expr.html
- Storing UTF-8 Encoded Text with Strings https://doc.rust-lang.org/book/ch08-02-strings.html
- https://doc.rust-lang.org/stable/std/primitive.slice.html
- https://doc.rust-lang.org/stable/std/slice/index.html

È¶ñÂÖàÔºåÂàáÁâáÊòØÊ≤°ÊúâÊâÄÊúâÊùÉÊ¶ÇÂøµÁöÑÔºåËøô‰∏ÄÁÇπ‰ΩøÂæóÂÆÉ‰∏éÂÖ∂ÂÆÉÊï∞ÊçÆÁ±ªÂûãÂå∫Âà´ÂºÄÊù•„ÄÇ

Rust ÊîØÊåÅ Range Ë°®ËææÂºèÔºåËøôÊòØÊîØÊåÅÂàáÁâáÁöÑËØ≠Ê≥ïÂü∫Á°ÄÔºö

    1..2;   // std::ops::Range
    3..;    // std::ops::RangeFrom
    ..4;    // std::ops::RangeTo
    ..;     // std::ops::RangeFull
    5..=6;  // std::ops::RangeInclusive
    ..=7;   // std::ops::RangeToInclusive

Â≠óÁ¨¶‰∏≤Â≠óÈù¢ÈáèË°®ËææÂ∞±ÊòØÂàáÁâáÁ±ªÂûãÔºåString Literals Are SlicesÔºåÂÆÉ‰ª¨Â∞±ÊòØÂÜÖÂ≠ò‰∏≠ÁöÑ‰∫åËøõÂà∂Êï∞ÊçÆÔºåÁ±ªÂûã‰∏∫ `&str`ÔºåÂç≥Â≠óÈù¢ÈáèÂ≠óÁ¨¶‰∏≤ÊòØ‰∏çÂèØÂèòÁöÑÔºö

    let s = "Hello, world!";
    let s: &str = "Hello, world!";

Â∞ùËØïÂÆûÁé∞‰∏Ä‰∏™ÂáΩÊï∞ÔºåÂÆÉËøîÂõûËæìÂÖ•Â≠óÁ¨¶‰∏≤ÁöÑÁ¨¨‰∏Ä‰∏™ËØçÔºö

```rust,ignore
fn main() {
    let mut s = String::from("hello world");

    let hello = first_word(&s); // immutable borrow occurs here
                                // s.clear(); mutable borrow occurs here
    println!("the 1st word is {}", hello);
    s.clear();
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[..=i];
        }
    }

    &s[..]
}
```

Áü•ÈÅìÂ≠óÁ¨¶‰∏≤ÂàáÁâáÂêéÔºåÂèØ‰ª•Â∞ÜÂèÇÊï∞Á±ªÂûãÊîπÂèò‰ΩøÁî®Â≠óÁ¨¶‰∏≤Á±ªÂûãÂàáÁâáÔºåËøôÊ†∑Â∞±Êõ¥ÈÄöÁî®‰∫ÜÔºö

```rust,ignore
let mut s = String::from("hello world");
println!("the 1st word is {}", &s[..5]);
// println!("the 1st word is {}", s[..5]);
// error[E0277]: the size for values of type `str` cannot be known at compilation time
```

Èô§‰∫ÜÂ≠óÁ¨¶‰∏≤ÂèØ‰ª•ÂàáÁâáÔºåÊï∞ÁªÑ‰πüÂèØ‰ª•ÂàáÁâáÔºö

```rust,ignore
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
```

‰ª•‰∏äÊï∞ÁªÑÂàáÁâáÁöÑÁ±ªÂûãÂ∞±ÊòØ `&[i32]`„ÄÇ

‰ΩøÁî® Rust Ë£ÖÁõíÊ®°ÂùóÔºåÂèØ‰ª•Â∞ÜÊï∞ÊçÆ‰øùÂ≠òÂà∞ Heap ÂÜÖÂ≠ò‰∏≠Ôºö

```rust,ignore
// A heap-allocated array, coerced to a slice
let boxed_array: Box<[i32]> = Box::new([1, 2, 3]);

// A (shared) slice into an array
let slice: &[i32] = &boxed_array[..];
```

Âíå Trait ÊåáÈíà‰∏ÄÊ†∑ÔºåÂä®ÊÄÅÂàáÁâáÊòØ DST - dynamically sized typesÔºåÂèØ‰ª•ÈÄöËøá‰ª•‰∏ã‰ª£Á†ÅÊü•Áúã‰∏éÊôÆÈÄöÊåáÈíàÁöÑÂå∫Âà´Ôºö

```rust,ignore
use std::mem::size_of;

dbg!(size_of::<&u32>());        // 8
dbg!(size_of::<&[u32; 2]>());   // 8
dbg!(size_of::<&[u32]>());      // 16
```

ÂØπÊâÄÊúâÁ±ªÂûãÊù•ËØ¥ÔºåÂÖ∂Âä®ÊÄÅÂàáÁâáÁöÑÊåáÈíàÈÉΩÊòØ‰∏ÄÊ†∑Â§ßÂ∞èÁöÑÔºåÊâÄ‰ª•Â∏∏ËßÅ `&[T]` or `&mut [T]` ‰∏§ÁßçÂΩ¢Âºè„ÄÇ

Âõ†‰∏∫ÊòØÊôÆÈÄöÊåáÈíàÁöÑ‰∏ÄÂÄçÂ§ßÔºåÊâÄ‰ª•‰πüÂè´‰Ωú fat pointerÔºåÂ§öÂá∫Êù•ÁöÑÁ©∫Èó¥ÊòØÁî®Êù•‰øùÂ≠òÈïøÂ∫¶‰ø°ÊÅØÔºåÂèØ‰ª•Áî®Á±ª‰ºº‰ª•‰∏ãÁöÑÁªìÊûÑÊù•Ë°®ËææËÉñÊåáÈíàÔºö

```rust,ignore
struct SliceRef { 
    ptr: *const u32, 
    len: usize,
}
```

Êï∞ÁªÑÁ±ªÊñπÊ≥ïÂÆûÁé∞Ôºö

    impl<T> [T]
    pub fn sort(&mut self) where T: Ord,
    pub fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering,
    pub fn sort_by_key<K, F>(&mut self, f: F) where F: FnMut(&T) -> K, K: Ord,
    pub fn sort_by_cached_key<K, F>(&mut self, f: F) where F: FnMut(&T) -> K, K: Ord,
    pub fn to_vec(&self) -> Vec<T, Global> where T: Clone,
    pub fn to_vec_in<A>(&self, alloc: A) -> Vec<T, A> where T: Clone, A: Allocator,
    pub fn into_vec<A>(self: Box<[T], A>) -> Vec<T, A> where A: Allocator,
    pub fn repeat(&self, n: usize) -> Vec<T, Global> where T: Copy,
    pub fn concat<Item>(&self) -> <[T] as Concat<Item>>::Output where Item: ?Sized, [T]: Concat<Item>,
    pub fn join<Separator>(&self, sep: Separator) -> <[T] as Join<Separator>>::Output where [T]: Join<Separator>,

Á§∫ËåÉÔºö

```rust,ignore
let mut v = vec![1, 2, 3, 4, 5, 6];
v.sort_by_key(|&num| num<4);
assert_eq!(v, [4,5,6, 1,2,3]);
println!("{:?}", v);
```



## ‚ö° Lifetime ÁîüÂëΩÂë®Êúü
- https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
- https://doc.rust-lang.org/std/keyword.const.html
- https://doc.rust-lang.org/rust-by-example/custom_types/constants.html
- https://doc.rust-lang.org/rust-by-example/scope/lifetime.html
- https://doc.rust-lang.org/rust-by-example/variable_bindings/scope.html
- https://doc.rust-lang.org/rust-by-example/variable_bindings/freeze.html
- Trait and lifetime bounds https://doc.rust-lang.org/stable/reference/trait-bounds.html
- Lifetime elision https://doc.rust-lang.org/stable/reference/lifetime-elision.html
- Memory allocation and lifetime https://doc.rust-lang.org/stable/reference/memory-allocation-and-lifetime.html
- Common Rust Lifetime Misconceptions https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md

ÂâçÈù¢Ëß£ÊûêÁöÑÂºïÁî®ÊâÄÊúâÊùÉÁöÑÂá∫ÂÄüÊ¶ÇÂøµÔºåÂÖ∂ÂÆûÂ∞±ÊòØÂú®ËÆ®ËÆ∫ÂºïÁî®ÁöÑÁîüÂëΩÂë®ÊúüÔºåRust ÁöÑÂºïÁî®ÈÉΩÊúâÁîüÂëΩÂë®ÊúüÔºåÁîüÂëΩÂë®Êúü‰πüÂè™ÊòØÂØπÂºïÁî®Á∫¶Êùü„ÄÇ

ËÄå‰ΩúÁî®ÂüüÂØπÂèòÈáèÁöÑÁîüÂ≠òÂë®ÊúüÁöÑ‰ΩúÁî®ÔºåÂèàÂ∏∏Â∏∏‰∏éÂºïÁî®ÁöÑÁîüÂëΩÂë®ÊúüÁõ∏Ê∑∑Ê∑Ü„ÄÇÈúÄË¶ÅÊòéÁ°ÆÔºåRust ÁöÑÈöæÁÇπÂú®‰∫éÂºïÁî®ÁöÑÁîüÂëΩÂë®ÊúüÔºåÂºïÁî®ÊòØ‰∏∫‰∫ÜÈÅøÂÖçÂ§çÂà∂Êï∞ÊçÆËÄåÊèêÂçáËøêË°åÊïàÁéáÔºåÊ≤°ÊúâÂºïÁî®Ôºå‰πüÂ∞±Ê≤°Êúâ Rust Â§çÊùÇÁöÑ lifetime„ÄÇ

ÂÆòÊñπÊñáÊ°£ rust-by-example ÁªôÂá∫ÁöÑÊ¶ÇÂøµÊºîÁ§∫‰ª£Á†ÅÔºåÊ≥®ÊÑè i ÂèòÈáèÂíå‰∏§‰∏™ÂºïÁî®ÁöÑÁîüÂëΩÂë®Êúü‰ΩúÁî®ËåÉÂõ¥Ôºö

```rust,ignore
fn main() {
  let i = 3; // Lifetime for `i` starts. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  { //                                                   ‚îÇ
      let borrow1 = &i; // `borrow1` lifetime starts. ‚îÄ‚îÄ‚îê‚îÇ
      println!("borrow1: {}", borrow1); //              ‚îÇ‚îÇ
  } // `borrow1 ends. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
  { //                                                   ‚îÇ
      let borrow2 = &i; // `borrow2` lifetime starts. ‚îÄ‚îÄ‚îê‚îÇ
      println!("borrow2: {}", borrow2); //              ‚îÇ‚îÇ
  } // `borrow2` ends. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
} // Lifetime ends. ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Rust ÁöÑ‰ª£Á†ÅÂùó‰πüÁÆóÊòØ‰∏Ä‰∏™‰ΩúÁî®ÂüüÔºåÈÄöËøá `let` ËØ≠Âè•Â∞ÜÂºïÁî®ÁªëÂÆöÂà∞ borrow1 Êàñ borrow2 ÁöÑÂºïÁî®ÔºåÂú®Ë∂ÖÂá∫‰ª£Á†ÅÂùóÂêéÂ∞±ÁªìÊùü‰∫Ü„ÄÇËÄåÂèòÈáè i ÁöÑÁîüÂëΩÂë®ÊúüÊòæÁÑ∂ÊØîÂÆÉ‰ª¨Êõ¥ÈïøÔºåÂê¶ÂàôÂºïÁî®Â∞±ÊòØÊÇ¨Á©∫Áä∂ÊÄÅ„ÄÇ

ÈÄöÂ∏∏ÔºåRust ÂºïÁî®ÁöÑÁîüÂëΩÂë®Êúü‰∏çÊòØÊâãÂä®ÊåáÂÆöÁöÑÔºåÂíåÁ±ªÂûãËá™Âä®Êé®Êñ≠‰∏ÄÊ†∑ÔºåÁºñËØëÂô®‰ºöÊ†πÊçÆ‰º†ÂÖ•ÁöÑÂèÇÊï∞ËøõË°åÁîüÂëΩÂë®ÊúüÊé®Êñ≠„ÄÇÁºñËØëÂô®‰ºöÊåÅÁª≠Ê†πÊçÆËØ≠Âè•‰∏ä‰∏ãÊñáÊé®Êñ≠Âá∫ÁîüÂëΩÂë®ÊúüÂèÇÊï∞ÔºåÂπ∂ÈÄâÊã©ÊúÄÂ∞èÁöÑÈÇ£‰∏™„ÄÇÂΩìÁºñËØëÂô®ÈÅáÂà∞ÊúâÂ§öÁßç‰∏çÂêåÁöÑÁîüÂëΩÂë®ÊúüÊó†Ê≥ïÁ°ÆÂÆöÔºåÂ∞±ÈúÄË¶Å annotate lifetimes Êù•ÊåáÁ§∫ÁºñËØëÂô®Êõ¥Â•ΩÂú∞Â§ÑÁêÜÔºåÁîüÂëΩÂë®ÊúüÊ†áÊ≥®ÁöÑÁõÆÁöÑÊòØ‰∏∫‰∫ÜÊ∂àÈô§Ê≠ß‰πâ„ÄÇ

Dust Ê≤°ÊúâËøêË°åÊó∂ÁöÑ GC Ë°å‰∏∫ÔºåÂÆÉÈÄöËøáÁºñËØëÊó∂ÂÜÖÂ≠òÊ£ÄÊü•ÂíåÂºïÁî®ÔºåÂü∫‰∫é borrowing and ownership ÂÆûÁé∞ÈùôÊÄÅÂûÉÂúæÂõûÊî∂Êú∫Âà∂„ÄÇRust ‰∏çÂú®ËøêË°åÊó∂ÈÄöËøáÂºïÁî®ËÆ°Êï∞Ê£ÄÊü•ÁöÑÊñπÂºèÂõûÊî∂ÂÜÖÂ≠òÔºåËÄåÊòØÂú®ÁºñËØëÊó∂ËøΩË∏™Ê£ÄÊü•ÁîüÂëΩÂë®ÊúüÔºåËøô‰ΩøÂæóÁ®ãÂ∫èËøêË°åÈùûÂ∏∏È´òÊïà„ÄÇ

‰ª•‰∏ã‰æãÂ≠êÊºîÁ§∫‰∫Ü Scope & Shadowing ÁöÑ‰ΩúÁî®Ôºö

```rust,ignore
fn main() {
    let shadowed_binding = 1;

    {
        // before being shadowed
        assert_eq!(1, shadowed_binding);

        // This binding *shadows* the outer one
        let shadowed_binding = "abc";
        assert_eq!("abc", shadowed_binding);
    }
    // shadows clear!
    assert_eq!(1, shadowed_binding);

    // This binding *shadows* the previous binding
    let shadowed_binding = 2;
    assert_eq!(2, shadowed_binding);
}
```

‰ª•‰∏ãÁ§∫ËåÉÂú®‰∏çÂêå‰ΩúÁî®Âüü‰∏ãÂΩ±Â≠êÁé∞Ë±°ÂºïËµ∑ÁöÑ Frozen data ÁöÑ‰ΩúÁî®Ôºö

```rust,ignore
fn main() {
   let mut _mutable_integer = 7i32;

    {
        // Shadowing by immutable `_mutable_integer`
        let _mutable_integer = _mutable_integer;

        // Error! `_mutable_integer` is frozen in this scope
        // _mutable_integer = 50;
    }

    // Ok! `_mutable_integer` is not frozen in this scope
    _mutable_integer = 3;
}
```

Rust ÁöÑ move semantics, borrowing, lifetime ‰πãÁ±ªÁöÑÊ¶ÇÂøµÂä†Âú®‰∏ÄËµ∑ÔºåÁ°ÆÂÆûËÆ©ËØ≠Ë®ÄÂèòÂæóÂ§çÊùÇ‰∏çÂ†™„ÄÇRust ÊñáÊ°£ÈÉΩËØ¥Ôºå‰Ω†ÂèØËÉΩÈúÄË¶Å‚Äúfight with the borrow checker‚Äù„ÄÇ‰∏∫‰∫ÜÈÄöËøáËøô‰∫õÊ£ÄÊü•Ôºå‰Ω†ÂøÖÈ°ªÁî®ÂæàÊÄ™ÂºÇÁöÑÊñπÂºèÊù•ÂÜôÁ®ãÂ∫èÔºåÈöèÁùÄÈóÆÈ¢òÂ§çÊùÇÂ∫¶ÁöÑÂ¢ûÂä†ÔºåÂ∞±Ë¶ÅÊ±ÇÊúâÊõ¥ÊÄ™ÂºÇÁöÑÂÜôÊ≥ï„ÄÇ

Âú®Ê∑±ÂÖ•ÁêÜËß£ÁîüÂëΩÂë®Êúü‰πãÂâçÔºåÊàë‰ª¨ÈúÄË¶ÅÂ∞ÜÂ∏∏ËßÑÊÑè‰πâÁöÑ‰ΩúÁî®ÂüüÊ¶ÇÂøµ‰Ωú‰∏Ä‰∏ãË∞ÉÊï¥ÔºåRust ÁîüÂëΩÂë®ÊúüËøô‰∏™ÊúØËØ≠Âíå‰ΩúÁî®ÂüüÂØÜÂàáËÅîÁ≥ªÔºå‰ΩÜÂèà‰∏çÊòØÁ≠â‰ª∑ÂÖ≥Á≥ª„ÄÇ

ÁîüÂëΩÂë®ÊúüÊ≥®Ëß£ÁöÑËØ≠Ê≥ïÊ†ºÂºèÂ¶Ç‰∏ãÔºåÂâçÁºÄ‰∏Ä‰∏™ apostropheÔºö

- `&i32` Â∏∏ËßÑËØ≠Ê≥ïË°®Á§∫ÂºïÁî®Ôºõ
- `&'a i32` Â∏¶ÊúâÊòæÂºèÁîüÂëΩÂë®ÊúüË°®Á§∫ÁöÑÂºïÁî®Ôºõ
- `&'a mut i32` Â∏¶ÊúâÊòæÂºèÁîüÂëΩÂë®ÊúüÁöÑÂèØÂèòÂºïÁî®Ôºõ

ÈÄöÂ∏∏ÔºåÂçï‰∏™ÁöÑÁîüÂëΩÂë®ÊúüÊ†áÊ≥®Êú¨Ë∫´ÊòØÊ≤°‰ªÄ‰πàÊÑè‰πâÁöÑÔºåÂõ†‰∏∫ Rust Âè™ÈúÄË¶ÅÈÄöËøáÂÆÉÊù•‰∫ÜËß£Â§ö‰∏™ÂºïÁî®‰πãÈó¥ÁöÑÁîüÂëΩÂë®ÊúüÂÖ≥Á≥ª„ÄÇ


### üü¢üîµ Function & Lifetimes

Êù•ÁúãÁúãÊõ¥ÈÄöÁî®ÁöÑÁîüÂëΩÂë®ÊúüÊ†áÊ≥®ËØ≠Ê≥ïÔºö

    foo<'a, 'b: 'a>
    // `foo` has lifetime parameters `'a` and `'b`

Âõ†‰∏∫ÂíåÊ≥õÂûãËØ≠Ê≥ïË°®ËææÁõ∏‰ººÔºåRust Â∞ÜËøôÁßç‰ΩøÁî®Â∞ñÊã¨Âè∑ÁöÑËØ≠Ê≥ïÈ£éÊ†ºÁß∞‰∏∫ Generic Lifetimes Ê≥õÂûãÁîüÂëΩÂë®Êúü„ÄÇÂ∞ñÊã¨Âè∑ÊåáÂÆöÁöÑÊòØÊ≥õÂûãÂèÇÊï∞ÔºåËøôÈáåÁî®Êù•Â£∞ÊòéÁîüÂëΩÂë®ÊúüÔºåÁî®ÂÆÉÊù•ÂÖ≥ËÅîÂáΩÊï∞ËæìÂÖ•ÂèÇÊï∞‰∏éËøîÂõûÂÄºÁöÑÁîüÂëΩÂë®ÊúüÂÖ≥Á≥ª„ÄÇÂèÇÊï∞ÈÉ®ÂàÜÂè´ÂÅöËæìÂÖ•Â£∞ÊòéÂë®ÊúüÔºåËøîÂõûÂÄºÈÉ®ÂàÜÂè´ÂÅöËæìÂá∫ÁîüÂëΩÂë®Êúü„ÄÇ

Ëøô‰∏™Á§∫ËåÉ‰ª£Á†ÅË°®Á§∫Ôºåfoo ÂêåÊó∂Êã•Êúâ‰∏§‰∏™ÁîüÂëΩÂë®ÊúüÂÆö‰πâÔºåÂπ∂‰∏î foo ‰∏çÂèØ‰ª•ÊØî `'a` ÊàñËÄÖ `'b` Êõ¥Èïø‰πÖ„ÄÇÂêåÊó∂ `'a` Ëá≥Â∞ëÂíå `'b` ÁîüÂ≠òÂë®Êúü‰∏ÄÊ†∑ÈïøÔºåÂâçËÄÖÂåÖÂê´ÂêéËÄÖ„ÄÇ

‰æãÂ¶ÇÔºå‰ª•‰∏ã‰∏§‰∏™ÂáΩÊï∞ÊòØÁ≠â‰ª∑ÁöÑÔºö

    fn elided_pass(x: &i32) -> &i32 { x }

    fn annotated_pass<'a>(x: &'a i32) -> &'a i32 { x }

ÁîüÂëΩÂë®ÊúüÊ≥®Ëß£ÂèØ‰ª•ÁúÅÁï•ÔºåÂõ†‰∏∫Âç≥‰ΩøÊ≤°ÊúâÁîüÂëΩÂë®ÊúüÊ≥®Ëß£ÔºåÁºñËØëÂô®‰πüÂèØ‰ª•Êé®Êñ≠Âá∫Êù•ÔºåËæìÂÖ•„ÄÅËæìÂá∫ÊúâÁõ∏ÂêåÁöÑÁîüÂëΩÂë®Êúü„ÄÇ

ÊñπÊ≥ïÊòæÂºèÂÆö‰πâ‰∫Ü `'a` ÁîüÂëΩÂë®ÊúüÔºåÁîüÂëΩÂë®ÊúüÊ†áÊ≥®ÁöÑÊÑè‰πâÂ¶Ç‰∏ãÔºö

- ÂèÇÊï∞ `x` ÂÖ∑Êúâ `'a` ÁîüÂëΩÂë®ÊúüÔºåÂÆÉËá≥Â∞ëÂíåÂáΩÊï∞‰∏ÄÊ†∑Èïø‰πÖ„ÄÇ
- ËøîÂõûÂºïÁî®‰πüÂíå `'a` ÁîüÂëΩÂë®Êúü‰∏ÄÊ†∑Èïø‰πÖÔºåÂÆûË∑µ‰∏≠ÔºåÂèÇËÄÉÂàóË°®‰ºöÊúâÂ§ö‰∏™ÁîüÂëΩÂë®ÊúüÔºåËøîÂõûÂÄºÂ∫îËØ•ÂíåÁîüÂëΩÂë®ÊúüÊúÄÁü≠ÁöÑ‰∏ÄËá¥„ÄÇ
- ËøîÂõûÂºïÁî®ÂøÖÈúÄ‰∏éËæìÂÖ•ÂèÇÊï∞ÊúâÁõ∏ÂêåÁöÑÁîüÂëΩÂë®ÊúüÔºåÊàñËÄÖÊòØ `'static` ÁîüÂëΩÂë®ÊúüÔºå‰ΩÜ‰∏çËÉΩÈïø‰∫éËæìÂÖ•ÁöÑÁîüÂëΩÂë®Êúü„ÄÇ
- `main()` ÂáΩÊï∞‰∏çËÉΩÊúâÊ≥õÂûãÁîüÂëΩÂë®ÊúüÂèÇÊï∞„ÄÇ

ËøôÊÑèÂë≥ÁùÄ‰ªéÂáΩÊï∞ÂÜÖÈÉ®ËøîÂõûÁöÑËøô‰∏™ÂºïÁî®ÔºåÂíåÂáΩÊï∞Â§ñÁöÑ `x` Âú®ÂêåÊ†∑ÁöÑ‰ΩúÁî®Âüü‰∏≠ÂÖ∑ÊúâÂêåÊ†∑ÁöÑÂèØÂºïÁî®ÊÄßÔºåËÄå‰∏ç‰ºöÂá∫Áé∞‰∏Ä‰∏™ÂºïÁî®ÊØîÂè¶‰∏ÄÊõ¥ÂÖàÁªìÊùüÁîüÂ≠òÔºåÂç≥‰∏ç‰ºöÂõ†‰∏∫Ê∏ÖÁêÜÔºåËÄåÂØºËá¥ÂºïÁî®Â§±Êïà„ÄÇ

ÊòæÂºèÊ†áÊ≥®ÁîüÂëΩÂë®ÊúüÂêéÔºåRust Â∞±‰ºöÂÜçËøõË°åÊé®Êñ≠‰∫ÜÔºåÂπ∂‰∏î‰ºöÊåâÊåáÂÆöË¶ÅÊ±ÇËøõË°åÂÄüÁî®Ê£ÄÊü•ÔºåÂπ∂‰∏îÂ∫îËØ•ÊãíÁªù‰ªª‰Ωï‰∏çÁ¨¶ÂêàËøô‰∫õÁ∫¶ÊùüÁöÑÂÄº„ÄÇÊ†áÊ≥®ÈÄöÂ∏∏Âè™ÈúÄË¶ÅÂú®ÂáΩÊï∞Á≠æÂêç‰∏≠Âá∫Áé∞ÔºåÁºñËØëÂô®‰ºöËá™Âä®ÂàÜÊûêÂáΩÊï∞‰ΩìÔºåÂè™Âú®ÂºïÁî®ÂáΩÊï∞Â§ñÈÉ®‰ª£Á†Å‰∏çÂèØËÉΩÂàÜÊûêÊó∂ÔºåÊâçÈúÄË¶ÅËøõË°åÊâãÂä®Ê†áÊ≥®„ÄÇ

ËØ∑Ê≥®ÊÑèÔºåÂáΩÊï∞‰∏çÈúÄË¶ÅÁ°ÆÂàáÂú∞Áü•ÈÅìÂèÇÊï∞ÁöÑÂØøÂëΩÔºåÂè™ÈúÄË¶Å‰∏Ä‰∫õ‰ΩúÁî®ÂüüÂèØ‰ª•ÊõøÊç¢‰∏∫Êª°Ë∂≥Ê≠§Á≠æÂêçÁöÑ 'a ÁîüÂëΩÂë®Êúü„ÄÇ

ÁîüÂëΩÂë®ÊúüÊ†áÊ≥®Â∞±ÊòØÁî®Êù•ÂëäËØâÁºñËØëÂô®ÔºåË¢´Ê†áÊ≥®ÁöÑÂØπË±°ÁöÑÁîüÂ≠òÊó∂Èó¥Ë¶Å‰ª•Ê†áÊ≥®ÁöÑÁîüÂëΩÂë®Êúü‰∏∫Á∫¶ÊùüÔºå‰∏çÂèØ‰ª•Ë∂ÖÂá∫Ëøô‰∏™Á∫¶ÊùüÊó∂Èó¥ÔºåÂê¶ÂàôÂ∞±ÊòØ‰∏Ä‰∏™ÊåáÈíàÊÇ¨ÂÅúÈóÆÈ¢ò Dangle References„ÄÇ

ÁîüÂëΩÂë®ÊúüÁÆ°ÁêÜÁöÑ‰∏Ä‰∏™‰∏ªË¶ÅÁõÆÁöÑÂ∞±ÊòØÈò≤Ê≠¢ÊÇ¨Á©∫ÂºïÁî® Dangling ReferencesÔºåÂâçÈù¢Â∑≤ÁªèËß£ÊûêËøáÔºåÂΩìÂÜÖÈÉ®‰ΩúÁî®ÂüüÁöÑÂºïÁî®Ë∂ÖÂá∫‰ΩúÁî®ÂüüÂ§±ÊïàÂêéÔºåÂÄºÂ∞±Â§±Êïà‰∏çËÉΩË¢´‰ΩøÁî®‰∫ÜÔºåÂ§ñÈÉ®ÂØπÂ∫îÁöÑÂºïÁî®Â∞±Â§ÑÁêÜÊÇ¨ÂÅúÁä∂ÊÄÅÔºö

```rust,ignore
fn main() {
    let reference_to_nothing = dangle();

    let reference_to_nothing; 
    {
        let b = 1;
        reference_to_nothing = &b;
    }
}

fn dangle() -> &String {
            // ^ expected named lifetime parameter
            // error[E0106]: missing lifetime specifier
    let s = String::from("hello");
    &s
}
```

‰ª•‰∏äÁ§∫ËåÉ‰∏≠ÔºåÊó†ËÆ∫ÊòØ `dangle()` ÂáΩÊï∞ÂÜÖÁöÑ `&s` ËøòÊòØËØ≠Âè•Âùó‰∏≠ÁöÑ `&b` ÈÉΩÊòØÂú®Âá∫ÂÄüÊâÄÊúâÊùÉÔºåÂú®Ë∂ÖÂá∫‰ΩúÁî®ÂüüÂêéÂºïÁî®Â§±ÊïàÔºåÂç≥ÁîüÂëΩÂë®ÊúüÁªìÊùüÔºåÂ§ñÂÄüÁöÑÂºïÁî®‰πüÂΩìÁÑ∂Â§±ÊïàÔºåRust ÁºñËØëÂô®‰ºöÈÄöËøá borrow checker Ê£ÄÊü•Âì™‰∫õÂÄüÁî®ÊòØÁî®ÊïàÁöÑ„ÄÇ


ÊØîÂ¶ÇÔºå‰ª•‰∏ãÁ§∫ËåÉ‰∏≠Êúâ‰∏§‰∏™ `longest()` ÂáΩÊï∞ÔºåÂÖ∂‰∏≠‰∏Ä‰∏™Â∏¶ÊúâÁîüÂëΩÂë®ÊúüÊ†áÊ≥®‰ø°ÊÅØÁöÑÁâàÊú¨ÊâçÂèØ‰ª•Ê≠£Â∏∏Â∑•‰ΩúÔºö

```rust,ignore
// normal reference version
// error[E0106]: missing lifetime specifier
// = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
//                              ‚Üì expected named lifetime parameter
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}
// lifetime annotated version
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

È¶ñÂÖàÔºåËøîÂõûÂáΩÊï∞‰ΩìÂÜÖÁöÑÂºïÁî®Ëøô‰∏ÄÂÅöÊ≥ïÊòØ‰∏çË¢´ÂÖÅËÆ∏ÁöÑÔºåÂõ†‰∏∫ÂáΩÊï∞ÂÜÖÈÉ®ÁöÑÊï∞ÊçÆ‰ºöÂú®ÂáΩÊï∞ÁªìÊùüÊó∂Ë¢´Ê∏ÖÁ©∫ÔºåÂÖ∂ÊâÄÊúâÊùÉ‰πü‰∏ÄÂπ∂Ê∂àÈô§ÔºåËøôÂøÖÁÑ∂‰ºöÂØºËá¥ÊÇ¨Á©∫ÂºïÁî® Dangling References„ÄÇ

‰ΩÜÊòØËøîÂõûÂ§ñÈÉ®‰º†ÂÖ•ÂáΩÊï∞ÁöÑÂºïÁî®ÊòØÂèØË°åÁöÑÔºåËÄåÁâàÊú¨‰∏ÄÁöÑÈîôËØØÂú®‰∫éÔºå‰ΩøÁî®ÂºïÁî®‰º†ÂèÇ„ÄÅÂπ∂ËøîÂõûÂºïÁî®ÔºåËÄåÊ≤°ÊúâÂ£∞ÊòéÂºïÁî®Ëá™‰ΩïÂ§Ñ„ÄÇÊòØÂõ†‰∏∫ Rust ÁºñËØëÂô®Âú®Â§ÑÁêÜÂáΩÊï∞‰Ωì‰∏≠ÁöÑÊù°‰ª∂ËØ≠Âè•Êó∂ÔºåÊúâ‰∏§‰∏™ÂèØËÉΩËøîÂõûÂÄº `x` Êàñ `y`ÔºåÂú®ÁºñËØëÊúü‰∏çÂèØÈ¢ÑÁü•„ÄÇÂ¶ÇÊûúÂèÇÊï∞Âè™Êúâ‰∏Ä‰∏™ÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•ÁúÅÁï•ÁîüÂëΩÂë®ÊúüÊ†áÊ≥®„ÄÇÂÆö‰πâÂ•ΩÂáΩÊï∞ÂêéÔºåÂÖ∑‰Ωì‰º†‰ªÄ‰πàÂÄºËøõÂÖ•‰πüÊòØ‰∏çÂèØÈ¢ÑÁü•Ôºåborrow checker ‰πü‰∏çËÉΩÁ°ÆÂÆö‰∏§‰∏™ÂêéÂ§áËøîÂõûÂÄº‰∏éÊúÄÁªàÂõûËøîÂÄºÁöÑÁîüÂëΩÂë®ÊúüÂÖ≥Á≥ª„ÄÇ

ÁÆÄÂçïÂú∞ËØ¥ÔºåDust ÁºñËØëÂô®‰∏çËÉΩÊ≠£Á°ÆÂú∞ËøΩË∏™ÂºïÁî®ÔºåÂ∞±‰∏çËÉΩÊ≠£Á°ÆÂú∞ÁÆ°ÁêÜÂÖ≥ËÅîÁöÑÂÜÖÂ≠òËµÑÊ∫êÔºå‰πüÊó†Ê≥ïÂú®ÁºñËØëÊúüÂÆåÂÖ®ÈúÄË¶ÅÂ§ÑÁêÜÂ•ΩÁöÑËµÑÊ∫êÁÆ°ÁêÜÂ∑•‰Ωú„ÄÇ

ËÄåÁâàÊú¨‰∫åÔºåÊòæÂºèÊ†áÊ≥®ÁîüÂëΩÂë®ÊúüÔºå‰º†ÂÖ•ÂèÇÊï∞ÊúâÊòéÁ°ÆÁöÑÁîüÂëΩÂë®ÊúüÂÆö‰πâ„ÄÇËøôÊ†∑Â§ÑÁêÜÁöÑÁªìÊûúÂ∞±ÊòØÔºåRust ÁºñËØëÁü•ÈÅìËøîÂõûÂÄºÂíåËæìÂÖ•ÂèÇÊï∞ÊúâÂêåÊ†∑ÁöÑÁîüÂëΩÂë®ÊúüÔºåÊâÄ‰ª•ÔºåÊó†ËÆ∫ËøîÂõû `x` Êàñ `y` ÂÆÉ‰ª¨ÈÉΩÂèØ‰ª•Âú® `main()` ÂáΩÊï∞‰∏≠Ê≠£Á°ÆÂú∞‰ΩøÁî®ÂÄüÂá∫ÁöÑÊâÄÊúâÊùÉ„ÄÇ

ÂÜçÊù•ÁúãÂè¶‰∏Ä‰∏™ÂàóÂ≠êÔºö

```rust,ignore
fn failed_borrow<'a>() {
  let _x = 12;

  // ERROR: `_x` does not live long enough
  let y: &'a i32 = &_x;
}
```

ÂáΩÊï∞ÂÜÖÈÉ®ÁöÑÂ±ÄÈÉ®ÂèòÈáè `_x`Ôºå‰∏ãÂàíÁ∫øË°®Á§∫ÂÜÖÈÉ®‰ΩøÁî®ÔºåÂáΩÊï∞Êú¨Ë∫´Ê≤°ÊúâÂèÇÊï∞‰πüÊ≤°ÊúâËøîÂõûÂÄºÔºåÊòæÂºè‰ΩøÁî® `'a` ÁîüÂëΩÂë®ÊúüÔºåËøô‰ºöÂ∏¶Êù•‰∏Ä‰∫õÂΩ±Âìç„ÄÇ

Â∞ùËØïÂú®ÂÜÖÈÉ®ÂÄüÁî®ÂÜÖÈÉ® `&_x` ÂèòÈáèÔºåÂπ∂‰∏îÊåáÊòéÁîüÂëΩÂë®Êúü `'a`ÔºåÂç≥ÂÄüÁî®ÂÖ∑ÊúâÂíåÂáΩÊï∞Áõ∏ÂêåÁöÑÁîüÂëΩÂë®Êúü„ÄÇ

‰ΩÜÊòØÔºåÂØπ‰∫éÂèòÈáè `_x` Êú¨Ë∫´‰ºöÂú®ÂáΩÊï∞ÁªìÊùüÊó∂ÈáäÊîæÔºå‰ªéÁºñËØëÂô®ËßíÂ∫¶Êù•ÁúãÔºåÂáΩÊï∞Ë¶ÅË¥üËΩΩÂ±ÄÈÉ®ÂèòÈáèÁöÑÊ∏ÖÁêÜÔºåÂõ†Ê≠§ÁîüÂëΩÂë®ÊúüÁêÜÂ∫îÊØîÂ±ÄÈÉ®ÂèòÈáèÊõ¥Èïø‰∏ÄÁÇπ„ÄÇËøôÂ∞±ÂØºËá¥‰∫ÜÔºåË¢´ÂÄüÂØπË±°ÁöÑÁîüÂ≠òÊó∂Èó¥ÊØîÂÄüÁî®ËøòÁü≠ÔºåÂºïÁî®ÊÇ¨Á©∫„ÄÇÊâÄ‰ª•‰∏çËÉΩÈÄöËøáÊâÄÊúâÊùÉÊ£ÄÊü•Êú∫Âà∂ÔºåÁºñËØëÂô®‰πüÁªôÂá∫ÊèêÁ§∫Êù°‰ª∂‰∏çÊª°Ë∂≥Ôºö`_x` Ë¢´ÂÄüÁî®‰∫é `'a` ÁîüÂ≠òÂë®Êúü„ÄÇ

    error[E0597]: `_x` does not live long enough
    fn failed_borrow<'a>() {
                     -- lifetime `'a` defined here
      let y: &'a i32 = &_x;
             -------   ^^^ borrowed value does not live long enough
             |
             type annotation requires that `_x` is borrowed for `'a`
    }
    - `_x` dropped here while still borrowed


### üü¢üîµ Temporary & Lifetimes elision
- Validating References with Lifetimes - Lifetime elision https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision

Rust Áî® `let` ËØ≠Âè•Êù•ÂàõÂª∫ÂèòÈáèÔºåÂπ∂ÁªëÂÆöÂà∞Á≠âÂè∑Âè≥‰æßÁöÑÂÄº‰∏äÔºåÁªëÂÆöËøô‰∏™Âä®‰Ωú‰πüÊ∂âÂèä‰∫Ü‰∏Ä‰∫õÁîüÂ≠òÂë®ÊúüÁöÑÂÜÖÂÆπ„ÄÇ

Âú® Rust ‰∏≠Ôºå‰∏¥Êó∂ÂÄºÁöÑÁîüÂëΩÂë®ÊúüÊòØÂÖ∂ËØ≠Âè•ÁöÑÁªìÂ∞æÔºåÈô§Èùû‰ΩøÁî® let Â∞Ü‰∏Ä‰∏™‰∏¥Êó∂ÂÄºÁªëÂÆöÂà∞ÂêçÁß∞ÔºåËøôÊ†∑ÂèØ‰ª•Ëé∑ÂæóÊõ¥ÈïøÁöÑÁîüÂëΩÂë®Êúü„ÄÇ

‰æãÂ¶ÇÔºåÂ¶Ç‰∏ã‰∏§‰∏™ÂáΩÊï∞‰∏≠ÔºåËøîÂõûÁöÑ‰∏¥Êó∂ÂÄºÔºåÂ∞±Ê≤°Êúâ‰ΩøÁî® let ÁªëÂÆöÂà∞ÂèòÈáè„ÄÇ

```rust,ignore
fn take_down() -> &str {
    "tempory"
}

fn take_ref(it: &String) -> &str {
    "tempory"
}
```

ÂØπ‰∫é tack_refÔºåÂèØ‰ª•Ê≠£Á°ÆËøîÂõûÁöÑ‰∏¥Êó∂ÂÄºÔºåËÄå take_down Âç¥‰∏çËÉΩÊ≠£Á°ÆËøîÂõû‰∏¥Êó∂ÂÄº„ÄÇ

    error[E0106]: missing lifetime specifier
       --> src\main.rs:130:19
        |
    130 | fn take_down() -> &str {
        |                   ^ help: consider giving it a 'static lifetime: `&'static`
        |
        = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from

ËøôÊòØÂõ†‰∏∫ÔºåÁºñËØëÂô®ÂèØ‰ª•‰ªéÂáΩÊï∞ÂèÇÊï∞‰∏≠Êé®ÊµãÁîüÂëΩÂë®Êúü‰ø°ÊÅØÔºåËÄå take_down ÂáΩÊï∞Ê≤°ÊúâÂèÇÊï∞ÂèØ‰æõÂèÇËÄÉÔºåÊâÄ‰ª•ÁºñËØë‰∏çËÉΩÈÄöËøá„ÄÇ

Âú® Rust Êó©ÊúüÂéÜÂè≤ÁâàÊú¨‰∏≠ÔºåÊØè‰∏™ÂºïÁî®ÈÉΩÈúÄË¶ÅÊòæÂºèÊ†áÊ≥®ÁîüÂëΩÂë®ÊúüÔºåÂê¶Âàô‰∏çËÉΩÈÄöËøáÁºñËØë„ÄÇËÄå Rust ËØ≠Ë®ÄÁöÑÂèëÂ±ïÂêëÊõ¥Â∞ëÁöÑÁîüÂëΩÂë®ÊúüÊ†áÊ≥®ÊñπÂêëÂèëÂ±ïÔºåÂõ†‰∏∫ÁîüÂëΩÂë®ÊúüÊ†áÊ≥®Á°ÆÂÆûÊòØÁÉ¶‰∫∫„ÄÇ

ÂØπ‰∫éÁõÆÂâçÔºåtake_down ÁîüÂëΩÂë®ÊúüÊ†áÊ≥®Êúâ‰∏§ÁßçÂΩ¢ÂºèÔºö

    fn take_down<'a>() -> &'a str {
    fn take_down() -> &'static str {


Êúâ‰∫õ‰∏¥Êó∂ÂÄºË°®Áé∞ÊØîËæÉÈöêËîΩÔºåÂ¶Ç‰∏ã‰ª£Á†Å‰∏≠Â∞±Êúâ‰∏¥Êó∂ÂÄºÔºö

```rust,ignore
fn main() {
    let mut foo = &mut "hello".to_string();
    // temporary value dropped while borrowed
    foo = &mut String::from("world");
    //         ^^^^^^^^^^^^^^^^^^^- temporary value is freed at the end of this statement
    //         |
    //         creates a temporary which is freed while still in use
    take_mut_ref(foo);
    //           --- borrow later used here
}

fn take_mut_ref(it: &mut String) {
    // ...
}
```

Rust Á≥ªÁªüÁöÑÊâÄÊúâÂÄºÈÉΩÊúâÁ±ªÂûãÔºå‰ª£Á†Å‰∏≠Ê≤°ÊúâÊåáÂÆö foo ÁöÑÂèòÈáèÁ±ªÂûãÔºåÂõ†‰∏∫ÂèØ‰ª•‰ªéÁ≠âÂè∑Âè≥‰æßÁöÑÂÄºÊé®ÊµãÂá∫Êù•ÊòØ `&mut String`ÔºåÂÆÉË°®Á§∫‰∏Ä‰∏™ÂºïÁî®ÔºåÂπ∂‰∏îËøô‰∏™ÂºïÁî®ÂèØ‰ª•Áî®Êù•ÊîπÂèòÊåáÂêëÁöÑÊï∞ÊçÆ„ÄÇ

ËÄå foo ÂèòÈáèÂ£∞Êòé‰∏∫ mutÔºåÊâÄ‰ª•ÂÆÉÊòØ‰∏Ä‰∏™ÂèØÂèòÂèòÈáèÔºåÊâÄ‰ª•ÂêéÈù¢ÂèØ‰ª•ÂØπ foo ËøõË°åÂÜçÊ¨°ËµãÂÄº„ÄÇ

Âú®ÂØπ foo ÂèòÈáèËøõË°åÁ¨¨‰∫åÊ¨°ËµãÂÄºÊó∂Ôºö

- `String::from("world")` ÊòØ‰∏Ä‰∏™ `String` Á±ªÂûãÁöÑÂÄºÔºõ
- Êï¥‰∏™Á≠âÂè∑Âè≥‰æßÊòØ‰∏Ä‰∏™ `&mut String` Á±ªÂûãÁöÑÂÄºÔºõ

ËøôÈáåÂ∞±ÈöêËóè‰∫Ü‰∏Ä‰∏™‰∏¥Êó∂ÂÄºÔºåÂç≥ Strng Á±ªÂûãÁöÑÂÄºÊòØ‰Ωú‰∏∫‰∏Ä‰∏™‰∏¥Êó∂ÂÄºÂ≠òÂú®ÁöÑ„ÄÇ

ÂêåÊ†∑ÁêÜÁî±ÔºåÂÅáÂ¶Ç foo ÁöÑÁ±ªÂûãÂÆö‰πâ‰∏∫ `&String`ÔºåÁ¨¨‰∫åÊ¨°ËµãÂÄºË°®ËææÂºèÂ¶Ç‰∏ãÔºö

    foo = &String::from("world");

ÂêåÊ†∑‰πüÂ≠òÂú®‰∏Ä‰∏™ `String` Á±ªÂûãÁöÑ‰∏¥Êó∂ÂÄºÔºåÂ¶ÇÊûú‰∏çÂú®ÂêéÈù¢‰ΩøÁî® foo ÂèòÈáèÔºåÈÇ£‰πàËøô‰∏™‰∏¥Êó∂ÂÄºÊòØÊ≤°Êúâ‰ªª‰ΩïÂâØ‰ΩúÁî®ÁöÑ„ÄÇ

ËÄå‰∏ÄÊó¶ÂêéÈù¢Áî®Âà∞‰∫Ü foo ÂèòÈáèÔºåÈÇ£‰πàÔºåfoo ÂºïÁî®Âà∞‰∫Ü‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáèÔºåËÄåËøô‰∏™‰∏¥Êó∂ÂèòÈáèÊó©Â∞±Âú®ËµãÂÄºËØ≠Âè•ÁªìÊùüÊó∂Â∞±ÈáäÊîæ‰∫ÜÔºåËøôÂ∞±ÂØºËá¥ÂÜÖÂ≠òÊó†ÊïàÂºïÁî®ÔºåÁºñËØë‰∏çËÉΩÈÄöËøá„ÄÇ

ÊâÄ‰ª•ÔºåÊ≠£Ëß£ÁöÑÂÅöÊ≥ïÊòØ‰ΩøÁî® let Â∞Ü‰∏¥Êó∂ÂÄºÁªëÂÆöÂà∞ÂèòÈáè‰∏äÔºö

    let foo = &String::from("world");
    let foo = &mut String::from("world");


### üü¢üîµ Lifetime Bound Syntax
- https://doc.rust-lang.org/rust-by-example/scope/lifetime/lifetime_bounds.html
- https://doc.rust-lang.org/stable/reference/trait-bounds.html

ÂíåÊ≥õÂûãÂèØ‰ª•‰ΩøÁî® Trait Bound ËØ≠Ê≥ï‰∏ÄÊ†∑ÔºåÁîüÂëΩÂë®Êúü‰πüÂèØ‰ª•ÁªëÂÆö„ÄÇ

- `<'_>` lifetime elision ÁîüÂëΩÂë®ÊúüÁúÅÁï•„ÄÇ
- `<'a: 'b, 'b>` reads as lifetime `'a` is at least as long as `'b`.
- `T: 'a` Ë°®Á§∫ T Á±ªÂûã‰∏≠ÁöÑ‰ªª‰ΩïÂºïÁî®ÈÉΩË¶ÅÊ¥ªÂæóÂíå `'a` ‰∏ÄÊ†∑Èïø
- `TÔºöTrait + 'a` Ë°®Á§∫ T Á±ªÂûãÂøÖÈ°ªÂÆûÁé∞ Trait Êâ©Â±ïÊñπÊ≥ïÔºåÂπ∂‰∏î‰ªª‰Ωï T Á±ªÂûãÂºïÁî®ÈÉΩË¶ÅÊ¥ªËøá `'a` ‰∏ÄÊ†∑Èïø

```rust,ignore
#[derive(Debug)]
struct Ref<'a, T: 'a>(&'a T);
// `Ref` contains a reference to a generic type `T` that has
// an unknown lifetime `'a`. `T` is bounded such that any
// references in `T` must outlive `'a`. Additionally, the lifetime
// of `Ref` may not exceed `'a`.

// A generic function which prints using the `Debug` trait.
fn print<T>(t: T) where
    T: Debug {
    println!("`print`: t is {:?}", t);
}

// Here a reference to `T` is taken where `T` implements
// `Debug` and all *references* in `T` outlive `'a`. In
// addition, `'a` must outlive the function.
fn print_ref<'a, T>(t: &'a T) where
    T: Debug + 'a {
    println!("`print_ref`: t is {:?}", t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&x);

    print_ref(&ref_x);
    print(ref_x);
}
```

Generic Type Parameters, Trait Bounds, and Lifetimes Together

```rust,ignore
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```


### üü¢üîµ Static ÈùôÊÄÅÁîüÂëΩÂë®Êúü
- https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html
- https://doc.rust-lang.org/rust-by-example/custom_types/constants.html

Â∏∏Èáè‰∏≠ÂîØ‰∏ÄÂÖÅËÆ∏ÁöÑÁîüÂ≠òÊúüÊòØ `'static`ÔºåÂÆÉÊòØ Rust Á®ãÂ∫èÂ∏∏ÈáèÈªòËÆ§ÂåÖÂê´ÁöÑÁîüÂ≠òÊúü„ÄÇ

‰æãÂ¶ÇÔºåÂÆö‰πâ‰∏Ä‰∏™Â∏¶ÊúâÈùôÊÄÅÁîüÊàêÊúüÁöÑÂ≠óÁ¨¶‰∏≤Â∏∏ÈáèÔºåÂΩìÁÑ∂ÂèØ‰ª•ÁúÅÁï•Ëøô‰∏™ÁîüÂ≠òÊúüÔºåÂõ†‰∏∫Â≠óÁ¨¶‰∏≤Â≠óÈù¢ÈáèÊú¨Ë∫´Â∞±ÊòØ `&'static str` Á±ªÂûãÔºåÂÆÉÊòØÂè™ËØªÁöÑÁ±ªÂûãÔºö

    const WORDS: &'static str = "hello rust!";
    const WORDS: &str = "hello convenience!";
    static WORDS: &str = "hello convenience!";

Â∏∏ÈáèÂÆö‰πâÔºö

    const MAX_POINTS: u32 = 100_000;
    const HELLO: &str = "Hello, world!";

Â≠óÁ¨¶‰∏≤ÂØπË±°Á±ªÂûãÊòØ‰∏ÄÁßç‰∏çËÉΩÂú®ÁºñËØëÊúüÁ°ÆÂÆöÁöÑÁöÑÁ±ªÂûãÔºåÊâÄ‰ª•‰∏çËÉΩÂÆö‰πâËøôÊ†∑‰∏ÄÁßçÂ∏∏ÈáèÔºö

    const DATABASE: String = String::from("something");

Rust Êèê‰æõÁöÑÂÆèËøôÁßçÈ´òÁ∫ßÁâπÊÄßÂèØ‰ª•ÂÅöÂæàÂ§ö‰∫ãÔºå‰æãÂ¶ÇÔºåÂ∞ÜÊñá‰ª∂ÂÜÖÂÆπËØªÂÖ•‰Ωú‰∏∫‰∏Ä‰∏™ÈùôÊÄÅÂèòÈáèÔºö

    const SRC: &'static str = include_str!("main.rs");
    const STR: &'static str = concat!("abc", "abc");

Â≠óÈù¢ÈáèÂ≠óÁ¨¶‰∏≤ÊòØÁ°¨ÁºñÁ†ÅÂú®ÁºñËØëÂá∫ÁöÑ‰∫åËøõÂà∂Êñá‰ª∂ÈáåÁöÑÔºåÂú®ËøêË°åÊó∂Ë¢´Âä†ËΩΩÂà∞Âè™ËØªÂÜÖÂ≠ò‰∏≠„ÄÇÂõ†Ê≠§ÔºåÂÆÉÊòØ‰∏çÂèØÂèòÁöÑÔºåÂπ∂‰∏îÂú®Êï¥‰∏™Á®ãÂ∫èËøêË°åÊó∂ÊúâÊïàÔºåÂõ†Ê≠§ÂÆÉÊòØ `'static` ÁöÑ„ÄÇ

ÈÄöÂ∏∏ÈùôÊÄÅÁîüÂ≠òÊúüÊòØÊé®Êñ≠Âá∫Êù•ÁöÑÔºå‰∏çÂøÖÊåáÂÆöÔºå‰øÆÊîπÂèØÂèòÈùôÊÄÅÂèòÈáèÊòØ‰∏çÂÆâÂÖ®ÁöÑ„ÄÇ

Ê†πÊçÆËøô‰∏™ÂéüÁêÜÔºåÂ∞±ÂèØ‰ª•Â∞ÜÂâçÈù¢ Dangling References Á§∫ËåÉ‰∏≠ÁöÑ‰ª£Á†ÅÂùóÊîπÈÄ†‰∏∫Ê≠£Á°ÆÁöÑÂºïÁî®Ôºö

```rust,ignore
fn main() {
    let a; 
    {
        static B: &i32 = &(123);
        a = &B;
    }
    println!("lifetime ok? {}", a);
}
```

Â¶ÇÂú®ÂáΩÊï∞‰∏≠‰ΩøÁî®Ê≥õÂûã where ‰ªéÂè•ÊñπÂºèÂÆö‰πâÔºö

    // 'static as part of a trait bound:
    fn generic<T>(x: T) where T: 'static {}

‰ΩÜÊòØÔºå‰∏Ä‰∏™Á±ªÂûã‰πüÂèØ‰ª•Áî®ÈùôÊÄÅÁîüÂ≠òÊúü‰øÆÈ•∞ÔºåÂå∫ÂàÜ‰ª•‰∏ã‰∏§ÁßçÂΩ¢ÂºèÔºö

- `&'static T` ÊòØÂÆö‰πâ‰∏Ä‰∏™ËÉΩÂ§üË¢´ÂÆâÂÖ®Âú∞ÊåÅÊúâÊó†Èôê‰πÖÁöÑ T Á±ªÂûãÔºåÁõ¥Âà∞Êï¥‰∏™Á®ãÂ∫èÁªàÊ≠¢„ÄÇ
- `T: 'static` Ë°®Á§∫ T Á±ªÂûãÂÖ∑Êúâ `'static` ÁîüÂëΩÂë®ÊúüÔºåËÉΩÂú®ËøêË°åÊó∂ÂàõÂª∫ÔºåËÉΩË¢´ÂÆâÂÖ®ÂíåÈöèÊÑèÂú∞ÊîπÂèòÔºåËÉΩË¢´ dropÔºåËÉΩÊ¥ªÂà∞Êï¥‰∏™Á®ãÂ∫èÁªàÊ≠¢„ÄÇ

Âú®ËøêË°åÊó∂ÁîüÊàêÂä®ÊÄÅÂàÜÈÖçÁöÑÈöèÊú∫Êï∞ÊçÆÔºåÁÑ∂ÂêéËøîÂõû‰∏Ä‰∏™ `'static` ÂºïÁî®ÊòØÂèØË°åÁöÑÔºåÂè™ÈúÄË¶Å‰ªòÂá∫ÂÜÖÂ≠òÊ≥ÑÊºèÁöÑ‰ª£‰ª∑Ôºå‰æãÂ¶ÇÔºö

```rust,ignore
use rand;

// generate random 'static str refs at run-time
fn rand_str_generator() -> &'static str {
    let rand_string = rand::random::<u64>().to_string();
    Box::leak(rand_string.into_boxed_str())
}
```

Êô∫ËÉΩÊåáÈíà Box Êèê‰æõÁöÑ leak ÊñπÊ≥ïÊöóÁ§∫‰∫ÜÊúâÂÜÖÂ≠òÊ≥ÑÊºèÈ£éÈô©ÔºåÂÆÉ‰ºöËøîÂõû‰∏Ä‰∏™ `&mut T`ÔºåÂ¶ÇÊûúÊ≤°Êúâ‰∏∫ÂÆÉÊåáÂÆö‰∏Ä‰∏™ÁîüÂ≠òÂë®ÊúüÔºåÈÇ£‰πàÊàê‰∏∫ `'static` ÁîüÂ≠òÂë®ÊúüÂπ∂Èïø‰πÖÂú∞Âç†ÊçÆÁùÄÊüêÂùóÂÜÖÂ≠òÔºåËÄå‰∏î‰∏çËÉΩÈÄöËøá Drop ‰∏ªÂä®ËøõË°åÈáäÊîæ„ÄÇ

‰ª•‰∏ãÁ§∫ËåÉÔºåÂ≠óÁ¨¶‰∏≤ÂØπË±°Â¶Ç‰Ωï‰º†ÂÖ• drop_static ÂáΩÊï∞‰∏≠ÁªëÂÆö `'static` ÁîüÂëΩÂë®ÊúüÔºåÂπ∂‰ªéÂÜÖÂ≠ò‰∏≠ÈáäÊîæÔºö

```rust,ignore
#![allow(unused)]
use std::string::String;
use std::thread;
use std::time::Duration;
use rand;

fn drop_static<T: 'static>(t: T) {
    std::mem::drop(t);
}

fn main(){
    let mut strings: Vec<String> = Vec::new();
    for _ in 0..10_000_000 {
        if rand::random() {
            // all the strings are randomly generated
            // and dynamically allocated at run-time
            let string = rand::random::<u64>().to_string();
            strings.push(string);
        }
    }

    thread::sleep(Duration::from_secs(6));
    // strings are owned types so they're bounded by 'static
    for mut string in strings {
        // all the strings are mutable
        string.push_str("a mutation");
        // all the strings are droppable
        drop_static(string); // compiles
    }
    
    thread::sleep(Duration::from_secs(6));
    // all the strings have been invalidated before the end of the program
    println!("i am the end of the program");
}
```

ÂèòÈáè strings ÊòØ‰∏Ä‰∏™ÂêëÈáèÂàóË°® `Vec<String>`ÔºåÂÖ∂ÂÖÉÁ¥† `String` ÂØπË±°Âç†ÊçÆÂÜÖÂ≠òÂ§ßÂ∞èÂ§ßÊ¶Ç‰∏∫Ôºö

- String ÊòØËÉñÊåáÈíàÔºåÊåáÈíà 8 Â≠óËäÇÔºålen ÊàêÂëò usize 8 Â≠óËäÇÔºõ
- 8 Â≠óËäÇÂÜÖÂÆπÈïøÂ∫¶ÔºåÁî± u64 ËΩ¨Â≠óÁ¨¶ÁîüÊàêÁöÑ 8 Â≠óËäÇÂÜÖÂÆπÔºõ

Êåâ 1 ÂçÉ‰∏á‰∏™ÂÖÉÁ¥†ËÆ°ÁÆóÔºåÊÄªÂÜÖÂ≠òÂç†Áî® 240MB„ÄÇ

```rust,ignore
let o = vec![String::from("A"), String::from("B"), String::from("C")];
println!("{:p}", &o);    // 0x3bd8d7fa08
println!("{:p}", &o[0]); // 0x1f806a828d0
println!("{:p}", &o[1]); // 0x1f806a828e8
println!("{:p}", &o[2]); // 0x1f806a82900
```

### üü¢üîµ Struct ‰∏éÁîüÂëΩÂë®Êúü

‰ª•‰∏ãÁ§∫ËåÉÁªìÊûÑ‰ΩìÔºåÂíåÂÖÉÁªÑÂåñÁªìÊûÑ‰ΩìÂç≥Ê≤°ÊúâÊàêÂëòÂêçÁß∞ÁöÑÁªìÊûÑ‰ΩìÔºåÂ¶Ç‰Ωï‰ΩøÁî®ÁîüÂëΩÂë®ÊúüÂÆö‰πâÔºåÂæàÂáΩÊï∞‰∏≠‰ΩøÁî®ÁîüÂëΩÂë®ÊúüÂÆö‰πâÔºö

```rust,ignore
// A type `Borrowed` which houses a reference to an
// `i32`. The reference to `i32` must outlive `Borrowed`.
#[derive(Debug)]
struct Borrowed<'a>(&'a i32);

// Similarly, both references here must outlive this structure.
#[derive(Debug)]
struct NamedBorrowed<'a> {
    x: &'a i32,
    y: &'a i32,
}

// An enum which is either an `i32` or a reference to one.
#[derive(Debug)]
enum Either<'a> {
    Num(i32),
    Ref(&'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&x);
    let double = NamedBorrowed { x: &x, y: &y };
    let reference = Either::Ref(&x);
    let number    = Either::Num(y);

    println!("x is borrowed in {:?}", single);
    println!("x and y are borrowed in {:?}", double);
    println!("x is borrowed in {:?}", reference);
    println!("y is *not* borrowed in {:?}", number);
}
```

Âú®ÁªìÊûÑ‰Ωì‰∏≠‰ΩøÁî®ÁîüÂëΩÂë®ÊúüÂÆö‰πâÔºåÁõÆÁöÑÊòØ‰∏∫‰∫Ü‰øùËØÅÁªìÊûÑ‰ΩìÂÆû‰æãÁöÑÁîüÂëΩÂë®ÊúüÂ∫îËØ•Âíå‰ªªÊÑè‰∏Ä‰∏™ÊàêÂëòÁöÑÁîüÂëΩÂë®ÊúüÂÖ±Â≠òÔºåÂê¶ÂàôÊàêÂëòÁîüÂëΩÁªàÁªìËÄåÁªìÊûÑ‰ΩìËøòÂú®ÊòØÊ≤°ÊúâÊÑè‰πâÁöÑ„ÄÇ

ÂØπË±°ÊñπÊ≥ïÁöÑÁîüÂëΩÂë®ÊúüÊ†áÊ≥®Ôºö

```rust,ignore
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

ÂØπË±°ÊñπÊ≥ï‰∏≠‰ΩøÁî®ÁîüÂëΩÂë®ÊúüÂÆö‰πâÁöÑÊ†ºÂºè‰πü‰∏ÄÊ†∑Ôºå‰ª•‰∏ã‰æãÂ≠ê‰∏∫‰∫ÜÊºîÁ§∫ÊïàÊûúÔºåÂú®ÂÖÉÁªÑÂåñÁªìÊûÑ‰ΩìÁöÑÊñπÊ≥ï‰∏≠Ê∑ªÂä†ÁîüÂëΩÂë®ÊúüÊ≥®Ëß£ÔºåÂéªÊéâ‰πüÊòØÊ≠£Â∏∏ÁöÑÔºö

```rust,ignore
struct StructedTuple(i32);

impl StructedTuple {
    // Annotate lifetimes as in a standalone function.
    fn add_one<'a>(&'a mut self) { 
        self.0 += 1;
    }
    fn print<'a>(&'a self) {
        println!("`print`: {}", self.0);
    }
}

fn main() {
    let mut owner = StructedTuple(18);

    owner.add_one();
    owner.print();
}
```


### üü¢üîµ Trait ‰∏éÁîüÂëΩÂë®Êúü
- https://doc.rust-lang.org/rust-by-example/scope/lifetime/trait.html

Trait ÊòØ Rust ÊúÄÊúâÁâπËâ≤ÁöÑÁ±ªÂûãÊâ©Â±ïÊäΩË±°Á≥ªÁªüÔºåÂíå Golang interface Á±ª‰ººÔºåÂü∫‰∫éÁªÑÂêàÁöÑÊñπÂºè‰∏∫ÂêÑÁßçÁ±ªÂûãÁöÑÊèê‰æõÊâ©Â±ïÊñπÊ≥ï„ÄÇ

Âú®Á±ªÂûãÁ≥ªÁªü‰∏≠Ôºå‰ª•‰∏ã‰∏â‰∏™Â∫îËØ•ÂΩì‰∏âÁßç‰∏çÂêåÁöÑÁ±ªÂûãÊù•ÁúãÂæÖÔºö

- `T` Ë°®Á§∫Êã•Êúâ‰∏ªÊùÉÁöÑÁ±ªÂûãÔºõ
- `&T` Ë°®Á§∫ÂÖ±‰∫´ÂºïÁî®Á±ªÂûãÔºõ
- `&mut T` Ë°®Á§∫Áã¨ÊúâÂèØÂèòÂºïÁî®Á±ªÂûãÔºõ

ÂÆÉ‰ª¨ÈÉΩÊòØÊó†ÈôêÈõÜÔºåÂõ†‰∏∫ÂèØ‰ª•ÂÄüÁî®‰∏Ä‰∏™Á±ªÂûãÊó†ÈôêÊ¨°„ÄÇ`T` ÊòØÂÖ∂ÂÆÉ‰∏§‰∏™Ôºå`&T` Âíå `&mut T` ÁöÑË∂ÖÈõÜÔºå‰ΩÜÊòØ `&T` Âíå `&mut T` Ê≤°Êúâ‰∫§ÈõÜ„ÄÇ

Áî®‰ª•‰∏ã‰ª£Á†ÅÁâáÊÆµÂèØ‰ª•ËØÅÊòéÔºö

```rust,ignore
trait Trait {}

impl<T> Trait for T {}

// impl<T> Trait for &T {}
// ^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `& _`
// impl<T> Trait for &mut T {}
// ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&mut _`
```

Âè™Ë¶Å‰∏∫ `T` ÂÆûÁé∞‰∫Ü TraitÔºåÂ∞±Êó†Ê≥ïÂÜç‰∏∫ `&T` Âíå `&mut T` ÂÆûÁé∞ TraitÔºåÂÆÉ‰ª¨ÊòØÁ≠â‰ª∑ÁöÑÂÆûÁé∞„ÄÇ



ÂàóÂ¶ÇÔºå‰ª•‰∏ãÁ§∫ËåÉ‰∏≠ÂÆö‰πâ‰∫Ü‰∏Ä‰∏™ Borrowed ÁªìÊûÑ‰ΩìÔºåÂπ∂ÁªìÂêàÁîüÂëΩÂë®ÊúüÂÆö‰πâÔºå‰ª•Ê≠£Á°ÆÂ§ÑÁêÜ `x` ÊàêÂëòÁöÑÂºïÁî®ÁîüÂëΩÂë®Êúü„ÄÇ

```rust,ignore
// A struct with annotation of lifetimes.
#[derive(Debug)]
struct Borrowed<'a> {
    x: &'a i32,
}

// Annotate lifetimes to impl.
impl<'a> Default for Borrowed<'a> {
    fn default() -> Self {
        Self {
            x: &10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!("b is {:?}", b);
}
```

`#[derive(Debug)]` ÂÖÉÊï∞ÊçÆ‰ΩúÁî®ÊòØ‰∏∫ Borrowed ÂÆûÁé∞ÊâìÂç∞Ë∞ÉËØï‰ø°ÊÅØÔºåÂç≥‰∏∫Ê†ºÂºèÊ®°Êùø `{:?}` Â°´ÂÖÖÊï∞ÊçÆ„ÄÇ

Â¶ÇÊûú‰∏çÂÆö‰πâÁîüÂëΩÂë®ÊúüÂèàÊòØÊÄé‰πàÂõû‰∫ãÔºüÂõ†‰∏∫ÂÜÖÈÉ®ÊàêÂëò `a` ÊòØÂú® Borrowed ÂÜÖÈÉ®‰ΩúÁî®ÂüüÂÆö‰πâÁöÑÂºïÁî®ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂÆö‰πâ‰∏Ä‰∏™ÁîüÂëΩÂë®ÊúüÔºåÁºñËØëÂô®Ê†πÊçÆÊó†Ê≥ïÁÆ°ÁêÜÂÆÉÔºåÁõ∏ÂΩì‰∫éÊÇ¨Á©∫ÊåáÈíà„ÄÇ

Âú® Trait ÂèØ‰ª•‰ΩøÁî®ÈùôÊÄÅÁîüÂëΩÂë®ÊúüÂÆö‰πâÔºå‰ΩÜÊòØÊ≥®ÊÑèÔºåTrait bound ÂÆÉÊÑèÂë≥ÁùÄÁªëÂÆöÁ±ªÂûã‰∏çÂåÖÂê´‰ªª‰ΩïÈùûÈùôÊÄÅÂºïÁî®„ÄÇÊñπÊ≥ïÂÖ≥ËÅîÁöÑ receiver ÂèØ‰ª•ÊÉ≥ÊãøÂ§ö‰πÖÂ∞±ÊãøÂ§ö‰πÖÔºåÁõ¥Âà∞ÊâßË°å `drop()` ÊääÂÆÉÊîæ‰∏ãÔºåÂÆÉÊâçÂ§±Êïà„ÄÇ

ËøôÊòØÂæàÈáçË¶ÅÁöÑÊ¶ÇÂøµÔºåÂç≥ÊâÄÊúâÊùÉÊÄªÁ±ªÂûãÊòØÈÄöËøá `'static` ÁîüÂëΩÂë®ÊúüÁªëÂÆöÁöÑÔºå‰ΩÜÊòØÂºïÁî®ÈÄöÂ∏∏Âç¥‰∏çÊòØ„ÄÇ

```rust,ignore
use std::fmt::Debug;

fn print_it( input: impl Debug + 'static ) {
    println!( "'static value passed in is: {:?}", input );
}

fn main() {
    // i is owned and contains no references, thus it's 'static:
    let i = 5;
    print_it(i);

    // oops, &i only has the lifetime defined by the scope of
    // use_it(), so it's not 'static:
    print_it(&i);
}
```



## ‚ö° Functional OOP ÂáΩÊï∞ÂºèÈù¢ÂêëÂØπË±°ÁºñÁ®ã
- Functors, Applicatives, And Monads In Pictures https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
- ÂáΩÊï∞ÂºèÁºñÁ®ãÂà´ÁÉ¶ÊÅº https://juejin.cn/post/6844903621507678216
- ‰∏∫‰ªÄ‰πàLispËØ≠Ë®ÄÂ¶ÇÊ≠§ÂÖàËøõÔºü http://www.ruanyifeng.com/blog/2010/10/why_lisp_is_superior.html
- Object Oriented Programming Features of Rust https://doc.rust-lang.org/book/ch17-00-oop.html

ÁºñÁ®ãËåÉÂºè Programming paradigm ‰∏ÄËØçÊúÄÊó©Êù•Ëá™ Robert Floyd Âú® 1979 Âπ¥ÂõæÁÅµÂ•ñÁöÑÈ¢ÅÂ•ñÊºîËØ¥ÔºåÊòØÊåáËÆ°ÁÆóÊú∫‰∏≠ÁºñÁ®ãÁöÑÂÖ∏ËåÉÊ®°ÂºèÊàñÊñπÊ≥ï„ÄÇÊòØÁ®ãÂ∫èÂëòÁúãÂæÖÁ®ãÂ∫èÂ∫îËØ•ÂÖ∑ÊúâÁöÑËßÇÁÇπÔºå‰ª£Ë°®‰∫ÜÁ®ãÂ∫èËÆæËÆ°ËÄÖËÆ§‰∏∫Á®ãÂ∫èÂ∫îËØ•Â¶Ç‰ΩïË¢´ÊûÑÂª∫ÂíåÊâßË°åÁöÑÁúãÊ≥ïÔºå‰∏éËΩØ‰ª∂Âª∫Ê®°ÊñπÂºèÂíåÊû∂ÊûÑÈ£éÊ†ºÊúâÁ¥ßÂØÜÂÖ≥Á≥ª„ÄÇ

Áé∞Âú®‰∏ªÊµÅÁöÑÁºñÁ®ãËåÉÂºèÔºö

- `ÁªìÊûÑÂåñÁºñÁ®ã` Structured programming
- `Èù¢ÂêëÂØπË±°ÁºñÁ®ã` Object-oriented programming ÂÖ∏ÂûãÁöÑ Java Â∞±ÊòØÈù¢ÂêëÂØπË±°ÁºñÁ®ã„ÄÇ
- `ÂáΩÊï∞ÂºèÁºñÁ®ã` Functional programming ÂÖ∏ÂûãÁöÑ C ËØ≠Ë®ÄÂ∞±ÊòØÂáΩÊï∞ÂºèÁºñÁ®ã„ÄÇ
- `ÂëΩ‰ª§ÂºèÁºñÁ®ã` Imperative ‰∏ªË¶ÅÊÄùÊÉ≥ÊòØÂÖ≥Ê≥®ËÆ°ÁÆóÊú∫ÊâßË°åÁöÑÊ≠•È™§ÔºåÂç≥‰∏ÄÊ≠•‰∏ÄÊ≠•ÂëäËØâËÆ°ÁÆóÊú∫ÂÖàÂÅö‰ªÄ‰πàÂÜçÂÅö‰ªÄ‰πà„ÄÇ
- `Â£∞ÊòéÂºèÁºñÁ®ã` Declarative ÂÆÉÁöÑ‰∏ªË¶ÅÊÄùÊÉ≥ÊòØÂëäËØâËÆ°ÁÆóÊú∫Â∫îËØ•ÂÅö‰ªÄ‰πàÔºå‰ΩÜ‰∏çÊåáÂÆöÂÖ∑‰ΩìË¶ÅÊÄé‰πàÂÅö„ÄÇÁªèÂÖ∏ÁöÑ SQL ÁºñÁ®ãÂ∞±ÊòØ‰æãÂ≠êÔºå‰ª•Êï∞ÊçÆÁªìÊûÑÁöÑÂΩ¢ÂºèÊù•Ë°®ËææÁ®ãÂ∫èÊâßË°åÁöÑÈÄªËæë„ÄÇ

C++ Êàñ Rust ÂàôÊòØÂ§öËåÉÂºèÁöÑÁ≥ªÁªüÁºñÁ®ãËØ≠Ë®ÄÔºåÊó¢ÊòØ OOP ‰πüÊòØ FP„ÄÇ

ËÄå Golang Âíå Rust Êó¢ FP ÂèàÊòØ FOOPÔºåÂü∫‰∫éÂáΩÊï∞ÂºèÂíåÊäΩË±°Êé•Âè£ÁªÑÂêàÁöÑÈù¢ÂêëÂØπË±°ÁºñÁ®ãÔºåÈÄöËøá interface Êàñ traits ÂÖ≥ÈîÆÂ≠óÂÆö‰πâÊé•Âè£„ÄÇ

Èù¢ÂØπÂØπË±°ÔºàOOPÔºâÂèØ‰ª•ÁêÜËß£‰∏∫ÊòØÂØπÊï∞ÊçÆÁöÑÊäΩË±°ÔºåÊØîÂ¶ÇÊää‰∏Ä‰∏™‰∫∫ÊäΩË±°Êàê‰∏Ä‰∏™ ObjectÔºåÂÖ≥Ê≥®ÁöÑÊòØÊï∞ÊçÆ‰∏éË°å‰∏∫„ÄÇ

ÂáΩÊï∞ÂºèÁºñÁ®ãÊòØ‰∏ÄÁßçËøáÁ®ãÊäΩË±°ÁöÑÊÄùÁª¥ÔºåÂ∞±ÊòØÂØπÂΩìÂâçÁöÑÂä®‰ΩúÂéªËøõË°åÊäΩË±°ÔºåÂÖ≥Ê≥®ÁöÑÊòØÂä®‰Ωú„ÄÇ

Lisp ÊòØÊâÄÊúâÂáΩÊï∞ÂºèËØ≠Ë®ÄÁöÑÂßãÁ•ñÔºå‰ΩÜ Lisp Âπ∂‰∏çÂçïÁ∫ØÊòØÂáΩÊï∞ÂºèÁºñÁ®ãËØ≠Ë®ÄÔºåËÄåÊòØÂ§öËåÉÂûãÁºñÁ®ãËØ≠Ë®Ä„ÄÇ‰ΩøÁî®ÂÆÉÂèØ‰ª•ËøõË°åÂáΩÊï∞ÂºèÁºñÁ®ãÔºå‰πüÂèØ‰ª•ËøõË°åËøáÁ®ãÂºèÁºñÁ®ã„ÄÅÈù¢ÂêëÂØπË±°ÁºñÁ®ã„ÄÇ

Lisp ËØ≠Ë®ÄËØûÁîüÂ∏¶Êù• 9 ÁßçÊñ∞ÊÄùÊÉ≥Ôºö

- if-else Êù°‰ª∂ÁªìÊûÑÔºåËøôÂú®ÂΩìÊó∂ÊµÅË°åÁöÑ Fortran I Ê≤°ÊúâËøô‰∏™ÁªìÊûÑÔºåÂÆÉÂè™ÊúâÂü∫‰∫éÊú∫Âô®Êåá‰ª§ÁöÑ goto ÁªìÊûÑ„ÄÇ
- ÂáΩÊï∞ÊòØÊï∞ÊçÆÁ±ªÂûãÔºåÊúâËá™Â∑±ÁöÑÂ≠óÈù¢Ë°®Á§∫ÂΩ¢ÂºèÔºàliteral representationÔºâÔºåËÉΩÂ§üÂÇ®Â≠òÂú®ÂèòÈáè‰∏≠Ôºå‰πüËÉΩÂΩì‰ΩúÂèÇÊï∞‰º†ÈÄí„ÄÇ
- ÈÄíÂΩíÔºåLisp ÊòØÁ¨¨‰∏ÄÁßçÊîØÊåÅÈÄíÂΩíÂáΩÊï∞ÁöÑÈ´òÁ∫ßËØ≠Ë®Ä„ÄÇ
- ÂèòÈáèÁöÑÂä®ÊÄÅÁ±ªÂûãÔºåÂèòÈáèÊòØÊåáÈíàÔºåÂÖ∂ÊåáÂêëÁöÑÂÄºÊâçÊúâÁ±ªÂûã‰πãÂàÜÔºåÂ§çÂà∂ÂèòÈáèÁõ∏ÂΩìÂ§çÂà∂ÊåáÈíàÔºåËÄå‰∏çÊòØÂÖ∂ÊåáÂêëÁöÑÊï∞ÊçÆ„ÄÇ
- ÂûÉÂúæÂõûÊî∂Êú∫Âà∂„ÄÇ
- Á®ãÂ∫èÁî±Ë°®ËææÂºèÁªÑÊàêÔºåÊØè‰∏™Ë°®ËææÂºèÈÉΩËøîÂõû‰∏Ä‰∏™ÂÄºÔºåËøô‰∏éÂ§ßÂ§öÊï∞ËØ≠Ë®Ä‰∏çÂêåÔºåÂÆÉ‰ª¨ÁöÑÁ®ãÂ∫èÁî±Ë°®ËææÂºèÂíåËØ≠Âè•ÁªÑÊàê„ÄÇ

    Âå∫ÂàÜË°®ËææÂºèÂíåËØ≠Âè•ÔºåÂú® Fortran I ‰∏≠ÊòØÂæàËá™ÁÑ∂ÁöÑÔºåÂõ†‰∏∫ÂÆÉ‰∏çÊîØÊåÅËØ≠Âè•ÂµåÂ•ó„ÄÇÊâÄ‰ª•ÔºåÂ¶ÇÊûú‰Ω†ÈúÄË¶ÅÁî®Êï∞Â≠¶ÂºèÂ≠êËÆ°ÁÆó‰∏Ä‰∏™ÂÄºÔºåÈÇ£Â∞±Âè™ÊúâÁî®Ë°®ËææÂºèËøîÂõûËøô‰∏™ÂÄºÔºåÊ≤°ÊúâÂÖ∂‰ªñËØ≠Ê≥ïÁªìÊûÑÂèØÁî®ÔºåÂõ†‰∏∫Âê¶ÂàôÂ∞±Êó†Ê≥ïÂ§ÑÁêÜËøô‰∏™ÂÄº„ÄÇ

    ÂêéÊù•ÔºåÊñ∞ÁöÑÁºñÁ®ãËØ≠Ë®ÄÊîØÊåÅÂå∫ÂùóÁªìÊûÑÔºàblockÔºâÔºåËøôÁßçÈôêÂà∂ÂΩìÁÑ∂‰πüÂ∞±‰∏çÂ≠òÂú®‰∫Ü„ÄÇ‰ΩÜÊòØ‰∏∫Êó∂Â∑≤ÊôöÔºåË°®ËææÂºèÂíåËØ≠Âè•ÁöÑÂå∫ÂàÜÂ∑≤ÁªèÊ†πÊ∑±ËíÇÂõ∫„ÄÇÂÆÉ‰ªé Fortran Êâ©Êï£Âà∞ Algol ËØ≠Ë®ÄÔºåÊé•ÁùÄÂèàÊâ©Êï£Âà∞ÂÆÉ‰ª¨‰∏§ËÄÖÁöÑÂêéÁªßËØ≠Ë®Ä„ÄÇ

- Á¨¶Âè∑Á±ªÂûã symbol ÂÆÉÂÆûÈôÖ‰∏äÊòØ‰∏ÄÁßçÊåáÈíàÔºåÊåáÂêëÂÇ®Â≠òÂú®ÂìàÂ∏åË°®‰∏≠ÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÊåáÈíàÂú∞ÂùÄÂèØ‰ª•ÊØîËæÉ‰∏§‰∏™Á¨¶Âè∑ÊòØÂê¶Áõ∏Á≠â„ÄÇ
- ‰ª£Á†Å‰ΩøÁî®Á¨¶Âè∑ÂíåÂ∏∏ÈáèÁªÑÊàêÁöÑÊ†ëÂΩ¢Ë°®Á§∫Ê≥ïÔºànotationÔºâ„ÄÇ
- Êó†ËÆ∫‰ªÄ‰πàÊó∂ÂÄôÔºåÊï¥‰∏™ËØ≠Ë®ÄÈÉΩÊòØÂèØÁî®ÁöÑ„ÄÇLisp Âπ∂‰∏çÁúüÊ≠£Âå∫ÂàÜËØªÂèñÊúü„ÄÅÁºñËØëÊúüÂíåËøêË°åÊúü„ÄÇ

    Âú®ËØªÂèñÊúüËøêË°å‰ª£Á†ÅÔºå‰ΩøÂæóÁî®Êà∑ÂèØ‰ª•ÈáçÊñ∞Ë∞ÉÊï¥ Lisp ÁöÑËØ≠Ê≥ïÔºõ
    Âú®ÁºñËØëÊúüËøêË°å‰ª£Á†ÅÔºåÂàôÊòØ Lisp ÂÆèÁöÑÂ∑•‰ΩúÂü∫Á°ÄÔºõ
    Âú®ËøêË°åÊúüÁºñËØë‰ª£Á†ÅÔºå‰ΩøÂæó Lisp ÂèØ‰ª•Âú® Emacs ËøôÊ†∑ÁöÑÁ®ãÂ∫è‰∏≠ÔºåÂÖÖÂΩìÊâ©Â±ïËØ≠Ë®ÄÔºõ
    Âú®ËøêË°åÊúüËØªÂèñ‰ª£Á†ÅÔºå‰ΩøÂæóÁ®ãÂ∫è‰πãÈó¥ÂèØ‰ª•Áî® S-expression ÈÄö‰ø°ÔºåËøëÊù• XML Ê†ºÂºèÁöÑÂá∫Áé∞‰ΩøÂæóËøô‰∏™Ê¶ÇÂøµË¢´ÈáçÊñ∞"ÂèëÊòé"Âá∫Êù•‰∫Ü„ÄÇ

Á∫ØÂáΩÊï∞ÊòØ‰∏Ä‰∏™ÈáçË¶ÅÁöÑÊ¶ÇÂøµÔºö

- ÂÆö‰πâÔºö‰∏Ä‰∏™ÂáΩÊï∞Â¶ÇÊûúËæìÂÖ•ÂèÇÊï∞Á°ÆÂÆöÔºåËæìÂá∫ÁªìÊûúÊòØÂîØ‰∏ÄÁ°ÆÂÆöÁöÑÔºå‰∏çÂØπÂ§ñÈÄ†ÊàêÂΩ±ÂìçÔºåÈÇ£‰πà‰ªñÂ∞±ÊòØÁ∫ØÂáΩÊï∞„ÄÇ
- ÁâπÁÇπÔºöÊó†Áä∂ÊÄÅÔºåÊó†ÂâØ‰ΩúÁî®ÔºåÊó†ÂÖ≥Êó∂Â∫èÔºåÂπÇÁ≠âÔºàÊó†ËÆ∫Ë∞ÉÁî®Â§öÂ∞ëÊ¨°ÔºåÁªìÊûúÁõ∏ÂêåÔºâ„ÄÇ

ÂèÇËÄÉÔºö

    function pureAdd(x, y){
       return x + y
    }

    let sum = 0;
    function notPureAdd(){
        sum++
    }

ÂáΩÊï∞ÊüØÈáåÂåñ curry ÊòØÂáΩÊï∞ÊèêÁ∫ØÁöÑ‰∏ÄÁßçÊñπÊ≥ïÔºåÂÆÉÂ∞ÅË£ÖÂéüÂáΩÊï∞ÔºåÂÆûÁé∞Âè™ÁªôÂÆÉ‰º†ÈÄí‰∏ÄÈÉ®ÂàÜÂèÇÊï∞Êù•Ë∞ÉÁî®ÂÆÉÔºåËøîÂõû‰∏Ä‰∏™ÂáΩÊï∞ÂéªÂ§ÑÁêÜÂâ©‰∏ãÁöÑÂèÇÊï∞„ÄÇ

‰æãÂ¶ÇÔºåÂ∞Ü‰∏äÈù¢ÁöÑ pureAdd ÂáΩÊï∞ÊüØÈáåÂåñÔºö

    function adder(y) {
       return function (x) { 
        return x + y;
       }; 
    }
    var addMore =  adder(2)(1)  

Â§çÊùÇ‰∏ÄÁÇπÁöÑÂáΩÊï∞ÊèêÁ∫ØÁ§∫ËåÉÔºö

    function change (fn , els , color){
        Array.from(els).map((item)=>(fn(item, color)))
    }

    function changeCurry(fn){
        return function(els, color){
            Array.from(els).map((item)=>(fn(item,color)))
        }
    }

ÁªèÂÖ∏ÂáΩÊï∞ÂºèÁºñÁ®ãÈÄöÂ∏∏ÊòØ‰∏ãÈù¢ËøôÊ†∑Ôºö

    function double(x) {
      return x * 2
    }
    function add5(x) {
      return x + 5
    }

    var a = double(add5(1))

ËΩØ‰ª∂ÊúÄÂü∫Êú¨ÁöÑÊï∞ÊçÆÔºåÂ∞±ÊòØÂêÑÁßçÂÄº valueÔºåÂ¶ÇÊûú‰ª•Êï∞ÊçÆ‰∏∫Ê†∏ÂøÉÔºå‰∏Ä‰∏™Âä®‰Ωú‰∏Ä‰∏™Âä®‰ΩúÂéªÊâßË°åÔºö

    (5).add5().double()

ÊòæÁÑ∂ÔºåÂ¶ÇÊûúËÉΩËøôÊ†∑ÊâßË°åÂáΩÊï∞ÁöÑËØùÔºåÂ∞±ËàíÊúçÂ§öÂï¶„ÄÇ

‰∏∫‰∫ÜÂÆûÁé∞ËøôÊ†∑ÁöÑËØ≠Ê≥ïÁªìÊûÑÔºåÈ¶ñÂÖàË¶ÅÂ∞ÜÊï∞ÊçÆÂΩì‰Ωú‰∏Ä‰∏™ÂØπË±°Êù•Â§ÑÁêÜÔºåÂõ†‰∏∫Ë¶ÅÊåÇËΩΩÊñπÊ≥ï„ÄÇ

ËøôÈáåÁõ¥Êé•ÂáΩÂ≠ê Functor ÁöÑÂÆûÁé∞Ôºö

    class Functor{
        constructor (value) {
           this.value = value ;
        }
        map (fn) {
          return Functor.of(fn(this.value))
        }
    }
    Functor.of = function (val) {
        return new Functor(val);
    }

    Functor.of(5).map(add5).map(double);

Functor ÈÄöËøá map ÊñπÊ≥ïÂÆûÁé∞ÊñπÊ≥ïÁÆ°ÁêÜÂÆπÂô®ÔºåÊØè‰∏Ä‰∏™ÂÄºÂ§ÑÁêÜÊâ£ÂèàÊò†Â∞ÑÂà∞Âè¶‰∏Ä‰∏™ÂÆπÂô®„ÄÇ

ÂáΩÊï∞ÂºèÁºñÁ®ãÈáåÈù¢ÁöÑËøêÁÆóÔºåÈÉΩÊòØÈÄöËøáÂáΩÂ≠êÂÆåÊàêÔºåÂç≥ËøêÁÆó‰∏çÁõ¥Êé•ÈíàÂØπÂÄºÔºåËÄåÊòØÈíàÂØπÁÆ°ÁêÜËøô‰∏™ÂÄºÁöÑÂÆπÂô®ÔºåËøô‰∏™ÂÆπÂô®‰πüÂèØ‰ª•Áß∞‰∏∫‰∏ä‰∏ãÊñπ„ÄÇ

Haskell ËØ≠Ë®Ä‰∏≠ÁöÑ Functors, Applicatives, Monads, Arrows Á≠âÁ≠âÈÉΩÂü∫‰∫éÊ≠§ÂéüÁêÜ„ÄÇ

    class Maybe{
           constructor (value) {
              this.value = value ;
           }      
           map (fn) {
              return this.value ? Maybe.of(fn(this.value)) : Maybe.of(null);
           }
        }
    Maybe.of = function (val) {
         return new Maybe(val);
    }

    var a = Maybe.of(null).map(function (s) {
      return s.toUpperCase();
    });

Âè™ÈúÄË¶ÅÊääÂú®‰∏≠ËÆæÁΩÆ‰∏Ä‰∏™Á©∫ÂÄºËøáÊª§ÔºåÂ∞±ÂèØ‰ª•ÂÆåÊàêËøôÊ†∑‰∏Ä‰∏™ Maybe ÂáΩÂ≠ê„ÄÇÊâÄ‰ª•ÂêÑÁßç‰∏çÂêåÁ±ªÂûãÁöÑÂáΩÂ≠êÔºå‰ºöÂÆåÊàê‰∏çÂêåÁöÑÂäüËÉΩ„ÄÇ

ÊØè‰∏™ÂáΩÂ≠êÂπ∂Ê≤°ÊúâÁõ¥Êé•ÂéªÊìç‰ΩúÈúÄË¶ÅÂ§ÑÁêÜÁöÑÊï∞ÊçÆÔºå‰πüÊ≤°ÊúâÂèÇ‰∏éÂà∞Â§ÑÁêÜÊï∞ÊçÆÁöÑÂáΩÊï∞‰∏≠Êù•ÔºåËÄåÊòØÂú®Ëøô‰∏≠Èó¥ÂÅö‰∫Ü‰∏Ä‰∫õÊã¶Êà™ÂíåËøáÊª§ÔºåËøôÂíåÈ´òÈò∂ÂáΩÊï∞ÊúâÁÇπÂÉè„ÄÇ

Áé∞Âú®Êàë‰ª¨Â∞±Áî®ÂáΩÊï∞ÂºèÁºñÁ®ãÂÅö‰∏Ä‰∏™Â∞èÁªÉ‰π†Ôºö Êàë‰ª¨Êúâ‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÔºåÂ∏åÊúõÂ§ÑÁêÜÊàêÂ§ßÂÜôÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÁÑ∂ÂêéÂä†ËΩΩÂà∞ÊåáÂÆö id ÁöÑ HTML ËäÇÁÇπ‰∏ä„ÄÇ

    let $ = id => Maybe.of(document.getElementById(id));
    class Maybe{
       constructor(value){
            this.value = value;   
       }
       map(fn){
        return this.value ? Maybe.of(fn(this.value)) : Maybe.of(null);
       }
       static of(value){
          return new Maybe(value);
       }
    }
    let toUpperCase = str => str.toUpperCase();
    let html = id => content => {
       $(id).map(dom => {
          return (dom.innerHTML = content);
       });
    };

    Maybe.of(str).map(toUpperCase).map(html('text'));

Ê≥®ÊÑè `html()` ÂáΩÊï∞ÂµåÂ•óÁªìÊûÑÔºö

- Â¶ÇÊûúÂè™Âú®ÈáåÈù¢Âä† return contentÔºåÂ§ñÈù¢ÂáΩÊï∞Âπ∂Ê≤°ÊúâËøîÂõûÂÄºÔºõ
- Â¶ÇÊûúÂè™Âú®Â§ñÈù¢Âä† returnÔºå‰πüÂèñ‰∏çÂà∞ contentÔºõ
- ÂµåÂ•óÂáΩÊï∞ÈÉΩÂä† return ËøôÂ∞±Âá∫Áé∞‰∫Ü Maybe.of( Maybe.of(str) ) ÂµåÂ•óÁªìÊûÑÔºõ

Monad ÂáΩÂ≠êÁöÑÂäüËÉΩÊØîËæÉÈáçË¶ÅÔºåÂΩìÈúÄË¶ÅÂ§ÑÁêÜÁöÑÊï∞ÊçÆÊòØ Maybe¬†{value: Maybe} ËøôÊ†∑ÁöÑÂµåÂ•óÁªìÊûÑÔºåÂèØ‰ª•Âä†‰∏Ä‰∏™ `join()` ÊñπÊ≥ïÊù•ËøîÂõû valueÔºåÊàñËÄÖÁõ¥Êé•Êèê‰æõ `chain()` ÊñπÊ≥ïÂú®ÊâßË°åÊó∂Áõ¥Êé•ÊâßË°å `map()` + `join()` ‰∏§‰∏™Ê≠•È™§„ÄÇ

    class Maybe{
       constructor (value) {
          this.value = value ;
       }      
       map (fn) {
          return this.value ? Maybe.of(fn(this.value)) : Maybe.of(null);
       }
       join ( ){
          return this.value;
       }
       chain(fn) {
          return this.map(fn).join();
       }
       static of(value){
          return new Maybe(value);
       }
    }

    Maybe.of(str).map(toUpperCase).chain(html('text'));

ËøôÊ†∑ÂéªÊéâ‰∏ÄÂ±ÇÂµåÂ•óÁöÑÂáΩÂ≠êÔºåËøîÂõûÁöÑÂ∞±ÊòØÂè™Êúâ‰∏ÄÂ±ÇÂµåÂ•óÁöÑÂáΩÂ≠êÂï¶„ÄÇ


### üü¢üîµ Functions ÂáΩÊï∞
- https://doc.rust-lang.org/book/ch03-03-how-functions-work.html
- https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html
- Rust by Example - Functions https://doc.rust-lang.org/stable/rust-by-example/fn.html
- https://cheats.rs/#functions-behavior
- Functional Language Features: Iterators & Closures https://doc.rust-lang.org/book/ch13-00-functional-features.html

Rust ÁöÑÂáΩÊï∞Âíå C++ ÁöÑÂü∫Êú¨ÁªìÊûÑÂæàÁõ∏‰ººÔºåËØ≠Ê≥ï‰∏äËøòÊòØÊúâ‰∫õÂ∑ÆÂà´ÁöÑ„ÄÇ

ÂáΩÊï∞‰ΩøÁî®ÊñπÂºèÂ¶Ç‰∏ãÔºö

- Function Áã¨Á´ãÂáΩÊï∞Ôºõ
- Methods ‰Ωú‰∏∫ÂØπË±°ÊñπÊ≥ïÔºåÂç≥ÈôÑÂä†Âà∞ÂØπË±°ÁöÑÂáΩÊï∞Ôºõ
- Closures ‰Ωú‰∏∫Èó≠ÂåÖ‰ΩøÁî®ÔºåËøôÊòØ Rust ‰∏≠ËæÉÂ§çÊùÇÁöÑÂäüËÉΩÔºõ
- Higher Order Functions È´òÈò∂ÂáΩÊï∞ÔºåÂáΩÊï∞‰Ωú‰∏∫ÂèÇÊï∞Âπ∂ËøîÂõû‰∏Ä‰∏™ÂáΩÊï∞Ôºå‰ªÖ‰ªÖÂä†‰∏™Â£≥Ôºõ
- Diverging functions ÂèëÊï£ÂáΩÊï∞ÔºåÂç≥Ê≤°ÊúâËøîÂõûÁöÑÂáΩÊï∞Ôºå‰πüÂè´ Never ! Á±ªÂûãÔºåÂ¶Ç‰∏Ä‰∏™ÂáΩÊï∞ÊâßË°åÈîôËØØ panicÔºõ

È¶ñÂÖàÔºåÊòØÂáΩÊï∞Â£∞Êòé‰∏≠Ôºå‰ΩøÁî® `->` Á¨¶Âè∑Ë°®Á§∫ÊúâËøîÂõûÂÄºÔºåÊ≤°ÊúâËøîÂõûÂÄºÁöÑÂáΩÊï∞‰∏çÁî®Ëøô‰∏™Á¨¶Âè∑„ÄÇ

ÂÖ∂Ê¨°ÔºåËøîÂõûÂÄºÁöÑÊñπÂºè‰∏çÂêå„ÄÇ‰æãÂ¶ÇÔºåËøîÂõûÂÄºÂèØ‰ª•‰ΩøÁî® `return` ËØ≠Âè•Ôºå‰πüÂèØ‰ª•‰ΩøÁî® `tail return` ËøîÂõûÂÄºÔºåÂç≥ÂáΩÊï∞‰ΩìÊúÄÂêé‰∏ÄË°åÔºåÊ≤°ÊúâË°åÊú´ÂàÜÂè∑„ÄÇ

Âè¶Â§ñÔºåRust Ëä±Êã¨Âè∑ËØ≠Âè•Âùó‰πüÂèØ‰ª•ÊúâËøîÂõûÂÄºÔºåÂÆÉÊòØ‰∏Ä‰∏™ÂÆåÊï¥ÁöÑ‰ΩúÁî®ÂüüÔºåÈÄöËøá `tail return` ËøîÂõû‰∏Ä‰∏™ÂÄºÔºåÊ≥®ÊÑè‰∏çËÉΩÂä†Êú´Â∞æÁöÑÂàÜÂè∑„ÄÇ

```rust,ignore
 fn main() {
    let x = plus_one(5);

    let y = {
        let x = 3;
        x + 1
    };
    println!("The value of x is: {} and y is: {}", x, y);

    let guess: u32 = "42".parse().expect("Not a number!");
    println!("guess {}", guess);
}

fn plus_one(x: i32) -> i32 {
    return x + 1;
    // x + 1
}
```

Âè¶Â§ñÔºå`println!()` ÊòØ‰∏Ä‰∏™ÂÆèÔºåËÄå‰∏çÊòØÂáΩÊï∞ÔºåÂå∫ÂàÜÂáΩÊï∞ÂíåÂÆèÁöÑÂîØ‰∏ÄÂäûÊ≥ïÔºåÂ∞±ÊòØÁúãÂêçÁß∞ÊúÄÂêéÊúâÊ≤°ÊúâÊÑüÂèπÂè∑„ÄÇ

Âú®Êï∞Â≠¶ÂíåËÆ°ÁÆóÊú∫ÁßëÂ≠¶‰∏≠ÔºåÈ´òÈò∂ÂáΩÊï∞ÊòØËá≥Â∞ëÂÖ∑Êúâ‰∏ãÂàóÂäüËÉΩ‰πã‰∏ÄÁöÑÂáΩÊï∞ÔºåÂÖ∂‰ªñÊâÄÊúâÂáΩÊï∞ÈÉΩÊòØ‰∏ÄÈò∂ÂáΩÊï∞Ôºö

- Â∞Ü‰∏Ä‰∏™ÊàñÂ§ö‰∏™ÂáΩÊï∞‰Ωú‰∏∫ÂèÇÊï∞„ÄÇ
- ËøîÂõû‰∏Ä‰∏™ÂáΩÊï∞‰Ωú‰∏∫ÁªìÊûú„ÄÇ

È´òÈò∂ÂáΩÊï∞Êää‰º†ÂÖ•ÁöÑÂáΩÊï∞ÂÅö‰∏Ä‰∏™Â∞ÅË£ÖÔºåÁÑ∂ÂêéËøîÂõûËøô‰∏™Â∞ÅË£ÖÂáΩÊï∞ÔºåËææÂà∞Êõ¥È´òÁ®ãÂ∫¶ÁöÑÊäΩË±°„ÄÇ

Âú®Êï∞Â≠¶‰∏≠ÔºåÈ´òÈò∂ÂáΩÊï∞‰πüÁß∞‰∏∫`ÁÆóÂ≠ê`Êàñ`Ê≥õÂáΩ`„ÄÇÂæÆÁßØÂàÜ‰∏≠ÁöÑÂæÆÂàÜÁÆóÂ≠êÊòØ‰∏Ä‰∏™ÂæàÂ∏∏ËßÅÁöÑ‰æãÂ≠êÔºåÂõ†‰∏∫ÂÆÉÊää‰∏Ä‰∏™ÂáΩÊï∞Êò†Â∞ÑÂà∞ÂÆÉÁöÑÂØºÊï∞Ôºå‰πüÊòØ‰∏Ä‰∏™ÂáΩÊï∞„ÄÇ

ÊôÆÈÅçÁöÑÈ´òÈò∂ÂáΩÊï∞Â∫îÁî®‰æãÂ≠êÔºö

- map ÂáΩÊï∞Âú®ËÆ∏Â§öÂáΩÊï∞ÂºèÁºñÁ®ãËØ≠Ë®Ä‰∏≠ÈÉΩÊúâÔºåÂÆÉÊòØÈ´òÈò∂ÂáΩÊï∞ÁöÑ‰∏Ä‰∏™‰æãÂ≠ê„ÄÇÂÆÉÊé•Âèó‰∏Ä‰∏™ÂáΩÊï∞ f Âíå‰∏Ä‰∏™ÂÖÉÁ¥†ÂàóË°®‰Ωú‰∏∫ÂèÇÊï∞ÔºåÁªìÊûúËøîÂõû‰∏Ä‰∏™Êñ∞ÂàóË°®ÔºåÂÖ∂‰∏≠fÂ∫îÁî®‰∫éÂàóË°®‰∏≠ÁöÑÊØè‰∏™ÂÖÉÁ¥†„ÄÇ
- ÊéíÂ∫èÂáΩÊï∞ÔºåÂÆÉÂ∞ÜÊØîËæÉÂáΩÊï∞‰Ωú‰∏∫ÂèÇÊï∞ÔºåÂÖÅËÆ∏Á®ãÂ∫èÂëòÂ∞ÜÊéíÂ∫èÁÆóÊ≥ï‰∏éÊ≠£Âú®ÊéíÂ∫èÁöÑÈ°πÁöÑÊØîËæÉÂàÜÂºÄ„ÄÇCÊ†áÂáÜÂáΩÊï∞qsortÂ∞±ÊòØ‰∏Ä‰∏™‰æãÂ≠ê„ÄÇ
- fold Êàñ reduce
- Function composition
- Integration
- Callback
- Tree traversal

‰ª•‰∏ãÁî®‰∏§ÁßçÊñπÂºèÁºñÁ®ãÂÆûÁé∞ 1000 ‰ª•ÂÜÖÁöÑÂÅ∂Êï∞Âπ≥ÊñπÂíåÔºö

```rust,ignore
fn is_odd(n: u32) -> bool {
    n % 2 == 1
}

println!("Find the sum of all the squared odd numbers under 1000");
let upper = 1000;

// Imperative approach
let mut acc = 0;
// Iterate: 0, 1, 2, ... to infinity
for n in 0.. {
    let n_squared = n * n;

    if n_squared >= upper {
        break;
    } else if is_odd(n_squared) {
        acc += n_squared;
    }
}
println!("imperative style: {}", acc);

// Functional approach
let sum_of_squared_odd_numbers: u32 =
    (0..).map(|n| n * n)                             // All natural numbers squared
         .take_while(|&n_squared| n_squared < upper) // Below upper limit
         .filter(|&n_squared| is_odd(n_squared))     // That are odd
         .fold(0, |acc, n_squared| acc + n_squared); // Sum them
println!("functional style: {}", sum_of_squared_odd_numbers);
```

ÂæóÁõä‰∫é lazy iteratorsÔºå‰∏äÈù¢ÂáΩÊï∞ÂºèÂÆûÁé∞‰∏≠ÔºåËôΩÁÑ∂Áªô `map()` `take_while()` `filter()` ËøôÁ±ªÊñπÊ≥ïÈÉΩ‰º†ÂÖ•‰∫Ü‰∏Ä‰∏™Èó≠ÂåÖÔºå‰ΩÜÊòØÂÆÉÂπ∂Ê≤°ÊúâÂØπÊâÄÊúâËá™ÁÑ∂Êï∞ÈÉΩÊâßË°å‰∏ÄÈÅçÔºåËÄåÊòØÂú®ÊâßË°å `fold()` Ê±ÇÂÄºÊó∂ÊâçÂºÄÂßãÂ§ÑÁêÜ„ÄÇ

Âú® Rust ‰∏≠Ê∞∏Ëøú‰∏çËøîÂõûÁöÑÂáΩÊï∞‰πüÊúâÁ±ªÂûãÔºåNever Á±ªÂûãÁî®ÊÑüÂèπÂè∑Ë°®Á§∫ÔºåÂ¶ÇÂåÖÂê´Êó†ÈôêÂæ™ÁéØ `loop {}`ÔºåÊàñËÄÖ panicÔºö

```rust,ignore
#![feature(never_type)]
fn panic() -> ! {
    panic!("This call never returns.");
}

fn main() {
    let a = panic();
    println!("Programme panic and you can‚Äòt see this line.");
    let x: ! = panic!("This call never returns.");
    println!("You will never see this line!");
}
```



### üü¢üîµ FOOP ÂáΩÊï∞ÂºèÈù¢ÂêëÂØπË±°ÁºñÁ®ã
- https://cheats.rs/#functions-behavior
- Object Oriented Programming Features of Rust https://doc.rust-lang.org/book/ch17-00-oop.html
- Design Patterns: Elements of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides
- What Was the Gang of Four in China? https://www.thoughtco.com/the-gang-of-four-195613
- Rust by Example - Traits https://doc.rust-lang.org/rust-by-example/trait.html
- Abstraction without overhead: traits in Rust https://blog.rust-lang.org/2015/05/11/traits.html
- Dynamically Sized Types and the Sized Trait https://doc.rust-lang.org/book/ch19-04-advanced-types.html

Design Patterns: Elements of Reusable Object-Oriented Software Âç≥„ÄäËÆæËÆ°Ê®°Âºè„Äã‰∏Ä‰π¶Áî± Erich Gamma„ÄÅRichard Helm„ÄÅRalph Johnson Âíå John Vlissides ÂêàËëóÔºàAddison-WesleyÔºå1995Ôºâ„ÄÇËøôÂá†‰Ωç‰ΩúËÄÖÂ∏∏Ë¢´Áß∞‰∏∫Âõõ‰∫∫ÁªÑÔºåËÄåËøôÊú¨‰π¶‰πüÂ∞±Ë¢´Áß∞‰∏∫ the Gang of Four Book Êàñ GoF„ÄÇ

Á§∫ËåÉÂ∞ÜÂáΩÊï∞ÈôÑÂä†Âà∞ÂØπË±°‰∏ä‰Ωú‰∏∫ÊñπÊ≥ï‰ΩøÁî®Ôºö

```rust,ignore
struct Point { x: f64, y: f64, }

// Implementation block, all `Point` methods go in here
impl Point {
    // This is a static method used as constructors
    fn origin() -> Point {
        Point { x: 0.0, y: 0.0 }
    }

    fn new(x: f64, y: f64) -> Point {
        Point { x: x, y: y }
    }
}

struct Rectangle { p1: Point, p2: Point, }

impl Rectangle {
    // This is an instance method
    // `&self` is sugar for `self: &Self`, where `Self` is the type of the
    // caller object. In this case `Self` = `Rectangle`
    fn area(&self) -> f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&self) -> f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // This method requires the caller object to be mutable
    // `&mut self` desugars to `self: &mut Self`
    fn translate(&mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` owns resources: two heap allocated integers
struct Pair(Box<i32>, Box<i32>);

impl Pair {
    // This method "consumes" the resources of the caller object
    // `self` desugars to `self: Self`
    fn destroy(self) {
        // Destructure `self`
        let Pair(first, second) = self;

        println!("Destroying Pair({}, {})", first, second);

        // `first` and `second` go out of scope and get freed
    }
}

fn main() {
    let rectangle = Rectangle {
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Instance methods are called using the dot operator
    // Note that the first argument `&self` is implicitly passed, i.e.
    // `rectangle.perimeter()` === `Rectangle::perimeter(&rectangle)`
    println!("Rectangle perimeter: {}", rectangle.perimeter());
    println!("Rectangle area: {}", rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Error! `rectangle` is immutable
    //rectangle.translate(1.0, 0.0);

    // Okay! Mutable objects can call mutable methods
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));
    pair.destroy();

    // Error! Previous `destroy` call "consumed" `pair`
    // pair.destroy();
    // TODO ^ Try uncommenting this line
}
```

Ë¶ÅÁÇπÔºö

- ‰ΩøÁî® `struct` ÂÆö‰πâÁªìÊûÑ‰ΩìÔºõ
- ‰ΩøÁî® `impl` ‰∏∫ÁªìÊûÑ‰ΩìÂÆûÁé∞ÊñπÊ≥ïÔºõ
- ÊñπÊ≥ïÂèÇÊï∞‰∏≠Á¨¨‰∏Ä‰∏™ÂèØ‰ª•ÂÆö‰πâ Self Á±ªÂûãÔºåÂπ∂‰∏îÂëΩÂêç‰∏∫ self Ë°®Á§∫‰∏Ä‰∏™ÊàêÂëòÊñπÊ≥ïÔºåÂê¶ÂàôË°®Á§∫‰∏Ä‰∏™ static ÊñπÊ≥ïÔºõ
- Âè¶Â§ñÔºåËøòËÉΩÈÄöËøá `Box<i32>` Êù•ÊºîÁ§∫Â¶Ç‰Ωï‰ΩøÁî® Heap ÂÜÖÂ≠òÊù•ÁºñÁ®ãÔºõ

Rust ‰∏∫ÊàêÂëòÊñπÊ≥ïÂÆö‰πâ self Êèê‰æõ‰∫ÜÁÆÄÂÜôË°®ËææÔºö

- `self` desugars to `self: Self`
- `&mut self` desugars to `self: &mut Self`
- `&self` is sugar for `self: &Self`


### üü¢üîµ Traits & Polymorphism

Rust ÁöÑÁ±ªÂûãÁ≥ªÁªüÂü∫‰∫éÁªÑÂêàÊÄùÁª¥Ôºå‰∏çÂÉè C++/Java ÈÄöËøáÁ±ªÊù•ÂåÖË£ÖÔºåÁªÑÂêàÊñπÂºèÊòØÂáΩÊï∞ÂºèÁºñÁ®ã‰∏≠ÂÆûÁé∞Èù¢ÂêëÂØπË±°ÁºñÁ®ãÁöÑ‰∏ÄÁßçÊúâÊïàÊâãÊÆµ„ÄÇÂπ∂‰∏îÔºåÁªÑÂêàÊñπÂºèÊØîÁ±ªÂ∞ÅË£ÖÁªßÊâøÊñπÂºèÊõ¥ËÉΩË°®ËææÁúüÂÆû‰∏ñÁïå„ÄÇ

ÊØîÂ¶ÇÔºåÁúüÂÆû‰∏ñÁïå‰∏≠ÁöÑÈ∏üÁ±ªÔºåÂÆÉ‰ºöÈ£ûÔºåÈÇ£‰πàÂÆö‰πâÁ±ªÔºö

    class Bird {
        void fly(){}
    }
    class BlankSwan extends Bird {
        void fly(){ ... }
    }

ÂΩìÈúÄË¶ÅË°®ËææÈ∏µÈ∏üËøôÁßç‰∏ç‰ºöÈ£ûÁöÑÈ∏üÊó∂ÔºåÂ∞±ÈúÄË¶ÅÂ•ΩÂ•ΩËÆæËÆ°‰∏Ä‰∏ãÁ±ªÁöÑÁªßÊâøÂÖ≥Á≥ª‰∫Ü„ÄÇ

‰ΩÜÊòØÔºå‰ΩøÁî®ÁªÑÂêàÊñπÂºèÔºåÂ∞±‰∏çÂ≠òÂú®ËøôÁßçÁªßÊâøÁ∫¶ÊùüÔºå‰∏çÁªôÈ∏µÈ∏üÂÆûÁé∞ `fly()` ÊñπÊ≥ïÂ∞±Ë°å‰∫ÜÔºåÊàñËÄÖ‰ΩøÁî® Flyable Trait Êù•Ë°®Ëææ‰ºöÈ£ûÁöÑÈ∏üÔºåÊà™Ëá≥ÊòØ‰∏çÊòØÈ∏üÁ±ªÁöÑËùôËù†„ÄÇ

ËøôÁßçÂü∫‰∫éÁªÑÂêàÊÄùÁª¥ÁöÑÈù¢ÂêëÂØπË±°ÁºñÁ®ã FOOP - Functional Object-Oriented Programming ÊòØÈùûÂ∏∏ÁÅµÊ¥ªÁöÑÂÆûÁé∞ÔºåÂπ∂‰∏îÊ≤°Êúâ C++ ÈÇ£Ê†∑Â§çÊùÇÂÜÖÂ≠òÊ®°Âûã„ÄÇ

ÈÄöËøáÁªÑÂêà‰∏éÂáΩÊï∞ÂºèÁºñÁ®ãÔºåRust ÂæàÂ•ΩÂú∞ÂÆûË∑µ‰∫ÜÈù¢ÂêëÂØπË±°ÁöÑ‰∏âÂ§ßÂéüÂàôÔºåCharacteristics of Object-Oriented LanguagesÔºö

- Encapsulation that Hides Implementation Details, Objects Contain Data and Behavior
- Inheritance as a Type System and as Code Sharing
- Polymorphism Â§öÊÄÅÊÄßÂØπËÆ∏Â§ö‰∫∫Êù•ËØ¥ÊòØÈÅó‰º†ÁöÑÂêå‰πâËØçÔºå‰ΩÜÂÆÉÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™Êõ¥‰∏ÄËà¨ÁöÑÊ¶ÇÂøµÔºåÊåáÁöÑÊòØÂèØ‰ª•Â§ÑÁêÜÂ§öÁßçÁ±ªÂûãÊï∞ÊçÆÁöÑ‰ª£Á†Å„ÄÇÂØπ‰∫éÁªßÊâøÔºåËøô‰∫õÂ§öÊÄÅÁ±ªÂûãÈÄöÂ∏∏ÊòØÂ≠êÁ±ª„ÄÇ

Rust ‰ΩøÁî®Ê≥õÂûãÊù•ÊäΩË±°‰∏çÂêåÁöÑÂèØËÉΩÁ±ªÂûãÂíåÂÆûÊñΩ trait boundsÔºå‰ªéËÄåÂØπËøô‰∫õÁ±ªÂûãÂÆûÁé∞Êâ©Â±ïÔºåËøôÊúâÊó∂Ë¢´Áß∞‰∏∫ÊúâÁïåÂèÇÊï∞Â§öÊÄÅÊÄß Bounded Parametric Polymorphism„ÄÇ

Áî®ÂÆòÊñπÂçöÂÆ¢ÊñáÁ´†ÁöÑÊÄªÁªìÊù•ÊèèËø∞ TraitÔºö

- Traits are Rust's sole notion of interface.
- Traits can be statically dispatched. Like C++ templates.
- Traits can be dynamically dispatched.
- Traits solve a variety of additional problems beyond simple abstraction.

Â¶ÇÊûú‰∏Ä‰∏™Á±ªÂûãÁ≥ªÁªüÂÖÅËÆ∏‰∏ÄÊÆµ‰ª£Á†ÅÂú®‰∏çÂêåÁöÑ‰∏ä‰∏ãÊñá‰∏≠ÂÖ∑Êúâ‰∏çÂêåÁöÑÁ±ªÂûãÔºåËøôÊ†∑ÁöÑÁ±ªÂûãÁ≥ªÁªüÂ∞±Âè´ÂÅöÂ§öÊÄÅÁ±ªÂûãÁ≥ªÁªü„ÄÇÂØπ‰∫éÈùôÊÄÅÁ±ªÂûãÁ≥ªÁªüËØ≠Ë®ÄÊù•ËØ¥ÔºåÂ§öÊÄÅÊÄßÁöÑÂ•ΩÂ§ÑÊòØÂèØ‰ª•Âú®‰∏çÂΩ±ÂìçÁ±ªÂûã‰∏∞ÂØåÁöÑÂâçÊèê‰∏ãÔºå‰∏∫‰∏çÂêåÁöÑÁ±ªÂûãÁºñÂÜôÈÄöÁî®ÁöÑ‰ª£Á†Å„ÄÇ

Áé∞‰ª£ÁºñÁ®ãËØ≠Ë®ÄÂåÖÂê´ÁöÑÂ§öÊÄÅÂΩ¢ÂºèÔºö

- Parametric Polymorphism ÂèØ‰ª•ÂÆûÁé∞Ê≥õÂûãÂÆû‰æãÂåñ‰Ωú‰∏∫ÂèÇÊï∞Êó∂ÊâçÂéªÁ°ÆÂÆöÁ±ªÂûã„ÄÇ
- Ad-hoc Polymorphism Áõ∏ÂΩì‰∫éÂáΩÊï∞ÈáçËΩΩÔºåÂáΩÊï∞ËÉΩÂ§ü‰æùÊçÆÂèÇÊï∞Á±ªÂûãÊåáÂÆö‰∏çÂêåÁöÑÂÆûÁé∞„ÄÇ
- Subtype Polymorphism ÂêçÂ≠óÊåáÂÆöÂÖ¨Áî®Ë∂ÖÁ±ªÁöÑ‰∏çÂêåÂ≠êÁ±ªÁöÑÂÆû‰æã„ÄÇ
- Row Polymorphism/Duck Typing ÁÆÄÂçïÂú∞ËØ¥ÔºåÂ¶ÇÊûúÊüê‰∏™‰∏úË•øÂè´ÂæóÂÉèÈ∏≠Â≠êÔºåËµ∞Ë∑ØÂèàÂíåÈ∏≠Â≠ê‰∏ÄÊ†∑ÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•ËÆ§‰∏∫ÊòØÈ∏≠Â≠ê„ÄÇ

Â¶ÇÊûúÊåâÂ§öÊÄÅÂèëÁîüÁöÑÊó∂Èó¥Êù•ÂàíÂàÜÔºåÂèàÂèØ‰ª•ÂàÜ‰∏∫Ôºö

- Static Polymorphism ÈùôÂ§öÊÄÅÂèëÁîüÂú®ÁºñËØëÊúüÔºåÈùôÂ§öÊÄÅÁâ∫Áâ≤ÁÅµÊ¥ªÊÄßËé∑ÂèñÊÄßËÉΩÔºåÂèÇÊï∞ÂåñÂ§öÊÄÅÂíå Ad-hoc ‰∏ÄËà¨ÊòØÈùôÂ§öÊÄÅ„ÄÇ
- Dynamic Polymorphism Âä®Â§öÊÄÅÂèëÁîüÂú®ËøêË°åÊó∂ÔºåÂä®Â§öÊÄÅÁâ∫Áâ≤ÊÄßËÉΩËé∑ÂèñÁÅµÊ¥ªÊÄßÔºåÂ≠êÁ±ªÂûãÂ§öÊÄÅ‰∏ÄËà¨ÊòØÂä®Â§öÊÄÅ„ÄÇ

Rust ËØ≠Ë®ÄÁöÑÁ±ªÂûãÁ≥ªÁªüÁ±ª‰ºº Duck TypingÔºåÂêåÊó∂ÊîØÊåÅÈùôÂ§öÊÄÅÂíåÂä®Â§öÊÄÅÔºåÈùôÂ§öÊÄÅÂ∞±ÊòØ‰∏ÄÁßçÈõ∂ÊàêÊú¨ÊäΩË±°„ÄÇ

Rust Âºï‰ª•‰∏∫ÂÇ≤ÁöÑÊòØÂ§çÂêàÁ±ªÂûãÁöÑÈõ∂ÊàêÊú¨ÊäΩË±°Ôºå‰æãÂ¶Ç struct AÔºåÁºñËØëÂÆå‰πãÂêéËøêË°åÊó∂‰∏çÂç†Áî®‰ªª‰ΩïÂÜÖÂ≠òÔºå‰∏çËøáÊòØÂú®ÁºñËØëÊúüÈó¥ÂÅö‰∫ÜÁâπÊÆäÂ§ÑÁêÜËÄåÂ∑≤„ÄÇ

Rust ÁöÑÁ±ªÂûãÁ≥ªÁªüÂü∫Êú¨ÂõäÊã¨‰∫ÜÁºñÁ®ã‰∏≠‰ºöÈÅáÂà∞ÁöÑÂêÑÁßçÊÉÖÂÜµÔºå‰∏ÄËà¨ÊÉÖÂÜµ‰∏ã‰∏ç‰ºöÊúâÊú™ÂÆö‰πâÁöÑË°å‰∏∫Âá∫Áé∞ÔºåÊâÄ‰ª•ËØ¥ÔºåRsut ÊòØÁ±ªÂûãÂÆâÂÖ®ÁöÑËØ≠Ë®Ä„ÄÇ


Èô§‰∫ÜÂâçÈù¢Â±ïÁ§∫Áõ¥Êé•ÁªôÁªìÊûÑ‰ΩìÂÆûÁé∞Êâ©Â±ïÊñπÊ≥ïÔºåRust ËøòÊèê‰æõ‰∫Ü Trait Êâ©Â±ïÊú∫Âà∂‰∏∫ÂêÑÁ±ªÂûãÂÆö‰πâÂÖ¨ÂÖ±Ë°å‰∏∫ÊñπÊ≥ïÔºåÂπ∂‰∏îÂèØ‰ª•‰∏∫ÂØπË±°ÂÆûÁé∞Â§ö‰∏™ TraitsÔºåÊâÄ‰ª• Trait Êõ¥ÂÉèÊòØ‰∏Ä‰∏™Êé•Âè£„ÄÇ

Âõ†‰∏∫ËøôÊ†∑ÁöÑÁ±ªÂûãÊú∫Âà∂ÔºåRust API ÂèÇËÄÉÊñáÊ°£‰πüÊòØÊåâ‰ª•‰∏ãÂá†ÁßçÂü∫Êú¨ÁªìÊûÑÁªÑÁªáÁöÑÔºö

- `Implementations` Á±ªÂûãÁõ¥Êé•ÂÆûÁé∞ÁöÑÊñπÊ≥ï„ÄÇ
- `Traits Implementations` ÊòØÊ†∏ÂøÉÈÉ®ÂàÜÔºöÂÆö‰πâ‰∫ÜÁ±ªÂûãÁöÑÂÖ¨ÂÖ±Ë°å‰∏∫ÊñπÊ≥ïÔºåËøô‰∫õÊñπÊ≥ïÂÄºÂæóÊäïÂÖ•‰∏Ä‰∫õÈ¢ùÂ§ñÁöÑÂ≠¶‰π†Êó∂Èó¥„ÄÇ
- `Blanket Implementations` ÊòØÂü∫Á°ÄÈÉ®ÂàÜÔºåÁî± Rust Âü∫Á°ÄÂ∫ìÊâπÈáèË¶ÜÁõñÂÆûÁé∞ÁöÑ Traits ÊñπÊ≥ï„ÄÇ
- `Auto Trait Implementations` ÊòØÂü∫Á°ÄÈÉ®ÂàÜÔºåÁî± Rust Âü∫Á°ÄÂ∫ìÊâπÈáèË¶ÜÁõñÂÆûÁé∞ÁöÑ Traits ÊñπÊ≥ï„ÄÇ

‰ΩøÁî® Traits Êâ©Â±ïÁ±ªÂûãÁöÑÊñπÊ≥ïÂè™ÈúÄË¶Å‰∏§‰∏™Ê≠•È™§Ôºö

- Define Trait Objects
- Implements Trait fro Types

Trait ÂèØ‰ª•ÁªßÊâøÔºåÂ¶Ç‰∏ãÔºåFooBar ÁöÑÂÆûÁé∞ËÄÖ‰πüË¶ÅÂêåÊó∂ÂÆûÁé∞ Foo Âíå BarÔºö

```rust,ignore
trait Foo {
    fn foo(&self);
}

trait Bar {
    fn bar(&self);
}

trait FooBar : Foo + Bar {
    fn foobar(&self);
}

struct Fb;

impl Foo for Fb {
    fn foo(&self) { println!("foo"); }
}

impl Bar for Fb {
    fn bar(&self) { println!("bar"); }
}

impl FooBar for Fb {
    fn foobar(&self) { println!("foobar"); }
}

let fb = Fb{};
fb.foo();
fb.bar();
fb.foobar();
```

‰ª•‰∏ä‰ª£Á†ÅÔºå‰πüÊºîÁ§∫‰∫ÜÂ¶Ç‰Ωï‰ΩøÁî® Trait Êåâ Dock Typing ÊñπÂºèÊù•ÂÆûÁé∞Á±ªÂûãÊâ©Â±ïÔºåÂÆûÁé∞ FooBar ÁöÑ Fb Êó¢ÊòØ Foo Á±ªÂûãÂèàÊòØ Bar Á±ªÂûã„ÄÇ

ËøôÈáåÊâÄÊåáÁöÑÁªßÊâø‰∏çÊòØÂæàÊÅ∞ÂΩìÔºåÂ∫îËØ•ÊòØ‰∏ÄÁßçË°å‰∏∫ÂÖ±‰∫´ÊàñËÄÖÁ∫¶ÊùüÔºåÂç≥ÂÆûÁé∞‰∫ÜÊüê‰∏™ trait ‰πüÊüêÁßçÂÖ±ÂêåÁöÑË°å‰∏∫„ÄÇ


### üü¢üîµ Dynamic vs Static Dispatch
- https://doc.rust-lang.org/stable/std/keyword.dyn.html
- https://doc.rust-lang.org/stable/book/ch17-02-trait-objects.html
- https://wiki.jikexueyuan.com/project/rust-1.7/trait-objects.html
- https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait
- https://doc.rust-lang.org/reference/types/trait-object.html
- trait object https://zhuanlan.zhihu.com/p/23791817

Ê≥®ÊÑèÔºåËøôÈáåËÆ®ËÆ∫ÁöÑ Trait ÂØπË±°‰∏çÊòØÁî® `trait` ÂÖ≥ÈîÆÂ≠óÂÆö‰πâÁöÑÂØπË±°ÔºåËÄåÁ±ª‰ºº‰ª•‰∏ãËøôÊ†∑ÁªìÊûÑÁöÑÂØπË±°Ôºö

```rust,ignore
pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}
```

ÊâÄË∞ì trait ÂØπË±°ÔºåÂèØ‰ª•ÁêÜËß£‰∏∫ÂÖ∂ÂÆÉÈù¢ÂêëÂØπË±°ËØ≠Ë®Ä‰∏≠ÊåáÂêëÊé•Âè£ÊàñÂü∫Á±ªÁöÑÊåáÈíàÊàñÂºïÁî®ÔºåÊåáÂêëÂü∫Á±ªÁöÑÊåáÈíàÂú®ËøêË°åÊó∂Á°ÆÂÆöÂÖ∂ÂÆûÈôÖÁ±ªÂûã„ÄÇRust Ê≤°ÊúâÁ±ªÁªßÊâøÔºåÈÄöËøá trait ÂØπË±°‰øùÂ≠òÁöÑÊåáÈíàÊàñÂºïÁî®Ëµ∑Âà∞Á±ª‰ººÁöÑÊïàÊûúÔºåËøêË°åÊó∂Ë¢´Á°ÆÂÆöÂÖ∑‰ΩìÁ±ªÂûã„ÄÇ

Â∫îÁî®‰∏≠ÔºåÂèØ‰ª•ËøôÊ†∑ÁêÜËß£ÔºåÊåáÂêë trait ÁöÑÊåáÈíàÂ∞±ÊòØ Trait ObjectÔºåÂÅáÂ¶Ç Bird ÊòØ‰∏Ä‰∏™ trait ÁöÑÂêçÁß∞ÔºåÈÇ£‰πàÊô∫ËÉΩÊåáÈíà `Box<Bird>` Âíå `&dyn Bird`ÔºåÊóßËØ≠Ê≥ïË°®Ëææ‰∏∫ `&Bird`ÔºåÂÆÉ‰ª¨ÈÉΩÊòØ‰∏ÄÁßç Trait Object„ÄÇ

Âõ†‰∏∫ Trait ÊòØ DST - dynamically sized typesÔºåÂÆÉÁöÑÊåáÈíàÂ∞±ÈúÄË¶ÅÁî®ËÉñÊåáÈíàÊù•ËÆ∞ÂΩïÂú∞ÂùÄÂíåÈïøÂ∫¶‰ø°ÊÅØÔºåÂèØ‰ª•ÈÄöËøá‰ª•‰∏ã‰ª£Á†ÅÊü•Áúã‰∏éÊôÆÈÄöÊåáÈíàÁöÑÂå∫Âà´Ôºö

```rust,ignore
use std::mem::size_of;
dbg!(size_of::<&Duck>());       // 8
dbg!(size_of::<&dyn Bird>());   // 16
```

ÂΩì‰ΩøÁî® Trait ObjectÔºåRust Â∞±ÂøÖÈúÄ‰ΩøÁî® `dynamic dispatch`ÔºåÂõ†‰∏∫ÁºñËØëÂô®Êó†Ê≥ïÂú®ÁºñËØëÊúüÂæóÁü•Á©∂Á´ü‰∏∫Â§öÂ∞ëÁ±ªÂûã‰ΩøÁî®‰∫Ü Trait Object„ÄÇËøôÊ†∑ÔºåRust Âú® Trait Object ÂÜÖ‰øùÂ≠ò‰∏Ä‰∏™ÊåáÈíàÔºåÂú®ËøêË°åÊó∂Áî®ÂÆÉÊù•ÊåáÂêëË¶ÅË∞ÉÁî®ÁöÑÊñπÊ≥ï„ÄÇÂú®Âä®ÊÄÅÊ¥æÂèëÊñπÂºè‰∏≠ÔºåÁºñËØëÂô®ÁîüÊàêÁöÑ‰ª£Á†Å‰ºöÂú®ËøêË°åÊó∂Ëß£ÂÜ≥Â∫îËØ•Ë∞ÉÁî®Âì™‰∏™ÊñπÊ≥ïÔºåËøôÂ∞±ÊØîÈùôÊÄÅÊ¥æÂèëÂ§ö‰∫Ü‰∏Ä‰∏™ËøêË°åÊó∂ÁöÑËÆ°ÁÆóÊ∂àËÄó„ÄÇ

ÂíåÂä®ÊÄÅÊ¥æÂèëÂØπÁ´ãÁöÑÂ∞±ÊòØ `static dispatch`ÔºåÂú®Ê≥õÂûãÁ´†ËäÇÂÜÖÂÆπ‰∏≠ÔºåËß£Êûê‰∫Ü Rust ÁºñËØëÂô®‰ºöÂú®ÁºñËØëÊúüËøõË°å monomorphization Â§ÑÁêÜ„ÄÇÂç≥ÈÇ£‰∫õÁªëÂÆöÊ≥õÂûãÁöÑ Traits ÊñπÊ≥ï‰ºöÂú®ÁºñËØëÊúüÂçï‰ΩìÂåñ‰∏∫ÂÖ∑‰ΩìÁ±ªÂûãÔºåÂíåÊ≥õÂûãÁõ∏ÂèçÊñπÂêëÁöÑÂ§ÑÁêÜËøáÁ®ã„ÄÇÁºñËØëÁªìÊûúÂ∞±ÊòØË∞ÉÁî®ÊñπÊ≥ïÊòØÈùôÊÄÅÊ¥æÂèëÁöÑÔºåÂú®ÁºñËØëÊúüÂ∞±ÂÜ≥ÂÆö‰∫Ü„ÄÇËÄåÂä®ÊÄÅÊ¥æÂèëËøò‰ºöÈòªÊ≠¢ÈÇ£Ê≠§ÈùôÊÄÅÊ¥æÂèëÁöÑ‰ºòÂåñÂ∑•‰ΩúÔºåÂ¶ÇÈùôÊÄÅÊ¥æÂèë‰∏≠‰ºöÂ∞Ü‰∏Ä‰∫õÂáΩÊï∞ËøõË°åÂÜÖËÅî inline ËÄåÁúÅÁï•ÂáΩÊï∞Ë∞ÉÁî®ÁöÑÊ∂àËÄó„ÄÇ

Rust ÊúÄÊñ∞ËßÑËåÉ‰∏≠Ôºåimpl Trait Âíå dyn Trait ÂàÜÂà´ÂØπÂ∫îÈùôÊÄÅÂàÜÂèëÂíåÂä®ÊÄÅÂàÜÂèëÊú∫Âà∂ÁöÑÂÆûÁé∞ËØ≠Ê≥ï„ÄÇ

Êù•Ëæ®Êûê‰∏Ä‰∏ãËøô‰∏§‰∏™ÂÖ≥ÈîÆÂ≠óÔºö

- `impl` Áî®‰∫é‰∏∫Á±ªÂûãÂÆûÁé∞ÂäüËÉΩÂáΩÊï∞Ôºå‰πüÂèØ‰ª•Áî®‰∫éÂ£∞ÊòéÂèÇÊï∞„ÄÅËøîÂõûÂÄº‰∏∫ÂÆûÁé∞Êüê Trait ÁöÑÁ±ªÂûãÔºõ
- `dyn` Áî®‰∫éÁ™ÅÂá∫Â£∞ÊòéÂØπ‰∫éÂÖ≥ËÅîÁöÑ Trait ÁöÑÊñπÊ≥ïË∞ÉÁî®ÊòØ Dynamic DispatchÔºåË¶Å‰ΩøÁî® `dyn some_trait` ËøôÁßçÊñπÂºèÔºåË¶ÅÊ±Ç some_trait ÂøÖÈúÄÊòØÂØπË±°ÂÆâÂÖ®ÁöÑÔºõ

‰∏éÊ≥õÂûãÂèÇÊï∞Êàñ `impl some_trait` ‰∏çÂêåÔºåÁºñËØëÂô®‰∏çÁü•ÈÅì `dyn some_trait` Ë¶Å‰º†ÈÄíÁöÑÂÖ∑‰ΩìÁ±ªÂûãÔºå‰πüÂ∞±ÊòØËØ¥ÔºåÁ±ªÂûãÂ∑≤Ë¢´Ê∏ÖÈô§„ÄÇÂõ†Ê≠§Ôºå`dyn some_trait`ÂºïÁî®ÂåÖÂê´‰∏§‰∏™ÊåáÈíàÔºå‰∏Ä‰∏™ÊåáÂêëÊï∞ÊçÆÔºà‰æãÂ¶ÇÔºåÁªìÊûÑÁöÑÂÆû‰æãÔºâÔºåÂè¶‰∏Ä‰∏™ÊåáÂêë‰∏Ä‰∏™‰øùÂ≠òÊñπÊ≥ïË∞ÉÁî®ÂêçÁöÑÊò†Â∞ÑÔºåÂç≥Áß∞‰∏∫ËôöÊãüÊñπÊ≥ïË°®Êàñ vtable ÁöÑÂØπË±°„ÄÇ

Âú®ËøêË°åÊó∂ÔºåÂΩìÈúÄË¶ÅÂØπ `dyn some_trait` Ë∞ÉÁî®‰∏Ä‰∏™ÊñπÊ≥ïÊó∂ÔºåÊü•ËØ¢ vtable ‰ª•Ëé∑ÂèñÂáΩÊï∞ÊåáÈíàÔºåÁÑ∂ÂêéË∞ÉÁî®ËØ•ÂáΩÊï∞ÊåáÈíà„ÄÇËøô‰πüÂ∞±ÊòØËØ¥ `dyn some_trait` ÊñπÂºèÈúÄË¶ÅÊ∂àËÄóËøêË°åÊó∂ÁöÑËµÑÊ∫êÊù•ÂÆåÊàê‰∏Ä‰∫õÂä®ÊÄÅË∞ÉÁî®Â∑•‰Ωú„ÄÇÁõ∏ÊØî `impl some_trait` ‰∏éÊ≥õÂûãÂèÇÊï∞ÊñπÂºèÔºåÂèØ‰ª•Âú®ÁºñËØëÊúüÁ°ÆÂÆöÔºåÁîüÊàêÂØπÂ∫îÁöÑÂêÑÁßçË∞ÉÁî®ÁâàÊú¨ÔºåÂπ∂ÂèØ‰ª•‰Ωú‰∏∫ÂÜÖËÅîÂΩ¢ÂºèÁºñËØëÔºåÂõ†Ê≠§ÂÖ∑ÊúâÊõ¥Â•ΩÁöÑÊÄßËÉΩ„ÄÇ

‰ΩÜÊòØÔºå`dyn some_trait` Âõ†‰∏∫‰∏çÂú®ÁºñËØëÊúüÁîüÊàêÂêÑÁßçË∞ÉÁî®ÁöÑÈùôÊÄÅ‰ª£Á†ÅÔºåÊâÄ‰ª•ÂÆÉ‰∫ßÁîüÊõ¥Â∞ëÁöÑÁºñËØë‰ª£Á†Å„ÄÇ 


Â¶ÇÊûú‰∏Ä‰∏™ Trait ÂØπË±°ÊòØÂØπË±°ÂÆâÂÖ®ÁöÑÔºåÈúÄË¶ÅÊª°Ë∂≥‰∏Ä‰∫õÊù°‰ª∂ÔºåÂÆûË∑µ‰∏≠ÂÆÉÁöÑÊâÄÊúâÊñπÊ≥ïÂÆö‰πâÂè™ÈúÄË¶ÅÊª°Ë∂≥‰ª•‰∏ã‰∏§‰∏™ÊÄßË¥®Ôºö

- The return type isn't `Self`.
- There are no generic type parameters.

ÊåâËøô‰∏§Êù°ÊÄßË¥®ÔºåÈÇ£‰πàÂåÖÂê´Â∏∏Áî®ÁöÑ clone() ÊñπÊ≥ïÁöÑ Trait Â∞±‰∏çÊòØÂØπË±°ÂÆâÂÖ®ÁöÑÔºö

```rust,ignore
pub trait Clone {
    fn clone(&self) -> Self;
}
```

ÂØπ‰∫éÁªôÂÆöÁöÑ‰∏Ä‰∏™ Trait ÂØπË±°ÔºåÂêçÂ≠óÂÅáÂÆö‰∏∫ SomeTraitÔºåÈÇ£‰πà‰ª•‰∏ãË°®ËææÂºèÈÉΩÊòØ Trait ÂØπË±°Ôºö

- dyn SomeTrait
- dyn SomeTrait + Send
- dyn SomeTrait + Send + Sync
- dyn SomeTrait + 'static
- dyn SomeTrait + Send + 'static
- dyn SomeTrait +
- dyn 'static + SomeTrait.
- dyn (SomeTrait)

ÂÖ≥ÈîÆÂ≠ó `dyn` ÊòØÂèØÈÄâÁöÑÔºåÂè™ÊòØË°®Á§∫ Dynamic dispatchÔºåÂç≥Âú®ËøêË°åÊó∂ËøõË°åÊñπÊ≥ïÊ¥æÂèëË∞ÉÁî®ÔºåÂØπÂ∫îÁöÑÈùôÊÄÅÊ¥æÂèëÊñπÂºèÊòØ `impl`„ÄÇ 

- ImplTraitType : impl TypeParamBounds
- ImplTraitTypeOneBound : impl TraitBound

ËÄå trait Êú¨Ë∫´‰∏çÊòØÂõ∫ÂÆöÂ§ßÂ∞èÁöÑÁ±ªÂûãÔºå‰∏çËÉΩÂú®ÁºñËØëÈò∂ÊÆµÁ°ÆÂÆöÂ§ßÂ∞è„ÄÇ‰∏çÂêåÁöÑÁ±ªÂûãÈÉΩÂèØ‰ª•ÂÆûÁé∞Âêå‰∏Ä‰∏™ traitÔºåÊª°Ë∂≥Âêå‰∏Ä‰∏™ trait ÁöÑÁ±ªÂûãÂèØËÉΩÂÖ∑Êúâ‰∏çÂêåÁöÑÂ§ßÂ∞è„ÄÇÂõ†Ê≠§Ôºå‰∏çËÉΩÁõ¥Êé•‰ΩøÁî® trait ÂΩì‰ΩúÂÆû‰æãÂèòÈáè„ÄÅÂèÇÊï∞„ÄÅËøîÂõûÂÄº„ÄÇ

ÂÅáËÆæÊúâ‰ª•‰∏ãÁöÑ trait BirdÔºåËøòÂè¶Â§ñÊúâ‰∏§‰∏™Á±ªÂûãÈÉΩÂÆûÁé∞‰∫ÜËøô‰∏™ traitÔºö

```rust,ignore
trait Bird {
  fn fly(&self);
}

struct Duck;
struct Swan;

impl Bird for Duck {
  fn fly(&self) { println!("duck fly..."); }
}

impl Bird for Swan {
  fn fly(&self) { println!("swan fly...");}
}
```

ÊÄª‰πã Trait Object ÊòØ‰∏ÄÁßç DST Á±ªÂûãÔºåÂπ∂‰∏çÊòØ‰∏ÄÁßçÂÖ∑‰ΩìÁ±ªÂûãÔºåÂÆÉÁöÑÂ§ßÂ∞èÂú®ÁºñËØëÈò∂ÊÆµ‰∏çÂõ∫ÂÆöÔºåËøô‰πüÊòØ trait Ë∑üÂÖ∂ÂÆÉËØ≠Ë®Ä‰∏≠ÁöÑ interface ÁöÑ‰∏Ä‰∏™Âå∫Âà´„ÄÇ

ËøôÊÑèÂë≥ÁùÄ‰∏çËÉΩÁî®Âú®ÂèÇÊï∞Á±ªÂûã„ÄÅÊàñËøîÂõûÂÄºÁ±ªÂûãÁöÑÂ£∞Êòé‰∏≠ÔºåÂÉè‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÊòØ‰∏çËÉΩÈÄöËøáÁºñËØëÁöÑÔºö

```rust,ignore
fn test(arg: Bird) {}
fn test() -> Bird  {}
```

ÂèØ‰ª•Êç¢‰∏ÄÁßçÊñπÂºèÔºåÂ£∞Êòé‰∏∫ÂÆûÁé∞‰∫Ü Bird ÁöÑÁ±ªÂûãÔºö

```rust,ignore
fn test(arg: &dyn Bird) {}
fn test(arg: impl Bird) {}
fn test() -> impl Bird  { Duck{} }
```

ÊàñËÄÖ‰ΩøÁî®Ê≥õÂûãÂèÇÊï∞ËææÂà∞Á±ª‰ººÁöÑÊïàÊûúÔºö

```rust,ignore
fn test<T: Bird>(arg: T) {
    arg.fly();
}
test(Duck{});
```

‰ª•‰∏äÂÆûÁé∞ÂÆûÈôÖ‰∏äÔºåÁºñËØëÂô®‰ºöËøõË°å monomorphization Â§ÑÁêÜÔºåÊ†πÊçÆÂÆûÈôÖË∞ÉÁî®ÂèÇÊï∞ÁöÑÁ±ªÂûãÂçï‰ΩìÂåñÔºåÁõ¥Êé•ÁîüÊàê‰∏çÂêåÁöÑÂáΩÊï∞ÁâàÊú¨ÔºåÁ±ª‰ºº C++ ÁöÑ template ‰∏ÄÊ†∑Ôºö

    // ‰º™‰ª£Á†ÅÁ§∫ÊÑè
    fn test_Duck(arg: Duck) { arg.fly(); }
    fn test_Swan(arg: Swan) { arg.fly(); }


```rust,ignore
// Define a Trait Object
pub trait Draw {
    fn draw(&self);
}

#[derive(Debug)]
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

// Implementing the Trait
impl Draw for Button {
    fn draw(&self) {
        // code to actually draw a button
        println!("{:?}", btn);
    }
}

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // code to actually draw a select box
        println!("{:?}", btn);
    }
}

fn main() {
    // use trait methods
    let btn = Button{ 
        width: 10, 
        height:8, 
        label: String::from("Go") 
    };
    btn.draw();
}
```

### üü¢üîµ Blog Demo
- The Rust Programming Language - 17.3 Implementing an Object-Oriented Design Pattern https://doc.rust-lang.org/book/ch17-03-oo-design-patterns.html

Âú®ÂÆòÊñπÊñáÊ°£ Implementing an Object-Oriented Design Pattern ‰∏≠ÔºåÂàÜÂà´Âè™Áî®ÁªìÊûÑ‰Ωì„ÄÅÁªìÊûÑ‰ΩìÁªìÂêà Trait ‰∏§ÁßçÊñπÂºèÂÆûÁé∞ State Pattern ÁºñÁ®ãÊ®°ÂºèÔºåÂæàÂ•ΩÊºîÁ§∫‰∫Ü Rust ÁöÑÁ±ªÂûãÁ≥ªÁªüÂ∑•‰ΩúÂéüÁêÜ„ÄÇ

Áä∂ÊÄÅÊ®°Âºè State Pattern ÊòØ‰∏ÄÁßçÈù¢ÂêëÂØπË±°ÁöÑËÆæËÆ°Ê®°ÂºèÔºåÊ®°ÂºèÁöÑÂÖ≥ÈîÆÊòØÊúâÂÜÖÈÉ®Áä∂ÊÄÅÁöÑÂÄºÔºåËøô‰∫õÁä∂ÊÄÅÁî±‰∏ÄÁªÑÁä∂ÊÄÅÂØπË±°Ë°®Á§∫ÔºåÂπ∂‰∏îÂÄºÁöÑË°å‰∏∫Ê†πÊçÆÂÜÖÈÉ®Áä∂ÊÄÅËÄåÊîπÂèò„ÄÇState ÂØπË±°Â∞Ü‰∏Ä‰∫õË°å‰∏∫ÂäüËÉΩÂÖ±‰∫´Âá∫Êù•ÔºåÊØè‰∏™Áä∂ÊÄÅÂØπË±°Ë¥üË¥£Ëá™Â∑±ÁöÑË°å‰∏∫ÔºåÂπ∂Ë¥üË¥£ÊéßÂà∂‰ΩïÊó∂Â∫îÊõ¥Êîπ‰∏∫Âè¶‰∏Ä‰∏™Áä∂ÊÄÅ„ÄÇËÄå‰øùÂ≠òÁä∂ÊÄÅÂØπË±°ÁöÑÂÄºÊú¨Ë∫´‰∏çÁü•ÈÅìÁä∂ÊÄÅÂØπË±°ÁöÑ‰∏çÂêåË°å‰∏∫ÔºåÊàñ‰ΩïÊó∂Âú®Áä∂ÊÄÅ‰πãÈó¥ËΩ¨Êç¢„ÄÇ

Âú® Rust ‰∏≠‰ΩøÁî® Struct Âíå Trait ÂÆûÁé∞ÔºåËÄå‰∏çÊòØ C++ ËØ≠Ë®ÄÈÇ£Ê†∑‰ΩøÁî®Á±ªÂØπË±°ÂíåÁªßÊâøÊú∫Âà∂„ÄÇ

‰∏§Áßç State Pattern ÂÆûÁé∞ÁöÑË¶ÅÁÇπÔºö

- Encoding States and Behavior as Trait
- Encoding States and Behavior as Types

ÊºîÁ§∫ÁöÑ Blog Ê°à‰æãÂäüËÉΩÂè™Ë¶ÅÊ±Ç‰ª•‰∏ãÂá†ÁÇπÔºö

- A blog post starts as an empty draft.
- When the draft is done, a review of the post is requested.
- When the post is approved, it gets published.
- Only published blog posts return content to print, so unapproved posts can‚Äôt accidentally be published.

Âç≥Ë¥¥Â≠ê‰ªéÂºÄÂßãÁöÑËçâÁ®øÁä∂ÊÄÅÔºåÁªèËøáÂÆ°Ê†∏Áä∂ÊÄÅÂÜçÂà∞ÂèëÂ∏ÉÁä∂ÊÄÅÔºåËøô‰∏™ËøáÁ®ã‰∏≠ÔºåÂè™ÊúâÂú®ÊúÄÂêéÂèëÂ∏ÉÁä∂ÊÄÅÊâçÂèØ‰ª•ÈÄöËøá `content()` ÊñπÊ≥ïËé∑ÂèñÂÜÖÂÆπ„ÄÇ

ÁâàÊú¨‰∏ÄÈááÁî®ÁªìÊûÑ‰ΩìÁªìÂêà State Trait ÁöÑÊñπÊ°àÂÆûÁé∞ÔºåËøô‰∏™ÁâàÊú¨‰∏≠Ë¶ÅÁÇπÔºö

- `struct Post` ÂÆûÁé∞Â∏ñÂ≠êÂÜÖÂÆπËÆæÁΩÆ„ÄÅ`request_review()` `approve()` Áä∂ÊÄÅËΩ¨Êç¢„ÄÅ`content()` ÂÜÖÂÆπËé∑ÂèñÊñπÊ≥ïÔºåËøîÂõûÂÜÖÂÆπÂèñÂÜ≥‰∫éÁä∂ÊÄÅÂØπË±°ÁöÑÂÆûÁé∞„ÄÇ
- `trait State` ‰Ωú‰∏∫Áä∂ÊÄÅÊé•Âè£ÔºåÊèê‰æõÈªòËÆ§ÁöÑ `content()` ÊñπÊ≥ïËøîÂõûÁ©∫Â≠óÁ¨¶‰∏≤ÔºåÈÄöËøá `request_review()` `approve()` ÊñπÊ≥ï‰ª•‰∏ãÁä∂ÊÄÅÂØπË±°„ÄÇ
    - `struct Draft` ÂÆûÁé∞Áä∂ÊÄÅÊé•Âè£ÔºåÂπ∂‰∏î‰∏çÂÖ∑Â§áÁõ¥Êé•ÈÄöËøá `approve()` Â∞ÜÂ∏ñÂ≠êËÆæÁΩÆ‰∏∫ÂèëÂ∏ÉÁä∂ÊÄÅ„ÄÇ
    - `struct PendingReview` ÂÆûÁé∞Áä∂ÊÄÅÊé•Âè£ÔºåÂÖ∑Â§áÁõ¥Êé•ÈÄöËøá `approve()` Â∞ÜÂ∏ñÂ≠êËÆæÁΩÆ‰∏∫ÂèëÂ∏ÉÁä∂ÊÄÅ„ÄÇ
    - `struct Published` ÂÆûÁé∞Áä∂ÊÄÅÊé•Âè£ÔºåÂπ∂Ë¶ÜÁõñÂÆûÁé∞ `content()` ÊñπÊ≥ïËøîÂõûÂ∏ñÂ≠êÂÜÖÂÆπ„ÄÇ

ËøôÁßçËÆæËÆ°Êúâ‰∏ÄÂÆöÁöÑÁÅµÊ¥ªÊÄßÔºåÊØîÂ¶ÇÊñ∞Â¢û‰∏Ä‰∫õÂäüËÉΩÔºö

- Ê∑ªÂä† `reject()` ÊñπÊ≥ïÊù•ÊãíÁªùÁä∂ÊÄÅËΩ¨Êç¢ÔºåÂ∞ÜÁä∂ÊÄÅ‰ªé `PendingReview` ÂõûÊªö‰∏∫ `Draft`Ôºõ
- ÈúÄË¶ÅÁªèËøá‰∏§Ê¨° approve ÊâçËøõÂÖ• `Published` Áä∂ÊÄÅÔºõ
- Âè™Âú® `Draft` Áä∂ÊÄÅ‰∏ãÊâçÂÖÅËÆ∏Áî®Êà∑‰øÆÊîπÂÜÖÂÆπÔºõ

‰ΩÜÊòØÔºåËøô‰∏™ÊñπÊ°à‰∏≠ÔºåState ÂØπË±°ÂíåË°å‰∏∫ËÉΩÂäõÊòØÁªü‰∏ÄÂ≠òÊîæÁöÑÔºå‰ªéÊ¶ÇÂøµ‰∏äËÆ≤ÔºåËøôÂπ∂‰∏çÊòØÁâπÂà´Â•ΩÁöÑÈÄªËæëÂ§ÑÁêÜÔºå‰πüÂ≠òÂú®‰∏Ä‰∫õÈáçÂ§çÁöÑ‰ª£Á†Å„ÄÇÂÅáÂ¶ÇÈúÄË¶ÅÊñ∞Â¢û‰∏Ä‰∏™Áä∂ÊÄÅÔºåÂ¶Ç `Scheduled` Â∞±ÂèØËÉΩË¶Å‰øÆÊîπÁé∞ÊúâÁöÑ‰∏ÄÊàñ‰∏§‰∏™Áä∂ÊÄÅÂØπË±°ÔºåËøôÊòØ‰∏ÄÁßçÂ§çÊùÇÁöÑÂ∑•‰Ωú„ÄÇ


ÁâàÊú¨‰∫å‰ªÖ‰ΩøÁî®ÁªìÊûÑ‰ΩìÁÆ°ÁêÜÁä∂ÊÄÅÁöÑÊñπÊ°àÂÆûÁé∞Ôºå‰ΩøÁî® 3 ‰∏™ÁªìÊûÑ‰ΩìÊù•ÂØπÂ∫î‰∏âÁßçÁä∂ÊÄÅÔºåËøô‰∫õÁªìÊûÑÈÉΩÊúâ `content` Êï∞ÊçÆÊàêÂëòÔºåËøô‰∏™ÁâàÊú¨‰∏≠Ë¶ÅÁÇπÔºö

- `struct Post` ÂÆûÁé∞ `content()` ÊñπÊ≥ïËøîÂõûÂ∏ñÂ≠êÂÜÖÂÆπÔºåÂÆûÁé∞ `new()` ÊñπÊ≥ïËøîÂõû‰∏Ä‰∏™ `DraftPost` ÂØπË±°Ôºõ
- `struct DraftPost` ÂÆûÁé∞ `request_review()` ÊñπÊ≥ïËøîÂõû‰∏Ä‰∏™ `PendingReviewPost` ÂØπË±°Ôºõ
- `struct PendingReviewPost` ÂÆûÁé∞ `approve()` ÊñπÊ≥ïËøîÂõû‰∏Ä‰∏™ `Post` ÂØπË±°Ôºõ

ÂèØ‰ª•ÁúãÂà∞Ëøô‰∏ÄÁâàÊú¨‰∏≠ÔºåÁî®‰∏çÂêåÁöÑÁªìÊûÑ‰ΩìÊù•Á∫¶ÊùüÁî®Êà∑ÁöÑË°å‰∏∫ÔºåÂè™ÊúâÁõ∏Â∫îÁöÑÁªìÊûÑ‰ΩìÂØπË±°ÊâçÂÖ∑ÊúâÊåáÂÆöÁöÑË°å‰∏∫ËÉΩÂäõÔºå‰ª£Á†ÅÂèÇËÄÉÂ¶Ç‰∏ãÔºö

```rust,ignore
pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

pub struct PendingReviewPost {
    content: String,
}

impl Post {
    pub fn new() -> DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&self) -> &str {
        &self.content
    }
}

impl DraftPost {
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }

    pub fn request_review(self) -> PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

impl PendingReviewPost {
    pub fn approve(self) -> Post {
        Post {
            content: self.content,
        }
    }
}
```

Âè¶‰∏ÄÁâàÊú¨‰ª£Á†ÅÂèÇËÄÉÔºåtrait State + struct ÂÆûÁé∞ÁâàÊú¨Ôºö

```rust,ignore
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }

    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }

    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self)
    }

    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }

    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;

    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ""
    }
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }

    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}
```

Ëøô‰∏ÄÁâàÊú¨‰∏≠‰ΩøÁî®‰∫Ü `Option` Á±ªÂûãËøòÊúâ `Box` Êô∫ËÉΩÊåáÈíàÊù•‰øùÂ≠òÁä∂ÊÄÅÂØπË±°„ÄÇ‰∏∫‰∫Ü‰ªé `Option` ÂèòÈáè‰∏≠ÂèñÂá∫Áä∂ÊÄÅÂØπË±°Ôºå‰ΩøÁî® `unwrap()` ÊñπÊ≥ï„ÄÇÂè¶Â§ñÔºåÂõ†‰∏∫ `Option` Êûö‰∏æÁ±ªÂûãÊúâ Some Âíå None ‰∏§ÁßçÂÄºÔºå‰ΩÜÂè™Êúâ Some ÂÖ≥ËÅî‰øùÂ≠ò‰∫ÜÁä∂ÊÄÅÂØπË±°ÔºåÈúÄË¶Å‰ΩøÁî® `take()` ÊñπÊ≥ï‰ªé `state` ÊàêÂëò‰∏≠ÂèñÂá∫ Some(state)„ÄÇ

    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self)
    }

ÂÖ∂‰∏≠ `as_ref()` ÊñπÊ≥ïÊòØ Trait std::convert::AsRef Êèê‰æõÁöÑÈÄöÁî®ÊñπÊ≥ïÔºåËøôÈáåË°®Á§∫Ëé∑Âèñ Option ÂÜÖÈÉ®ÂÄºÁöÑÂºïÁî®ÔºåËÄå‰∏çÊòØÂÖ∂ÊâÄÊúâÊùÉ„ÄÇÂú® `Option<Box<dyn State>>` Á±ªÂûã‰∏äË∞ÉÁî®ËøîÂõûÁöÑÂÄºÂ∞±ÊòØ `Option<&Box<dyn State>>`„ÄÇÂ¶ÇÊûú‰∏çÈÄöËøáËøô‰∏™ÊñπÊ≥ïËÄåÁõ¥Êé•‰ΩøÁî®Ëøô‰∏™ÂÜÖÈÉ®ÂÄºÔºåÂ∞±‰ºöÂØºËá¥ÊâÄÊúâÊùÉËΩ¨ÁßªÔºåËÄåÂÖ∂Êù•Ê∫êÊòØ `&self` Âç≥‰∏çÂèØÂèòÂÄüÁî®ÔºåÊâÄ‰ª•ÁºñËØëÂô®‰∏çÂÖÅËÆ∏ËøôÊ†∑ÂÅö„ÄÇ




### üü¢üîµ Traits ÁâπË¥®Êâ©Â±ï
- https://doc.rust-lang.org/stable/std/keyword.trait.html
- https://doc.rust-lang.org/stable/reference/types/trait-object.html
- https://doc.rust-lang.org/stable/reference/types/impl-trait.html
- Rust by Example - Traits https://doc.rust-lang.org/rust-by-example/trait.html
- Traits: Defining Shared Behavior https://doc.rust-lang.org/book/ch10-02-traits.html

ÂÆòÊñπÊñáÊ°£‰∏≠Áî®‰∏Ä‰∏™Ê†áÈ¢ò‰Ωú‰∫ÜÊòéÁ§∫ Traits: Defining Shared Behavior„ÄÇ

Traits Ëøô‰∏™Ê¶ÇÂøµÂú® PHP ‰∏≠‰πüÊúâÔºåÂÆÉË¢´Áî®Êù•ÂØπÂêÑÁßçÁ±ªÂûãËøõË°åÂäüËÉΩÊâ©Â±ï„ÄÇRust ‰∏≠ÁöÑ trait ‰πüÊòØÂÅöËøôÁßçÂ∑•‰ΩúÁöÑÔºåÂíåÊ≥õÂûã‰∏ÄÊ†∑ÊòØÈùûÂ∏∏ÈáçË¶ÅÁöÑÊ¶ÇÂøµÔºåtrait ÂèØ‰ª•ÁøªËØë‰∏∫ÁâπÊÄß„ÄÅÁâπË¥®Á≠âÔºåtrait Ëøô‰∏™Ê¶ÇÂøµÊâøÊãÖ‰∫ÜÂ§öÁßçËÅåË¥£„ÄÇ

ÂíåÂÖ∂ÂÆÉËØ≠Ë®Ä‰∏≠ÁöÑ Interface ÊäΩË±°Á±ªÂûãÁõ∏ÊØîÔºåtrait Ëøô‰∏™Ê¶ÇÂøµÊúâÂæàÂ§ß‰∏çÂêåÔºåÊõ¥Êé•Ëøë Golang interface ÈááÁî®ÁöÑÁªÑÂêàÊñπÂºè„ÄÇ

Rust ËÆæËÆ°ÁöÑ‰∏âÂ§ßÊîØÊü±ÁâπÊÄßÔºö

- Êó†ÂûÉÂúæÂõûÊî∂ÁöÑÂÆâÂÖ®ÂÜÖÂ≠òÁÆ°ÁêÜ No GC
- Êó†Êï∞ÊçÆÁ´û‰∫âÈ£éÈô©ÁöÑÂπ∂Âèë - Data Race
- Èõ∂ÂºÄÈîÄÁöÑÊäΩË±° - Zero-cost Abstraction

Trait Êú∫Âà∂ÊòØ Rust ÂÆûÁé∞Èõ∂ÂºÄÈîÄÁöÑÊäΩË±°Ëøô‰∏ÄÂéüÂàôÁöÑÂü∫Áü≥ÔºåÊòØ Rust ÂîØ‰∏ÄÁöÑÊé•Âè£ÊäΩË±°ÊñπÂºè„ÄÇ 

- ‰∏ÄÊñπÈù¢Ôºå‰∏çÂêåÁßçÁ±ªÂûãÂèØ‰ª•ÂÆûÁé∞Âêå‰∏Ä Trait Á±ªÂûãÔºå‰πüÂèØ‰ª•‰∏∫Â∑≤ÊúâÁöÑÁ±ªÂûãÊ∑ªÂä†Êñ∞ÁöÑ Trait Á±ªÂûã„ÄÇ
- Âè¶‰∏ÄÊñπÈù¢ÔºåÂΩì‰Ω†ÊÉ≥Ë¶ÅÂØπÊüêÊú™Áü•Á±ªÂûãËøõË°åÊäΩË±°ÁöÑÊó∂ÂÄôÔºåTrait ÂèØ‰ª•Â∏ÆÂä©‰Ω†Á°ÆÂÆöËØ•Á±ªÂûãÂèØ‰ª•ËøõË°åÁöÑÊìç‰Ωú„ÄÇ
- Trait ÂèØ‰ª•ÈùôÊÄÅÁîüÊàêÔºåËøô‰∏é C++ Ê®°Êùø‰∏ÄËá¥ÔºåÂØπ‰∏çÂêåÁßçÁ±ªÂûãÁöÑÊäΩË±°ÈùôÊÄÅÂú∞ÁîüÊàê‰∏çÂêåÁöÑ‰ª£Á†ÅÔºåËÄåÊäΩË±°Êú¨Ë∫´Ê≤°ÊúâÂ¢ûÂä†Ë¥üÈù¢ÂΩ±ÂìçÔºåÂõ†ËÄå‰πü‰∏ç‰ºöÂ∏¶Êù•‰ªª‰ΩïËøêË°åÂºÄÈîÄ„ÄÇ
- Trait ÂèØ‰ª•Âä®ÊÄÅË∞ÉÁî®ÔºåÊúâÊó∂‰Ω†Á°ÆÂÆûÈúÄË¶ÅÂú®ËøêË°åÊó∂Ë∞ÉÁî®ÊüêÁßçÈó¥Êé•ÊäΩË±°ÔºåËøôÊó∂Â∞±‰∏çËÉΩÈùôÊÄÅÂÆû‰æãÂåñËØ•ÊäΩË±°‰∫ÜÔºåÂõ†Ê≠§Êèê‰æõ‰∫ÜÂä®ÊÄÅË∞ÉÁî®ÔºàDynamic DispatchÔºâÁöÑÊú∫Âà∂„ÄÇ
- Trait ËøôÁßçÁÆÄÂçïÊäΩË±°ËÉΩÂ§üËß£ÂÜ≥Â§ßÈáèÁöÑÈ¢ùÂ§ñÈóÆÈ¢òÔºåÂèØ‰ª•Ë¢´Áî®‰∫éÂÆö‰πâÊâ©Â±ïÊñπÊ≥ïÔºåÂØπÂ∑≤ÊúâÁ±ªÂûãÊ∑ªÂä†ÂÖ∂‰ªñÊñπÊ≥ïÔºåÂõ†Ê≠§‰º†ÁªüÁöÑÊñπÊ≥ïÈáçËΩΩ‰∏çÂÜçÂøÖË¶Å„ÄÇ
- Trait Êú∫Âà∂‰πü‰ΩøÂæóËøêÁÆóÁ¨¶ÈáçËΩΩÊõ¥Âä†ÁÆÄÂçï„ÄÇ

Rust ÊòØ‰∏ÄÁßçÁî®Êà∑ÂèØ‰ª•ÂØπÂÜÖÂ≠òÊúâÁ≤æÁ°ÆÊéßÂà∂ËÉΩÂäõÁöÑÂº∫Á±ªÂûãËØ≠Ë®ÄÔºåÂèØ‰ª•Ëá™Áî±ÊåáÂÆö‰∏Ä‰∏™ÂèòÈáèÊòØÂú®Ê†àÈáåÈù¢ÔºåËøòÊòØÂú®Â†ÜÈáåÈù¢„ÄÇÂú®Â±ÄÈÉ®ÂèòÈáèÂ£∞Êòé„ÄÅÂáΩÊï∞ÂèÇÊï∞‰º†ÈÄí„ÄÅËøîÂõûÂÄº‰º†ÈÄíÁ≠âÁ≠âÂú∞ÊñπÔºåÈÉΩË¶ÅÊ±ÇËøô‰∏™Á±ªÂûãÂú®ÁºñËØëÈò∂ÊÆµÊúâÁ°ÆÂÆöÁöÑÂ§ßÂ∞èÔºåÂê¶ÂàôÁöÑËØùÔºåÁºñËØëÂô®Â∞±‰∏çÁü•ÈÅìËØ•Â¶Ç‰ΩïÁîüÊàê‰ª£Á†Å„ÄÇ

ÂÆö‰πâ Traits ÂèØ‰ª•ÂåÖÂê´‰ª•‰∏ã‰∏âÁßçÊàêÂëòÔºå‰ΩÜÂ∞±ÊòØ‰∏çËÉΩÊ∑ªÂä†ÂÖ∂ÂÆÉÊï∞ÊçÆÊàêÂëòÔºö

- functions and methods
- types
- constants

Traits ÁöÑÁõ∏ÂÖ≥ËØ≠Ê≥ïË¶ÅÁÇπÔºö

- `impl SomeTrait for SomeStruct {}` ‰∏∫ÁªìÊûÑ‰ΩìÂÆûÁé∞ SomeTraitÔºõ
- `fn foo() -> impl SomeTrait {}` ‰∏∫ÂáΩÊï∞Â£∞ÊòéÂÖ∂ÂèÇÊï∞„ÄÅËøîÂõûÂÄº‰∏∫ÂÆûÁé∞‰∫Ü SomeTrait ÁöÑÁ±ªÂûãÔºõ
- `fn foo<T: Debug + Clone>(s: T) {}` Ë°®Á§∫Ê≥õÂûã T ‰∏∫ÂêåÊó∂ÂÆûÁé∞ Debug + CloneÔºåÂä†Âè∑Áî®Êù•ËøûÊé•Â§ö‰∏™ Trait„ÄÇ
- `fn foo<T, K> where T:Debug + Clone, K: Copy (s: T) {}` Ê≥õÂûã Traits ÁÆÄÂåñÁ±ªÂûãË°®ËææÁöÑ where ‰ªéÂè•ËØ≠Ê≥ïÔºõ
- `impl<T: SomeTrait> ToString for T {}` Ë¶ÜÁõñÂÆûÁé∞Ôºåblanket implementationsÔºå‰∏∫ÊâÄÊúâÂÆûÁé∞ SomeTrait ÁöÑÁ±ªÂûãÊèê‰æõ ToString ÂÆûÁé∞Ôºõ
- `impl<T> SomeTrait for T { }` Ê≥õÂûãÂÆûÁé∞Ôºå‰∏∫ÊâÄÊúâÁ±ªÂûãÂÆûÁé∞ SomeTraitÔºõ

ÂÉè `T: SomeTrait` ËøôÊ†∑ÁöÑËØ≠Ê≥ïÁªìÊûÑÊòØÊóßÁâàÊú¨ÁöÑÁúÅÁï•ÂÜôÊ≥ïÔºåÂØπÂ∫îÂÆåÊï¥ÁöÑË°®ËææÂ∫îËØ•ÊòØ `(dyn Trait + 'static)`ÔºåÂõ†‰∏∫ Trait Âè™ÂÆö‰πâ‰∏Ä‰∏™Êé•Âè£Á∫¶ÊùüÔºå‰∏çÊòØÂÖ∑‰ΩìÁ±ªÂûãÔºå

‰ΩøÁî® Trait ÈúÄË¶Å‰∏§‰∏™Ê≠•È™§Ôºö

- Defining a Trait
- Implementing a Trait on a Type

ÊúÄÁÆÄÂçïÁöÑÊñπÊ≥ïÂ∞±ÊòØ‰ΩøÁî®ÂÖÉÊï∞ÊçÆÁºñÁ®ãÔºåÁõ¥Êé•ÊâøÁªßÁ≥ªÁªüÊèê‰æõÁöÑ Derivable Trait ÂØπË±°:

- Comparison traits: `Eq`, `PartialEq`, `Ord`, `PartialOrd`.
- `Clone`, to create T from &T via a copy.
- `Copy`, to give a type 'copy semantics' instead of 'move semantics'.
- `Hash`, to compute a hash from &T.
- `Default`, to create an empty instance of a data type.
- `Debug`, to format a value using the `{:?}` formatter.

‰ΩøÁî®Á§∫ËåÉÔºö

```rust,ignore
// `Centimeters`, a tuple struct that can be compared
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`, a tuple struct that can be printed
#[derive(Debug)]
struct Inches(i32);

println!("Derivable Debug {:?}", Inches(12));
```

Ëá™ÂÆö‰πâ Trait ÂØπË±°ÂèØ‰ª•ÂÉèÂÆö‰πâÊé•Âè£‰∏ÄÊ†∑Âè™ÁªôÂá∫ÂáΩÊï∞Â§¥ÔºåÂèØ‰ª•ÂÆö‰πâÂ§ö‰∏™ÊñπÊ≥ïÔºåÂΩìÁÑ∂‰πüÂèØ‰ª•Ê≤°Êúâ‰ªª‰ΩïÊñπÊ≥ï„ÄÅÂ∏∏ÈáèÊàñÁ±ªÂûãÂÆö‰πâ„ÄÇ

‰πüÂèØ‰ª•ÁªôÂá∫ÂáΩÊï∞ÂÆûÁé∞ÔºåËøôÂè´ÂÅöÈªòËÆ§ÂÆûÁé∞ÔºåÊ≥®ÊÑèËä±Êã¨Âè∑ÂêéÈù¢Ê≤°ÊúâÂàÜÂè∑Ôºö

```rust,ignore
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

ÁÑ∂ÂêéÔºå‰∏∫ÈúÄË¶Å‰ΩøÁî® Trait ÁöÑÂØπË±°ÈÄöËøá `impl` ÂÖ≥ÈîÆÂ≠óÊù•ÂÆûÁé∞ÂÆÉÔºåÂØπ‰∫éÈªòËÆ§ÂÆûÁé∞ÁöÑ TraitÔºåÂè™ÈúÄË¶Å‰∏ÄÂØπËä±Êã¨Âè∑ÔºåÂ¶Ç `impl Summary for T {}`„ÄÇÊàñËÄÖÊèê‰æõÂÖ∂ÂÆÉÊú™ÂÆûÁé∞ÁöÑÊñπÊ≥ïÔºåËÄåÁúÅÁï•ÈªòËÆ§ÂÆûÁé∞ÁöÑÊñπÊ≥ï„ÄÇ

```rust,ignore
pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

// use Default Implementation
// impl Summary for Tweet { }

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
```

ÊâÄÊúâÁöÑ trait ÈÉΩÊúâ‰∏Ä‰∏™ÈöêËóèÁöÑÁ±ªÂûã `Self`Ôºå‰ª£Ë°®ÂΩìÂâçËøô‰∏™ÂÆûÁé∞‰∫ÜÊ≠§Êé•Âè£ÁöÑÂÖ∑‰ΩìÁ±ªÂûãÔºå‰πüÂ∞±ÊòØËøô‰∏™Á±ªÂûãÁöÑÂà´ÂêçËÄåÂ∑≤„ÄÇtrait ‰∏≠ÂÆö‰πâÁöÑÂáΩÊï∞Ôºå‰πüÁß∞‰ΩúÂÖ≥ËÅîÂáΩÊï∞(associated function)„ÄÇÂáΩÊï∞ÁöÑÁ¨¨‰∏Ä‰∏™ÂèÇÊï∞Â¶ÇÊûúÊòØ Self Áõ∏ÂÖ≥ÁöÑÁ±ªÂûãÔºå‰∏îÂëΩÂêç‰∏∫ `self`ÔºåËøô‰∏™ÂèÇÊï∞ÂèØË¢´Áß∞ÂÅöÊé•Êî∂ËÄÖÔºåÂç≥ÂáΩÊï∞Ë∞ÉÁî®Âä®‰ΩúÁöÑÊé•Êî∂ËÄÖÔºåÂáΩÊï∞Ë∞ÉÁî®‰∫ßÁîüÁöÑÂΩ±ÂìçÁî± receiver Êé•Êî∂„ÄÇËøôÊ†∑ÁöÑÂáΩÊï∞ÂèØ‰ª•Áß∞‰ΩúÊñπÊ≥ï methodÔºåÂèØ‰ª•ÂΩìÁÑ∂ÂèòÈáèÂÆû‰æãÁöÑÊàêÂëòÊñπÊ≥ï‰ΩøÁî®ÔºåÂç≥ÈÄöËøáÂ∞èÊï∞ÁÇπÊù•ËÆøÈóÆËøô‰∏™ÊñπÊ≥ï„ÄÇÊ≤°Êúâ receiver ÂèÇÊï∞ÁöÑÂáΩÊï∞ÔºåÊàë‰ª¨ÂèØ‰ª•Áß∞‰ΩúÈùôÊÄÅÂáΩÊï∞ static functionÔºåÂèØ‰ª•ÈÄöËøáÁ±ªÂûãÂä†ÂèåÂÜíÂè∑ :: ÁöÑÊñπÂºèÊù•Ë∞ÉÁî®„ÄÇÂú® Rust ‰∏≠ÔºåÂáΩÊï∞ÂíåÊñπÊ≥ïÊ≤°ÊúâÊú¨Ë¥®Âå∫Âà´„ÄÇ

trait ‰∏≠ÁöÑÊñπÊ≥ï‰∏éÊôÆÈÄöÂáΩÊï∞‰∏ÄÊ†∑ÔºåÂèØ‰ª•ÊåáÂÆöÊâÄÊúâÂèÇÊï∞ÊòØÂÄº‰º†ÈÄí„ÄÅÂºïÁî®‰º†ÈÄíÔºåÂåÖÊã¨ self ÂèÇÊï∞‰πü‰∏çÁâπÊÆä„ÄÇÂØπ‰∫é self ÂèÇÊï∞Âè™ËÉΩÁî®Âú®Á¨¨‰∏Ä‰∏™ÂèÇÊï∞ÁöÑ‰ΩçÁΩÆÔºåÂèØ‰ª•ÊòØÔºö

- self : Self       ÁÆÄÂåñÂÜôÊ≥ï self
- self : mut Self   ÁÆÄÂåñÂÜôÊ≥ï mut self
- self : &Self      ÁÆÄÂåñÂÜôÊ≥ï &self
- self : &mut Self  ÁÆÄÂåñÂÜôÊ≥ï &mut self

ÂèØ‰ª•Â∞Ü Trait Á±ªÂûã‰Ωú‰∏∫ÂèÇÊï∞‰º†ÈÄíÔºåÂèØ‰ª•‰ΩøÁî® impl Trait ËØ≠Ê≥ïÔºå‰πüÂèØ‰ª•‰ΩøÁî® Trait ÁªëÂÆöËØ≠Ê≥ïÔºåÂÆÉ‰ª¨ÊòØÁ≠â‰ª∑ÁöÑÔºö

```rust,ignore
// Traits as Parameters - syntax sugar of bound syntax
// impl Trait syntax
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

// Trait Bound Syntax
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

Bound Ëøô‰∏™Áß∞Ë∞ìÂèØ‰ª•ÁøªËØë‰Ωú‰∏∫ÊçÜÁªëÊàñÁªëÂÆöÈÉΩÂèØ‰ª•ÔºåËøôÂæàË¥¥ÂêàËØ≠Ê≥ïÁöÑÂê´‰πâÔºåÁøªËØëÊú∫Âô®Áõ¥Êé•Ëß£Êûê‰∏∫Á∫¶ÊùüÔºåËøô‰∏™ÂÆûÂú®‰∏çÊÅ∞ÂΩì„ÄÇ

Â¶ÇÊûúÂÆûÁé∞Â§ö‰∏™ TraitÔºåÂèØ‰ª•‰ΩøÁî® + ËøûÊé•ÔºåÂπ∂‰∏îÂèØ‰ª•‰ΩøÁî®Êõ¥Ê∏ÖÊô∞ÁöÑ where ClausesÔºö

```rust,ignore
// Multiple Trait Bounds with the + Syntax
pub fn notify(item: &(impl Summary + Display)) { ... }
pub fn notify<T: Summary + Display>(item: &T) { ... }

// Clearer Trait Bounds with where Clauses
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{ ... }
```

ÂáΩÊï∞‰πüÂèØ‰ª•ËøîÂõû Trait Á±ªÂûãÔºåReturning Types that Implement TraitsÔºåÊ≥®ÊÑèÔºåÂáΩÊï∞Âè™ËÉΩËøîÂõûÂêå‰∏Ä‰∏™Á±ªÂûãÔºåËÄå‰∏çÂèØ‰ª•ËøîÂõûÂ§ö‰∏™Á±ªÂûãÔºö

```rust,ignore
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
```

Traits ËøòÊúâ‰∏ÄÁßçË¶ÜÁõñÂÆûÁé∞ÔºåÂç≥‰∏ÄÊèΩÂ≠êÂÆûÁé∞ blanket implementationsÔºåÂ∞±‰∏∫Â∑≤ÁªèÂÆûÁé∞ÊüêÁßç Trait ÁöÑÁ±ªÂûãÂÆûÁé∞Âè¶‰∏ÄÁßç TraitÔºåËøôÂú® Rust Ê†áÂáÜÂ∫ì‰∏≠ÂπøÊ≥õ‰ΩøÁî®„ÄÇ

‰æãÂ¶ÇÔºåÊ†áÂáÜÂ∫ì‰∏≠Âü∫Êú¨ÈÉΩÂÆûÁé∞‰∫Ü Display TraitÔºåÂπ∂‰∏îÈÄöËøá‰ª•‰∏ãÊñπÂºè‰∏∫ÊâÄÊúâÂÆûÁé∞ Display ÁöÑÁ±ªÂûãÂÆûÁé∞ ToString„ÄÇÂ∞±ËøôÊ†∑ÔºåÊâÄÊúâÂèØ‰ª•ÊâßË°å Display ÊâìÂç∞‰ø°ÊÅØÁöÑÁ±ªÂûãÈÉΩÊúâ `to_string()` ÊñπÊ≥ï„ÄÇ

```rust,ignore
#![allow(unused)]
impl<T: Display> ToString for T {
    // --snip--
}

fn main() {
    let s = 3.to_string();
}
```

‰∏∫ÁªìÊûÑ‰ΩìÊèê‰æõÊåâÊù°‰ª∂ÂÆûÁé∞ÔºåRust Á≥ªÁªü‰∏≠ÁöÑ Traits Êèê‰æõÁöÑËøôÁßçËÉΩÂäõÔºåÁúüÁöÑÂæà AOP - Aspect-oriented programming„ÄÇ


### üü¢üîµ Drop & Copy Trait
- https://doc.rust-lang.org/std/ops/trait.Drop.html
- https://doc.rust-lang.org/std/marker/trait.Copy.html
- https://doc.rust-lang.org/stable/std/boxed/struct.Box.html
- Smart Pointers https://doc.rust-lang.org/book/ch15-00-smart-pointers.html

Âú® Ownership Á´†ËäÇÁöÑÂÜÖÂÆπ‰∏≠ÔºåËÆ®ËÆ∫‰∫Ü Rust Á®ãÂ∫è‰∏≠ÁöÑÂØπË±°Êúâ‰∏§ÁßçÂæàÂü∫Êú¨ÁöÑË°å‰∏∫Ôºö

- Drop ÂºïÁî®ÊàñÂèòÈáèÁ¶ªÂºÄ‰ΩúÁî®ÂüüÊó∂ÔºåÂç≥ÁîüÂëΩÂë®ÊúüÁªìÊùüÊó∂ÊâßË°å `drop()` ËøõË°åÊ∏ÖÁêÜÔºõ
- Copy ÂØπË±°ËµãÂÄºÊó∂‰∫ßÁîüÁöÑÊ∑±Â∫¶Â§çÂà∂Ë°å‰∏∫„ÄÇ

ÂèÇËÄÉÂ¶Ç‰∏ã‰ª£Á†ÅÔºö

```rust,ignore
let s1 = String::from("hello");
let s2 = s1;
println!("s1: {}", s1);
```

Âõ†‰∏∫ String Á±ªÂûãÊ≤°ÊúâÂÆûÁé∞ Copy Trait ÊñπÊ≥ïÔºåÊâÄ‰ª•ËµãÂÄºÂç≥ÊÑèÂë≥ÁùÄÊâÄÊúâÊùÉÁöÑÁßªÂä®ÔºåÂèëÁîüÂú®Áªô `s2` ËµãÂÄºÁöÑËØ≠Âè•‰∏äÔºåËΩ¨Áßª‰∫ÜÊâÄÊúâÊùÉÂêé `s1` Â∞±Â§±Ê¥ª‰∏çËÉΩÂÜç‰ΩøÁî®‰∫Ü„ÄÇ

ÊâÄ‰ª•ÁºñËØëÊó∂ÈîôËØØÊèêÁ§∫Ôºå`s1` ËµãÂÄºËøáÁ®ã‰∏≠Âõ†‰∏∫Ê≤°Êúâ Copy trait ‰ºöÂºïËµ∑ÊâÄÊúâÊùÉÁßªÂä®ÔºåÊâÄ‰ª•ÂÆÉÁõ∏ÂêåÁîüÂëΩÂë®ÊúüÁªìÊùüÔºå‰∏çËÉΩÁî®‰∫éÊâìÂç∞‰ø°ÊÅØ„ÄÇ

Copy and Drop are exclusive ‰∏§ËÄÖ‰∏çÂèØÂêåÊó∂ÂÆûÁé∞ÔºåÂ¶ÇÊûúÂÆûÁé∞‰∫Ü Drop Â∞±Ë°®Á§∫ÂÆÉÂú®ËµãÂÄºÊó∂ÂøÖÈúÄËΩ¨ÁßªÊâÄÊúâÊùÉÊàñÂá∫ÂÄüÊâÄÊúâÊùÉ„ÄÇ

Copy ‰∏é Clone ÊòØÊúâÂå∫Âà´ÁöÑÔºö

- Copy ÊòØËµãÂÄºÁ¨¶Âè∑‰∏≠Âá∫Áé∞ÁöÑÈöêÂºèÊìç‰ΩúÔºåÊÄªÊòØÊâßË°åÁÆÄÂçïÁöÑ bit-wise Êã∑Ë¥ùÔºåÂπ∂‰∏î‰∏çÂèØ‰ª•ÈáçËΩΩÔºåÂèØ‰ª•ÁúãÂà∞ÂêéÈù¢ÂÆûÁé∞ Copy Êó∂‰ΩøÁî®ÁöÑÊòØ { }„ÄÇ
- Clone ÊòØÊòæÂºèÊâßË°åÊï∞ÊçÆÁöÑÂ§çÂà∂Êìç‰ΩúÔºåÂèØ‰ª•Ê†πÊçÆÈúÄË¶ÅÈáçËΩΩ `clone()` Ëøô‰∏™ËøáÁ®ã„ÄÇ

ÂèØ‰ª•ÂÆûÁé∞ Copy ÁöÑÁ±ªÂûãË¶ÅÊ±ÇÊúüÂ≠êÊàêÂëò‰πüÂøÖÈúÄÂÆûÁé∞ Copy„ÄÇ

Êúâ‰∫õÁ±ªÂûãÊòØ‰∏çÂèØ‰ª•ÂÆûÁé∞ÁöÑ Copy ÁöÑÔºåÂ¶Ç `&mut T` ÊâßË°åÊã∑Ë¥ùÂêéÂ∞±Êúâ‰∏§‰∏™ÂèØÂèòÂºïÁî®ÔºåËøôÊòØ Rust ÁºñËØëÂô®‰∏çÂÖÅËÆ∏ÁöÑË°å‰∏∫„ÄÇ`String` Á±ªÂûã‰πüÁ±ª‰ººÔºåÂõ†‰∏∫Êã∑Ë¥ùÂÆÉÂ∞±Ë°®Á§∫Êúâ‰∏§‰∏™ÊåáÂêëÂêå‰∏ÄÂ≠óÁ¨¶‰∏≤ buffer ÁöÑÂºïÁî®ÔºåÂú®ÈáäÊîæËµÑÊ∫êÊó∂Â∞±‰ºöÂá∫Áé∞ double free ÈóÆÈ¢ò„ÄÇÊâÄ‰ª•ÔºåÈÇ£‰πàÂÆûÁé∞‰∫Ü Drop ÁöÑÁ±ªÂûãÊú¨Ë∫´Â∞±Ë°®Á§∫ÊúâÂÖ≥ËÅîÁöÑÊï∞ÊçÆÈúÄË¶ÅÂú®ÁªìÊùüÊó∂Ê∏ÖÁêÜÔºåÁõ¥Êé•ÊâßË°å Copy ÊòØÂç±Èô©Ë°å‰∏∫ÔºåÂ∫îËØ•Ê†πÊçÆÈúÄË¶ÅÈáçËΩΩ `clone()` ÊñπÊ≥ï„ÄÇ

ÂÆûÁé∞ Copy Trait ÊúÄÁÆÄÂçïÁöÑÊñπÂºèÊòØ‰ΩøÁî®ÂÖÉÊï∞ÊçÆÁºñÁ®ãÔºåÁõ¥Êé• derive Á≥ªÁªüÊèê‰æõÁöÑÈªòËÆ§ÂÆûÁé∞Ôºå‰πüÂèØ‰ª•ÊâãÂÜåÂÆûÁé∞„ÄÇ

Áé∞Âú®ÔºåÈÄöËøáÂÆûÁé∞ Copy Trait Êù•‰øÆÊ≠£ÂâçÈù¢‰ª£Á†ÅÁâáÊÆµ‰∏≠ÈÅáÂà∞ÁöÑÈóÆÈ¢òÔºö

```rust,ignore
// #[derive(Debug, Copy, Clone)]
// struct S<'a>(&'a str);

#[derive(Debug)]
struct S(&'static str);

impl Copy for S { }

impl Clone for S {
    fn clone(&self) -> S {
        *self
    }
}

fn main() {
    let s1 = S("hello");
    let s2 = s1;
    println!("s1: {:?}", s1);
}
```

Âõ†‰∏∫ `pub trait Copy: Clone` ÊâÄ‰ª•ÈúÄË¶Å‰∏ÄÂπ∂ÂÆûÁé∞ Clone„ÄÇ

ÂÖ∂ÂÆÉÂ∑≤ÁªèÂÆûÁé∞ Copy ÁöÑÁ±ªÂûãÂ¶Ç‰∏ãÔºö

- Function item types (i.e., the distinct types defined for each function)
- Function pointer types (e.g., fn() -> i32)
- Array types, for all sizes, if the item type also implements Copy (e.g., [i32; 123456])
- Tuple types, if each component also implements Copy (e.g., (), (i32, bool))
- Closure Â¶ÇÊûúÊ≤°Êúâ‰ªéÁéØÂ¢É‰∏≠ÊçïËé∑‰ªª‰ΩïÂÄºÔºåÊàñËÄÖÊâÄÊúâËøô‰∫õÊçïËé∑ÁöÑÂÄºÈÉΩÂÆûÁé∞‰∫Ü Copy Êú¨Ë∫´„ÄÇ

ËØ∑Ê≥®ÊÑèÔºåÂÖ±‰∫´ÂºïÁî®ÊçïËé∑ÁöÑÂèòÈáèÂßãÁªàÂÆûÁé∞ Copy Âç≥‰ΩøË¢´ÂºïÁî®ÊñπÊ≤°ÊúâÔºåËÄåÂèØÂèòÂºïÁî®ÊçïËé∑ÁöÑÂèòÈáè‰ªé‰∏çÂÆûÁé∞ Copy„ÄÇ


Êåâ‰ª•‰∏ãÂéüÂûãÂÆûÁé∞ std::ops::Drop Trait ÂèØ‰ª•Âú®ÂØπË±°ÁîüÂëΩÂë®ÊúüÁªìÊùüÊó∂ÊâßË°åËµÑÊ∫êÊ∏ÖÁêÜÂ∑•‰Ωú„ÄÇ

    pub trait Drop {
        pub fn drop(&mut self);
    }

Drop::drop ÊòØ‰∏çÂÖÅËÆ∏ÊâãÂä®Ë∞ÉÁî®ÔºåÈúÄË¶ÅÊèêÂâçÈáäÊîæËµÑÊ∫êÔºåÊØîÂ¶ÇÂÜôÂÖ•Êñá‰ª∂ÂÆåÊàêÂêéÔºåÈúÄË¶ÅÁ´ãÈ©¨ close ÂèØ‰ª•ÈÄöËøá `std::mem::drop()` ÂáΩÊï∞Êù•ÈáäÊîæ„ÄÇ

ÁªìÂêà Box Êô∫ËÉΩÊåáÈíàÁ§∫ËåÉ Drop ÂÆûÁé∞Ôºö

```rust,ignore
use std::mem::drop;

struct Foo(Box<i32>);

impl Foo {
    fn destroy(self){
        drop(self);
    }
}
impl Drop for Foo {
    fn drop(&mut self) {
        let Foo(v) = self;
        println!("Leave scope and object destroyed!")
    } // leave scope
}

// unit struct
struct Bar;

impl Drop for Bar {
    fn drop(&mut self) {
        println!("Dropping Bar!")
    }
}

fn main() {
    {
        let _foo = Foo(Box::new(1));
        let _bar = Bar;
    }
    println!("after lifetime 'a.")

}
```

ËæìÂá∫ÔºåÂèØ‰ª•ÁúãÂà∞ drop() Ë∞ÉÁî®ÁöÑÈ°∫Â∫èÊòØ‰ªéÊúÄÂêé‰∏Ä‰∏™Â§±ÊïàÁöÑÂØπË±°ÂºÄÂßãÊâßË°åÁöÑÔºö

    Dropping Bar!
    Leave scope and object destroyed!
    after lifetime 'a.




### üü¢üîµ Operator Overloading
- https://doc.rust-lang.org/rust-by-example/trait/ops.html
- https://doc.rust-lang.org/stable/core/ops/trait.Add.html
- https://doc.rust-lang.org/stable/std/ops/index.html#traits

‰ª•‰∏ãÁ§∫ËåÉÈÄöËøáÂÆûÁé∞ `std::ops::Add` Êù•ÈáçËΩΩ + ËøêÁÆóÁ¨¶ÔºåÂÖ∂ÂÆÉËøêÁÆóÁ¨¶Âè∑ÂèÇËÄÉÊ†áÂáÜÂ∫ìÊñáÊ°£Ôºö

```rust,ignore
use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// The `std::ops::Add` trait is used to specify the functionality of `+`.
// Here, we make `Add<Bar>` - the trait for addition with a RHS of type `Bar`.
// The following block implements the operation: Foo + Bar = FooBar
impl ops::Add<Bar> for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -> FooBar {
        println!("> Foo.add(Bar) was called");

        FooBar
    }
}

// By reversing the types, we end up implementing non-commutative addition.
// Here, we make `Add<Foo>` - the trait for addition with a RHS of type `Foo`.
// This block implements the operation: Bar + Foo = BarFoo
impl ops::Add<Foo> for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -> BarFoo {
        println!("> Bar.add(Foo) was called");

        BarFoo
    }
}

fn main() {
    println!("Foo + Bar = {:?}", Foo + Bar);
    println!("Bar + Foo = {:?}", Bar + Foo);
}
```

Ê≥õÂûãÈáçËΩΩÁöÑÂÆûÁé∞Ôºö

```rust,ignore
use std::ops::Add;

#[derive(Debug, Copy, Clone, PartialEq)]
struct Point<T> {
    x: T,
    y: T,
}

// Notice that the implementation uses the associated type `Output`.
impl<T: Add<Output = T>> Add for Point<T> {
    type Output = Self;

    fn add(self, other: Self) -> Self::Output {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
           Point { x: 3, y: 3 });
```

ÂΩì‰Ω†‰∏∫ÊüêÁ±ªÂûãÂÆûÁé∞Êüê trait ÁöÑÊó∂ÂÄôÔºåÂøÖÈ°ªË¶ÅÊ±ÇÁ±ªÂûãÊàñËÄÖ trait Ëá≥Â∞ëÊúâ‰∏Ä‰∏™ÊòØÂú®Âêå‰∏Ä crate ‰∏≠ÂÆö‰πâÁöÑÔºåÂç≥‰∏çËÉΩ‰∏∫Á¨¨‰∏âÊñπÁöÑÁ±ªÂûãÂÆûÁé∞Á¨¨‰∏âÊñπÁöÑ trait„ÄÇ 

Ëøô‰∏ÄÁÇπÊòØÂæàÁõ¥ËßÇÁöÑÔºåËøôÈÅøÂÖçÂÖ•‰æµÂºè‰ª£Á†ÅÂØπÁ¨¨‰∏âÊñπÊ®°ÂùóÁöÑÁ†¥ÂùèÔºåÊúâ‰∫õËµÑÊñôÊääËøô‰∏™Á∫¶ÊùüÁß∞‰∏∫Â≠§ÂÑøËßÑÂàô Orphan rule„ÄÇ

```rust,ignore
use std::ops::Add;
// only traits defined in the current crate can be implemented for arbitrary types
// impl doesn't use only types from inside the current crate
impl Add<i32> for bool {
    type Output = bool;
    fn add(self, other: i32) -> Self::Output {
        other
    }
}
```

‰ª•‰∏ä‰ª£Á†ÅÁºñËØë‰ºöÂá∫ÈîôÔºåÁºñËØëÂô®ÊèêÁ§∫Ôºö

    error[E0117]: only traits defined in the current crate can be implemented for arbitrary types  
     --> src\main.rs:4:1
      |
    4 | impl Add<i32> for bool {
      | ^^^^^--------^^^^^----
      | |    |            |
      | |    |            `bool` is not defined in the current crate
      | |    `i32` is not defined in the current crate
      | impl doesn't use only types from inside the current crate
      |
      = note: define and implement a trait or new type instead

‰æãÂ¶ÇÔºå‰∏∫ÂéüÂßãÁ±ªÂûãÂÆûÁé∞‰∏Ä‰∏™Ê±ÇÈù¢ÁßØÁöÑÊñπÊ≥ïÔºö

```rust,ignore
trait HasArea {
    fn area(&self) -> f64;
}

impl HasArea for i32 {
    fn area(&self) -> f64 {
        *self as f64
    }
}

println!("{}",5.area());
```

Âè¶‰∏Ä‰∏™‰æãÂ≠êÔºö

```rust,ignore
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> &'static str;
}

impl Add<Self> for bool {
    type Output = bool;
    fn add(self, other: Self) -> &'static str {
        if self && other { "TT" } else { "FF" } 
    }
}
println!("Boolean + {}", true.add( true));
```



### üü¢üîµ Iterator Ëø≠‰ª£Âô®
- https://doc.rust-lang.org/std/iter/index.html
- https://doc.rust-lang.org/rust-by-example/trait/iter.html
- Processing a Series of Items with Iterators https://doc.rust-lang.org/book/ch13-02-iterators.html
- Comparing Performance: Loops vs. Iterators https://doc.rust-lang.org/book/ch13-04-performance.html

Iterator ÂÆö‰πâÊú¨Ë∫´ÊòØÁÆÄÂçïÁöÑÔºåÂè™Êúâ‰∏Ä‰∏™ `next()` ÊñπÊ≥ïÔºö

```rust,ignore
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

Ë∞ÉÁî® `next()` ÊñπÊ≥ïËøîÂõû‰∏Ä‰∏™ `Option<Item>` Á±ªÂûãÂÄºÔºåÂè™Ë¶ÅÊúâÊï∞ÊçÆÂ∞±ËøîÂõû `Some(Item)`ÔºåÂê¶ÂàôËøîÂõû `None` Ë°®Á§∫Â∑≤ÁªèËø≠‰ª£ÂÆåÊàê„ÄÇ

‰ª•‰∏ãÊòØÂíåÈõÜÂêàÈÖçÂêà‰ΩøÁî®ÁöÑ‰∏Ä‰∫õÂ∏∏Áî®ÁöÑÊñπÊ≥ïÔºö

- `map()` Êò†Â∞Ñ‰∏∫‰∏Ä‰∏™Êñ∞ÁöÑËø≠‰ª£Âô®ÔºåÂ¶Ç `iter.map(|x| x*2)`Ôºõ
- `fold()` Á±ª‰ºº reduce ÊñπÊ≥ïÔºåÂ¶Ç `iter.fold(0, |a, b| a+b)`Ôºõ
- `skip(n)` Ë∑≥ËøáÊåáÂÆöÊï∞ÈáèÁöÑÂÖÉÁ¥†Ôºõ
- `take(n)` ÊãøÊéâÊåáÂÆöÊï∞ÈáèÁöÑÂÖÉÁ¥†Ôºõ
- `rev()` ÂèçËΩ¨Ëø≠‰ª£Âô®È°∫Â∫èÔºõ


ÂÆûÁé∞‰∏Ä‰∏™ËÆ°Êï∞Áî®ÁöÑËø≠‰ª£Âô®Ôºö

```rust,ignore
struct Counter { count: usize, }

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = usize;

    // next() is the only required method
    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;

        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}

let mut counter = Counter::new();

assert_eq!(counter.next(), Some(1));
assert_eq!(counter.next(), Some(2));
assert_eq!(counter.next(), Some(3));
assert_eq!(counter.next(), Some(4));
assert_eq!(counter.next(), Some(5));
assert_eq!(counter.next(), None);
for (index, value) in counter.enumerate() {
    println!("#{}: {}", index, value);
}
```

The three forms of iteration

- `iter()`, which iterates over `&T`.
- `iter_mut()`, which iterates over `&mut T`.
- `into_iter()`, which iterates over `T`.

‰ª•‰∏ãÁ§∫ËåÉÈÄöËøáÂºïÁî®„ÄÅÂèØÂèòÂºïÁî®ÁöÑÊñπÂºèËø≠‰ª£Ôºö

```rust,ignore
let mut values = vec![41];
for x in values.iter_mut() {
    *x += 1;
}
for x in values.iter() {
    assert_eq!(*x, 42);
}
assert_eq!(values.len(), 1);
```

‰ª•‰∏ãÊòØ `into_iter()` ÊñπÂºèÁöÑÁÆÄÂåñ‰ΩøÁî®ÊñπÂºèÔºö

```rust,ignore
let values = vec![1, 2, 3, 4, 5];

for x in values {
    println!("{}", x);
}
```
ÂÖ∂‰∏≠ `vec!` Ëøô‰∏™ÂÆèÂèØÂÉè‰ΩøÁî®Êï∞ÁªÑ‰∏ÄÊ†∑ÂàõÂª∫‰∏Ä‰∏™ Vec ÂêëÈáèÂàóË°®„ÄÇ

Á≠â‰ª∑ÁöÑÂéªËØ≠Ê≥ïÁ≥ñÁâàÊú¨Â¶Ç‰∏ãÔºåÁªìÂêà‰∫Ü match Ê®°ÂºèÂåπÈÖçÔºö

```rust,ignore
let values = vec![1, 2, 3, 4, 5];
{
    match IntoIterator::into_iter(values) {
        mut iter => loop {
            let val;
            match iter.next() {
                Some(next) => val = next,
                None => break,
            };
            let () = { println!("{}", val); };
        },
    };
}
```

ÈááÁî®‰∏îÂèàËøîÂõû `Iterator` ÁöÑÂáΩÊï∞Áß∞‰∏∫Ëø≠Ëµ∑Âô®ÈÄÇÈÖçÂô®Ôºåiterator adaptersÔºåÂ∏∏Áî®ÁöÑÊúâ `map()`, `take()`, `filter()`„ÄÇ

```rust,ignore
let vec1 = vec![1, 2, 3];
let vec2 = vec![4, 5, 6];

// `iter()` for vecs yields `&i32`. Destructure to `i32`.
println!("2 in vec1: {}", vec1.iter().any(|&x| x == 2));
// `into_iter()` for vecs yields `i32`. No destructuring required.
println!("2 in vec2: {}", vec2.into_iter().any(| x| x == 2));

// println!("Find 2 in vec1: {:?}", vec1.iter()     .find(|&&x| x == 2));
// println!("Find 2 in vec2: {:?}", vec2.into_iter().find(| &x| x == 2));
```

Ëø≠‰ª£Âô®ÊòØ lazy ÁöÑÔºåÂç≥ÂàõÂª∫‰∏Ä‰∏™Ëø≠‰ª£Âô®Âπ∂‰∏ç‰ºöÊâßË°å‰ªÄ‰πàÔºåÈô§Èùû‰Ω†ÊâßË°å `next()` ËøôÊ†∑ÁöÑÊï∞ÊçÆÊ∂àË¥πÊñπÊ≥ïÔºåÊàñËÄÖ `sum()` `fold()` Ëøô‰∫õË∞ÉÁî®‰∫Ü `next()` ÁöÑÊñπÊ≥ï„ÄÇ

‰ª•‰∏ã‰ª£Á†ÅË∞ÉÁî®‰∫Ü‰∏ÄÊ¨° `next()` ÊâÄ‰ª• map ‰º†ÂÖ•ÁöÑ closure ÂáΩÊï∞Âè™ÊâßË°å‰∏ÄÊ¨°Ôºö

```rust,ignore
let v = vec![1, 2, 3, 4, 5];
v.iter().map(|x| println!("{}", x)).next();
for x in &v {
    println!("=>{}", x);
}
```

ÂØπ Range ËøõË°åËø≠‰ª£Ôºö

```rust,ignore
let numbers = 0..;
let five_numbers = numbers.take(5);
// let five_numbers = 0..=4;
for number in five_numbers {
    println!("{}", number);
}
```

### üü¢üîµ Generic Types
- https://doc.rust-lang.org/book/ch10-00-generics.html
- https://rustc-dev-guide.rust-lang.org/backend/monomorph.html
- https://doc.rust-lang.org/rust-by-example/generics.html

ÊâÄ‰ª•È´òÁ∫ßËØ≠Ë®ÄÈÉΩÊúâÁî®Êù•Ëß£ÂÜ≥ÈáçÂ§ç‰ª£Á†ÅÁöÑÂ∑•ÂÖ∑ÔºåÊ≥õÂûãÊòØÂ∏∏Áî®ÁöÑÂ∑•ÂÖ∑ÔºåRust ‰πüÁî®ÂÆÉ„ÄÇ

ÊÄªÁªì‰∏Ä‰∏ãÊ≥õÂûãÁöÑ‰ΩøÁî®ÊñπÂºèÔºö

- Ê≥õÂûãÂáΩÊï∞ `fn genericFun<T>(arg: SomeType<T>) {}`
- Ê≥õÂûãÂÆûÁé∞ `impl<T>` ÊåâÊ≥õÂûãÂÆûÁé∞ÂØπË±°ÁöÑÊñπÊ≥ïÊâ©Â±ï„ÄÇ
- Ê≥õÂûã Traits `trait GenericeTrait<T>{...}`

‰æãÂ¶ÇÔºåÂÆö‰πâ‰∏Ä‰∏™Ê≥õÂûãÁöÑÁªìÊûÑ‰ΩìÔºö

```rust,ignore
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

Â¶ÇÊûúÔºåÈúÄË¶ÅÂ§ö‰∏™Ê≥õÂûãÂèÇÊï∞ÔºåÂú®Â∞ñÊã¨Âè∑‰∏≠Ê∑ªÂä†Âç≥ÂèØÔºåÂ¶Ç‰∏ãÔºö

```rust,ignore
struct Point<T, U> {
    x: T,
    y: U,
}

let also_work = Point { x: 5, y: 4.0 };
```

Ê≥õÂûãÁöÑÊûö‰∏æÁ±ªÂûãÂÆö‰πâÔºå‰πüÂèØ‰ª•Â§ö‰∏™Ê≥õÂûãÂèÇÊï∞Ôºö

```rust,ignore
enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Áé∞Âú®ÔºåÂÅáËÆæË¶ÅÂÆûÁé∞‰∏Ä‰∏™ÂáΩÊï∞ÔºåÂÆÉÂèØ‰ª•ËøîÂõû‰∏ÄÁªÑÊï∞ÁöÑÊúÄÂ§ßÈÇ£‰∏™ÔºåÂè™ÈúÄË¶ÅÂÆûÁé∞‰∏Ä‰∏™ÂáΩÊï∞Â∞±ÂèØ‰ª•Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò„ÄÇ

ÂΩìÈúÄË¶ÅÂèò‰∫ÜÔºåÈúÄË¶ÅÂØπÊï¥Êï∞ÂàóË°®„ÄÅÊµÆÁÇπÊï∞ÂàóË°®ËøòÊúâÂ≠óÁ¨¶‰∏≤ÂàóË°®ËøõË°åÂ§ÑÁêÜÔºåËøîÂõûÂÖ∂‰∏≠ÊúÄÂ§ßÁöÑ‰∏Ä‰∏™„ÄÇÂ¶ÇÊûúÊåâ‰º†ÁªüÊñπÂºèÔºåÂèØËÉΩÈúÄË¶ÅÂÆö‰πâ‰∏â‰∏™ÈÄªËæëÂü∫Êú¨‰∏ÄËá¥ÁöÑÂáΩÊï∞ÔºåËøôÂ∞±Âá∫Áé∞‰∫ÜÂ§ßÈáèÁöÑ‰ª£Á†ÅÈáçÂ§ç„ÄÇ

ÈÄöËøáÊ≥õÂûãÂ∑•ÂÖ∑ÂèØ‰ª•ÊúâÊïàÂú∞Ëß£ÂÜ≥ËøôÊ†∑ÁöÑÂäüËÉΩÈáçÂ§ç‰ª£Á†ÅÔºåÂè™ÈúÄË¶ÅÂÆûÁé∞‰∏Ä‰∏™Ê≥õÂûãÂáΩÊï∞ÔºåÊé•Êî∂‰∏Ä‰∏™Ê≥õÂûãÂàóË°®ÔºåÂÜçÁî®Áõ∏ÂêåÁöÑÂäüËÉΩÈÄªËæë‰ª£Á†ÅËøõË°åÂ§ÑÁêÜËøîÂõûÁªìÊûú„ÄÇ

Ê≥õÂûãÂ∑•ÂÖ∑ÁöÑËØ≠Ê≥ï‰∏äÂè™ÊòØÂú®ÂéüÊúâÁöÑÂêçÁß∞ÂêéÈù¢Â¢ûÂä†ÁÆ≠Êã¨Âè∑ÔºåÁî®‰∫é‰º†ÂÖ•Ê≥õÂûãÂ∑•ÂÖ∑ÊâÄÈúÄË¶ÅÁöÑÂèÇÊï∞ÔºåÂú®ËøôÈáåÂèØ‰ª•Â∞ÜÊ≥õÂûãÂáΩÊï∞Áúã‰ΩúÊòØ‰∏Ä‰∏™ÂáΩÊï∞Â∑•ÂéÇÔºåÂÆÉ‰ºöÊ†πÊçÆË∞ÉÁî®ÁöÑÂèÇÊï∞Á±ªÂûãÁîü‰∫ßÂá∫Áõ∏Â∫îÁöÑÂáΩÊï∞„ÄÇ

```rust,ignore
fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for elem in list {
        // error[E0369]: binary operation `>` cannot be applied to type `&T`
        if elem > largest {
            largest = elem;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```

ÂèØÊòØÔºå‰ª•‰∏äÁöÑÂáΩÊï∞‰∏≠ÔºåÊØîËæÉÂ§ßÂ∞èÁöÑÁ¨¶Âè∑‰∏çËÉΩÈÄöËøáÁºñËØë„ÄÇ

Ê≥õÂûãÊé•Êî∂‰∫ÜÂ§öÁßçÁ±ªÂûãÔºåÈÇ£‰πàÂ∞±ÈúÄË¶ÅÂØπÂéüÊúâ‰ª£Á†Å‰ΩúÈÄÇÂΩìË∞ÉÊï¥ÔºåÊØïÁ´ü‰∏çÊòØÊâÄÊúâÁ±ªÂûãÈÉΩÂèØ‰ª•ÂÅöÂêåÊ†∑ÁöÑÊìç‰Ωú„ÄÇÂØπ‰∫éËøô‰∏™‰æãÂ≠êËÄåË®ÄÔºåÊ∂âÂèä‰∫Ü‰∏§‰∏™ÂÄºÁöÑÊØîËæÉÔºåÂ∞±ÂèØËÉΩÈúÄË¶ÅËøõË°å‰∏Ä‰∫õÊâ©Â±ïÔºåTrait Â∞±ÊòØÂÅöËøô‰∏™Â∑•‰ΩúÁöÑ„ÄÇ

Âà∞ËøôÈáåÔºåÈúÄË¶ÅÂÖàÂ≠¶‰π† 10. Generic Types, Traits, and Lifetimes Á´†ËäÇÁöÑÂÜÖÂÆπÔºåÂõ†Ê≠§‰øÆÂ§ç‰ª•‰∏äÈîôËØØÂè™ÈúÄË¶Å‰∏ÄÁÇπÁÇπ Traits ÁöÑÂü∫Á°Ä„ÄÇ

ÈÇ£Â∞±ÊòØ‰∏∫Ê≥õÂûãÂáΩÊï∞ÂèÇÊï∞Êèê‰æõ std::cmp::PartialOrd Âíå Copy

```rust,ignore
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```

Rust Ê≥õÂûãÂπ∂‰∏ç‰ºö‰ΩøÁ®ãÂ∫èËøêË°åÂèòÊÖ¢ÔºåÈÄöËøáÁºñËØëÊúüÁöÑÂçï‰ΩìÂåñÔºåMonomorphizationÔºåÂ∞ÜÊ≥õÂûãËΩ¨Âèò‰∏∫ÂÖ∑‰ΩìÁ±ªÂûãÔºå‰πüÊòØÊ≥õÂûãÂåñÁöÑÈÄÜÂêëÊìç‰Ωú„ÄÇËøôÁßçÂú®ÁºñËØëÊúüÂ∞±ÂèØ‰ª•Á°ÆÂÆöÁöÑË∞ÉÁî®ÔºåÁß∞‰∏∫ static dispatch„ÄÇ‰∏é‰πãÁõ∏ÂØπÁöÑÊòØ dynamic dispatchÔºåÂç≥‰∏çËÉΩÂú®ÁºñËØëÊúüÁ°ÆÂÆöÁöÑË∞ÉÁî®ÔºåÈúÄË¶ÅÂú®ËøêË°åÊó∂Á°ÆÂÆö„ÄÇ

‰ª•‰∏ãÁ§∫ËåÉ `impl<T>` Ê≥õÂûãÂÆûÁé∞Ôºö

```rust,ignore
struct GenVal<T> {
    gen_val: T,
}

impl<T> GenVal<T> {
    fn value(&self) -> &T {
        &self.gen_val
    }
}

fn main() {
    let x = GenVal { gen_val: 3i32 };
    let y = GenVal { gen_val: "3i32" };

    println!("{}, {}", x.value(), y.value());
}
```

ÂΩìÁÑ∂Ôºå‰πüÂèØ‰ª•ÊåáÂÆöÂèÇÊï∞ÂÆûÁé∞‰ª•‰∏äÁöÑÁªìÊûÑ‰ΩìÔºåÂè™ÂÆûÁé∞Âçï‰ΩìÂåñÁâàÊú¨ÔºåÂ¶Ç `impl GenVal<&str> {}`„ÄÇ


Á§∫ËåÉÂÆûÁé∞‰∏Ä‰∏™ÂÖ∑ÊúâÊ∏ÖÁêÜÂäüËÉΩÁöÑ `Empty`Ôºö

```rust,ignore
struct Empty;
struct Null;

// A trait generic over `T`.
trait DoubleDrop<T> {
    fn drop(self, _: T);
}

// Implement `DoubleDrop<T>` for any generic parameter `T` and caller `U`.
impl<T, U> DoubleDrop<T> for U {
    // This method takes ownership of both passed arguments,
    // deallocating both.
    fn drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // Deallocate `empty` and `null`.
    empty.drop(null);

    //empty;
    //null;
    // ^ TODO: Try uncommenting these lines.
}
```

Ê≥®ÊÑèÔºå`drop()` ÊñπÊ≥ïÔºåÂèÇÊï∞Ê≤°Êúâ‰ΩøÁî®ÂºïÁî®ÔºåÂÆÉ‰ª¨‰ºöÂú®Ë∞ÉÁî®Êó∂ÂèëÁîüÊâÄÊúâÊùÉËΩ¨ÁßªÂà∞ÂáΩÊï∞ÂÜÖÈÉ®ÔºåÂπ∂ÈöèÁùÄÂáΩÊï∞Á∫øÊùüËÄåË¢´Ê∏ÖÁêÜ„ÄÇ





## ‚ö° Patterns & Match Ê®°ÂºèÂåπÈÖç
- https://doc.rust-lang.org/book/ch06-02-match.html
- Pattern Matching https://cheats.rs/#pattern-matching
- https://doc.rust-lang.org/rust-by-example/flow_control/match.html
- https://doc.rust-lang.org/stable/reference/expressions/match-expr.html
- https://doc.rust-lang.org/stable/rust-by-example/flow_control/match.html
- Patterns and Matching https://doc.rust-lang.org/book/ch18-00-patterns.html
- https://doc.rust-lang.org/stable/std/keyword.ref.html

Ê®°ÂºèÂåπÈÖçÊòØÊØîËæÉÊñ∞Â•áÁöÑËØ≠Ê≥ïÁªìÊûÑÔºåErlang ËøôÊ†∑ÁöÑËØ≠Ë®Ä‰∏≠Â§ßÈáèÈááÁî®„ÄÇ

Ê®°ÂºèÂåπÈÖçÂèØ‰ª•ÁªìÂêà match Êù•ËøõË°åÊµÅÁ®ãÊéßÂà∂Ôºå‰πüÂèØ‰ª•ÁªìÂêà let ËØ≠Âè•ÂÆåÊàêÂèòÈáèÁöÑËß£ÊûÑ„ÄÇ

ÊÄªÁöÑÊù•ËØ¥ÔºåÊúâ‰∏âÁ±ªÊ®°ÂºèÂåπÈÖçÔºö

- Destructuring ÂØπÁªìÊûÑ‰Ωì„ÄÅÂÖÉÁªÑ„ÄÅÊûö‰∏æÁ≠âÂæÖÁªÑÂêàÁ±ªÂûãËß£ÊûÑÔºå‰ª•Ëé∑ÂæóÂÖ∂‰∏≠ÁöÑÊàêÂëòÊàñÂÖÉÁ¥†ÂÄºÔºõ
- Guards ‰ΩøÁî® if Êù°‰ª∂ÂåπÈÖçÔºõ
- Binding ‰ΩøÁî® `@` ÁªëÂÆöÂÖ∑‰ΩìÂÄºÔºõ

Pattern Matching ‰ΩøÁî®Âø´ÈÄüÂèÇËÄÉÔºö

- `a | b` Â§öÊù°ÁõÆÂåπÈÖçÊìç‰ΩúÁ¨¶Ôºõ
- `_` Êàñ `..` ÁúÅÁï•ÂåπÈÖçÔºåÂåπÈÖçÊâÄÊúâÊú™ÊåáÂÆöÁöÑÊù°ÁõÆÔºõ
- `ref some` ‰ΩøÁî® `ref` ÂÖ≥ÈîÆÂ≠óÂåπÈÖçÂàõÂª∫‰∏Ä‰∏™ÂºïÁî®Ôºå`ref mut` ÂàõÂª∫‰∏Ä‰∏™ÂèØÂèòÂºïÁî®ÔºåÂíå `&` ÂºïÁî®Êìç‰ΩúÁ¨¶Âè∑Âå∫Âà´ÂºÄÊù•Ôºõ
- `(z @ 1, _)` ‰ª•ÁªëÂÆöÊ®°ÂºèÂåπÈÖç‰∏Ä‰∏™ÂÖÉÁªÑÂåñÔºåÂπ∂‰∏îÁ¨¨‰∏ÄÂÄº‰∏∫ 1ÔºåÂøΩÁï•Á¨¨‰∫å‰∏™ÂÄº„ÄÇ`@` Â≠óÁ¨¶ÂèØ‰ª•Áî®Êù•ÊåáÂÆö‰∏Ä‰∏™ÂÄºÔºå‰∏Ä‰∏™ Range Á≠âÔºõ
- `Struct(z @ 1, _)` ‰ª•ÁªëÂÆöÊ®°ÂºèÂåπÈÖç‰∏Ä‰∏™ÂÖÉÁªÑÂåñÁªìÊûÑ‰ΩìÔºåÂπ∂‰∏îÁ¨¨‰∏ÄÂÄº‰∏∫ 1ÔºåÂøΩÁï•Á¨¨‰∫å‰∏™ÂÄºÔºõ
- `Some(x) if x < 10 => ...` Match guards Âç≥‰ΩøÁî®Êù°‰ª∂ÁöÑÂåπÈÖçÔºõ

& vs ref

- `&` Ë°®Á§∫ÈúÄË¶Å‰∏Ä‰∏™ÂºïÁî®Ôºõ
- `ref` Ë°®Á§∫Âú®Ê®°ÂºèÂåπÈÖç‰∏≠Â∞ÜÂºïÁî®Ëß£ÂåÖÂá∫Êù•Ôºõ

```rust,ignore
fn main() {
    let number = 13;
    println!("Tell me about {}", number);
    match number {
        // Match a single value
        1 => println!("One!"),
        // Match several values
        2 | 3 | 5 | 7 | 13 => println!("This is a prime"),
        // Match an inclusive range
        13..=19 => println!("A teen"),
        // Handle the rest of cases
        _ => println!("Ain't special"),
        // TODO ^ Try commenting out this catch-all arm
    }

    let boolean = true;
    // Match is an expression too
    let binary = match boolean {
        // The arms of a match must cover all the possible values
        false => 0,
        true => 1,
        // TODO ^ Try commenting out one of these arms
    };
    println!("{} -> {}", boolean, binary);
}
```

Match guards Âç≥ÁªôÊ®°ÂºèÂåπÈÖçÊ∑ªÂä†Êù°‰ª∂Ôºö

```rust,ignore
let message = match maybe_digit {
    Some(x) if x < 10 => process_digit(x),
    Some(x) => process_other(x),
    None => panic!(),
};
```

Ê≥®ÊÑè‰∏ãÂàíÁ∫øÁöÑ‰ΩøÁî®Ôºå`_x` ËøôÊ†∑ÁöÑÂèòÈáèÂëΩÂêçËÆ©‰∫∫ÁúãËµ∑Êù•Â•ΩÂÉè‰ºöÂøΩÁï•ÁªëÂÆöÔºåÂÖ∂ÂÆû‰∏çÊòØÔºö

```rust,ignore
let s = Some(String::from("Hello!"));

if let Some(_s) = s {
        //   -- value moved here
    println!("found a string");
}

// println!("{:?}", s);
//                  ^ value borrowed here after partial move
```

Êõ¥Â§öÁöÑÊ®°ÂºèÂåπÈÖçÁ§∫ËåÉÔºåÂ¶Ç Range ÂåπÈÖçÔºö

```rust,ignore
let x = 9;
let message = match x {
    0 | 1  => "not many",
    2 ..= 9 => "a few",
    _      => "lots"
};

let x = 'c';

match x {
    'a'..='j' => println!("early ASCII letter"),
    'k'..='z' => println!("late ASCII letter"),
    _ => println!("something else"),
}

assert_eq!(message, "a few");

// Demonstration of pattern match order.
struct S(i32, i32);

match S(1, 2) {
    S(z @ 1, _) | S(_, z @ 2) => assert_eq!(z, 1),
    _ => panic!(),
}
```

Âú®Âæ™ÁéØ‰∏≠‰ΩøÁî®Ê®°ÂºèÂåπÈÖçÔºö

```rust,ignore
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!("{} is at index {}", value, index);
}
```

Êõ¥Â§öÂÖ≥‰∫éÁªìÊûÑ‰ΩìÂåπÈÖçÁöÑÂèÇËÄÉÔºö

```rust,ignore
struct Foo {
    x: (u32, u32),
    y: u32,
}

// Try changing the values in the struct to see what happens
let foo = Foo { x: (1, 2), y: 3 };

match foo {
    Foo { x: (1, b), y } => println!("First of x is 1, b = {},  y = {} ", b, y),

    // you can destructure structs and rename the variables,
    // the order is not important
    Foo { y: 2, x: i } => println!("y is 2, i = {:?}", i),

    // and you can also ignore some variables:
    Foo { y, .. } => println!("y = {}, we don't care about x", y),
    // this will give an error: pattern does not mention field `x`
    //Foo { y } => println!("y = {}", y),
}
```


Èô§‰∫Ü‰ΩøÁî® `match` ÂÖ≥ÈîÆÂ≠ó‰ΩøÁî®Ê®°ÂºèÂåπÈÖçÊéßÂà∂ÊµÅÁ®ãÂ§ñÔºåËøòÊúâ let ËØ≠Âè•ÁöÑÊ®°ÂºèÂåπÈÖçÔºåÂèÇËÄÉÂ¶Ç‰∏ãÔºö

- `match m {}`  Initiate pattern matching, then use match arms, c. next list.
- `let S(x) = get();`   Notably, let also destructures similar to the table below.
    - `let S { x } = s;`    Only x will be bound to value s.x.
    - `let (_, b, _) = abc;`    Only b will be bound to value abc.1.
    - `let (a, ..) = abc;`  Ignoring 'the rest' also works.
    - `let (.., a, b) = (1, 2);`    Specific bindings take precedence over 'the rest', here a is 1, b is 2.
    - `let Some(x) = get();`    Won't work üõë if pattern can be refuted, use if let instead.
- `if let Some(x) = get() {}`   Branch if pattern can be assigned (e.g., enum variant), syntactic sugar. *
    - Desugars to `match get() { Some(x) => {}, _ => () }`
- `fn f(S { x }: S)`    Function parameters also work like let, here x bound to s.x of f(s).


‰ª•‰∏ãËß£Êûê `match m {}` ÁöÑÂåπÈÖçÂàÜÊîØÔºåÂÆÉ‰ª¨ÂêåÊ†∑ÂèØ‰ª•Áî®‰∫é let ËØ≠Âè•ÁöÑÊ®°ÂºèÂåπÈÖçÔºö

- `E::A => {}`  Match enum variant A, c. pattern matching.
- `E::B ( .. ) => {}`   Match enum tuple variant B, wildcard any index.
- `E::C { .. } => {}`   Match enum struct variant C, wildcard any field.
- `S { x: 0, y: 1 } => {}`  Match struct with specific values (only accepts s with s.x of 0 and s.y of 1).
- `S { x: a, y: b } => {}`  Match struct with any(!) values and bind s.x to a and s.y to b.
    - `S { x, y } => {}`    Same, but shorthand with s.x and s.y bound as x and y respectively.
- `S { .. } => {}`  Match struct with any values.
- `D => {}` Match enum variant E::D if D in use.
- `D => {}` Match anything, bind D; possibly false friend üõë of E::D if D not in use.
- `_ => {}` Proper wildcard that matches anything / "all the rest".
- `(a, 0) => {}`    Match tuple with any value for a and 0 for second.
- `[a, 0] => {}`    Slice pattern, match array with any value for a and 0 for second.
    - `[1, ..] => {}`   Match array starting with 1, any value for rest; subslice pattern. ?
    - `[1, .., 5] => {}`    Match array starting with 1, ending with 5.
    - `[1, x @ .., 5] => {}`    Same, but also bind x to slice representing middle (c. next entry).
- `x @ 1..=5 => {}` Bind matched to x; pattern binding, here x would be 1, 2, ‚Ä¶ or 5.
- `0 | 1 => {}` Pattern alternatives (or-patterns).
    - `E::A | E::Z` Same, but on enum variants.
    - `E::C {x} | E::D {x}` Same, but bind x if all variants have it.
- `S { x } if x > 10 => {}` Pattern match guards, condition must be true as well to match.

ÁúãÂà∞Êúâ‰∫∫ÈóÆËøôÊ†∑ÁöÑË°®Ëææ `match <|>a`ÔºåÊ≤°ËßÅËøá„ÄÇ


Ê®°ÂºèÂåπÈÖç‰πü‰ºöÊúâ‰∏çÂèØÁî®ÁöÑÊÉÖÂÜµÔºö

```rust,ignore
enum Void {}

let res: Result<u32, Void> = Ok(0);

// Err doesn't exist anymore, so Ok is actually irrefutable.
let Ok(num) = res;
```

Âõ†‰∏∫ Ok(num) Âπ∂‰∏çÂåÖÂê´ `Result<u32, Void>` Á±ªÂûãÁöÑÂè¶‰∏Ä‰∏™ÂÄº ErrÔºåÊ≤°ÊúâÂÆåÊï¥Ë¶ÜÁõñÂèØËÉΩÁöÑÂÄºÔºåËøôÁßçÊÉÖÂÜµÁß∞‰∏∫ refutable patternÔºåËÄå let ËØ≠Âè•‰∏çÊé•ÂèóËøôÊ†∑ÁöÑÊ®°ÂºèÂåπÈÖç„ÄÇ

Ëß£ÂÜ≥ÊñπÊ≥ïÊòØ‰ΩøÁî® if let ËØ≠Âè•Ôºö

```rust,ignore
if let Ok(x) = res {
    println!("{}", x);
}
```


## ‚ö° Enums Êûö‰∏æÁ±ªÂûã
- https://doc.rust-lang.org/book/ch06-00-enums.html
- https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html

ÂíåÁªìÊûÑ‰Ωì‰∏ÄÊ†∑ÔºåÊûö‰∏æÁ±ªÂûã‰πüÊòØÂ§çÂêàÁ±ªÂûãÔºåÊòØÁî®Êà∑ÂÆö‰πâÁ±ªÂûã„ÄÇ

Êûö‰∏æÁ±ªÂûãÂÆö‰πâ‰∏é‰ΩøÁî®Ôºå‰æãÂ¶ÇÂÆö‰πâÁΩëÁªúÂú∞ÂùÄÁ±ªÂûãÔºö

```rust,ignore
#[derive(Debug)]
enum IpAddrKind {
    V4,
    V6,
}

#[derive(Debug)]
struct IpAddr {
    kind: IpAddrKind,
    address: String,
}
fn main() {
    
    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };
    
    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
    println!("{:?} -> {:?}", home, IpAddrKind::V4);
}
```

‰ª•‰∏ä IpAddrKind Êûö‰∏æÁ±ªÂûãÁöÑÊàêÂëòÊ≤°ÊúâÊåáÂÆöÁ±ªÂûãÔºåÂèØ‰ª•ÊåáÂÆöÊàêÂëòÁöÑÁ±ªÂûãÔºåÂπ∂‰∏îÂèØ‰ª•ÊåáÂÆö‰∏çÂêåÁöÑÊï∞ÊçÆÁ±ªÂûã„ÄÇ


```rust,ignore
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
```

```rust,ignore
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
```

```rust,ignore
enum Message {
    Quit,                       // Quit has no data associated with it at all.
    Move { x: i32, y: i32 },    // Move includes an anonymous struct inside it.
    Write(String),              // Write includes a single String.
    ChangeColor(i32, i32, i32), // ChangeColor includes three i32 values.
}
```

‰ª•‰∏äËøô‰∫õÈÉΩË°®ÊòéÊûö‰∏æÁ±ªÂûãÂíåÁªìÊûÑ‰ΩìÂæàÁõ∏‰ººÔºåÂåÖÂê´ÂÆö‰πâÊñπÊ≥ïÔºå‰πüÊòØÔºö

```rust,ignore
impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}
```

‰ΩøÁî®‰∏Ä‰∏™ Option Enum Â•ΩËøá‰ΩøÁî® Null ValuesÔºåRust Á≥ªÁªü‰∏≠Ôºå‰ΩøÁî® Option Êù•Êõø‰ª£Áõ¥Êé•‰ΩøÁî® Null ÊåáÈíà„ÄÇ

```rust,ignore
#[derive(Debug)]
enum Option<T> {
    Some(T),
    None,
}

let y: Option<i8> = Option::Some(5);
let absent_number: Option<i32> = Option::None;
if let Option::Some(x) = y {
    println!("Sum val is : {}" , x);
}else{
    println!("absent_number can not equal None")
}
```

Êûö‰∏æÁ±ªÂûãÈÖçÁΩÆ match ÊµÅÁ®ãÊéßÂà∂ÁöÑÁî®Ê≥ïÂú® Rust ‰∏≠ÂæàÂ∏∏ËßÅÔºö

```rust,ignore
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
```

‰∏Ä‰∏™Êûö‰∏æÊàêÂëòÂ∞±ÂÉèÊòØ‰∏Ä‰∏™ÁªìÊûÑ‰ΩìÂØπË±°ÔºåÈô§‰∫ÜÊûö‰∏æÂÄºÁöÑ‰ΩøÁî®ÊñπÂºèÂíåÁªìÊûÑ‰ΩìÂ∑ÆÂºÇËæÉÂ§ßÔºåÂÖ∂ÂÆÉÊñπÈù¢ÁöÑÁõ∏‰ººÊÄßÊõ¥Â§ö„ÄÇ

Êûö‰∏æÁ±ªÂûãÂíåÁªìÊûÑ‰ΩìÈÉΩÂèØ‰ª•ÂµåÂ•óÂÆö‰πâÔºå‰ΩÜ‰∏çËÉΩÂæ™ÁéØÂµåÂ•óËá™Ë∫´„ÄÇ


## ‚ö° Structures ÁªìÊûÑ‰Ωì
- https://doc.rust-lang.org/book/ch05-00-structs.html
- https://doc.rust-lang.org/stable/book/ch10-01-syntax.html
- https://doc.rust-lang.org/stable/std/keyword.struct.html
- https://doc.rust-lang.org/stable/reference/expressions/struct-expr.html
- https://doc.rust-lang.org/reference/items/structs.html

Âíå Tuples Á±ª‰ººÔºåÁªìÊûÑ‰Ωì‰πüÂèØ‰ª•ÁªÑÂêà‰∏çÂêåÁ±ªÂûãÁöÑÊï∞ÊçÆÔºå‰ΩÜÊòØÁªìÊûÑ‰ΩìÂèØ‰ª•ÁªôÊàêÂëòÂëΩÂêç„ÄÇ

Rust Êèê‰æõ‰∏âÁßçÁªìÊûÑ‰ΩìÔºö

- Unit-Like StructÔºåÂ¶Ç `struct Point`Ôºõ
- Tuple-Like StructÔºåÂ¶Ç `struct Point(i32, i32)`Ôºõ
- Named-Field StructÔºåÂ¶Ç `struct Point(x: i32, y: i32)`Ôºõ

‰ª•‰∏ã Cookie Âçï‰ΩçÁªìÊûÑ‰ΩìÁöÑÁ≠â‰ª∑Ë°®ËææÔºö

```rust,ignore
struct Cookie;
let c = [Cookie, Cookie {}, Cookie, Cookie {}];

struct Cookie {}
const Cookie: Cookie = Cookie {};
let c = [Cookie, Cookie {}, Cookie, Cookie {}];
```

Tuple-Like Struct ÁöÑÊàêÂëòËÆøÈóÆÔºö

```rust,ignore
struct Point(i32, i32);
let mut p = Point(10, 11);
let px: i32 = match p { Point(x, _) => x };
p.0 = 11;
```

Named-Field ÁªìÊûÑ‰Ωì‰ΩøÁî®Á§∫ËåÉÔºö

```rust,ignore
struct User {
    pub username: String,
    pub email: String,
    pub sign_in_count: u64,
    pub active: bool,
}

let mut user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from("anotheremail@example.com");
```

pub Âç≥ public ÂÖ¨ÂÖ±ËÆøÈóÆÔºåÂèØ‰ª•ÁúÅÁï•ÔºåÂØπ‰∫éÁªìÊûÑ‰ΩìÔºåÈªòËÆ§Â∞±ÊòØÂÖ¨ÂÖ±ËÆøÈóÆ„ÄÇ

ÂèØ‰ª•‰∏çÂÆö‰πâËÄå‰ΩøÁî®ÂåøÂêçÁªìÊûÑ‰ΩìÔºåanonymous structÔºåÂ∞±ÂÉè JSON ÂØπË±°‰∏ÄÊ†∑ÔºåÁî®Ëä±Êã¨Âè∑ÁºñÂÜôÊàêÂëò„ÄÇ

Rust ÂØπÁªìÊûÑ‰ΩìÁöÑÂ§ÑÁêÜ‰∏äÔºåÊúâÁÇπÈ´òÁ∫ßËØ≠Ë®ÄÁöÑÁâπÊÄßÔºåÂΩìÊàêÂëò‰ΩøÁî®ÁöÑÂèòÈáèÂÄºÂêåÂêçÊó∂ÔºåÂèØ‰ª•‰ΩøÁî® Struct Update Syntax ÁÆÄÂÜôÔºö

```rust,ignore
fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

‰πüÂèØ‰ª•ÁªìÂêà Tuples ÂÆö‰πâÊ≤°ÊúâÊàêÂëòÂêçÂ≠óÁöÑÁªìÊûÑ‰ΩìÔºö

```rust,ignore
#![allow(unused)]
use std::fmt::Debug; // Trait to bound with.

#[derive(Debug)]
struct Color(i32, i32, i32);

struct QuitMessage; // unit struct
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct

fn main() {
    let black = Color(0, 0, 0);
    println!("Color {:?}", black);
}
```

ËøòÂèØ‰ª•ÂÆö‰πâÂçï‰ΩçÂåñÁªìÊûÑ‰ΩìÔºåUnit-Like Structs Without Any FieldsÔºåÂç≥Ê≤°Êúâ‰ªª‰ΩïÊàêÂëòÁöÑÁªìÊûÑ‰ΩìÔºåÂ¶Ç `struct SomeUnit {}` Êàñ `struct Unit`„ÄÇ

‰ª•‰∏äÁªìÊûÑ‰Ωì‰∏≠Âè™‰ΩøÁî®‰∫ÜÂéüÂßãÊï∞ÊçÆÁ±ªÂûãÔºåÂπ∂Ê≤°Êúâ‰ΩøÁî®Âà∞Â§çÊùÇÁ±ªÂûãÔºå‰πüÊ≤°Êúâ‰ΩøÁî®ÂºïÁî®ÔºåËøô‰∫õÂÜÖÂÆπÂú®Ê∂âÂèäÁîüÂëΩÂë®ÊúüËøô‰∏ÄÊ¶ÇÂøµÁöÑÊñáÊ°£ËøõË°åËß£Êûê„ÄÇ

Ê≥õÂûãÁªìÊûÑ‰ΩìÔºö

```rust,ignore
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```
Ê≥®ÊÑèÔºåRust ÁªìÊûÑ‰ΩìÂÆö‰πâÊï∞ÊçÆÊàêÂëòÔºåËÄåÊñπÊ≥ïÂÆûÁé∞Áî± impl ÂÖ≥ÈîÆÂ≠óÂéªÂÆûÁé∞ÔºåÂíå C/C++ Âú®ÁªìÊûÑ‰ΩìÂÜÖÈÉ®Â£∞ÊòéÊñπÊ≥ï‰∏çÂêå„ÄÇ

Ê≥õÂûãÂÆûÁé∞ËøôÁßçËØ≠Ê≥ïÔºåËøòÂèØ‰ª•ÊúâÊù°‰ª∂ÂÆûÁé∞Ôºå‰∏∫ÈÇ£‰∫õÁªëÂÆöÊüê‰∫õ Trait ÁöÑÁªìÊûÑ‰ΩìÊèê‰æõÂÆûÁé∞ÔºåÂ¶Ç‰∏ãÔºö

```rust,ignore
// Listing 10-16: Conditionally implement methods on a generic type depending on trait bounds
impl<T: Display + PartialOrd> Point {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```


Âè¶Â§ñÔºåÂèÇËÄÉ Trait Á±ª‰ººÁöÑ‰∏ÄÊèΩÂ≠êÂÆûÁé∞ blanket implementations„ÄÇ



## ‚ö° Union ËÅîÂêà‰Ωì
- https://doc.rust-lang.org/reference/items/unions.html
- Rust's Unsafe Code Guidelines Reference - Unions https://rust-lang.github.io/unsafe-code-guidelines/layout/unions.html
- Rust's Unsafe Code Guidelines Reference - Enums https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html

ÁªìÊûÑ‰Ωì `Struct` ÂíåËÅîÂêà‰Ωì `Union` Áî®Ê≥ïÂæàÂÉèÔºå‰ΩÜÊòØ Rust ÁöÑËÅîÂêà‰ΩìÂíå C ËØ≠Ë®ÄÁöÑ‰∏ÄËá¥ÔºåÂè™Ê†πÊçÆÊúÄÂ§ßÂ≠óÊÆµÊù•ÂàÜÈÖçÂÜÖÂ≠òÔºåËÆøÈóÆËÅîÂêà‰ΩìÈúÄË¶Å‰ΩøÁî® unsafeÔºö

```rust,ignore
use std::mem::{size_of, align_of_val};

#[repr(C)]
union MyUnion {
    f1: i8,
    f2: f32,
}

let u = MyUnion { f2: 2. };
println!("{:p}", unsafe{&u.f1});
println!("{:p}", unsafe{&u.f2});
assert_eq!(std::mem::size_of::<MyUnion>(), size_of::<f32>());
```

Rust ÁöÑ Enums ÂÖ∂ÂÆûÊòØ Tagged UnionÔºåËÄå Union Ê≤°ÊúâÁõ∏Â∫îÁöÑ Tag ‰∏çÂÖ∑ÊúâÂÆâÂÖ®ÊÄßÔºåÊâÄ‰ª•ÈúÄË¶ÅÈÄöËøá unsafe ËøõË°åËÆøÈóÆ„ÄÇ

‰ª•‰∏ãÊûö‰∏æÁ±ªÂûã MyEnum ÂèØ‰ª•Á≠â‰ª∑Âú∞‰ΩøÁî® Union Âíå Struct ÂÆûÁé∞Ôºö

```rust,ignore
#[repr(C, Int)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
}
```

Á≠â‰ª∑ÂÆûÁé∞Ôºö

```rust,ignore
#[repr(C)]
struct MyEnumRepr {
    tag: MyEnumTag,
    payload: MyEnumPayload,
}

#[repr(Int)]
enum MyEnumTag { A, B, C, D }

#[repr(C)]
union MyEnumPayload {
   A: u32,
   B: MyEnumPayloadB,
   C: MyEnumPayloadC,
   D: (),
}

#[repr(C)]
struct MyEnumPayloadB(f32, u64);

#[repr(C)]
struct MyEnumPayloadC { x: u32, y: u8 }
```



## ‚ö° Error Handling ÈîôËØØÂ§ÑÁêÜ
- https://doc.rust-lang.org/rust-by-example/error.html
- https://doc.rust-lang.org/stable/core/option/index.html
- https://doc.rust-lang.org/stable/std/result/index.html
- https://doc.rust-lang.org/stable/std/option/index.html
- https://doc.rust-lang.org/std/panic/fn.catch_unwind.html
- https://doc.rust-lang.org/nomicon/panic-handler.html
- Writing an OS in Rust - Handling Exceptions https://os.phil-opp.com/handling-exceptions/

### üü¢üîµ Panics Option Result

Rust Êúâ‰∏ÄÂ•óÁã¨ÁâπÁöÑÂ§ÑÁêÜÂºÇÂ∏∏ÊÉÖÂÜµÁöÑÊú∫Âà∂ÔºåÂÆÉÂπ∂‰∏çÂÉèÂÖ∂ÂÆÉËØ≠Ë®Ä‰∏≠ÁöÑ try Êú∫Âà∂ÔºåÊàñ Exception Á±ªÊù•Ë°®Á§∫ÈîôËØØ„ÄÇ

Rust Á®ãÂ∫è‰∏≠‰∏ÄËà¨‰ºöÂá∫Áé∞‰∏§ÁßçÈîôËØØÔºö

- ÂèØÊÅ¢Â§çÈîôËØØÔºåÂØπÂ∫îËøîÂõû Result<T, E>„ÄÇ
- ‰∏çÂèØÊÅ¢Â§çÈîôËØØÔºåÂØπÂ∫î panic! ÂÆèÔºåÂÆÉ‰ºöË∞ÉÁî®ÁºñËØëÂô®Êèê‰æõÁöÑ‰ª£Á†ÅÁªàÊ≠¢Á®ãÂ∫èËøêË°å„ÄÇ

ÂèØÊÅ¢Â§çÈîôËØØÁöÑÂÖ∏ÂûãÊ°à‰æãÊòØÊñá‰ª∂ËÆøÈóÆÈîôËØØÔºåÂ¶ÇÊûúËÆøÈóÆ‰∏Ä‰∏™Êñá‰ª∂Â§±Ë¥•ÔºåÊúâÂèØËÉΩÊòØÂõ†‰∏∫ÂÆÉÊ≠£Âú®Ë¢´Âç†Áî®ÔºåÊòØÊ≠£Â∏∏ÁöÑÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøáÁ≠âÂæÖÊù•Ëß£ÂÜ≥„ÄÇ

‰∏çÂèØÊÅ¢Â§çÈîôËØØÊòØÁî±ÁºñÁ®ã‰∏≠Êó†Ê≥ïËß£ÂÜ≥ÁöÑÈÄªËæëÈîôËØØÂØºËá¥ÁöÑÔºå‰æãÂ¶ÇËÆøÈóÆÊï∞ÁªÑÊú´Â∞æ‰ª•Â§ñÁöÑ‰ΩçÁΩÆ„ÄÇ

Rust ÁöÑÂàÜÂ±ÇÈîôËØØÂ§ÑÁêÜÊ®°ÂºèÔºö

- Â¶ÇÊûúÂêàÁêÜÊúüÊúõÁº∫Â§±ÔºåÂàô‰ΩøÁî® `Option<T>`„ÄÇ
- Â¶ÇÊûúÈîôËØØÂèØ‰ª•ÂêàÁêÜÂú∞Â§ÑÁêÜÔºåÂàô‰ΩøÁî® `Result<T, E>`„ÄÇ
- Â¶ÇÊûúÈîôËØØÊó†Ê≥ïÂêàÁêÜÂú∞Â§ÑÁêÜÔºåÁ∫øÁ®ã panics„ÄÇ
- Â¶ÇÊûúÂèëÁîüÁÅæÈöæÊÄßÁöÑÈîôËØØÔºåÁ®ãÂ∫èÂ∞±‰ºö‰∏≠Ê≠¢„ÄÇ

‰ª•‰∏ãÊòØ‰∏§‰∏™Â∏∏ËßÅÁöÑËøîÂõûÁ±ªÂûãÔºö

    pub enum Option<T> {
        None,
        Some(T),
    }

    pub enum Result<T, E> {
       Ok(T),
       Err(E),
    }

ÊâÄÊúâÂèØËÉΩÂèëÁîüÈîôËØØÁöÑÂáΩÊï∞ÈÉΩ‰ºöËøîÂõû‰∏Ä‰∏™Ê†áÂáÜÁöÑ `Result<T, E>` Êûö‰∏æÁ±ªÂûãÔºåÂÆÉÊúâ‰∏§‰∏™Ê≥õÂûãÂèÇÊï∞ÔºåÂàÜÂà´Áî®‰∫é‰∏§‰∏™ÂèñÂÄºÔºö

- `Ok(value)` Ë°®Á§∫Êìç‰ΩúÊàêÂäüÁöÑÊàêÂëòÔºåÂåÖË£Ö‰∫Ü‰∏Ä‰∏™ `T` ÂûãÂÄºÔºõ
- `Err(why)` Ë°®Á§∫Êìç‰ΩúÂ§±Ë¥•ÁöÑÊàêÂëòÔºåÈÄöÂ∏∏Âíå panic ÂÖ≥ËÅîÔºåÂåÖË£Ö‰∫Ü‰∏Ä‰∏™ `E` ÂûãÂÄºÔºåËøô‰∏™ÂÄºÈÄöÂ∏∏ÂåÖÂê´Âá∫ÈîôÁöÑÂèÇËÄÉ‰ø°ÊÅØÔºõ

ÁªìÂêàÊ®°ÂºèÂåπÈÖçÔºåÂèØ‰ª•ÂØπÂáΩÊï∞ÂèØËÉΩÂá∫Áé∞ÁöÑÂÄºËøõË°åÂà§Êñ≠Ôºö

    if let Ok(some_value) = fun() {
        // do something with some_value
    }

Á§∫ËåÉ `Result<T, E>` Êûö‰∏æÁ±ªÂûãÁöÑ‰ΩøÁî®Ôºö

```rust,ignore
#[derive(Debug)]
enum Version { Version1, Version2 }

fn parse_version(header: &[u8]) -> Result<Version, &'static str> {
    match header.get(0) {
        None => Err("invalid header length"),
        Some(&1) => Ok(Version::Version1),
        Some(&2) => Ok(Version::Version2),
        Some(_) => Err("invalid version"),
    }
}

let version = parse_version(&[1, 2, 3, 4]);
match version {
    Ok(v) => println!("working with version: {:?}", v),
    Err(e) => println!("error parsing header: {:?}", e),
}
```

‰ª•‰∏ä‰æãÂ≠ê parse_version ÂáΩÊï∞ÁªìÂêà‰∫Ü match Ê®°ÂºèÂåπÈÖçÊù•ËøîÂõûÊï∞ÂÄºÂØπÂ∫îÁöÑ Version Êûö‰∏æÂÄºÔºåÁÑ∂ÂêéÂÜçÁî®‰∏ÄÊù° match Ê®°ÂºèÂåπÈÖç Ok or Err ÂÄºÊù•ÊâìÂç∞‰∏çÂêåÁöÑ‰ø°ÊÅØ„ÄÇ

```rust,ignore
let optional = None;
check_optional(optional);

let optional = Some(Box::new(9000));
check_optional(optional);

fn check_optional(optional: Option<Box<i32>>) {
    match optional {
        Some(p) => println!("has value {}", p),
        None => println!("has no value"),
    }
}
```

ÈÄöËøá `unwrap()` ÊñπÊ≥ïÂèØ‰ª•ÂèñÂá∫ `Ok(value)` ÂåÖË£ÖÁöÑÂÄºÔºå‰ΩÜ‰∏çËÉΩÂØπ `Err(why)` Êìç‰ΩúÔºåÂê¶Âàô panic„ÄÇÊâÄ‰ª•Âú®‰ΩøÁî® `unwrap()` ÊñπÊ≥ï‰ºöÂú®ÊïÖÈöúÊó∂ÊâßË°å panicÔºÅ Âπ∂‰∏îÁªàÊ≠¢Á®ãÂ∫è„ÄÇÊõ¥ÁÆÄÂçïÁöÑÂÅöÊ≥ïÊòØ‰ΩøÁî® ? Êìç‰ΩúÁ¨¶Êõø‰ª£ ÔºåÂÆÉÂèØ‰ª•ÈìæÂºè‰ΩøÁî®ÔºåÂ¶Ç x?ÔºåÂ¶ÇÊûú x ÊòØ None Êàñ ErrÔºåÈÇ£‰πà ? Êìç‰ΩúÁ¨¶Â∞±ÊòØÂêë‰∏ä‰º†Êí≠ panic!ÔºåÊóßÂºè‰ª£Á†ÅËøòÂèØ‰ª•‰ΩøÁî®ÂÖ∑ÊúâÁõ∏ÂêåÂäüËÉΩÁöÑ try! ÂÆè„ÄÇ

‰πüÂèØ‰ª•‰ΩøÁî® `expect()` ÊñπÊ≥ïÔºåÂÆÉÂèØ‰ª•ÊåáÂÆöÂá∫Áé∞ÈîôËØØÊó∂ÁöÑÊèêÁ§∫‰ø°ÊÅØÔºåÂπ∂‰∏îÂú®Ê≠£Â∏∏ÊÉÖÂÜµ‰∏ãËøîÂõû OK Â∞ÅË£ÖÁöÑÂÄºÔºö

    expect("Some message...");

Âπ∂‰∏îÔºåRust ÈªòËÆ§‰ΩøÁî®‰∫Ü `#[warn(unused_must_use)]`ÔºåÂç≥ÂøÖÈúÄ‰ΩøÁî®ËøîÂõûÂÄº `Result<T, E>`ÔºåÂèØ‰ª•Áõ¥Êé•‰ΩøÁî® `unwrap()`ÔºåÂ¶ÇÊûúÊàë‰ª¨Áü•ÈÅìÈîôËØØÊàñÊìç‰ΩúÂ§±Ë¥•‰∏ç‰ºöÂèëÁîüÔºå‰ΩÜÊòØÁºñËØëÂô®‰∏çÁü•ÈÅìËøô‰∏ÄÁÇπ„ÄÇ

Ê†πÊçÆ‰∏çÂêåÁöÑ‰ΩøÁî®Âú∫ÊôØÔºåResult Êàñ Option ÈÉΩÊèê‰æõ‰∫Ü‰ª•‰∏ãÁ±ª‰ººÊñπÊ≥ïÊñπ‰æøÂ§ÑÁêÜÂêÑÁßçÂèØËÉΩÁöÑÊÉÖÂÜµÔºö

- `unwrap` Áõ¥Êé•Ê∂àË¥πÊúâÊïàÊï∞ÊçÆÔºå‰∏çÁÆ°ÈîôËØØÊÉÖÂÜµ„ÄÇ
- `unwrap_unchecked` Ê∂àË¥πÊï∞ÊçÆÔºå‰∏çÊ£ÄÊü•ËøîÂõûÂÄºÊòØÂê¶‰∏∫ Err ÂÄº„ÄÇ
- `unwrap_err` Êàñ `unwrap_none` Áõ¥Êé•Ê∂àË¥πÊï∞ÊçÆ„ÄÇ
- `unwrap_err_unchecked` Ê∂àË¥πÊï∞ÊçÆÔºå‰∏çÊ£ÄÊü•ËøîÂõûÂÄºÊòØÂê¶‰∏∫ Ok ÂÄº„ÄÇ
- `unwrap_or` ËøîÂõû Ok ÂÄºÔºåÂ¶ÇÊûúÊòØ Err ÂàôËøîÂõûÊåáÂÆöÁöÑÈªòËÆ§ÂÄº„ÄÇ
- `unwrap_or_default` ËøîÂõû Ok ÂÄºÔºåÂ¶ÇÊûúÊòØ Err ÂàôËøîÂõû T Á±ªÂûãÁöÑÈªòËÆ§ÂÄºÔºåÂ¶ÇÊï∞ÂÄºÁ±ªÂûãÁöÑÈªòËÆ§ÂÄº‰∏∫ 0ÔºåÂ≠óÁ¨¶‰∏≤Á±ªÂûãÈªòËÆ§ÂÄº‰∏∫ ""„ÄÇ
- `unwrap_or_else` ËøîÂõû Ok ÂÄºÔºåÂ¶ÇÊûúÊòØ Err Âàô‰ªé‰∏Ä‰∏™Èó≠ÂåÖ‰∏≠ËÆ°ÁÆó‰∏Ä‰∏™ÂÄº„ÄÇ

```rust,ignore
#![allow(unused)]
#![feature(option_result_unwrap_unchecked)]
fn main() {
    let x: Result<u32, &str> = Err("2");
    assert_eq!(unsafe { x.unwrap_unchecked() }, 2);
}
```

ÂÖ∂ÂÆÉÈÄªËæëÊìç‰ΩúÊñπÊ≥ïÔºö

- `and` ËøîÂõû None/Err ÂÄºÔºåÂ¶ÇÊûúÊòØ Some/Ok ÂàôËøîÂõû‰∏Ä‰∏™ÊåáÂÆöÂÄº„ÄÇ
- `and_then` ËøîÂõû None/Err ÂÄºÔºåÂ¶ÇÊûúÊòØ Some/Ok Âàô‰ªé‰∏Ä‰∏™Èó≠ÂåÖ‰∏≠ËÆ°ÁÆó‰∏Ä‰∏™ÂÄº„ÄÇ
- `or` ËøîÂõû Some/Ok ÂÄºÔºåÂ¶ÇÊûúÊòØ None/Err ÂàôËøîÂõû‰∏Ä‰∏™ÊåáÂÆöÂÄº„ÄÇ
- `or_else` ËøîÂõû Some/Ok ÂÄºÔºåÂ¶ÇÊûúÊòØ None/Err Âàô‰ªé‰∏Ä‰∏™Èó≠ÂåÖ‰∏≠ËÆ°ÁÆó‰∏Ä‰∏™ÂÄº„ÄÇ

Âè¶Â§ñÔºåÂèØ‰ª•‰ΩøÁî®ÂØπËøîÂõûÂÄºËøõË°åÊò†Â∞ÑÂèòÊç¢ÊàêÂè¶‰∏ÄÁßçÂÄºÔºåÂú®ÂáΩÊï∞ËøîÂõûÂ§öÁßçÈîôËØØÁ±ªÂûãÊó∂ÔºåËøô‰∫õÊñπÊ≥ïÂèØ‰ª•Áî®Êù•Áªü‰∏ÄÈîôËØØÁ±ªÂûã„ÄÇ

- `map( |T|->T )` Â∞Ü Option„ÄÅResult ÁöÑÊï∞ÊçÆÁ±ªÂûãÊò†Â∞Ñ‰∏∫Èó≠ÂåÖËøîÂõûÁöÑÊñ∞Á±ªÂûãÔºåÂç≥Êõ¥Êñ∞ Some/Ok ÂåÖË£ÖÁöÑÊï∞ÊçÆÁ±ªÂûãÔºåËÄå‰∏çÁÆ° None/Err„ÄÇ
- `map_or( T, |T|->T )` Â∞Ü Some/Ok ÈÄöËøáË°åÈó≠ÂåÖÂáΩÊï∞Êò†Â∞ÑËΩ¨Êç¢‰∏∫ T Á±ªÂûãÔºåÂ¶ÇÊûúÊòØ None/Err ÂàôËøîÂõûÊåáÂÆöÁöÑÈªòËÆ§ÂÄºÔºåÁ¨¨‰∏Ä‰∏™ÂèÇÊï∞ÊåáÂÆöÈªòËÆ§ÂÄº„ÄÇ
- `map_or_else( |T|->T, |T|->T )` ÊåáÂÆö‰∏§‰∏™Èó≠ÂåÖÔºåÂàÜÂà´Áî®‰∫éÈáçÊñ∞Êò†Â∞Ñ None/Err Âíå Some/Ok ÂåÖË£ÖÁöÑÂÄºÁ±ªÂûã„ÄÇ

ÁúãÊ∫ê‰ª£Á†ÅÂÆö‰πâÊõ¥Ê∏ÖÊô∞Ôºö

```rust,ignore
pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {
    match self {
        Some(x) => Some(f(x)),
        None => None,
    }
}
pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {
    match self {
        Some(t) => f(t),
        None => default,
    }
}
pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {
    match self {
        Some(t) => f(t),
        None => default(),
    }
}
```

Âè¶Â§ñÔºå‰º†ÂÖ• map_or ÁöÑÂèÇÊï∞ÊòØÂâçÊúüËØÑ‰º∞ÔºåËÄå map_or_else ÂàôÊòØÂª∂ËøüËØÑ‰º∞„ÄÇ

ÂàóÂ¶ÇÔºå‰ª•‰∏ã‰æãÂ≠êÔºö

```rust,ignore
fn double_first_v1(vec: Vec<&str>) -> Option<Result<i32, ParseIntError>> {
    vec.first().map(|first| {
        first.parse::<i32>().map(|n| 2 * n)
    })
}
fn double_first_v2(vec: Vec<&str>) -> Result<Option<i32>, ParseIntError> {
    let opt = vec.first().map(|first| {
        first.parse::<i32>().map(|n| 2 * n)
    });

    opt.map_or(Ok(None), |r| r.map(Some))
}
fn double_first_v3(vec: Vec<&str>) -> Option<i32> {
    let opt = vec.first().map(|first| {
        first.parse::<i32>().map(|n| 2 * n)
    });
    opt.map_or(None, |s| {
        match s {
            Ok(v) => Some(v),
            Err(i) => None,
        }
    })
}
let numbers = vec!["42", "93", "18"];
let empty = vec![];
let strings = vec!["tofu", "93", "18"];

println!("The first doubled is {:?}", double_first_v1(numbers));
println!("The first doubled is {:?}", double_first_v1(empty));
println!("The first doubled is {:?}", double_first_v1(strings));
```

Â≠óÁ¨¶‰∏≤ÁöÑÊï∞ÂÄºËß£ÊûêÊñπÊ≥ï parse ËøîÂõûÁ±ªÂûã‰∏∫ `Result<i32, ParseIntError>`„ÄÇ

Ê†πÊçÆËæìÂÖ•Êï∞ÊçÆÔºåÂØπ‰∫é numbers Êàñ strings ËøõË°åËß£ÊûêÔºåvec.first() ÈÉΩÂèØ‰ª•ÂæóÂà∞‰∏Ä‰∏™Êï∞ÊçÆËøõË°åÂ§ÑÁêÜ„ÄÇËÄåÂ§ÑÁêÜ empty ÁöÑÁ©∫ÂêëÈáèÂàóË°®Êó∂ÔºåÂ∞±Ê≤°ÊúâÊï∞ÊçÆ‰∫Ü„ÄÇËøô‰ºöÂØºËá¥ double_first_v1 Âá∫Áé∞Ê∑∑‰π±ÁöÑËøîÂõûÂÄºÔºåÂç≥‰ΩøËß£ÊûêÊï∞ÂÄºÂá∫Èîô‰πü‰ºöÂæóÂà∞‰∏Ä‰∏™ Some ÂÄº„ÄÇ

ÈÄöËøá map ÊñπÊ≥ïÈáçÊñ∞Êò†Â∞ÑÔºåÂèØ‰ª•ÊîπÂèòËøôÊ†∑Ê∑∑‰π±ÁöÑÂ±ÄÈù¢Ôºö

    # double_first_v1
    The first doubled is Some(Ok(84))
    The first doubled is None
    The first doubled is Some(Err(ParseIntError { kind: InvalidDigit }))

    # double_first_v2
    The first doubled is Ok(Some(84))
    The first doubled is Ok(None)
    The first doubled is Err(ParseIntError { kind: InvalidDigit })

    # double_first_v3
    The first doubled is Some(84)
    The first doubled is None
    The first doubled is None

‰πüÂèØ‰ª•ÈÄöËøá ok ÊñπÊ≥ïËΩ¨Êç¢ `Option<T>` Âíå `Result<T, E>` ‰∏§ÁßçÁ±ªÂûãÔºö

```rust,ignore
let x = Some("foo");
assert_eq!(x.ok_or(0), Ok("foo"));

let x: Option<&str> = None;
assert_eq!(x.ok_or(0), Err(0));

let x = Some("foo");
assert_eq!(x.ok_or_else(|| 0), Ok("foo"));

let x: Option<&str> = None;
assert_eq!(x.ok_or_else(|| 0), Err(0));

let x: Result<u32, &str> = Ok(2);
assert_eq!(x.ok(), Some(2));

let x: Result<u32, &str> = Err("Nothing here");
assert_eq!(x.ok(), None);
```

### üü¢üîµ Unpacking & Propagating Errors with ?

Â¶ÇÊûú‰Ω†ÁöÑ‰ª£Á†ÅÊúâÂ§ßÈáèÁöÑÂáΩÊï∞Ë∞ÉÁî®‰ºöËøîÂõû ResultÔºåÈÇ£‰πàÈîôËØØÂ§ÑÁêÜÂ∞Ü‰ºöÊòØÈùûÂ∏∏ÂÜó‰ΩôÊûØÁá•ÁöÑ„ÄÇ

Rust Êèê‰æõ‰∫Ü ? Êìç‰ΩúÁ¨¶Êù•ÁÆÄÂåñÈîôËØØÂÄºÂæó‰º†Êí≠ÔºåÁõ∏ÂΩì‰∫é throws Êìç‰ΩúÔºåÂπ∂‰∏îÂèØ‰ª•ËøõË°åÈìæÂºèË°®ËææÔºö

```rust,ignore
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```

Ëøô‰∏™Êìç‰ΩúÁ¨¶Âè∑ÂØπ‰∫é `Result` or `Option` ÊàñÂÖ∂ÂÆÉÂÆûÁé∞‰∫Ü std::ops::Try ÁöÑÁ±ªÂûãÊúâÊïà„ÄÇ

Â¶ÇÊûúÂáΩÊï∞ËøîÂõû `Result` or `Option`ÔºåÈÇ£‰πàÂèØ‰ª•‰ΩøÁî® ? Êìç‰ΩúÁ¨¶„ÄÇ

```rust,ignore
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```



### üü¢üîµ Panic Hook

Rust Âú® std::panic Ê®°ÂûãÊèê‰æõ‰∫ÜÂá†‰∏™ÈîôËØØÂ§ÑÁêÜÁöÑÁõ∏ÂÖ≥ÂáΩÊï∞Ôºö

- `catch_unwind`    Ë∞ÉÁî®Èó≠ÂåÖÂπ∂ÊçïÊçâ unwinding panic„ÄÇ
- `panic_any`   Á±ª‰ºº panic ÂÆèÔºå‰ΩÜÂèØ‰ª•Êèê‰æõ‰∏Ä‰∏™ÂÄº‰Ωú‰∏∫ panic payload„ÄÇ
- `resume_unwind`   Ëß¶Âèë panic ‰ΩÜ‰∏çË∞ÉÁî® panic hook„ÄÇ
- `set_hook`    Ê≥®ÂÜå‰∏Ä‰∏™ panic hook ÂáΩÊï∞Ôºå‰ºöÊõøÊç¢Â∑≤ÁªèÊ≥®ÂÜåÁöÑÂáΩÊï∞„ÄÇ
- `take_hook`   Ëß£Èô§ panic hookÔºåÂπ∂ËøîÂõûËøô‰∏™ÂáΩÊï∞„ÄÇ

ËøòÊúâ‰∏§‰∏™ÈîôËØØ‰ø°ÊÅØÂØπË±°Ôºö

```rust,ignore
#[lang = "panic_info"]
#[stable(feature = "panic_hooks", since = "1.10.0")]
#[derive(Debug)]
pub struct PanicInfo<'a> {
    payload: &'a (dyn Any + Send),
    message: Option<&'a fmt::Arguments<'a>>,
    location: &'a Location<'a>,
}

#[lang = "panic_location"]
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[stable(feature = "panic_hooks", since = "1.10.0")]
pub struct Location<'a> {
    file: &'a str,
    line: u32,
    col: u32,
}
```

Rust ÁöÑ Unwinding Á≠ñÁï•ÂèØ‰ª•Â∞Ü panic Áä∂ÊÄÅÊÅ¢Â§çËøáÊù•Ôºö

```rust,ignore
use std::panic;

let result = panic::catch_unwind(|| {
    println!("hello!");
});
assert!(result.is_ok());

let result = panic::catch_unwind(|| {
    panic!("oh no!");
});
assert!(result.is_err());
```

‰ΩøÁî® `set_hook`„ÄÅ`take_hook` ÂèØ‰ª•Ê≥®ÂÜå„ÄÅËß£Èô§‰∏Ä‰∏™ panic hook ÂáΩÊï∞Ôºå

```rust,ignore
use std::panic;

panic::set_hook(Box::new(|panic_info| {
    if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
        println!("panic occurred: {:?}", s);
    } else {
        println!("panic occurred");
    }
    if let Some(location) = panic_info.location() {
        println!("panic occurred in file '{}' at line {}", location.file(), location.line());
    } else {
        println!("panic occurred but can't get location information...");
    }
}));

// let _ = panic::take_hook();

panic!("Normal panic");
```

‰ΩøÁî® `resume_unwind` Ëß¶Âèë panic Âπ∂‰∏îÈÅøÂÖçÊâßË°å panic hookÔºö

```rust,ignore
use std::panic;

let result = panic::catch_unwind(|| {
    panic!("oh no!");
});

if let Err(err) = result {
    panic::resume_unwind(err);
}
```

ÂèÇËÄÉ„ÄäÊ∑±ÂÖ•ÊµÖÂá∫ Rust„ÄãÔºåÂ¶ÇÊûúÊàë‰ª¨Â∞ùËØï‰ΩøÁî® `-C panic=abort` ÈÄâÈ°πÁºñËØë‰ª£Á†ÅÔºåÂèØ‰ª•ÁúãÂà∞ÔºåËøô‰∏™ std::panic::catch_unwind Ëµ∑‰∏ç‰∫Ü‰ªÄ‰πà‰ΩúÁî®„ÄÇ

    rustc -C panic=unwind test.rs
    rustc -C panic=abort test.rs

‰ΩÜÊòØÔºåËØ∑Â§ßÂÆ∂Ê≥®ÊÑèÔºåËøô‰∏™ catch_unwind Êú∫Âà∂ÁªùÂØπ‰∏çÊòØËÆæËÆ°Áî®‰∫éÊ®°Êãü ‚Äútry catch‚Äù Êú∫Âà∂ÁöÑ„ÄÇËØ∑Â§ßÂÆ∂Ê∞∏Ëøú‰∏çË¶ÅÂà©Áî®Ëøô‰∏™Êú∫Âà∂ÔºåÊù•ÂÅöÊ≠£Â∏∏ÁöÑÊµÅÁ®ãÊéßÂà∂„ÄÇÂÆÉÁöÑ‰∏ªË¶ÅÁî®Â§ÑÂú®Âì™ÈáåÂë¢ÔºåÊØîÂ¶Ç‰∏ãÈù¢ÁöÑËøô‰∫õÊÉÖÂÜµÔºö

Âú® FFI Âú∫ÊôØ‰∏ãÁöÑÊó∂ÂÄôÔºåC ËØ≠Ë®ÄË∞ÉÁî® Rust ÂáΩÊï∞ÔºåÂú® Rust ÂÜÖÈÉ®Âá∫Áé∞‰∫Ü panicÔºåÁõ¥Êé•ÊâîÂà∞ C ‰ª£Á†Å‰∏≠‰ºöÂØºËá¥Êú™ÂÆö‰πâË°å‰∏∫Ôºàundefined behaviorÔºâ„ÄÇ

Êüê‰∫õÈ´òÁ∫ßÊäΩË±°Êú∫Âà∂ÔºåÈúÄË¶ÅÈòªÊ≠¢Ê†àÂ±ïÂºÄÔºåÊØîÂ¶ÇÁ∫øÁ®ãÊ±†ÔºåÂ¶ÇÊûú‰∏Ä‰∏™Á∫øÁ®ã‰∏≠Âá∫Áé∞‰∫Ü panicÔºåÊàë‰ª¨Â∏åÊúõÂè™ÊääËøô‰∏™Á∫øÁ®ãÂÖ≥Èó≠ÔºåËÄå‰∏çËá≥‰∫éÂ∞ÜÊï¥‰∏™Á∫øÁ®ãÊ±†‰∏ÄËµ∑Ë¢´Êãñ‰∏ãÊ∞¥„ÄÇ


### üü¢üîµ Error Message

ÈîôËØØÂèëÁîüÊó∂ÔºåÈÄöÂ∏∏ÂèØ‰ª•ËÆ∞ÂΩïÁöÑÊòØ‰∏Ä‰∏™ÈîôËØØÁ†ÅÔºåËÄåÂ∞ÜÈîôËØØÁ†Å‰∏éÁõ∏ÂÖ≥ÁöÑ‰ø°ÊÅØÂÖ≥ËÅîËµ∑Êù•ÔºåÊâçËÉΩÁªôÁî®Êà∑ÂèãÂ•ΩÁöÑÊèêÁ§∫„ÄÇ

ÂèÇËÄÉ std::io Â∫ì‰∏≠ÁöÑÈîôËØØÂ§ÑÁêÜÊñπÂºèÔºö

```rust,ignore
pub struct Error {
    repr: Repr,
}

#[stable(feature = "rust1", since = "1.0.0")]
impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self.repr, f)
    }
}

#[stable(feature = "rust1", since = "1.0.0")]
impl fmt::Display for Error {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.repr {
            Repr::Os(code) => {
                let detail = sys::os::error_string(code);
                write!(fmt, "{} (os error {})", detail, code)
            }
            Repr::Custom(ref c) => c.error.fmt(fmt),
            Repr::Simple(kind) => write!(fmt, "{}", kind.as_str()),
        }
    }
}

enum Repr {
    Os(i32),
    Simple(ErrorKind),
    Custom(Box<Custom>),
}

impl fmt::Debug for Repr {
    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {
            Repr::Os(code) => fmt
                .debug_struct("Os")
                .field("code", &code)
                .field("kind", &sys::decode_error_kind(code))
                .field("message", &sys::os::error_string(code))
                .finish(),
            Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),
            Repr::Simple(kind) => fmt.debug_tuple("Kind").field(&kind).finish(),
        }
    }
}
```

Á§∫ËåÉ‰ΩøÁî®Ôºö

```rust,ignore
use std::io::{Error, ErrorKind};

fn main(){
    let not_found = ErrorKind::NotFound;
    let error = Error::from(not_found);
    assert_eq!("entity not found", format!("{}", error));
    assert_eq!("Kind(NotFound)", format!("{:?}", error));
}
```


## ‚ö° Collections ÈõÜÂêà
- https://doc.rust-lang.org/book/ch08-00-common-collections.html
- https://doc.rust-lang.org/std/collections/index.html
- https://doc.rust-lang.org/stable/std/collections/index.html
- https://doc.rust-lang.org/rust-by-example/std.html
- Learn Rust With Entirely Too Many Linked Lists https://rust-unofficial.github.io/too-many-lists/

ÈõÜÂêàÂá†‰πéÊòØÊâÄÊúâÈ´òÁ∫ßËØ≠Ë®ÄÂøÖÈúÄÁöÑÊï∞ÊçÆÁªìÊûÑÁ±ªÂûãÔºåÂÖ∂ÂÆÉÊï∞ÊçÆÁ±ªÂûã‰∏ÄËà¨Ë°®Ëææ‰∏Ä‰∏™ÂÄºÔºåËÄåÈõÜÂêàË°®Ëææ‰∏ÄÁ≥ªÂàóÁöÑÂÄºÔºåÂπ∂‰∏îËøôÊ≠§ÂÄºÂ≠òÊîæ‰∫é Heap ÂÜÖÂ≠òÂå∫ÔºåÂç≥ÁºñËØëÂô®‰∏çËÉΩÁ°ÆÂÆöÂÆÉÁöÑÂ§ßÂ∞è„ÄÇÊâÄ‰ª•ÔºåÈõÜÂêàÁ±ªÂûãÈúÄË¶ÅÂú®ËøêË°åÊó∂ÊâçÁü•ÈÅìÈúÄË¶ÅÂ§öÂ§ßÂÆπÈáèÂéªÂ≠òÂÇ®Êï∞ÊçÆÔºåÂπ∂‰∏îÂÆπÈáèÂèØ‰ª•ÈöèÊó∂Ë∞ÉÊï¥„ÄÇ‰∏çÂêåÁöÑÈõÜÂêàÁ±ªÂûãÂÖ∑Êúâ‰∏çÂêåÁöÑÊÄßËÉΩÔºåËøôÈúÄË¶ÅÊ†πÊçÆÈúÄË¶ÅÂéªÈÄâÊã©ÂêàÂºèÁöÑÈõÜÂêàÁ±ªÂûã„ÄÇ

ÈõÜÂêàÁöÑÂ∫ïÂ±ÇÂÆûÁé∞Ê∂âÂèä‰∫åÂèâÊ†ëÊï∞ÊçÆÁªìÊûÑÁöÑÂÆûÁé∞ÔºåÈúÄË¶ÅÂØπÁ∫¢ÈªëÊ†ëÊúâ‰∏ÄÂÆöÁöÑ‰∫ÜËß£„ÄÇ

‰ª•‰∏ãÊòØÊúÄÂ∏∏Áî®ÁöÑ‰∏Ä‰∫õÈõÜÂêàÁ±ªÂûãÔºö

- A `vector` allows you to store a variable number of values next to each other.
- A `string` is a collection of `characters`. We‚Äôve mentioned the `String` type previously, but in this chapter we‚Äôll talk about it in depth.
- A `hash map` allows you to associate a value with a particular key. 

Ê†áÂáÜÂ∫ì std::collections std::vec Êèê‰æõ‰∫Ü‰ª•‰∏ãÂá†ÁßçÈõÜÂêàÁ±ªÂûãÔºå‰∏ªË¶ÅÊòØÂêëÈáèÂíåÂìàÂ∏åÊò†Â∞ÑÁ±ªÂûãÔºö

- Sequences: 
    - `Vec` ÂêëÈáèÂàóË°®ÔºåÊØè‰∏™ÂÄºÁ¥ßÊé•Ââç‰∏Ä‰∏™ÂÄºÔºåÁ±ª‰ººÊï∞ÁªÑÔºåÂ∑ÆÂà´Âú®‰∫é‰ΩøÁî® Heap ÂÜÖÂ≠ò‰∏îÂèØÂä®ÊÄÅÂ¢ûÈïøÔºåÈÄöËøá vec ÂÆèÂèØ‰ª•ÂÉèÊï∞ÁªÑ‰∏ÄÊ†∑ÂàõÂª∫ÂêëÈáèÂàóË°®„ÄÇ
    - `VecDeque` Âü∫‰∫éÂèØÂ¢ûÈïøÁöÑÁéØÂΩ¢ÁºìÂÜ≤Âå∫ÁÆóÊ≥ï RingBuffer ÂÆûÁé∞ÁöÑÂèåÁ´ØÈòüÂàóÔºåÂèØ‰ª•ÂæÄ‰∏§Á´Ø push„ÄÅpop Êï∞ÊçÆÔºåËøòÂèØ‰ª•ËøõË°å rotate Êìç‰Ωú„ÄÇ
    - `LinkedList` ÂèåÂêëÈìæË°®ÔºåÊÄßËÉΩÊØî VecDeque Â∑ÆÔºåÊØî Vec Êõ¥Â∑Æ„ÄÇ
- Maps: 
    - `HashMap` Êó†Â∫èÂìàÂ∏åÊò†Â∞Ñ„ÄÇ
    - `BTreeMap` ÊúâÂ∫è‰∫åÂèâÊ†ëÊò†Â∞Ñ„ÄÇ
- Sets:  
    - `HashSet` Êó†Â∫èÂìàÂ∏åÈõÜÂêàÔºåÂÄº‰∏∫Á©∫ÂÖÉÁªÑÁöÑÁâπÂÆöÁ±ªÂûã„ÄÇ
    - `BTreeSet` ÊúâÂ∫èÁöÑ‰∫åÂèâÊ†ëÈõÜÂêàÔºåÂÄº‰∏∫Á©∫ÂÖÉÁªÑÁöÑÁâπÂÆöÁ±ªÂûã„ÄÇ
- Misc: 
    - `BinaryHeap` Âü∫‰∫é‰∫åÂèâÊúÄÂ§ßÂ†Ü(Binary Heap)ÂÆûÁé∞ÁöÑ‰ºòÂÖàÈòüÂàó„ÄÇ

Sets Âíå Collections ÈÉΩÂè´ÈõÜÂêàÔºåÈÄöÂ∏∏ÂêéËÄÖÁî®‰∫éÊ¶ÇÊã¨ÊÄßÁöÑÁß∞Ë∞ì„ÄÇ

‰ªéÁ±ªÂûãÂêçÂ≠óÂèØ‰ª•ÁúãÂà∞Ôºå‰∫åÂèâÊ†ë B-Tree ËøôÁßçÊï∞ÊçÆÁªìÊûÑÁöÑÂ∫îÁî®ÊòØÈùûÂ∏∏ÂπøÊ≥õÁöÑÔºåËÄåÂÆûÈôÖ‰∏≠ËøòÊúâÂêÑÁßçÊâ©Â±ïÁâàÊú¨ÔºåÂ¶ÇÁ∫¢ÈªëÊ†ë„ÄÇ

‰ΩøÁî®ÈõÜ‰ΩìÊó∂ÔºåÈúÄË¶ÅËÄÉËôëÈõÜÊàêÁöÑ‰∏ªË¶ÅÂºÄÈîÄÔºåÊ∂âÂèä‰ª•‰∏ãÂá†‰∏™ÊñπÈù¢Ôºö

- ÈöèÁùÄÊï∞ÊçÆÂ¢ûÈïøÔºåÈõÜÂêàÈúÄË¶ÅË∞ÉÊï¥ÂÆπÈáèÊó∂ÁöÑÂºÄÈîÄÔºõ
- 
- ÂØπ‰∫éÈìæË°®ÔºåÊï∞ÊçÆÊéíÂ∫è

Sequences

    |            |     get(i)     |    insert(i)    |   remove(i)    | append |  split_off(i)  |
    |------------|----------------|-----------------|----------------|--------|----------------|
    | Vec        | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |
    | VecDeque   | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |
    | LinkedList | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |

ÊòüÂè∑Ê†áÊ≥®ÁöÑÊñπÊ≥ïÔºåÂ¶ÇÊûúÊØîËæÉËµ∑Êù•ÔºåÈÄöÂ∏∏ `Vec` ÊòØÊúÄÂø´ÁöÑÔºåÂÖ∂ÂÆûÊòØ `VecDeque`ÔºåÊúÄÂêéÊòØ `LinkedList`„ÄÇ

Maps Âíå Sets ÁöÑÊìç‰ΩúÂºÄÈîÄ‰∏ÄËá¥

    |          |    get    |   insert  |   remove  | predecessor | append |
    |----------|-----------|-----------|-----------|-------------|--------|
    | HashMap  | O(1)~     | O(1)~*    | O(1)~     | N/A         | N/A    |
    | BTreeMap | O(log(n)) | O(log(n)) | O(log(n)) | O(log(n))   | O(n+m) |


ÊåâÊñáÊ°£Êèê‰æõÁöÑÂª∫ËÆÆÈõÜÂêàÁ±ªÂûãÁöÑÈÄâÊã©Ôºö

- Use a `Vec` when:
    - ÊÉ≥Ë¶ÅÊî∂ÈõÜ‰∏ÄÁ≥ªÂàóÊù°ÁõÆÂè¶Â§ñÂÜçËøõË°åÂ§ÑÁêÜ„ÄÇ
    - ÊÉ≥Ë¶Å‰∏Ä‰∏™ÁâπÂÆöÈ°∫Â∫èÁöÑÂÖÉÁ¥†Â∫èÂàóÔºåÂπ∂‰∏îÂè™ÈôÑÂä†Âà∞ÊàñÈù†ËøëÊú´Á´Ø„ÄÇ
    - ÊÉ≥Ë¶Å‰∏Ä‰∏™ Stack Êï∞ÊçÆÁªìÊûÑ„ÄÇ
    - ÊÉ≥Ë¶Å‰∏Ä‰∏™ÂèØ‰ª•Ë∞ÉÊï¥Â§ßÂ∞èÁöÑÊï∞ÁªÑ„ÄÇ
    - ÊÉ≥Ë¶Å‰∏Ä‰∏™‰ΩøÁî® Heap ÂÜÖÂ≠òÁöÑÊï∞ÁªÑ„ÄÇ
- Use a `VecDeque` when:
    - ÊÉ≥Ë¶ÅÊÉ≥Ë¶Å‰∏Ä‰∏™ÊîØÊåÅÂú®Â∫èÂàó‰∏§Á´ØÊúâÊïàÊèíÂÖ•Êï∞ÊçÆÁöÑ Vec„ÄÇ
    - ÊÉ≥Ë¶ÅÊÉ≥Ë¶Å‰∏Ä‰∏™ÈòüÂàó„ÄÇ
    - ÊÉ≥Ë¶ÅÊÉ≥Ë¶Å‰∏Ä‰∏™ÂèåÁ´ØÈòüÂàó queue or deque„ÄÇ
- Use a `LinkedList` when:
    - ÊÉ≥Ë¶Å‰∏Ä‰∏™Â§ßÂ∞èÊú™Áü•ÁöÑ Vec or VecDequeÔºå‰ΩÜÊòØ‰∏çÂÆπÂøçÊëäÊ¥æÔºàtolerate amortizationÔºâ„ÄÇ
    - ÊÉ≥Ë¶ÅÈ´òÊïà split„ÄÅappend ÁöÑÂàóË°®„ÄÇ
    - ÁúüÁöÑÁ°ÆÂÆöÈúÄË¶Å‰∏Ä‰∏™ÂèåÂêëÈìæË°®ÔºåËøûÁª≠ÁöÑÁ°ÆËÆ§Ë°®Á§∫Ëøô‰∏™Êï∞ÊçÆÁªìÊûÑÊòØÊ∂àËÄóÊØîËæÉÂ§ßÁöÑ„ÄÇ
- Use a `HashMap` when:
    - ÊÉ≥Ë¶ÅÈÄöËøáÂÖ≥ËÅî keys ËÆøÈóÆ‰ªªÊÑèÁöÑ‰ªÄ„ÄÇ
    - ÊÉ≥Ë¶Å‰∏Ä‰∏™ÁºìÂ≠ò„ÄÇ
    - ÊÉ≥Ë¶Å‰∏Ä‰∏™ÂΩ±Â∞ÑÔºåÂ∞±Âè™ÊòØËøô‰∏™ÈúÄÊ±Ç„ÄÇ
- Use a `BTreeMap` when:
    - ÊÉ≥Ë¶Å‰∏Ä‰∏™ key ÊòØÊúâÂ∫èÁöÑÂΩ±Â∞Ñ„ÄÇ
    - ÊÉ≥Ë¶ÅÊåâÈúÄËé∑Âèñ‰∏Ä‰∏™ËåÉÂõ¥ÁöÑÊù°ÁõÆ„ÄÇ
    - ÂØπÊúÄÂ∞èÊàñÊúÄÂ§ßÁöÑÈîÆÂÄºÂØπÊÑüÂÖ¥Ë∂£„ÄÇ
    - ÊÉ≥Ë¶ÅÊü•ÊâæÁõ∏‰ººÊàñÊõ¥Â§ßÁöÑÂÜÖÂÆπÂÖ≥ËÅîÁöÑÊúÄÂ§ßÊàñÊúÄÂ∞èÁöÑ key„ÄÇ
- Use the `Set` variant of any of these Maps when:
    - Âè™ÈúÄË¶ÅËÆ∞ÂæóÂì™‰∫õÈîÆÊòØÁúãÂà∞ËøáÁöÑ„ÄÇ
    - Ë¶ÅÂ§ÑÁêÜÁöÑÂÄºÂπ∂Ê≤°ÊúâÂÖ≥ËÅîÁöÑ keys„ÄÇ
    - Âè™ÈúÄË¶Å‰∏Ä‰∏™ set ÈõÜÂêà„ÄÇ
- Use a `BinaryHeap` when:
    - ÊÉ≥Ë¶ÅÂ≠òÂÇ®‰∏ÄÂ†ÜÂÖÉÁ¥†ÔºåÈúÄË¶ÅÂú®‰ªª‰ΩïÁªôÂÆöÊó∂Èó¥Âè™Â§ÑÁêÜÊúÄÂ§ßÊàñÊúÄÈáçË¶ÅÁöÑÂÖÉÁ¥†„ÄÇ
    - ÊÉ≥Ë¶Å‰∏Ä‰∏™‰ºòÂÖàÁ∫ßÈòüÂàó„ÄÇ

ÊâÄÊúâÁöÑÊëäÈîÄÊàêÊú¨ÊòØÊåáÂΩìÂÆπÈáèÁî®Â∞ΩÊó∂ÂèØËÉΩÈúÄË¶ÅÈáçÊñ∞Ë∞ÉÊï¥Â§ßÂ∞è„ÄÇÂ¶ÇÊûúÂèëÁîüË∞ÉÊï¥Â§ßÂ∞èÔºåÈúÄË¶ÅO(n)Êó∂Èó¥„ÄÇÊàë‰ª¨ÁöÑÈõÜÂêà‰ªéÊù•‰∏ç‰ºöËá™Âä®Áº©Â∞èÔºåÊâÄ‰ª•ÁßªÈô§Êìç‰Ωú‰∏ç‰ºöÊëäÈîÄ„ÄÇÂú®Ë∂≥Â§üÂ§ßÁöÑ‰∏ÄÁ≥ªÂàóÊìç‰Ωú‰∏≠ÔºåÊØèÊ¨°Êìç‰ΩúÁöÑÂπ≥ÂùáÊàêÊú¨Â∞ÜÁ°ÆÂÆöÂú∞Á≠â‰∫éÁªôÂÆöÊàêÊú¨„ÄÇ

ÂÆπÈáèÁÆ°ÁêÜÊòØÈõÜÂêà‰∏≠ÈáçË¶ÅÁöÑÂÜÖÂÆπÔºåÈõÜÂêàÊï∞ÊçÆÂ≠òÂÇ®ÊòØÂü∫‰∫éÊï∞ÁªÑÁöÑÔºåÂ¶ÇÊûúËÉåÂêéÁöÑÊï∞ÁªÑÂ§ßÂ∞èÂíåÊï∞ÊçÆÂ§ßÂ∞è‰∏ÄËá¥ÔºåËøôÂπ∂‰∏çÊòØÂæàÊúâÊïàÁöÑÁ≠ñÁï•„ÄÇÂõ†‰∏∫ÊØèÊ¨°Êï∞ÊçÆÂèòÂä®ÈÉΩ‰ºöÂØºËá¥ÂÆπÈáèÁöÑË∞ÉÊï¥ÔºåËøôÊÑèÂë≥ÁùÄÈúÄË¶ÅÈáçÊñ∞ÂàÜÈÖçÂÜÖÂ≠òÔºåËøôÊòØÂ§ßÂ§öÊï∞ËÆ°ÁÆóÊú∫‰∏äÂàÜÈÖçÂíåÁÆ°ÁêÜÂÜÖÂ≠òÁöÑÊñπÂºè„ÄÇÂàÜÈÖç‰∏Ä‰∏™ÂÖ®Êñ∞ÁöÑÊï∞ÁªÑÂêéÔºåÂÜçÂ∞ÜÊóßÊï∞ÁªÑ‰∏≠ÁöÑÊØè‰∏™ÂÖÉÁ¥†Â§çÂà∂Âà∞Êñ∞Êï∞ÁªÑ‰∏≠ÔºåËøôÂπ∂‰∏çÊòØÊúâÊïàÁöÑÊìç‰Ωú„ÄÇ

Âõ†Ê≠§ÔºåÂ§ßÂ§öÊï∞ÈõÜÂêà‰ΩøÁî®ÂàÜÊëäÁ≠ñÁï•ÔºåÂÖàÂàÜÈÖçÁõ∏ÂΩìÂ§öÁöÑÁ©∫Èó≤Á©∫Èó¥ÔºåÊØîÂ¶ÇÂ§ö‰∫éÊï∞ÊçÆ‰∏ÄÂÄçÁöÑÁ©∫Èó¥ÔºåËøôÊ†∑Âè™‰ºöÂÅ∂Â∞îËß¶ÂèëÂÆπÈáèË∞ÉÊï¥„ÄÇÂΩìÊï∞ÊçÆÁ°ÆÂÆûÂ¢ûÈïøËøáÂ§ßÊó∂ÔºåÊâç‰ºöÈáçÊñ∞ÂàÜÈÖç‰∏Ä‰∏™Â§ßÂæóÂ§öÁöÑÊï∞ÁªÑÊù•ÁßªÂä®ÂÖÉÁ¥†Ôºå‰ª•‰æøÈúÄË¶Å‰∏ÄÊÆµÊó∂Èó¥Êâç‰ºöËøõË°åÂè¶‰∏Ä‰∏™Â¢ûÈïø„ÄÇËôΩÁÑ∂ËøôÁßçÁ≠ñÁï•ÊÄª‰Ωì‰∏äÂæàÂ•ΩÔºå‰ΩÜÂ¶ÇÊûúÈõÜÂêà‰∏çÂøÖË∞ÉÊï¥ÂÖ∂ÂêéÂ§áÊï∞ÁªÑÂ§ßÂ∞èÔºåÊïàÊûú‰ºöÊõ¥Â•Ω„ÄÇÊâÄ‰ª•ÔºåÂºÄÂèëËÄÖ‰ΩøÁî®ÈõÜÂêàÊó∂ÈúÄË¶ÅÁªô‰∏Ä‰∫õÊåáÁ§∫‰ø°ÊÅØ„ÄÇ

ÈõÜÂêàÂØπË±°Êèê‰æõ‰∫ÜÂ§öÁßçÊûÑÈÄ†ÂáΩÊï∞Ôºå`with_capacity(capacity: usize)` ÊåáÂÆöÈúÄË¶ÅÁöÑÂÆπÈáèÂ∞±ÂèØ‰ª•ÈÅøÂÖç‰∏çÂøÖË¶ÅÁöÑÈáçÂ§çÂÜÖÂ≠òÊìç‰ΩúÔºåÂ¶ÇÊûúÁü•ÈÅìÊï∞ÊçÆÂ§ßÂ∞èÂ∞±Â∞ΩÂèØËÉΩ‰ΩøÁî®ËøôÁ±ªÊñπÊ≥ï„ÄÇ

Â¶ÇÊûúÂèØ‰ª•È¢ÑÊúüÂà∞‰ºöÊúâÂ§ßÈáèÂÖÉÁ¥†Ôºå`reserve(&mut self, additional: usize)` ÊñπÊ≥ïÂèØ‰ª•ÊèêÁ§∫ÈõÜÂêàÂáÜÂ§á‰∏∫Âç≥Â∞ÜÂà∞Êù•ÁöÑÊï∞ÊçÆÁïôÂá∫Â§öÂ∞ëÁ©∫Èó¥„ÄÇ

Â¶ÇÊûúÁ°ÆÂÆö‰∏çÂÜçÊúâÂÖ∂ÂÆÉÊï∞ÊçÆÔºåÂàôÂèØ‰ª•‰ΩøÁî® `shrink_to_fit()` ÊñπÊ≥ïÂ∞ÜÂ§ö‰ΩôÁöÑÂêéÂ§áÁ©∫Èó¥Ê∏ÖÁêÜÊéâ„ÄÇÂ¶Ç‰ΩïË∞ÉËØïÈúÄË¶ÅÊòéÁ°ÆÁü•ÈÅì‰ΩøÁî®Â§öÂ§ßÂÆπÈáèÔºåÂèØ‰ª•ÈÄöËøá `capacity()` ÊñπÊ≥ïËé∑Âèñ„ÄÇ

ÈõÜÂêàÁöÑÂÖÉÁ¥†ÂèØ‰ª•ÈÄöËøáÊûö‰∏æÊñπÂºèÊúâÊïàÁöÑËÆøÈóÆÔºåÈÄöËøá `iter()` ÊñπÊ≥ïËé∑ÂèñËø≠‰ª£Âô®Ôºö

```rust,ignore
let vec = vec![1, 2, 3, 4];
for x in vec.iter() {
   println!("vec contained {}", x);
}

let mut vec = vec![1, 2, 3, 4];
for x in vec.iter_mut() {
   *x += 1;
}
```

‰ΩøÁî® `into_iter()` ÊñπÊ≥ïÂèØ‰ª•Â∞ÜÈõÜÂêàËΩ¨Êç¢‰∏∫ÊåâÂÄºÈÅçÂéÜÁöÑËø≠‰ª£Âô®ÔºåÊ≥®ÊÑèÂíå `iter()` Ëé∑ÂèñËø≠‰ª£Âô®ÁöÑÂ∑ÆÂà´Ôºå‰∏Ä‰∏™ÊåâÂÄºËø≠‰ª£Ôºå‰∏Ä‰∏™ÊåâÂºïÁî®Ëø≠‰ª£„ÄÇÂΩì‰∏çÂÜçÈúÄË¶ÅÈõÜÂêàÊú¨Ë∫´ÔºåËÄåÂÖ∂‰ªñÂú∞ÊñπÈúÄË¶ÅÂÄºÊó∂ÔºåËøôÊòØÈùûÂ∏∏Â•ΩÁöÑ„ÄÇËøòÊúâ `extend()` ÊñπÊ≥ïÊòØ‰∏ªË¶ÅÁöÑÁî®Êù•Â∞Ü‰∏Ä‰∏™ÈõÜÂêàÁöÑÊï∞ÊçÆÁßªÂà∞Âè¶‰∏Ä‰∏™ÈõÜÂêà‰∏≠ÔºåÂÆÉ‰ºöËá™Âä®Ë∞ÉÁî® `into_iter()` ÊñπÊ≥ï„ÄÇ

```rust,ignore
use std::collections::VecDeque;

let mut vec1 = vec![1, 2, 3, 4];
let vec2 = vec![10, 20, 30, 40];

// move values from vec2 to vec1, and vec1 to buf
vec1.extend(vec2);
let buf: VecDeque<_> = vec1.into_iter().collect();
```

ÂíåÈõÜÂêàÈÖçÂêà‰ΩøÁî®ÁöÑËø≠‰ª£Âô®ÂØπË±°ÊñπÊ≥ïËøòÊúâÔºö

- `map()` Êò†Â∞Ñ‰∏∫‰∏Ä‰∏™Êñ∞ÁöÑËø≠‰ª£Âô®ÔºåÂ¶Ç `iter.map(|x| x*2)`Ôºõ
- `fold()` Á±ª‰ºº reduce ÊñπÊ≥ïÔºåÂ¶Ç `iter.fold(0, |a, b| a+b)`Ôºõ
- `skip(n)` Ë∑≥ËøáÊåáÂÆöÊï∞ÈáèÁöÑÂÖÉÁ¥†Ôºõ
- `take(n)` ÊãøÊéâÊåáÂÆöÊï∞ÈáèÁöÑÂÖÉÁ¥†Ôºõ
- `rev()` ÂèçËΩ¨Ëø≠‰ª£Âô®È°∫Â∫èÔºõ


Âè¶Â§ñÔºåÂØπ‰∫éÊò†Â∞ÑÁ±ªÂûãÔºåËøòÊúâÁõ∏Â∫îÁöÑ entry Êìç‰ΩúÁöÑÁõ∏ÂÖ≥ÂáΩÊï∞Ôºå‰ª•Êèê‰æõ‰∏ÄÁßçÊúâÊïàÁöÑÊú∫Âà∂ÔºåÁî®‰∫éÊúâÊù°‰ª∂Âú∞ÊìçÁ∫µ key Êò†Â∞ÑÁöÑÂÜÖÂÆπÔºåËøôÊñπÈù¢ÁöÑ‰∏ªË¶ÅÂä®Êú∫ÊòØÊèê‰æõÊúâÊïàÁöÑÁ¥ØÂä†Âô®Êò†Â∞Ñ„ÄÇ

ÊØîÂ¶ÇÔºåË¶ÅÂØπ key Âá∫Áé∞ÁöÑËøáÁöÑÊ¨°Êï∞ËÆ°Êï∞Ôºå‰ºöÈúÄË¶ÅÊ†πÊçÆ key ÊòØÂê¶ÊòØÈ¶ñÊ¨°Âá∫Áé∞ËøõË°åÊù°‰ª∂Âà§Êñ≠ÔºåÊâßË°å find ÂêéÂÜçÊâßË°å insert Êìç‰ΩúÔºåÂπ∂‰∏îÂú®ÊØèÊ¨°Êìç‰Ωú‰∏≠ÊúâÊïàÁéáÂú∞ÈáçÂ§çÊâßË°åËøô‰∏ÄËøáÁ®ã„ÄÇ

```rust,ignore
use std::collections::btree_map::BTreeMap;

let mut count = BTreeMap::new();
let message = "she sells sea shells by the sea shore";

for c in message.chars() {
    *count.entry(c).or_default() += 1;
}

assert_eq!(count.get(&'s'), Some(&8));

println!("Number of occurrences of each character");
for (char, count) in &count {
    println!("{}: {}", char, count);
}
```

ÂΩìÊâßË°å `map.entry(&key)` ÊñπÊ≥ïÔºåÊò†Â∞Ñ‰ºöÊêúÁ¥¢ key Âπ∂ÂæóÂà∞‰∏Ä‰∏™ `Entry` Êûö‰∏æÂèòÈáè„ÄÇ

Â¶ÇÊûúÊòØ‰∏Ä‰∏™Á©∫Êù°ÁõÆ `Vacant(entry)`ÔºåÂàôË°®Á§∫ key ‰∏çÂ≠òÂú®„ÄÇÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÂîØ‰∏ÄÊúâÊïàÁöÑÊìç‰ΩúÊòØÂú®Êù°ÁõÆ‰∏≠ÊèíÂÖ•‰∏Ä‰∏™ÂÄº„ÄÇÂÆåÊàêÊèíÂÖ•Êù°ÁõÆÂêéÔºåÂ∞ÜÁ©∫Êù°ÁõÆËΩ¨Êç¢‰∏∫‰∏∫ÊèíÂÖ•ÁöÑÂÄºÁöÑÂèØÂèòÂºïÁî® mutable reference„ÄÇËøôÂÖÅËÆ∏Âú®ÊêúÁ¥¢Êú¨Ë∫´ÁöÑÁîüÂ≠òÊúü‰πãÂ§ñÂØπÂÄºËøõË°åËøõ‰∏ÄÊ≠•ÁöÑÊìç‰ΩúÔºåÈúÄË¶ÅÂØπÂÄºÊâßË°åÂ§çÊùÇÁöÑÈÄªËæëËÄå‰∏çÁÆ°ËØ•ÂÄºÊòØÂê¶ÂàöÂàöÊèíÂÖ•ÔºåËøôÂ∞ÜÈùûÂ∏∏ÊúâÁî®„ÄÇ

Â¶ÇÊûúÊòØ‰∏Ä‰∏™Â∑≤Âç†Áî®Êù°ÁõÆ `Occupied(entry)` ÂàôË°®Á§∫ÊâæÂà∞ keyÔºåÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÂèØ‰ª•Ëé∑Âèñ„ÄÅÊèíÂÖ•ÊàñÂà†Èô§ÂØπÂ∫îÁöÑÂÄº„ÄÇÊ≠§Â§ñÔºåËøòÂèØ‰ª•Â∞ÜÂç†Áî®ÁöÑÊù°ÁõÆËΩ¨Êç¢‰∏∫ÂØπÂÖ∂ÂÄºÁöÑÂèØÂèòÂºïÁî®Ôºå‰ªéËÄåÊèê‰æõÂØπÁß∞ÁöÑÊèíÂÖ•Êìç‰Ωú„ÄÇ



### üü¢üîµ Vec ÂêëÈáèÂàóË°®
- https://doc.rust-lang.org/stable/std/vec/struct.Vec.html
- The Rustonomicon - Implementing Vec https://doc.rust-lang.org/nomicon/vec.html
- Rust È´òÁ∫ß‰∏éÈùûÂÆâÂÖ®Á®ãÂ∫èËÆæËÆ° - ÂÆûÁé∞ Vec https://learnku.com/docs/nomicon/2018/90-implementing-vec/4743

Â≠óÁ¨¶‰∏≤Á±ªÂûã String Â∞±ÊòØÊúÄÂ∏∏ËßÅÁöÑÂêëÈáèÂàóË°®Ôºå‰ΩøÁî® `vec!` ÂÆèÊòØÊúÄÁÆÄÂçïÁöÑÂêëÈáèÂàóË°®ÂàõÂª∫ÊñπÂºèÔºåÂèØ‰ª•ÂÉèÊï∞ÁªÑ‰∏ÄÊ†∑ÂàõÂª∫‰∏Ä‰∏™ÂêëÈáèÂàóË°®„ÄÇ

ÊàñËÄÖ‰ΩøÁî® `Vec::new()` ÊñπÊ≥ïÊûÑÈÄ†Ôºö

    use crate::raw_vec::RawVec;

    pub const fn new() -> Self {
        Vec { buf: RawVec::NEW, len: 0 }
    }

ÂèØ‰ª•‰ΩøÁî® Vec Â≠òÂÇ®‰∏çÂêåÁ±ªÂûãÁöÑÂÄºÔºö

```rust,ignore
#[derive(Debug)]
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
println!("{:?}", row);
```

Â∏∏Áî® Vec Êìç‰ΩúÂèÇËÄÉÔºö

```rust,ignore
// Iterators can be collected into vectors
let vec_list: Vec<i32> = (1..4).collect();
let vec_list = vec![1, 2, 3];

// Define a mutable vectors so it can grow
let mut vec_list: Vec<i32> = Vec::new();
vec_list.push(1);
vec_list.push(2);
vec_list.push(3);

// borrow `vec_list` as mutable
let third = vec_list.pop().take();

assert_eq!(vec_list, vec![1,2]);
assert_eq!(third, Some(3));

let first = &vec_list[0];
let second = &vec_list[1];
assert_eq!(first, &(1));

println!("First element: {:?}", first);
println!("Second element: {:?}", second);
println!("Third element popped: {:?}", third);
println!("vector list: {:?}", vec_list);
println!("vector list len: {:?}", vec_list.len());
println!("vector list cap: {:?}", vec_list.capacity());

// Out of bounds indexing yields a panic
// println!("Fourth element: {}", vec_list[3]);
// FIXME ^ Comment out this line

// `Vector`s can be easily iterated over
println!("Contents of vec_list:");
for x in vec_list.iter() {
    println!("> {}", x);
}

// A `Vector` can also be iterated over while the iteration
// count is enumerated in a separate variable (`i`)
for (i, x) in vec_list.iter().enumerate() {
    println!("In position {} we have value {}", i, x);
}

// Thanks to `iter_mut`, mutable `Vector`s can also be iterated
// over in a way that allows modifying each value
for x in vec_list.iter_mut() {
    *x *= 3;
}
println!("Updated vector: {:?}", vec_list);
```

Ê†πÊçÆËæìÂÖ•ÂàõÂª∫ÊåáÂÆöÂÆπÈáèÂêëÈáèÂàóË°®Ôºö

```rust,ignore
use std::env;
use std::str::FromStr;

let args: Vec<String> = env::args().collect();

if args.len()==1 {
    println!("usage: {} num", args[0]);
    return;
}
let number = match usize::from_str(&args[1]){
    Ok(val) => {
        let vec:Vec<usize> = Vec::with_capacity(val);
        dbg!(vec.len(), vec.capacity());
        val
    }
    Err(info) => {
        dbg!(info);
        0
    }
};
```



### üü¢üîµ String Â≠óÁ¨¶‰∏≤ÂàóË°®
- https://doc.rust-lang.org/std/str/
- https://doc.rust-lang.org/std/string/
- https://doc.rust-lang.org/stable/std/ffi/struct.CString.html
- https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html
- Rust Language Cheat Sheet https://cheats.rs/#strings-chars
- Storing UTF-8 Encoded Text with Strings  https://doc.rust-lang.org/book/ch08-02-strings.html
- regex 1.4.5 https://crates.io/crates/regex

Rust Êúâ‰∏§Á±ªÂ≠óÁ¨¶‰∏≤Ôºå`String` Á±ªÂûãÂü∫‰∫éÂêëÈáèÂàóË°® `Vec<u8>`ÔºåËÄåÂ≠óÁ¨¶‰∏≤ `&str` ÊòØÂàáÁâáÁ±ªÂûã `&[u8]`„ÄÇ
Âú®‰ª£Á†ÅÊñá‰ª∂‰∏≠ÁöÑÂ≠óÈù¢ÈáèÔºåÂç≥ÂèåÂºïÂè∑ÁöÑÂ≠óÁ¨¶‰∏≤Â≠óÈù¢ÈáèÊòØ `&str` Á±ªÂûãÔºåto_string() ÊñπÊ≥ïÂèØËé∑Âèñ String Á±ªÂûã„ÄÇ

Stirng Âà∞ &str ÂèØ‰ª•Áõ¥Êé• as_str() Âà∞ËΩ¨Êç¢ÂæóÂà∞ÔºåÊ≤°Êúâ‰ªÄ‰πàËÆ°ÁÆóËøáÁ®ã„ÄÇ

Âè¶Â§ñÔºåÂõ†‰∏∫‰ª•‰∏ãÁêÜÁî±ÔºåRust Êèê‰æõ‰∫ÜÁ±ª‰ººÁöÑ OsString Âíå &OsStr ‰∏§ÁßçÂ≠óÁ¨¶‰∏≤Ôºö

- Âú® Unix Á≥ªÁªüÔºåÂ≠óÁ¨¶‰∏≤ÂèØ‰ª•ÊòØ‰ªªÊÑèÈùû 0 ÂÄºÂ≠óËäÇÂ∫èÂàóÔºåÈÄöÂ∏∏Ëß£Êûê‰∏∫ UTF-8„ÄÇ
- Âú® Windows Á≥ªÁªüÔºåÂ≠óÁ¨¶‰∏≤Ëß£Êûê‰∏∫Èùû 0 ÂÄº 16-bit ÂÄºÔºåËß£Êûê‰∏∫ UTF-16„ÄÇ
- Rust ÁöÑÂ≠óÁ¨¶ÊÄªÊòØÊúâÊïàÁöÑ UTF-8 Â≠óÁ¨¶ÈõÜÔºåÂåÖÊã¨ 0 ÂÄº„ÄÇ

Rust ‰ΩøÁî® OsString & OsStr ÂØπÊé•Âπ≥Âè∞ÂéüÁîüÂ≠óÁ¨¶‰∏≤ÂÄºÔºåÂÆÉ‰ª¨ÂèØ‰ª•È´òÊïàÂú∞‰∫íÁõ∏ËΩ¨Êç¢ÔºåÂá†‰πéÊ≤°Êúâ‰ªª‰ΩïÊ∂àËÄó„ÄÇ

Âè¶Â§ñÔºå‰∏∫‰∫ÜÊèê‰æõ C/C++ FFI ËØ≠Ë®ÄÊé•Âè£ÔºåÂèàÊèê‰æõ‰∫Ü &CStr Âíå CString ‰∏§Á±ªÂ≠óÁ¨¶‰∏≤ÔºåÂÆÉ‰ª¨‰ª• NUL Â≠óÁ¨¶‰Ωú‰∏∫ÁªìÊùüÊ†áËÆ∞ÔºåÂÆÉ‰ª¨‰πüÊòØ‰∏çÂê´ 0 ÂÄºÁöÑÂ≠óÁ¨¶‰∏≤„ÄÇÂú® Unix Á≥ªÁªüË∞ÉÁî®‰∏≠ÔºåÂ∫îËØ•‰ΩøÁî® CStr„ÄÇ

C++ Á®ãÂ∫èÊãºÊé•Â≠óÁ¨¶‰∏≤Ôºö

```rust,ignore
string s1 = "Hello,";
const string s2 = "world";
s1 += s2;
```

Rust Á®ãÂ∫èÊãºÊé•Â≠óÁ¨¶‰∏≤Ôºö

```rust,ignore
let mut s1 = "Hello,".to_string();
let s2 = "world".to_string();
s1 += &s2;
```

Rust Â≠óÁ¨¶‰∏≤ÁöÑÊãºÊé•ÔºåÊ†πÊú¨Â∞±ÊòØÊääÂä†Ê≥ïÊìç‰ΩúÁ¨¶Âè≥‰æßÁöÑÂ≠óÁ¨¶‰∏≤ÔºåÊã∑Ë¥ù‰∏Ä‰ªΩÔºåÂπ∂ÈôÑÂà∞Â∑¶‰æßÂ≠óÁ¨¶‰∏≤‰πãÂêéÔºåÂêåÊó∂Âè≥‰æßÁöÑÂ≠óÁ¨¶‰∏≤ÁöÑÊâÄÊúâÊùÉ‰∏çÂèóÂΩ±Âìç„ÄÇRust ËØ≠Ë®ÄÁöÑËÆæËÆ°ÈúÄË¶ÅÂ∞Ü„ÄåÂÄüÁî®„ÄçÊòæÂºèÂÜôÂá∫ÔºåÊâÄ‰ª•Â∞±ÊØî C++ Â§ö‰∫Ü‰∏Ä‰∏™ÂÄüÁî®Êìç‰ΩúÁ¨¶„ÄÇ

‰∏§‰∏™ `&str` ‰πü‰∏çËÉΩÁõ¥Êé•Áõ∏Âä†Ôºå‰ΩÜÂèØ‰ª•Â∞Ü `&str` Âä†Âà∞ String ‰∏äÔºåÂπ∂‰∏îÔºå‰∏§‰∏™ String Áõ∏Âä†ÔºåË¶ÅÂ∞Ü + Âè≥‰æßÁöÑËΩ¨Êç¢‰∏∫ÂÄüÁî®ÂΩ¢ÂºèÔºö

    let s = "Hello," + "world"; // Can't use + with two &str
    let s = s1 + &s2; // Move s1 to s, and concats s2 to s

ÂØπ‰∫é + Âè≥‰æßÁöÑ String ÂÆÉÂøÖÈúÄËΩ¨Êç¢Êàê `&str` ÊâçËÉΩË¢´ËøûÊé•Âà∞Âè¶‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤‰∏äÔºåÂõ†‰∏∫Â≠óÁ¨¶‰∏≤ÂØπË±°Ê≤°Êúâ Copy ÁâπÊÄß„ÄÇ

Êõ¥Â•ΩÁöÑÊñπÂºèÊòØ‰ΩøÁî® format! ÂÆèÔºö

```rust,ignore
let s1 = String::from("Hello");
let s2 = String::from("world.");

let s = format!("{}, {}", s1, s2);
```

Â≠óÁ¨¶‰∏≤‰ΩøÁî®Ôºö

```rust,ignore
// (all the type annotations are superfluous)
// A reference to a string allocated in read only memory
let pangram: &'static str = "the quick brown fox jumps over the lazy dog";
println!("Pangram: {}", pangram);

// Iterate over words in reverse, no new string is allocated
println!("Words in reverse");
for word in pangram.split_whitespace().rev() {
    println!("> {}", word);
}

// Copy chars into a vector, sort and remove duplicates
let mut chars: Vec<char> = pangram.chars().collect();
chars.sort();
chars.dedup();

// Create an empty and growable `String`
let mut string = String::new();
for c in chars {
    // Insert a char at the end of string
    string.push(c);
    // Insert a string at the end of string
    string.push_str(", ");
}

// The trimmed string is a slice to the original string, hence no new
// allocation is performed
let chars_to_trim: &[char] = &[' ', ','];
let trimmed_str: &str = string.trim_matches(chars_to_trim);
println!("Used characters: {}", trimmed_str);

// Heap allocate a string
let alice = String::from("I like dogs");
// Allocate new memory and store the modified string there
let bob: String = alice.replace("dog", "cat");

println!("Alice says: {}", alice);
println!("Bob says: {}", bob);
```

Âú®Á®ãÂ∫è‰∏≠‰ΩøÁî®ÁöÑÂ≠óÁ¨¶‰∏≤Â≠óÈù¢ÈáèÊòØ `&'static str` Á±ªÂûãÔºåÈùôÊÄÅÂàÜÈÖç‰∏çÂèØ‰øÆÊîπ„ÄÇ

    let hello_world = "Hello, World!";
    let hello_world: &'static str = "Hello, world!";

Â≠óÈù¢ÈáèÂ≠óÁ¨¶‰∏≤ËΩ¨‰πâÂèÇËÄÉÔºö

```rust,ignore
// You can use escapes to write bytes by their hexadecimal values...
let byte_escape = "I'm writing \x52\x75\x73\x74!";
println!("What are you doing\x3F (\\x3F means ?) {}", byte_escape);

// ...or Unicode code points.
let unicode_codepoint = "\u{211D}";
let character_name = "\"DOUBLE-STRUCK CAPITAL R\"";

println!("Unicode character {} (U+211D) is called {}",
            unicode_codepoint, character_name );


let long_string = "String literals
                    can span multiple lines.
                    The linebreak and indentation here ->\
                    <- can be escaped too!";
println!("{}", long_string);
```

‰∏é C/C++ ÁöÑÂÖ∂ÂÆÉ‰∏çÂêåÁÇπÔºö

- Rust ‰ΩøÁî® UTF-8 ‰Ωú‰∏∫Â∫ïÂ±ÇÁöÑÁºñÁ†ÅÔºåËÄå‰∏çÊòØÂ∏∏ËßÅÁöÑ ASCII„ÄÇ‰πüÂ∞±ÊòØËØ¥ÔºåRust ‰∏≠ÁöÑÂ≠óÁ¨¶Êï∞ÊçÆÁ±ªÂûãÂèØ‰ª•ÂåÖÂê´ Unicode ÂíåÂÖ∂ÂÆÉÁâπÊÆäÂ≠óÁ¨¶„ÄÇ
- Rust ‰∏≠ÁöÑÊï∞Â≠óÁ±ªÂûãÁöÑÊòØ Rust ËØ≠Ë®Ä‰∏çÂÖÅËÆ∏Á±ªÂûãËá™Âä®ËΩ¨Êç¢„ÄÇ

Âú®‰ΩøÁî®Â≠óÁ¨¶‰∏≤ÂàáÁâáÊó∂ÔºåÊ≥®ÊÑèËé∑ÂèñÂà∞ÈùûÂ≠óÁ¨¶ËæπÁïåÂ∞ÜÊäõÂá∫ÂºÇÂ∏∏Ôºå‰æãÂ¶ÇÂõΩÂ≠óÁöÑ UTF8 ÁºñÁ†ÅÊòØ 3 ‰∏™Â≠óËäÇÔºå‰ª•‰∏ãÂàáÁâáÂ∞±Ê≤°ÊúâËé∑ÂèñÂà∞Â≠óÁ¨¶ËæπÁïåÔºö

    println!("{}", &("ÂõΩËØ≠")[0..2]);
    // thread 'main' panicked at 'byte index 2 is not a char boundary; it is inside 'ÂõΩ' (bytes 0..3) of `ÂõΩËØ≠`'

Strings & Chars Â≠óÈù¢ÈáèË°®ËææÂèÇËÄÉÔºö

- `"..."`   String literal, UTF-8, will interpret `\n` as line break 0xA, ‚Ä¶
- `r"..."`  Raw string literal. UTF-8, won't interpret `\n`, ‚Ä¶
- `r#"..."#`    Raw string literal, UTF-8, but can also contain `"`. Number of `#` can vary.
- `b"..."`  Byte string literal; constructs ASCII [u8], not a string.
- `br"..."`, `br#"..."#`    Raw byte string literal, ASCII [u8], combination of the above.
- `'ü¶Ä'` Character literal, fixed 4 byte unicode 'char'.
- `b'x'`    ASCII byte literal.

ASCII escapes

- `\x41`    7-bit character code (exactly 2 digits, up to 0x7F)
- `\n`  Newline
- `\r`  Carriage return
- `\t`  Tab
- `\\`  Backslash
- `\0`  Null


Â≠óÁ¨¶‰∏≤ÂàÜÂâ≤Ôºö

    Concatenate strings (any Display‚Üì that is). 1   format!("{}{}", x, y)
    Split by separator pattern. STD üîó   s.split(pattern)
         ... with &str  s.split("abc")
         ... with char  s.split('/')
         ... with closure   s.split(char::is_numeric)
    Split by whitespace.    s.split_whitespace()
    Split by newlines.  s.lines()
    Split by regular expression.2   Regex::new(r"\s")?.split("one two three")

‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÔºö

```rust,ignore
use regex::Regex;

fn main() {
    let re = Regex::new(r"(?x)
(?P<year>\d{4})  # the year
-
(?P<month>\d{2}) # the month
-
(?P<day>\d{2})   # the day
").unwrap();
    let caps = re.captures("2010-03-14").unwrap();

    assert_eq!("2010", &caps["year"]);
    assert_eq!("03", &caps["month"]);
    assert_eq!("14", &caps["day"]);
}
```

```rust,ignore
use regex::Regex;

const TO_SEARCH: &'static str = "
On 2010-03-14, foo happened. On 2014-10-14, bar happened.
";

fn main() {
    let re = Regex::new(r"(\d{4})-(\d{2})-(\d{2})").unwrap();

    for caps in re.captures_iter(TO_SEARCH) {
        // Note that all of the unwraps are actually OK for this regex
        // because the only way for the regex to match is if all of the
        // capture groups match. This is not true in general though!
        println!("year: {}, month: {}, day: {}",
                 caps.get(1).unwrap().as_str(),
                 caps.get(2).unwrap().as_str(),
                 caps.get(3).unwrap().as_str());
    }
}
```

### üü¢üîµ VecDeque
### üü¢üîµ LinkedList
### üü¢üîµ HashMap
### üü¢üîµ BTreeMap
### üü¢üîµ HashSet BTreeSet
- https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html

ÈõÜÂêà Sets ÁöÑÊñπÊ≥ïÂíå Map Á±ª‰ººÔºåÂõ†‰∏∫ÊòØÂü∫‰∫é HashMap BTreeMap ÂÆûÁé∞ÁöÑ„ÄÇ



### üü¢üîµ BinaryHeap
- https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html
- https://doc.rust-lang.org/stable/std/cmp/struct.Reverse.html

Â†ÜÊ†ë‰∫¶Áß∞‰∏∫‰ºòÂÖàÈòüÂàó priority queueÔºåÈÄöÂ∏∏ÊòØ‰∏Ä‰∏™ÂèØ‰ª•Ë¢´ÁúãÂÅö‰∏ÄÊ£µÊ†ëÁöÑÊï∞ÁªÑÂØπË±°ÔºåÂ¶Ç Rust ÁöÑ BinaryHeap ÂÆûÁé∞„ÄÇÂú®ÈòüÂàó‰∏≠ÔºåË∞ÉÂ∫¶Á®ãÂ∫èÂèçÂ§çÊèêÂèñÈòüÂàó‰∏≠Á¨¨‰∏Ä‰∏™‰Ωú‰∏öÂπ∂ËøêË°åÔºåÂõ†ËÄåÂÆûÈôÖÊÉÖÂÜµ‰∏≠Êüê‰∫õÊó∂Èó¥ËæÉÁü≠ÁöÑ‰ªªÂä°Â∞ÜÁ≠âÂæÖÂæàÈïøÊó∂Èó¥ÊâçËÉΩÁªìÊùüÔºåÊàñËÄÖÊüê‰∫õ‰∏çÁü≠Â∞èÔºå‰ΩÜÂÖ∑ÊúâÈáçË¶ÅÊÄßÁöÑ‰Ωú‰∏öÔºåÂêåÊ†∑Â∫îÂΩìÂÖ∑Êúâ‰ºòÂÖàÊùÉÔºåÂ†ÜÂç≥‰∏∫Ëß£ÂÜ≥Ê≠§Á±ªÈóÆÈ¢òËÆæËÆ°ÁöÑ‰∏ÄÁßçÊï∞ÊçÆÁªìÊûÑ„ÄÇ

Âü∫‰∫é `Heap Tree` Â†ÜÁßØÊ†ëÔºåÂú®Â†ÜÊéíÂ∫è‰∏≠ÊúâÂ∫îÁî®ÔºåÊòØ‰∏ÄÁßçÂÆåÂÖ®‰∫åÂèâÊ†ëÔºåmin-heap Â∞èÊ†πÂ†ÜË¶ÅÊ±ÇËäÇÁÇπÂ∞è‰∫éÊàñÁ≠â‰∫éÂ≠êËäÇÁÇπÂÄºÔºåmax-heap Â§ßÊ†πÂ†ÜË¶ÅÊ±ÇËäÇÁÇπÂ§ß‰∫éÊàñÁ≠â‰∫éÂ≠êËäÇÁÇπÂÄº„ÄÇ

          max-heap          min-heap
             9                 3      
         ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê  
         8       7         4       5  
       ‚îå‚îÄ‚î¥‚îÄ‚îê   ‚îå‚îÄ‚î¥‚îÄ‚îê     ‚îå‚îÄ‚î¥‚îÄ‚îê   ‚îå‚îÄ‚î¥‚îÄ‚îê
       6   5   4   3     6   7   8   9
     ‚îå‚îÄ‚î¥‚îÄ‚îê             ‚îå‚îÄ‚î¥
     6   5             7

Â∞ÜÊôÆÈÄö‰∫åÂèâÊ†ëËΩ¨Êç¢ÊàêÂ†ÜÊ†ëÁöÑËøáÁ®ãÂ∞±ÊòØÂ†ÜÂåñ heapify„ÄÇ

BinaryHeap ‰ΩøÁî®Ë¶ÅÁÇπÔºö

- push Êó†Â∫èÂÖ•Ê†àÔºõ
- pop ÊúâÂ∫èÂá∫Ê†àÔºåÂØπ‰∫é Max-heap ÊÄªÊòØÂÖàÂ§ßÂêéÂ∞èÁöÑÂÄºÂá∫Ê†àÔºõ
- ÂØπ‰∫é Min-heapÔºåÂèØ‰ª•ÂºïÂÖ• `Reverse` ËøõË°åÈÄÜÂêëÊéíÂ∫èÔºåpop ÂÖàÂ∞èÂêéÂ§ßÔºåÂåÖË£ÖÂêéÁõ∏Â∫îÂÄº‰∏∫ `Some(Reverse(x))`Ôºõ

Â¶ÇÊûúÈúÄË¶ÅÂåÖË£ÖËá™ÂÆö‰πâÂØπË±°ÔºåÈúÄË¶ÅÂÆûÁé∞ `Ord` `Eq` `PartialOrd` `PartialEq`„ÄÇ

‰ΩøÁî®Á§∫ËåÉÔºåÈªòËÆ§ÊòØ Max-heapÔºö

```rust,ignore
use std::collections::BinaryHeap;

// Type inference lets us omit an explicit type signature (which
// would be `BinaryHeap<i32>` in this example).
let mut heap = BinaryHeap::<i8>::new();

// We can use peek to look at the next item in the heap. In this case,
// there's no items in there yet so we get None.
assert_eq!(heap.peek(), None);

// Let's add some scores...
heap.push(1);
heap.push(5);
heap.push(127);

// Now peek shows the most important item in the heap.
assert_eq!(heap.peek(), Some(&127));

// We can check the length of a heap.
assert_eq!(heap.len(), 5);

// Iterate over the items in the heap in a random order.
for x in &heap {
    println!("{}", x);
}

// If we instead pop these scores, they should come back in order.
assert_eq!(heap.pop(), Some(127));
assert_eq!(heap.pop(), Some(5));
assert_eq!(heap.pop(), Some(1));
assert_eq!(heap.pop(), None);

// We can clear the heap of any remaining items.
heap.clear();

// The heap should now be empty.
assert!(heap.is_empty());
```

```rust,ignore
use std::collections::BinaryHeap;
use std::cmp::Reverse;
use std::cmp::Ord;
use std::cmp::PartialOrd;
use std::cmp::PartialEq;
use std::cmp::Ordering;

#[derive(Debug, Eq)]
struct Task {
    name: &'static str
}

// #[derive(Eq)]
// impl Eq for Foo {}

impl Ord for Task {
    fn cmp(&self, other: &Self) -> Ordering {
        self.name.cmp(&other.name)
    }
}
impl PartialOrd for Task {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.name.cmp(other.name))
    }
}

impl PartialEq for Task {
    fn eq(&self, other:&Self) -> bool {
        self.name == other.name
    }
}

let mut heap = BinaryHeap::new();

heap.push(Reverse(Task{name:"t1"}));
heap.push(Reverse(Task{name:"t5"}));
heap.push(Reverse(Task{name:"t2"}));

println!("{:?} - {:?}", heap.pop(), Some(Reverse(Task{name:"t1"})));
println!("{:?} - {:?}", heap.pop(), Some(Reverse(Task{name:"t2"})));
println!("{:?} - {:?}", heap.pop(), Some(Reverse(Task{name:"t5"})));
println!("{:?} - {:?}", heap.pop(), "None");
```




## ‚ö° Smart Pointers
- Dynamically Sized Types and the Sized Trait https://doc.rust-lang.org/book/ch19-04-advanced-types.html
- Smart Pointers https://doc.rust-lang.org/book/ch15-00-smart-pointers.html
- Rc - Reference Counted https://doc.rust-lang.org/stable/std/rc/index.html
- Box - heap allocation https://doc.rust-lang.org/stable/std/boxed/index.html
- https://doc.rust-lang.org/stable/std/boxed/struct.Box.html
- https://doc.rust-lang.org/stable/std/borrow/enum.Cow.html
- https://doc.rust-lang.org/stable/std/sync/struct.Arc.html
- https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html
- https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html
- https://doc.rust-lang.org/stable/std/ptr/index.html

‰∏çÂÉè Java ËøôÁ±ªÈ´òÁ∫ßËØ≠Ë®ÄÔºåÂÆÉ‰ª¨Â∏¶ÊúâËøêË°åÊó∂ÁöÑÂûÉÂúæÂõûÊî∂Âô®Êú∫Âà∂Ôºå‰ºöÂú®Á®ãÂ∫èËøêË°åËøáÁ®ã‰∏≠Ê†πÊçÆÂÜÖÂ≠ò‰ΩøÁî®Áä∂ÊÄÅËá™Âä®ÈáäÊîæ‰∏çÂÜç‰ΩøÁî®ÁöÑÂÜÖÂ≠òÁ©∫Èó¥ÔºåËÄå C/C++/Rust ÂàôÊ≤°ÊúâÂûÉÂúæÂõûÊî∂Âô®„ÄÇ

ÂâçÈù¢ÁöÑÂÜÖÂÆπÂ∑≤ÁªèËß£Èáä‰∫ÜÈÄöÂ∏∏ËØ¥ÁöÑË∞ÉÁî®Â†ÜÊ†àÊåáÁöÑÂ∞±ÊòØ StackÔºåÂÆÉÊòØÂú®Á°¨‰ª∂Â±ÇÂÆûÁé∞ÁöÑ‰∏Ä‰∏™ LIFO - Last in, first out Êï∞ÊçÆÁªìÊûÑÔºåÈÄöËøá CPU ÁöÑ `pop` `push` Êåá‰ª§Êìç‰Ωú„ÄÇËøô‰∫õÊåá‰ª§ÊéßÂà∂ÁùÄ CPU ÂÜÖÈÉ®ÁöÑ‰∏Ä‰∏™Â†ÜÊ†àÊåáÈíàÂØÑÂ≠òÂô® SP - Stack PointerÔºåÂú®Á®ãÂ∫èËøêË°åÊó∂ÔºåÂßãÁªàÊåáÂêë Stack È°∂ÈÉ®Ôºå‰ºöÈöèÁùÄÂáΩÊï∞Ë∞ÉÁî®„ÄÅËøîÂõûËΩ¨Áßª„ÄÇ

ÂØπÊØî Stack Âíå Heap ÂÜÖÂ≠òÔºö 

- Stack ÂÜÖÂ≠òËÆøÈóÆÊõ¥Âø´ÔºåÊúâÂØÑÂ≠òÂô®Áõ¥Êé•ÂèØËææÔºåÊ†à‰∏äÂÜÖÂ≠òÂàÜÈÖçÊòØËøûÁª≠ÁöÑÔºåË¶ÅÂú®ÁºñËØëÊúüÊòéÁ°Æ‰ΩøÁî®Â§öÂ§ßÁöÑ Stack ÂÜÖÂ≠òÔºõ
- ËÄåÂ†ÜÂÜÖÂ≠òÔºåÊõ¥Â§öÊòØÁî±ÂºÄÂèëËÄÖ‰∏ªÂä®Áî≥ËØ∑Ë∞ÉÈÖçÔºåÈÄöËøá `malloc()` `free()` Á≠âÂáΩÊï∞Âä®ÊÄÅÈöèÊú∫ÂàÜÈÖçÂÜÖÂ≠òÔºåÂÖ∏ÂûãÁöÑÂ∞±ÊòØ‰ΩøÁî® `new` ÂÖ≥ÈîÆÂ≠óÊù•‰∏∫ÂÆû‰æãÁî≥ËØ∑ÂÜÖÂ≠ò„ÄÇ

Stack Ë∞ÉÁî®Ê†àÂÜÖÂ≠ò‰ªéÈ´ò‰ΩçÂú∞ÂùÄÂêë‰∏ãÂ¢ûÈïøÔºå‰∏îÊ†àÂÜÖÂ≠òÂàÜÈÖçÊòØËøûÁª≠ÁöÑÔºå‰∏ÄËà¨Êìç‰ΩúÁ≥ªÁªüÂØπÊ†àÂÜÖÂ≠òÂ§ßÂ∞èÊòØÊúâÈôêÂà∂ÁöÑÔºåLinux/Unix Á±ªÁ≥ªÁªü‰∏äÈù¢ÂèØ‰ª•ÈÄöËøá ulimit ÂëΩ‰ª§ËÆæÁΩÆÊúÄÂ§ßÊ†àÂÜÖÂ≠òÁ©∫Èó¥Â§ßÂ∞è„ÄÇË∞ÉÁî® Rust ÂáΩÊï∞Êó∂‰ºöÂàõÂª∫‰∏Ä‰∏™‰∏¥Êó∂Ê†àÁ©∫Èó¥ÔºåË∞ÉÁî®ÁªìÊùüÂêé Rust ‰ºöËÆ©Ëøô‰∏™Ê†àÁ©∫Èó¥ÈáåÁöÑÂØπË±°Ëá™Âä®ËøõÂÖ• Drop ÊµÅÁ®ãÔºåÊúÄÂêéÊ†àÈ°∂ÊåáÈíàËá™Âä®ÁßªÂä®Âà∞‰∏ä‰∏Ä‰∏™Ë∞ÉÁî®Ê†àÈ°∂ÔºåÊó†ÈúÄÁ®ãÂ∫èÂëòÊâãÂä®Âπ≤È¢ÑÔºåÂõ†ËÄåÊ†àÂÜÖÂ≠òÁî≥ËØ∑ÂíåÈáäÊîæÊòØÈùûÂ∏∏È´òÊïàÁöÑ„ÄÇ

Heap Â†ÜÂÜÖÂ≠òÂàôÊòØ‰ªé‰Ωé‰ΩçÂú∞ÂùÄÂêë‰∏äÂ¢ûÈïøÔºåÂ†ÜÂÜÖÂ≠òÈÄöÂ∏∏Âè™ÂèóÁâ©ÁêÜÂÜÖÂ≠òÈôêÂà∂„ÄÇ

Rust Âú®ÁºñËØëÊó∂‰ºöË∑üË∏™‰ª£Á†ÅÁöÑÂì™‰∫õÈÉ®ÂàÜÊ≠£Âú®‰ΩøÁî®Â†ÜÂÜÖÂ≠òÔºåÊúÄÂ∞èÂåñÂ†Ü‰∏äÈáçÂ§çÊï∞ÊçÆÁöÑÊï∞ÈáèÔºåÊ∏ÖÁêÜÂ†Ü‰∏äÊú™‰ΩøÁî®ÁöÑÊï∞ÊçÆ‰ª•ÈÅøÂÖçÁ©∫Èó¥ËÄóÂ∞ΩÔºåËøô‰∫õÈÉΩÊòØÊâÄÊúâÊùÉÊâÄË¶ÅËß£ÂÜ≥ÁöÑÈóÆÈ¢ò„ÄÇ

‰∏ÄÊó¶ÊÇ®‰∫ÜËß£‰∫ÜÊâÄÊúâÊùÉÔºåÂ∞±‰∏çÈúÄË¶ÅÁªèÂ∏∏ËÄÉËôëÂ†ÜÊ†àÂíåÂ†ÜÔºå‰ΩÜÊòØÁü•ÈÅìÁÆ°ÁêÜÂ†ÜÊï∞ÊçÆÊòØÊâÄÊúâÊùÉÂ≠òÂú®ÁöÑÂéüÂõ†ÊúâÂä©‰∫éËß£ÈáäÂÆÉ‰∏∫‰ªÄ‰πà‰ª•ËøôÁßçÊñπÂºèÂ∑•‰Ωú„ÄÇ

ÂΩìÁÑ∂ÔºåRust Êèê‰æõ‰∫ÜÊô∫ËÉΩÊåáÈíàÁÆÄÂåñÂØπ Heap ÂÜÖÂ≠òÁöÑ‰ΩøÁî®„ÄÇ

Êô∫ËÉΩÊåáÈíàÁöÑ‰∏Ä‰∫õÁî®ÈÄîÔºö

- ÈÄöËøáÊô∫ËÉΩÊåáÈíàÂèØ‰ª•ÂÆûÁé∞Â§öÊâÄÊúâÊùÉ„ÄÇ
- ÈÄöËøá Box ÂÆûÁé∞ÈÄíÂΩíÁ±ªÂûã Recursive TypesÔºåÈÇ£‰∫õÂú®ÊàêÂëò‰∏≠ÂåÖÂê´Ëá™Â∑±ÁöÑÁ±ªÂûãÊó†Ê≥ïÂú®ÁºñËØëÊúüÁ°ÆÂÆöÂ§ßÂ∞èÔºåËÄåÊô∫ËÉΩÊåáÈíàÂèØ‰ª•ËÆ©ÂÆÉÂú®ËøêË°åÊó∂ÊàêÁ´ã„ÄÇ

‰ª•‰∏ãÊòØÂ∏∏Áî®Êô∫ËÉΩÊåáÈíàÔºö

- `Box<T>`Êô∫ËÉΩÊåáÈíàÂÜÖÈÉ®ÊåáÂêëÂ†ÜÂÜÖÂ≠òÔºåÊï∞ÊçÆÁ±ªÂûã‰∏∫ T„ÄÇ
    - ÈÄöËøá`Box::new(v)`ÂàõÂª∫ÔºåÁßªÂä®ËØ≠‰πâÔºåÁã¨Âç†ÊâÄÊúâÊùÉ - moveÔºåÂÖÅËÆ∏‰ΩøÁî® * ËΩ¨ÁßªÊú¨‰ΩìÊâÄÊúâÊùÉ„ÄÇ
    - ÊòØ‰∏ÄÁßçÁã¨‰∫´ÊâÄÊúâÊùÉÊô∫ËÉΩÊåáÈíàÔºåÁ±ª‰ºº C++ ÁöÑ unique_ptr„ÄÇ
- `Rc<T>` ÂºïÁî®ËÆ°Êï∞Êô∫ËÉΩÊåáÈíà Reference CountingÔºåËÆ∞ÂΩïÂ†ÜÂÜÖÂ≠ò‰∏äÁöÑÊï∞ÊçÆË¢´ÂºïÁî®ÁöÑÊ¨°Êï∞„ÄÇ
    - ÈÄöËøá`Rc::new(v)`ÂàõÂª∫ÔºåÁßªÂä®ËØ≠‰πâÔºåÂÖ±‰∫´ÊâÄÊúâÊùÉ - cloneÔºåÁ¶ÅÊ≠¢‰ΩøÁî® * ËΩ¨ÁßªÊú¨‰ΩìÊâÄÊúâÊùÉ„ÄÇ
    - ÊòØ‰∏ÄÁßçÂÖ±‰∫´ÊâÄÊúâÊùÉÊô∫ËÉΩÊåáÈíàÔºåÁ±ª‰ºº C++ ÁöÑ shared_ptr„ÄÇ

Rust ÁöÑÊâÄÊúâÊùÉÊú∫Âà∂‰∏ãÔºåÈÄöÂ∏∏‰∏çËÉΩÈÄöËøáÂºïÁî®ÊàñÂèòÈáèÁõ¥Êé•‰øÆÊîπÊï∞ÊçÆÔºå‰ΩÜÊòØÂú®Êô∫ËÉΩÊåáÈíàÁöÑ‰ΩúÁî®‰∏ãÔºåÂºïÂÖ•‰∫Ü‰∏Ä‰∏™Êñ∞Ê¶ÇÂøµÂÜÖÈÉ®ÂèØÂèòÊÄß interior mutability„ÄÇ

Â¶Ç‰∏ãÔºö

- `Ref<T>`„ÄÅ`RefMut<T>`ÊåáÈíàÂºïÁî®ÁöÑÊï∞ÊçÆÂèØ‰ª•Áõ¥Êé•ÈÄöËøá`RefCell<T>`ËøõË°å‰øÆÊîπ„ÄÇ

ÈÄöËøá`RefCell<T>`Êô∫ËÉΩÊåáÈíàÔºåÂÆûÁé∞Âú®ËøêË°åÊó∂Âº∫Âà∂ÂÄüÁî®ËßÑÂàôÁöÑÁ±ªÂûãÔºåËÄå‰∏çÊòØÈÄöÂ∏∏ÁöÑÁºñËØëÊó∂ÂÄüÁî®ËßÑÂàô„ÄÇÂÜÖÈÉ®ÂèØÂèòÊ®°Âºè‰∏ãÔºåÁªô‰∏çÂèØÂèòÁ±ªÂûãÂÖ¨ÂºÄ‰∫Ü‰∏Ä‰∏™ API Êù•ÊîπÂèòÂÜÖÈÉ®ÂÄº„ÄÇËÄåËøôÁßçÂÅöÊ≥ïÂ∏¶Êù•Êñπ‰æøÁöÑÂêåÊó∂Ôºå‰πüËÆ©ÂÜÖÂ≠òÊ≥ÑÊºèÂèòÊàêÂèØËÉΩÔºåÈúÄË¶ÅÁü•ÈÅìÈò≤Ê≠¢ÂÆÉÂèëÁîü„ÄÇ

- `Cell<T>` Êô∫ËÉΩÊåáÈíàÂÖÅËÆ∏ÂÄüÁî®ÂèØÂèòÂºïÁî®ÔºåÂç≥‰ΩøÊï∞ÊçÆÊòØ‰∏çÂèØÂèòÁöÑÔºåËøô‰∏™ËøáÁ®ãË¢´Áß∞‰∏∫ÂÜÖÈÉ®ÂèØÂèòÊÄß„ÄÇ
    - ÈÄÇÂêàÂÆûÁé∞‰∫ÜCopyÁöÑÁ±ªÂûãÔºåÊàñËÄÖ‰ΩìÁßØÂ∞èÁöÑstructÔºåÂõ†‰∏∫getÊñπÊ≥ïÊòØÁõ¥Êé•Êåâ‰ΩçÂ§çÂà∂ÁöÑ„ÄÇ
    - Êó†ËøêË°åÊó∂ÂºÄÈîÄÔºåËøêË°åÊó∂ÂÆâÂÖ®„ÄÇ
    - `Cell::new(v)` ÂàõÂª∫ÔºåÁßªÂä®ËØ≠‰πâ
    - Ëé∑ÂèñÊú¨‰Ωì vÔºöCell::get()
    - Ëé∑ÂèñÊú¨‰ΩìÂÄüÁî® &vÔºöCell::get_mut()
    - ‰øÆÊîπÊú¨‰Ωì vÔºöCell::set(vv)
- `RefCell<T>` Êô∫ËÉΩÊåáÈíàÂÖÅËÆ∏ÂÄüÁî®ÂèØÂèòÂºïÁî®ÔºåÂç≥‰ΩøÊï∞ÊçÆÊòØ‰∏çÂèØÂèòÁöÑÔºåËøô‰∏™ËøáÁ®ãË¢´Áß∞‰∏∫ÂÜÖÈÉ®ÂèØÂèòÊÄß„ÄÇ

    ÈÄÇÂêàÊú™ÂÆûÁé∞‰∫ÜCopyÁöÑÁ±ªÂûãÔºåÊàñËÄÖ‰ΩìÁßØÂ§ßÁöÑstructÔºåCell‰∏çÂ•Ω‰ΩøÁöÑÈÉΩÊòØÁî®Ëøô‰∏™„ÄÇ
    ËøêË°åÊó∂ÊúâÂºÄÈîÄÔºå‰ºöÊâßË°åÂÄüÁî®Ê£ÄÊü•ÔºåËøêË°åÊó∂‰∏çÂÆâÂÖ®„ÄÇ

    RefCell::new(v) Ôºö ÂàõÂª∫ÔºåÁßªÂä®ËØ≠‰πâ
    ‰∏çÂèØÂèòÂÄüÁî®ÔºöRefCell::borrow()„ÄÅÁ±ª‰ººCell::get
    ÂèØÂèòÂÄüÁî®ÔºöRefCell::borrow_mut()„ÄÅÁ±ª‰ººCell::set

ÈíàÂØπÂ§öÁ∫øÁ®ãÔºåËøòÊèê‰æõ‰∫Ü‰ª•‰∏ãÊô∫ËÉΩÊåáÈíàÔºö

- `Arc<T>` ÂéüÂ≠êÂºïÁî®ËÆ°Êï∞Êô∫ËÉΩÊåáÈíà Atomic Reference CountingÔºåÊîØÊåÅÂéüÂ≠êÊìç‰ΩúÔºåÂ§öÁ∫øÁ®ãÂÆâÂÖ®ÂÖ±‰∫´ÔºåÈÄöËøá `Arc::new(v)` ÂàõÂª∫ÔºåÁßªÂä®ËØ≠‰πâÔºåÂÖ±‰∫´ÊâÄÊúâÊùÉ - cloneÔºåÁ¶ÅÊ≠¢‰ΩøÁî® * ËΩ¨ÁßªÊú¨‰ΩìÊâÄÊúâÊùÉ„ÄÇÊòØ‰∏ÄÁßçÁ∫øÁ®ãÂÆâÂÖ®ÁöÑÂÖ±‰∫´ÊâÄÊúâÊùÉÊô∫ËÉΩÊåáÈíàÔºåÁ±ª‰ºº C++ ÁöÑ shared_ptr + mutex„ÄÇ
- `Mutex<T>` ‰∫íÊñ•ÈáèÁî®Êù•‰øùÊä§ÂÖ±‰∫´Êï∞ÊçÆÔºåÈÄöËøá `lock()` Âíå `try_lock()` ÊñπÊ≥ïËøîÂõûÁöÑÊòØ‰∏Ä‰∏™ `MutexGuard<T>` Êô∫ËÉΩÂáΩÊï∞ÔºåÁî± `LockResult` ÂåÖË£ÖÔºå`unwrap()` Ëß£ÂåÖÔºåÈîÅÂÆöÂêéÂ∞±ÂèØ‰ª•ÈÄöËøáÊô∫ËÉΩÊåáÈíàËÆøÈóÆ‰∫íÊñ•ÈáèÂÜÖÈÉ®ÁöÑÊï∞ÊçÆ„ÄÇ
- `RwLock<T>` ËØªÂÜôÈîÅÔºåÂêåÊó∂ÂÖÅËÆ∏Â§ö‰∏™ËØªÔºå‰ΩÜÂè™ËÉΩÊúâ‰∏Ä‰∏™ÂÜôÔºåÂπ∂‰∏îËØªÂíåÂÜô‰∏çËÉΩÂêåÊó∂Â≠òÂú®„ÄÇÈÄöËøá `read()` `try_read()` `write()` `try_write()`ÊñπÊ≥ïËøîÂõû `RwLockReadGuard<T>` Êàñ `RwLockWriteGuard<T>` Êô∫ËÉΩÊåáÈíà„ÄÇ


Âè¶Â§ñ `Cow<T>` ÊòØ‰∏ÄÁßçÂÜôÊó∂Â§çÂà∂ÁöÑÊûö‰∏æ‰ΩìÁöÑÊô∫ËÉΩÊåáÈíà

    ÁõÆÁöÑÊòØÂáèÂ∞ëÂ§çÂà∂Êìç‰ΩúÔºåÊèêÈ´òÊÄßËÉΩÔºåÂ§öÁî®‰∫éËØªÂ§öÂÜôÂ∞ëÁöÑÂú∫ÊôØ

    Cow::Borrowed(v) | Cow::Owned(v) Ôºö ÂàõÂª∫ÔºåÁßªÂä®ËØ≠‰πâ
    ‰∏çÂèØÂèòÂÄüÁî®ÔºöCow::deref()ÔºåOwned‰ºöË∞ÉÁî®borrowËøîÂõûÔºåBorrowedÁõ¥Êé•ËøîÂõû
    ÂèØÂèòÂÄüÁî®ÔºöCow::to_mut()ÔºåBorrowed‰ºöË∞ÉÁî®cloneÊõøÊç¢Ëá™Â∑±‰∏∫OwnedÔºåÁÑ∂ÂêéOwned‰ºöÂåπÈÖçref mutÈáäÊîæÂÄüÁî®„ÄÇ
    Ëé∑ÂæóÊú¨‰ΩìÔºöCow::into_owned()ÔºåBorrowed‰ºöË∞ÉÁî®cloneÂêéËøîÂõûÔºåOwned‰ºöÊääËá™Â∑±ËøîÂõû„ÄÇ

Êô∫ËÉΩÊåáÈíàÊúâ‰∏§‰∏™Âü∫Êú¨ÁöÑË°å‰∏∫Ôºö

- `Deref<T>` ‰∏∫Êô∫ËÉΩÊåáÈíàÊèê‰æõËß£Èô§ÂºïÁî®ËøêÁÆóÁ¨¶ `*ref`ÔºåËøòÊúâ `DerefMut<T><T>` ÊòØÂèØÂèòËß£ÂºïÁî®ÔºåÊúâÂÆÉÊâçÂèØ‰ª•‰øÆÊîπÂºïÁî®ÁöÑÊï∞ÊçÆ„ÄÇ
- `Drop<T>` ‰∏∫Êô∫ËÉΩÊåáÈíàÊèê‰æõËá™Âä®ÈáäÊîæÁ©∫Èó¥Ë°å‰∏∫ÂÆûÁé∞ÔºåÂú®Êô∫ËÉΩÊåáÈíàË∂ÖÂá∫‰ΩúÁî®ÂüüÊó∂Ëá™Âä®ÊâßË°å„ÄÇ

Êô∫ËÉΩÊåáÈíàÂü∫Êú¨Êèê‰æõ‰∫Ü‰∏çÂèØÂèòÂÄüÁî®ÂíåÂèØÂèòÂÄüÁî®ÊñπÊ≥ïÔºåÂÆûÁé∞‰∫Ü‰ª•‰∏ãÈÉ®ÂàÜÊé•Âè£ÁöÑÈùôÊÄÅÊñπÊ≥ïÔºö

- AsMut<T> - `as_ref()`
- AsRef<T> - `as_mut()`
- Borrow<T> - `borrow()`
- BorrowMut<T> - `borrow_mut()`

Rc Âíå Arc ÈÉΩÊúâ Weak ÂΩ¢ÂºèÔºåRc Weak Âíå Arc WeakÔºå

Rc ÊòØ‰∏Ä‰∏™ÂºïÁî®ËÆ°Êï∞ÊåáÈíàÔºå‰ºöÂØπÂºïÁî®ËøõË°åËÆ°Êï∞ÔºåÊØèÊâßË°å‰∏ÄÊ¨° `clone()` ÂºïÁî®ËÆ°Êï∞Âä†‰∏ÄÔºö

- `Rc<T>` ÂåÖË£ÖÁöÑÊï∞ÊçÆÂØπË±°ÊòØ immutable ‰∏çÂèØÂèòÁöÑÔºåÂç≥Êó†Ê≥ï‰øÆÊîπ T Êï∞ÊçÆÂØπË±°ÔºåÂè™ËÉΩËØªÔºõ
- `Rc<T>` Âè™ËÉΩÁî®‰∫éÂêå‰∏ÄÁ∫øÁ®ãÂÜÖÈÉ®Ôºå‰∏çËÉΩÁî®‰∫éÁ∫øÁ®ã‰πãÈó¥ÁöÑÂØπË±°ÂÖ±‰∫´ÔºåË∑®Á∫øÁ®ã‰º†ÈÄíÂèØ‰ª•‰ΩøÁî® `Arc<T>`Ôºõ
- `Rc<T>` ÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™ÊåáÈíàÔºåÂÆÉ‰∏çÂΩ±ÂìçÂåÖË£πÂØπË±°ÁöÑÊñπÊ≥ïË∞ÉÁî®ÂΩ¢ÂºèÔºåÂç≥‰∏çÂ≠òÂú®ÂÖàËß£ÂºÄÂåÖË£πÂÜçË∞ÉÁî®ÂÄºËøô‰∏ÄËØ¥„ÄÇ
- ‰∏ÄÊó¶ÊúÄÂêé‰∏Ä‰∏™Êã•ÊúâËÄÖÊ∂àÂ§±ÔºåÂàôËµÑÊ∫ê‰ºöË¢´Ëá™Âä®ÂõûÊî∂ÔºåËøô‰∏™ÁîüÂëΩÂë®ÊúüÊòØÂú®ÁºñËØëÊúüÂ∞±Á°ÆÂÆö‰∏ãÊù•ÁöÑÔºõ

Rc weak Áâà‰∏ç‰ºöÂ¢ûÂä†ÂºïÁî®ËÆ°Êï∞ÔºåÊúâ‰ª•‰∏ãÂá†‰∏™ÁâπÁÇπÔºö

- ÂèØËÆøÈóÆÔºå‰ΩÜ‰∏çÊã•Êúâ„ÄÇ‰∏çÂ¢ûÂä†ÂºïÁî®ËÆ°Êï∞ÔºåÂõ†Ê≠§Ôºå‰∏ç‰ºöÂØπËµÑÊ∫êÂõûÊî∂ÁÆ°ÁêÜÈÄ†ÊàêÂΩ±ÂìçÔºõ
- `Weak<T>` ÂèØÈÄöËøáË∞ÉÁî® `Rc::downgrade()` ÊñπÊ≥ïËÄåËΩ¨Êç¢ÂæóÂà∞Ôºõ
- `Weak<T>` ÈÄöËøá `upgrade()` ÊñπÊ≥ïËΩ¨Êç¢Êàê `Option<Rc<T>>`ÔºåÂ¶ÇÊûúËµÑÊ∫êÂ∑≤ÁªèË¢´ÈáäÊîæÔºåÂàô Option ÂÄº‰∏∫ NoneÔºõ
- Â∏∏Áî®‰∫éËß£ÂÜ≥Âæ™ÁéØÂºïÁî®ÁöÑÈóÆÈ¢ò„ÄÇ

```rust,ignore
use std::rc::Rc;

let five = Rc::new(5);

let weak_five = Rc::downgrade(&five);

let strong_five: Option<Rc<_>> = weak_five.upgrade();
assert!(strong_five.is_some());

// Destroy all strong pointers.
drop(strong_five);
drop(five);

assert!(weak_five.upgrade().is_none());
```



## ‚ö° Box - heap allocation

ÊúÄÁÆÄÂçïÁöÑÊô∫ËÉΩÊåáÈíàÂ∞±ÊòØ std::boxed::BoxÔºö

    let five = 5;           // 5 in Stack memory
    let five = Box::new(5); // 5 in Heap memory

    let mut boxed = box 5;
    *boxed += 5;

‰∫ãÂÆû‰∏äÔºå`String` Âíå `Vec<T>` ÈÉΩÊòØÊô∫ËÉΩÊåáÈíàÔºå‰ΩÜÈÄöÂ∏∏‰∏çËøôÊ†∑Áß∞ÂëºÂÆÉ‰ª¨„ÄÇÂÆÉ‰ª¨ÂêÑËá™Êã•ÊúâÂèØÁÆ°ÁêÜÁöÑÂÜÖÂ≠òÔºå‰πüÈÉΩÂÆûÁé∞‰∫Ü Drop Âíå Deref ‰∏§‰∏™ÁâπÊÄß„ÄÇ

Âõ†‰∏∫ÊâÄÊúâÊùÉÁöÑÁ∫¶ÊùüÔºå‰∏çËÉΩÁõ¥Êé•ËøîÂõûÂáΩÊï∞Êú¨Âú∞ÂÄºÁöÑÂºïÁî® &TÔºåÂõ†‰∏∫ÂÆÉÁöÑÊâÄÊúâÊùÉ‰ΩúÁî®ÂüüÂú®ÂáΩÊï∞ÂÜÖÈÉ®ÔºåÂáΩÊï∞ÁªìÊùüÊó∂Â∞±Êî∂ÂõûÂÜÖÂ≠òÔºåËøîÂõûÂºïÁî®Â∞±ÂØºËá¥ÊåáÈíàÊÇ¨Á©∫ Dangling References„ÄÇ

Èô§ÈùûÂºïÁî®ÊòØÂáΩÊï∞ÂÖ•ÂèÇÔºåËøôÁßçÊÉÖÂÜµ‰∏ãÂáΩÊï∞ÊâçÂèØ‰ª•ËøîÂõûÂºïÁî®Ôºå&str Êàñ &StringÔºåÂõ†‰∏∫ÂÆÉ‰ΩçÈÉΩÊòØÂáΩÊï∞Â§ñÈÉ®‰º†ÂÖ•ÁöÑÔºåÁõ∏ÂΩì‰∫éÂΩíËøòÊâÄÊúâÊùÉÔºåÊâÄ‰ª•ÁîüÂëΩÂë®Êúü‰πüÁ¨¶ÂêàÁ∫¶Êùü„ÄÇ

ÊâÄ‰ª•ÔºåÈÄöÂ∏∏Áî®ËøîÂõû String ËÄå‰∏çÊòØ &str, ËøîÂõû Vec<T> ËÄå‰∏çÊòØ &[T]ÔºåÂç≥ÂáΩÊï∞Â∫îËØ•ËøîÂõû T ËÄå‰∏çÊòØÂºïÁî® &TÔºå‰πüÂ∞±ÊòØÂ∞ÜÊâÄÊúâÊùÉÁßªÂá∫ÂáΩÊï∞ÂÜÖÈÉ®„ÄÇ

ÂÖ∂ÂÆû String Á±ªÂûã‰ΩøÁî®Â†ÜÊù•Â≠òÂÇ®Êï∞ÊçÆÔºåÊâÄ‰ª•ÂèØ‰ª•Áõ¥Êé•ËøîÂõûÔºåÂú®ÂáΩÊï∞ËøîÂõûÊó∂ÂáΩÊï∞Ê†àÈîÄÊØÅÂêé‰æùÁÑ∂Â≠òÂú®„ÄÇ

```rust,ignore
fn main() {
    let foo = &mut "world!".to_string();
    let s1 = return_as_is_v2(foo);
    let s2 = return_owned_v1("world!");
    assert_eq!("Hello, world!", format!("{}", s1));
    assert_eq!("Hello, world!", format!("{}", s2));
}

fn return_as_is_v1(x:&str)->&str {
    // let a:String = "Hello, ".to_string()+ x;
    // cannot return value referencing local variable `a`
    // returns a value referencing data owned by the current function
    // &a[..]
    
    // cannot return reference to temporary value
    // &("Hello, ".to_string() + x)
    
    &x[..]
    // or return x
}

fn return_as_is_v2(x:&mut String)->&str {
    x.insert_str(0, "Hello, ");
    &x[..]
    // or return x
}

fn return_owned_v1(x:&str)->String {
    let a:String = "Hello, ".to_string()+ x;
    a
}
```

Âè¶Â§ñÔºåRust Á§æÂå∫Êúâ‰∏Ä‰∏™ owning_ref Ê®°ÂùóÂÆûÁé∞‰∫ÜÂú®ÂáΩÊï∞ËøîÂõûÂºïÁî®Ôºå‰ΩÜÂÆÉËøòÊòØÂü∫‰∫éÊâÄÊúâÊùÉÁßªÂä®ÁöÑÂü∫Á°Ä‰∏äÁöÑ„ÄÇ

Âè¶Â§ñÔºåÂØπ‰∫é‰∏çËÉΩÂú®ÁºñËØëÊúüÁ°ÆÂÆöÂ§ßÂ∞èÁöÑÁ±ªÂûã DSTÔºåÂ¶ÇÂ∏∏ËßÅÁöÑ strÔºåÂèØ‰ª•ÁªìÂêà Box Â∞ÜÂÖ∂Â≠òÂÇ®Âú®Â†ÜÂÜÖÂ≠ò‰∏≠ÔºåÂπ∂‰∏îÈÄöËøáÊô∫ËÉΩÊåáÈíàËøõË°åÊìç‰Ωú„ÄÇ

Rust ÂºïÂÖ•ÁöÑ `box` ÂÖ≥ÈîÆËØçÔºåÂèØ‰ª•Áî®Êù•Âèñ‰ª£ Box::new() Áî≥ËØ∑‰∏Ä‰∏™Â†ÜÁ©∫Èó¥Ôºå‰πüÂèØ‰ª•Áî®Âú®Ê®°ÂºèÂåπÈÖçÔºö

```rust,ignore
#![feature(box_syntax, box_patterns)]
fn main() {
    let boxed = Some(box 5);
    match boxed {
        Some(box unboxed) => println!("Some {}", unboxed),
        None => println!("None"),
    }
}
```

ÂÆÉ‰∏çÊòØ stable ÂäüËÉΩÔºå‰∏çËÉΩÂú® Rust stable ÁâàÊú¨‰ΩøÁî®„ÄÇ

Ê≥®ÊÑèÔºå`Box<str>` ‰πü‰∏çËÉΩÁõ¥Êé•ÈÄöËøá `Box::new()` ËøôÊ†∑ÁöÑÊñπÂºèÂàõÂª∫ÔºåËÄåÊòØÈÄöËøá String ËΩ¨Êç¢ÂæóÂà∞„ÄÇ

```rust,ignore
use std::boxed::Box;

fn main() {
    let s3 = return_boxed_str("world!");
    assert_eq!("Hello, world!", format!("{}", s3));
}

// fn foo(x:&str)->Box<&str> {
//     let s:String = "Hello, ".to_string()+ x;
//     // cannot return Box<&str>, value referencing local variable `s`
//     // Box::new(&s[..]) 
    
//     // cannot return Box<&str>, value referencing temporary value
//     // Box::new(&s.to_owned()[..])

//     // expected `Box<str>`, found `Box<&str>`
//     // let boxed_str_ref: Box<str> = Box::new("string");

//     // the size for values of type `str` cannot be known at compilation time
//     // let boxed_str_ref = Box::new(s[..]);
// }

fn return_boxed_str(x:&str)->Box<str> {
    let s:String = "Hello, ".to_string()+ x;
    let boxed_str: Box<str> = s.to_owned().into_boxed_str();
    // let boxed_bytes: Box<[u8]> = boxed_str.into_boxed_bytes();
    // assert_eq!(*boxed_bytes, *s.as_bytes());
    boxed_str
}
```

## ‚ö° owning_ref Âç†Áî®ÂºïÁî®
- Owning Ref https://crates.io/crates/owning_ref
- http://kimundi.github.io/owning-ref-rs/owning_ref/index.html

Áî±‰∫éÊâÄÊúâÊùÉÊú∫Âà∂ÁöÑÂ≠òÂú®ÔºåRust Á≥ªÁªüÈÄöÂ∏∏‰∏çÂÖÅËÆ∏ÂáΩÊï∞ËøîÂõûÂÜÖÈÉ®ÂÄºÁöÑÂºïÁî®„ÄÇ

‰ΩÜÊòØÂèØ‰ª•Âú®Â∫ïÂ±ÇÂÆûÁé∞Ëøô‰∏ÄÈúÄÊ±ÇÔºåowning_ref Ê®°ÂùóÂ∞±ÊòØÂü∫‰∫é stable_deref_trait ÂÆûÁé∞Ëøô‰∏ÄÂäüËÉΩ„ÄÇÂíåÂèòÈáè‰∏ÄÊ†∑ÔºåÂºïÁî®‰πüÊúâÊâÄÊúâËÄÖÔºåowning_ref ‰ºöÂ∞ÜÂºïÁî®ÁöÑÊâÄÊúâÊùÉ‰ªéÂéüÊù•ÊâÄÊúâÊñπÁßªÂä®Âà∞‰∏Ä‰∏™Êô∫ËÉΩÊåáÈíà‰∏ä„ÄÇ

Ê†πÊçÆÊ®°ÂùóÂÆö‰πâÔºåÊèê‰æõ‰ª•‰∏ãÊô∫ËÉΩÊåáÈíàÁöÑÂåÖË£ÖÁ±ªÂûãÔºö

- `ArcRef`  ‰ΩøÁî®‰∏Ä‰∏™ `Arc` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `BoxRef`  ‰ΩøÁî®‰∏Ä‰∏™ `Box` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `BoxRefMut`   ‰ΩøÁî®‰∏Ä‰∏™ `Box` ‰Ωú‰∏∫ÂèØÂèòÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `ErasedArcRef`    ‰ΩøÁî®‰∏Ä‰∏™ `Erased` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `ErasedBoxRef`    ‰ΩøÁî®‰∏Ä‰∏™ `Erased` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `ErasedBoxRefMut` ‰ΩøÁî®‰∏Ä‰∏™ `Erased` ‰Ωú‰∏∫ÂèØÂèòÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `ErasedRcRef` ‰ΩøÁî®‰∏Ä‰∏™ `Erased` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `MutexGuardRef`   ‰ΩøÁî®‰∏Ä‰∏™ `MutexGuard` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `MutexGuardRefMut`    ‰ΩøÁî®‰∏Ä‰∏™ `MutexGuard` ‰Ωú‰∏∫ÂèØÂèòÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `RcRef`   ‰ΩøÁî®‰∏Ä‰∏™ `Rc` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `RefMutRef`   ‰ΩøÁî®‰∏Ä‰∏™ `RefMut` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `RefMutRefMut`    ‰ΩøÁî®‰∏Ä‰∏™ `RefMut` ‰Ωú‰∏∫ÂèØÂèòÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `RefRef`  ‰ΩøÁî®‰∏Ä‰∏™ `Ref` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `RwLockReadGuardRef`  ‰ΩøÁî®‰∏Ä‰∏™ `RwLockReadGuard` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `RwLockWriteGuardRef` ‰ΩøÁî®‰∏Ä‰∏™ `RwLockWriteGuard` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `RwLockWriteGuardRefMut`  ‰ΩøÁî®‰∏Ä‰∏™ `RwLockWriteGuard` ‰Ωú‰∏∫ÂèØÂèòÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `StringRef`   ‰ΩøÁî®‰∏Ä‰∏™ `String` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `StringRefMut`    ‰ΩøÁî®‰∏Ä‰∏™ `String` ‰Ωú‰∏∫ÂèØÂèòÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `VecRef`  ‰ΩøÁî®‰∏Ä‰∏™ `Vec` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ
- `VecRefMut`   ‰ΩøÁî®‰∏Ä‰∏™ `Vec` ‰Ωú‰∏∫ÂºïÁî®ÁöÑÊâÄÊúâËÄÖ„ÄÇ

Ê®°Âùó‰∏≠ÁöÑ `StableDeref` Âè™ÊòØ‰∏Ä‰∏™ unsafe marker traitÔºåÂÆÉÊ≤°ÂÖ∑‰ΩìÁöÑÊñπÊ≥ïÂÆö‰πâÔºåÂè™ÊòØÊ†áËÆ∞ unsafe Ë°å‰∏∫ÔºåÁ°Æ‰øùËß£ÂºïÁî®ÂèØ‰ª•ÂæóÂà∞‰∏Ä‰∏™Á®≥ÂÆöÁöÑÂú∞ÂùÄÔºåÂç≥ÂÆÉÁöÑÊâÄÊúâÊùÉÂ∑≤ÁªèÁßªÂä®„ÄÇÊØîÂ¶ÇÔºåBox, Vec, Rc, Arc Âíå String Á≠âÁ≠âÊô∫ËÉΩÊåáÈíàÈÉΩÂÆûÁé∞‰∫ÜËøô‰∏ÄÁâπÊÄßÔºåÂΩì‰∏Ä‰∏™ Box ÁßªÂä®ÂêéÔºåÂÆÉÂÜÖÈÉ®Êï∞ÊçÆÁöÑ‰øùÂ≠òÂú∞ÂùÄ‰ªçÁÑ∂ÊòØÂõ∫ÂÆöÁöÑ„ÄÇ

Êõ¥ÂÖ∑‰ΩìÂú∞ËØ¥ÔºåÂÆûÁé∞ËÄÖÂøÖÈ°ªÁ°Æ‰øùË∞ÉÁî® deref() ÊñπÊ≥ïËøîÂõûÁöÑÁªìÊûúÂú®ÂØπË±°ÁöÑÁîüÂ≠òÊúüÂÜÖÊúâÊïàÔºåËÄå‰∏ç‰ªÖ‰ªÖÊòØÂú®ÂÄüÁî®ÁöÑÁîüÂ≠òÊúüÂÜÖÊúâÊïàÔºåÂπ∂‰∏îÂç≥‰ΩøÂØπË±°Ë¢´ÁßªÂä®Ôºåderef ‰πüÊòØÊúâÊïàÁöÑ„ÄÇ

Ê®°Âùó‰∏ªË¶ÅÊèê‰æõ‰ª•‰∏ã‰∏§‰∏™ÂØπË±°Êù•Âç†ÊúâÂºïÁî®ÊâÄÊúâÊùÉÔºåÂÆÉ‰ª¨Âè™Êúâ‰∏§‰∏™ÊàêÂëòÔºåowner Âíå referenceÔºö

```rust,ignore
pub struct OwningRef<O, T: ?Sized> {
    owner: O,
    reference: *const T,
}

pub struct OwningRefMut<O, T: ?Sized> {
    owner: O,
    reference: *mut T,
}

pub struct OwningHandle<O, H>
    where O: StableAddress, H: Deref,
{
    handle: H,
    _owner: O,
}
```

ÂÆÉÁöÑÂ∑•‰ΩúÂéüÁêÜÊòØË¶ÅÊ±ÇÊâÄÊúâËÄÖÁ±ªÂûãËß£ÂºïÁî®ÂæóÂà∞‰∏Ä‰∏™Á®≥ÂÆöÂÜÖÂ≠òÂú∞ÂùÄÔºåËøôÂÆûÈôÖ‰∏äÈúÄË¶ÅÊåâ `Box<T>`„ÄÅ`Rc<T>` Á≠âÊô∫ËÉΩÊåáÈíàÊèê‰æõÁöÑÂ†ÜÂàÜÈÖç„ÄÇ

`OwningHandle` Á±ªÂûãÊòØ‰∏Ä‰∏™Ë°•ÂÖÖÁ±ªÂûãÔºåOwningRef ÂÖÅËÆ∏‰ΩøÁî®ËÄÖ‰º†ÈÄí‰∏Ä‰∏™ owned ÂØπË±°ÔºåÂíå‰∏Ä‰∏™ÂºïÁî® reference„ÄÇËÄå OwningHandle ÂåÖÂê´‰∏Ä‰∏™ owned ÂØπË±°ÔºåÂíå‰∏Ä‰∏™‰æùËµñÂØπË±°„ÄÇ

OwningHandle ÂèØ‰ª•ÈÄöËøá `RefMut` ÂèäÂÖ≥ËÅîÁöÑ `RefCell` ÂåÖË£ÖÔºåÊàñËÄÖÈÄöËøá `RwLockReadGuard` ÂèäÂÖ≥ËÅîÁöÑ `RwLock` ÂåÖË£ÖÔºåÂÆÉ‰ª¨ÁöÑ API ÈÉΩÊòØÁªü‰∏ÄÁöÑÔºåÂØπÂèØ‰ª•‰ΩøÁî®Âì™‰∫õÁ±ªÂûãÁöÑ owned ÂØπË±°Âíå‰æùËµñÂØπË±°Ê≤°ÊúâÈôêÂà∂„ÄÇ

OwningHandle ÂàõÂª∫Êó∂Ôºå‰ΩøÁî® `new` ÊñπÊ≥ï‰º†ÂÖ•‰∏Ä‰∏™ÂÆûÁé∞‰∫Ü `ToHandle` Êàñ `ToHandleMut` ÁöÑ owner ÂØπË±°ÔºåË∞ÉÁî®ÂÖ∂Êèê‰æõÁöÑËΩ¨Êç¢ÊñπÊ≥ïÔºåÂØπÂÖ∂Ëß£ÂºïÁî®ÂæóÂà∞Á®≥ÂÆöÁöÑÂú∞ÂùÄ„ÄÇÊàñËÄÖÂØπ‰∫éÊ≤°ÊúâÂÆûÁé∞  `ToHandle` Êàñ `ToHandleMut` ÁöÑÂØπË±°ÔºåÂàõÂª∫‰ΩøÁî® `new_with_fn` ÊñπÊ≥ïÂπ∂‰∏îÊèê‰æõ‰∏Ä‰∏™ÂõûË∞ÉÔºåÂõûË∞É‰ºöÊé•Êî∂Âà∞ÂØπË±°ÁöÑÂºïÁî®ÔºåÂÆÉË¶Å‰øùËØÅËøîÂõûÁöÑÂØπË±°‰∏ç‰ºö‰ª•ÊØîÊé•Êî∂Âà∞ÁöÑÂºïÁî®Êõ¥ÈïøÂëΩ„ÄÇ

Áî±‰∫é‰º†ÂÖ•ÁöÑÂõûË∞ÉÈúÄË¶ÅËß£ÂºïÁî®‰∏Ä‰∏™Ë£∏ÊåáÈíà raw pointerÔºåÂç≥ÈúÄË¶Å‰ΩøÁî® unsafeÔºå‰∏∫‰∫ÜÈÅøÂÖçÂú®Â§ßÂ§öÊï∞Ë∞ÉÁî®Êñπ‰∏äÂº∫Âà∂ÊâßË°åËøôÁßç‰∏çÂÆâÂÖ®ÊÄßÔºå`ToHandle` ÁâπÊÄß‰Ωú‰∏∫ÂÖ¨ÂÖ±Êï∞ÊçÆÁªìÊûÑË¢´ÂÆûÁé∞‰∏∫ unsafe ÊñπÊ≥ï„ÄÇÂÆûÁé∞ ToHandle ÁöÑÁ±ªÂûãÂèØ‰ª•Áî® OwningHandle ÂåÖË£ÖÔºåËÄåÊó†ÈúÄ‰º†ÈÄíÂõûË∞É„ÄÇ


Ê≠§Ê®°ÂùóÊèê‰æõ‰∫Ü `Erased` trait ÂØπË±°Áî®Êù•Êì¶Èô§ÊâÄÊúâËÄÖÁöÑÂÖ∑‰ΩìÂü∫Á±ªÂûãÔºåËøôÂÖÅËÆ∏Â∞ÜÊâÄÊã•ÊúâÁöÑÂºïÁî®‰∏é‰∏çÂêåÁöÑÊâÄÊúâËÄÖÂü∫Á±ªÂûãÊ∑∑Âêà„ÄÇ

Ëøô‰∏§‰∏™Âü∫Êú¨ÁªìÊûÑ‰ΩìÊèê‰æõ‰ª•‰∏ãÂÖ±ÂêåÁöÑÊñπÊ≥ïÔºåÂèÇÊï∞‰ºöÊúâ‰∫õÂ∑ÆÂà´Ôºå‰ΩÜÂäüËÉΩÂü∫Êú¨‰∏ÄËá¥ÔºåËøòÊúâÂá†‰∏™ÁâπÊúâÊñπÊ≥ïÔºö

- `as_owner` ËøîÂõû owner ÁöÑÂºïÁî®„ÄÇ
- `erase_owner` Âç≥ `self.owner.into_erased()`ÔºåÂ∞Ü owner ÁöÑÁ±ªÂûãÊì¶Èô§„ÄÇ
- `into_owner` ËøîÂõû owner Âπ∂ÊîæÂºÉÊâÄÊúâÊùÉ„ÄÇ
- `map` Â∞Ü reference ÊàêÂëòÊò†Â∞Ñ‰∏∫Èó≠ÂåÖËøîÂõûÂºïÁî®ÊåáÂêëÁöÑÊï∞ÊçÆÂèäÁ±ªÂûãÔºåÂõûË∞ÉÁ±ªÂûã `FnOnce(&T) -> &U` ÊàñËÄÖ `FnOnce(&mut T) -> &U`„ÄÇ
- `try_map` ÂÖÅËÆ∏Â§±Ë¥•ÁöÑ `map`ÔºåËøîÂõû `Result` Êûö‰∏æÁ±ªÂûãÂåÖË£ÖÁöÑ `OwningRef`„ÄÇ
- `map_owner` Â∞Ü owner ÊàêÂëòÊò†Â∞Ñ‰∏∫Èó≠ÂåÖËøîÂõûÁöÑÊï∞ÊçÆÂèäÁ±ªÂûãÔºåunsafe ÊñπÊ≥ï„ÄÇ
- `map_owner_box` Âç≥ `Box::new(self.owner)`ÔºåÁî® Box ÊåáÈíàÂåÖË£Ö owner„ÄÇ
- `new` ÂàõÂª∫ÂÆû‰æã„ÄÇ
- `new_assert_stable_address` Á±ª‰ºº `new` ‰ΩÜ‰∏çË¶ÅÊ±ÇÂèÇÊï∞Á±ªÂûãÂÆûÁé∞ `StableAddress`„ÄÇ

- OwningRefMut

    - `as_owner_mut` ÂèØÂèòÂºïÁî®ÁâàÊú¨ÁöÑ `as_owner`ÔºåËøîÂõû owner ÁöÑÂèØÂèòÂºïÁî®„ÄÇ
    - `map_mut` ÂèØÂèòÁâàÁöÑ `map`ÔºåÂõûË∞ÉÁ±ªÂûã `FnOnce(&mut T) -> &mut U`
    - `try_map_mut` ÂèØÂèòÁâàÊú¨ÁöÑ `try_map`ÔºåÂõûË∞ÉÁ±ªÂûã `FnOnce(&mut T) -> Result<&mut U, E>`„ÄÇ

- OwningRef

    - `map_with_owner` Á±ª‰ºº `map` ÊñπÊ≥ïÔºåÂè™ÊòØÂõûË∞É‰∏≠Â§ö‰∫Ü‰∏Ä‰∏™ÂèÇÊï∞ `f(&self.owner, &self)`„ÄÇ
    - `try_map_with_owner`  Á±ª‰ºº `map_with_owner` ÊñπÊ≥ïÔºåÂè™ÊòØÂõûË∞ÉËøîÂõû `Result` Á±ªÂûãÂåÖË£ÖÁöÑ `OwningRef`„ÄÇ

‰∏§‰∏™ÂØπË±° new ÊñπÊ≥ïÂÆö‰πâÔºåËøîÂõûÂÄºÈÉΩÂÆûÁé∞ StableAddressÔºåÂ∑ÆÂà´Âú®‰∫é Deref Âíå DerefMutÔºö

```rust,ignore
pub fn new(o: O) -> Self where O: StableAddress + Deref<Target = T>,
{
    OwningRef {
        reference: &*o,
        owner: o,
    }
}

pub fn new(o: O) -> Self where O: StableAddress + DerefMut<Target = T>,
{
    OwningRefMut {
        reference: &mut *o,
        owner: o,
    }
}
```

ËÄÉËôë‰ª•‰∏ãÁöÑ‰ª£Á†ÅÔºö

```rust,ignore
fn return_owned_and_referenced<'a>() -> (Vec<u8>, &'a [u8]) {
    let v = vec![1, 2, 3, 4];
    let s = &v[1..3];
    (v, s)
}
```

Â∞ΩÁÆ°Ôºå‰ª•‰∏ä‰ª£Á†ÅÊòØ‰∏çËÉΩÈÄöËøáÁºñËØëÁöÑÔºåÂõ†‰∏∫ËøîÂõû‰∫ÜÊú¨Âú∞ÂèòÈáèÁöÑÂºïÁî®ÔºåÊâÄÊúâÊùÉÊú∫Âà∂‰∏çËÆ∏ÂèØ„ÄÇ‰ΩÜ‰ªéÂÜÖÂ≠òÂ∏ÉÂ±ÄÊù•ÁúãÔºåÂ¶ÇÊûú Vector Â≠òÊ¥ªÂë®ÊúüË∂ÖËøáÂºïÁî®ÁöÑÂ≠òÊ¥ªÊúü 'aÔºåÈÇ£‰πàËøîÂõûÁöÑÂºïÁî®Â∞±ÊòØÂÆâÂÖ®ÁöÑÔºåÂõ†‰∏∫ÂêëÈáèÁöÑÊï∞ÊçÆÂàÜÈÖçÂú∞ÂùÄÊ≤°ÊúâÊîπÂèò„ÄÇ 

Ê≠§Â∫ìÁöÑ OwningRef„ÄÅOwningRefMut ÈÄöËøá‰∏§‰∏™ÊàêÂëòÔºåÂ∞ÜÊâÄÊúâËÄÖÂíåÂºïÁî®ÊçÜÁªëÂú®‰∏Ä‰∏™ÂåÖË£ÖÂô®Á±ªÂûã‰∏≠Êù•ÂÆûÁé∞Ê≠§ÂÆâÂÖ®‰ΩøÁî®ÔºåËØ•ÂåÖË£ÖÂô®Á±ªÂûãÁ°Æ‰øùÁîüÂ≠òÊúüÁ∫¶Êùü„ÄÇ

```rust,ignore
extern crate owning_ref;

use owning_ref::{BoxRef, OwningRef};

fn return_owned_and_referenced() -> OwningRef<Vec<u8>, [u8]> {
    let v = vec![1, 2, 3, 4];
    // {owner: vec![1,2,3,4], reference[1,2,3,4]}
    let or = OwningRef::new(v);
    // {owner: vec![1,2,3,4], reference[2,3]}
    let or = or.map(|v| &v[1..3]);
    or
}

fn owned_referenced_v1() -> OwningRef<String, str> {
    let mut s = String::from("Hello world!");
    let or = OwningRef::new(s);
    let or = or.map(|v| &v[0..5]);
    or
}

fn owned_referenced_v2() -> Result<OwningRef<Box<[i32;4]>, i32>, ()> {
    let owning_ref = OwningRef::new(Box::new([1, 2, 3, 4]));
    let owning_ref = owning_ref.map(|array| &array[2]);

    let owning_ref = owning_ref.try_map_with_owner(|array, _prev| {
        if array[1] == 2 { Ok(&array[1]) } else { Err(()) }
    });
    // assert_eq!(*owning_ref.unwrap(), 2);
    owning_ref
}
```

Ê†πÊçÆ new ÊñπÊ≥ïÂÆö‰πâÔºå‰º†ÂÖ•ÁöÑÊòØ `Vec[u8]`ÔºåÊâÄ‰ª• reference ÊàêÂëòÊòØ `&*Vec[u8]` Âç≥ `[u8]`ÔºåÂ¶ÇÊûú‰º†ÂÖ•ÁöÑÊòØ StringÔºåÈÇ£‰πà `&*String` ÂæóÂà∞ÁöÑÁ±ªÂûãÂ∞±ÊòØ `str`„ÄÇ

ÂΩìÁÑ∂ÔºåÂ¶ÇÊûú‰º†ÂÖ•ÁöÑÊòØ‰∏Ä‰∏™ÂºïÁî®ÔºåÈÇ£‰πàÂ∞±ÂèàÂõûÂà∞ÂâçÈù¢ÁöÑÈóÆÈ¢ò‰∫ÜÔºåÊâÄÊúâÊùÉ‰∏çÂÖÅËÆ∏ËøîÂõû‰∏Ä‰∏™ÂºïÁî®„ÄÇ



## ‚ö° I/O & Command Line
- https://doc.rust-lang.org/book/ch12-00-an-io-project.html
- https://doc.rust-lang.org/book/ch12-06-writing-to-stderr-instead-of-stdout.html

ÂíåÂÖ∂ÂÆÉËØ≠Ë®Ä‰∏ÄÊ†∑ÔºåRust ‰πüÊúâ Standard Output Âíå Standard Error ‰∏§ÁßçËæìÂá∫Ê†áÂáÜÔºåÈªòËÆ§ËæìÂá∫ÊòØÊéßÂà∂Âè∞ÔºåÈÄöÂ∏∏ÂèØ‰ª•‰ΩøÁî®ÈáçÂÆöÂêëÂ∞ÜÈªòËÆ§ËæìÂá∫ÂÆöÂêëÂà∞Êñá‰ª∂Ôºö

    cargo run > output.txt

ËøôÊ†∑Ôºåprintln ËøôÁ±ªÊâìÂç∞‰ø°ÊÅØÂ∞±‰ºöÂÜôÂÖ•Âà∞Êñá‰ª∂Ôºå‰ΩÜ‰∏ç‰ºöÂìçÂ∫îÈîôËØØ‰ø°ÊÅØ„ÄÇ

    eprintln!("Application error: {}", e);


### üü¢üîµ CLI Arguments
- https://doc.rust-lang.org/stable/std/env/index.html
- https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html
- https://doc.rust-lang.org/book/ch12-05-working-with-environment-variables.html

Âíå C++ ËØ≠Ë®Ä‰∏çÂêåÔºåRust ÁöÑ main() ÂáΩÊï∞‰∏çÈÄöËøáÂèÇÊï∞ÂàóË°®Êé•Êî∂Á®ãÂ∫èËøêË°åÊó∂‰º†ÂÖ•ÁöÑÂèÇÊï∞ÔºåËÄåÊòØÈÄöËøáÁéØÂ¢ÉÂèòÈáèÁöÑÊñπÂºèËØªÂèñÔºåÂèØ‰ª•‰ΩøÁî® env ËØªÂèñÂÖ∂ÂÆÉÁéØÂ¢ÉÂèòÈáèÔºö

```rust,ignore
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    let version = env!("CARGO_PKG_VERSION");

    let query = &args[1];
    let filename = &args[2];

    println!("Command Line arguments: {:?}", args);
    println!("Package version: {}", version);

    println!("Searching for {}", query);
    println!("In file {}", filename);
}
```

Ë¶ÅÁÇπÔºö

- `Vec<String>` Â≠óÁ¨¶‰∏≤ÂêëÈáèÔºåÂºïÁî® args() ËøîÂõûÁöÑ Args ÁªìÊûÑ‰ΩìÈõÜÂêàÔºõ
- `&args[0]` ÂÄüÁî®ÂèÇÊï∞ÂºïÁî®ÔºåÂõ†‰∏∫Â§ñÈÉ®‰º†ÂÖ•ÁöÑ String ÊâÄÊúâÊùÉ‰∏çËÉΩËΩ¨ÁßªÔºõ
- `{:?}` ÊâìÂç∞Ê®°Êùø‰ΩøÁî®ÈÄöÈÖçÁ¨¶Âè∑ÊâìÂç∞Â§ö‰∏™ÂÄºÔºõ


Á§∫ËåÉ‰ΩøÁî® std::fs Ê†áÂáÜÊ®°ÂùóÊù•ËØªÂèñÊñá‰ª∂ÔºåÈÄöËøá `read_to_string()` ÈùôÊÄÅÊñπÊ≥ïÔºö

```rust,ignore
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();
    let filename = &args[1];
    println!("In file {}", filename);

    let contents = fs::read_to_string(filename)
        .expect("Something went wrong reading the file");

    println!("With text:\n{}", contents);
}
```

Ê®°Âùó env ÂØºÂá∫ÂáΩÊï∞Ôºö

- `args`    ËøîÂõûÊâÄÊúâÂëΩ‰ª§Ë°åÂèÇÊï∞ÔºåÂ≠óÁ¨¶‰∏≤Á±ªÂûã‰∏∫ String„ÄÇ
- `args_os` ËøîÂõûÊâÄÊúâÂëΩ‰ª§Ë°åÂèÇÊï∞ÔºåÂ≠óÁ¨¶‰∏≤Á±ªÂûã‰∏∫ std::ffi::OsString„ÄÇ
- `current_dir` Returns the current working directory as a PathBuf.
- `current_exe` Returns the full filesystem path of the current running executable.
- `home_dir`    DeprecatedReturns the path of the current user's home directory if known.
- `join_paths`  Joins a collection of Paths appropriately for the PATH environment variable.
- `remove_var`  Removes an environment variable from the environment of the currently running process.
- `set_current_dir` Changes the current working directory to the specified path.
- `set_var` Sets the environment variable k to the value v for the currently running process.
- `split_paths` Parses input according to platform conventions for the PATH environment variable.
- `temp_dir`    Returns the path of a temporary directory.
- `var` Ê†πÊçÆ key Ëé∑ÂèñÂØπÂ∫îÁöÑÁéØÂ¢ÉÂèòÈáèÔºåËøîÂõû `Result<String, VarError>`„ÄÇ
- `var_os`  Ê†πÊçÆ key Ëé∑ÂèñÂØπÂ∫îÁöÑÁéØÂ¢ÉÂèòÈáèÔºåËøîÂõû `Option<OsString>`„ÄÇ
- `vars`    Ëé∑ÂèñÁöÑÊâÄÊúâÁöÑÁéØÂ¢ÉÂèòÈáèÔºåËøîÂõû‰∏Ä‰∏™Ëø≠‰ª£Âô®ÔºåÂÖÉÁ¥†ÊòØ (variable, value) Â≠óÁ¨¶‰∏≤Á±ªÂûã‰∏∫ String„ÄÇ
- `vars_os` Ëé∑ÂèñÁöÑÊâÄÊúâÁöÑÁéØÂ¢ÉÂèòÈáèÔºåËøîÂõû‰∏Ä‰∏™Ëø≠‰ª£Âô®ÔºåÂÖÉÁ¥†ÊòØ (variable, value) Â≠óÁ¨¶‰∏≤Á±ªÂûã‰∏∫ std::ffi::OsString„ÄÇ


### üü¢üîµ Shell ÂëΩ‰ª§ÊâßË°å
- https://doc.rust-lang.org/stable/std/process/struct.Command.html
- https://docs.microsoft.com/en-US/troubleshoot/cpp/redirecting-error-command-prompt
- BASH Shell Redirect stderr To stdout https://www.cyberciti.biz/faq/redirecting-stderr-to-stdout/
- Clap - Command Line Argument Parser for Rust https://crates.io/crates/clap

Rust ËøõÁ®ãÊ†áÂáÜÂ∫ìÊèê‰æõ‰∫Ü‰∏éÊìç‰ΩúÁ≥ªÁªüËøõÁ®ãÁ∫ßÂà´ÁöÑ‰∫§‰∫íËÉΩÂäõÔºåÊèê‰æõ‰∫Ü Command Ê®°ÂùóÊù•ÊâßË°åÂ§ñÈÉ®ÂëΩ‰ª§„ÄÇ

Ê†áÂáÜÂ∫ìÊèê‰æõ‰∏â‰∏™Êñá‰ª∂Êù•Êìç‰ΩúËøõÁ®ãÔºö

- `process::abort()` Êó†Êù°‰ª∂ÁªìÊùüËøõÁ®ãÔºõ
- `process::exit(code: i32)` ÈÄÄÂá∫ËøõÁ®ãÔºõ
- `process::id()` Ëé∑ÂèñËøõÁ®ã IDÔºõ

ÂëΩ‰ª§ÂØπË±° `Command` ÂíåÂ≠êËøõÁ®ã `Child` ÊòØ‰∏ªË¶ÅÂØπË±°ÔºåËøõÁ®ãÊ†áÂáÜÂ∫ìÈÉΩÊòØÂõ¥ÁùÄÂÆÉËøêËΩ¨ÁöÑ„ÄÇ

ÂëΩ‰ª§ÂØπË±°Êèê‰æõÁöÑ‰∏∞ÂØåÁöÑÊñπÊ≥ïÔºö

    pub fn new<S: AsRef<OsStr>>(program: S) -> Command
    pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command
    pub fn args<I, S>(&mut self, args: I) -> &mut Command
    where
        I: IntoIterator<Item = S>,
        S: AsRef<OsStr>, 
    pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command
    where
        K: AsRef<OsStr>,
        V: AsRef<OsStr>, 
    pub fn envs<I, K, V>(&mut self, vars: I) -> &mut Command
    where
        I: IntoIterator<Item = (K, V)>,
        K: AsRef<OsStr>,
        V: AsRef<OsStr>, 
    pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command
    pub fn env_clear(&mut self) -> &mut Command
    pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command
    pub fn stdin<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command
    pub fn stdout<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command
    pub fn stderr<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command
    pub fn spawn(&mut self) -> Result<Child>
    pub fn output(&mut self) -> Result<Output>
    pub fn status(&mut self) -> Result<ExitStatus>

    üî¨ nightly-only experimental API
    pub fn get_program(&self) -> &OsStr
    pub fn get_args(&self) -> CommandArgs<'_>
    pub fn get_envs(&self) -> CommandEnvs<'_>
    pub fn get_current_dir(&self) -> Option<&Path>

Â∏∏Áî®ÊñπÊ≥ïÔºö

- new ÂàõÂª∫ÂëΩ‰ª§ÂØπË±°Ôºõ
- arg/args ËÆæÁΩÆÂëΩ‰ª§ÂèÇÊï∞Ôºõ
- env/envs ËÆæÁΩÆÂëΩ‰ª§ÁéØÂ¢ÉÂèòÈáèÔºõ
- spawn ÂΩì‰ΩúÂ≠êËøõÁ®ãÊâßË°åÂëΩ‰ª§ÔºåËøîÂõû‰∏Ä‰∏™Â≠êËøõË°åÂè•ÊüÑÔºõ
- output ÂΩì‰ΩúÂ≠êËøõÁ®ãÊâßË°åÂëΩ‰ª§ÔºåÁ≠âÂæÖÂÆåÊàêÂπ∂ÊçïÊçâËæìÂá∫Êï∞ÊçÆÂØπË±°Ôºõ
- status ÂΩì‰ΩúÂ≠êËøõÁ®ãÊâßË°åÂëΩ‰ª§ÔºåÁ≠âÂæÖÂÆåÊàêÂπ∂Ëé∑ÂèñÁä∂ÊÄÅÔºõ

ËÄåÂ≠êËøõÁ®ãÂØπË±°Êú¨Ë∫´Âè™Êèê‰æõ‰∫Ü 4 ‰∏™ÊñπÊ≥ï„ÄÇ

    pub fn kill(&mut self) -> Result<()>
    pub fn id(&self) -> u32
    pub fn try_wait(&mut self) -> Result<Option<ExitStatus>>
    pub fn wait_with_output(self) -> Result<Output>

‰∏éÂ≠êËøõÁ®ã‰∫§‰∫íÔºåÂÖç‰∏çÂá∫ÈúÄË¶ÅË¶ÅÂ§ÑÁêÜ stdout, stdin, stderr Á≠â IO ÂØπË±°ÔºåËøô‰∫õÈÉΩÊòØÂ≠êËøõÁ®ãÁöÑÊàêÂëò„ÄÇ

```rust,ignore
pub struct Child {
    pub stdin:  Option<ChildStdin>,
    pub stdout: Option<ChildStdout>,
    pub stderr: Option<ChildStderr>,
    // some fields omitted
}
```

Ê≥®ÊÑèÂå∫Âà´ÔºåÂëΩ‰ª§ÊàñÂ≠êËøõÁ®ãÊâßË°åÂÆåÊØïÔºåËæìÂá∫ÁöÑÊï∞ÊçÆ‰øùÂ≠òÂú® Output ÂØπË±°„ÄÇ

‰æãÂ¶ÇÔºåÊâßË°å‰∏Ä‰∏™ echo ÂëΩ‰ª§ÔºåÊ≥®ÊÑèÔºåWindows Âíå Linux Á≥ªÁªüÁöÑÊç¢Ë°åÁ¨¶Âè∑ÂàÜÂà´‰∏∫ `\r\n`„ÄÅ`\n`„ÄÇ

```rust,ignore
use std::process::Command;

let output = Command::new("echo")
                     .arg("Hello world")
                     .output()
                     .expect("Failed to execute command");

assert_eq!(b"Hello world\n", output.stdout.as_slice());
```

‰ª•‰∏ãÁ§∫ËåÉË∞ÉÁî® Linux Á≥ªÁªüÁöÑ grep ÂëΩ‰ª§ÔºåÂÆÉËÉΩÂØπÁõÆÊ†áÊñá‰ª∂ËøõË°åÂàÜÊûêÂπ∂Êü•ÊâæÁõ∏Â∫îÂ≠óÁ¨¶‰∏≤ÔºåÂπ∂ËØ•Â≠óÁ¨¶‰∏≤ÊâÄÂú®Ë°åËæìÂá∫„ÄÇ

```rust,ignore
use std::process::*;
use std::env::args;

fn main() {
    let mut arg_iter = args();
    // panic if there is no one
    arg_iter.next();
    let pattern = arg_iter.next().unwrap_or("main".to_string());
    let pt =  arg_iter.next().unwrap_or("./".to_string());
    let child = Command::new("grep")
        .arg("-n")
        .arg("-r")
        .arg(&pattern)
        .arg(&pt)
        // pipeline to parent
        // .stdout(Stdio::null())
        .stdout(Stdio::piped())
        .spawn().unwrap();

    // wait child to finish
    let out = child.wait_with_output().unwrap();
    let out_str = String::from_utf8_lossy(&out.stdout);
    for line in out_str.split("\n") {
        println!("{}", line);
    }
}
```

‰∏äÈù¢‰ª£Á†Å‰∏≠ÔºåËôΩÁÑ∂‰ΩøÁî®‰∫Ü wait_with_output ÊñπÊ≥ïÁ≠âÂæÖÂ≠êËøõÁ®ãÔºå‰ΩÜÊòØËæìÂá∫ÂÜÖÂÆπÂπ∂‰∏çËÉΩÁõ¥Êé•Ë¢´ÊçïÊçâÂà∞„ÄÇÂõ†‰∏∫Â≠êÁ∫øÁ®ã‰ºöÁªßÊâøÁà∂ËøõÁ®ãÁöÑÊâÄÊúâÂè•ÊüÑÔºåÂ≠êËøõÁ®ã‰πüÂ∞±‰ºöÁªßÊâøÁà∂ËøõÁ®ãÁöÑÊ†áÂáÜËæìÂá∫„ÄÇ

Âè™ÈúÄË¶Å‰ΩøÁî® pipe ÈáçÂÆöÂêëÂ≠êÁ∫øÁ®ãÁöÑÊ†áÂáÜËæìÂá∫Âà∞Âè¶Â§ñ‰∏Ä‰∏™ËæìÂá∫ÁºìÂÜ≤Âå∫ÔºåËÄå‰∏çÊòØÁà∂ËøõÁ®ãÁöÑ stdoutÔºåËøôÊ†∑Â∞±ÂèØ‰ª•ÊçïÊçâÂ≠êËøõÁ®ãÁöÑËæìÂá∫ÂÜÖÂÆπ„ÄÇ

Unix/Linux Ê†áÂáÜ I/O ÊµÅË°åÊñá‰ª∂‰∏éÂØπÂ∫îÁöÑ IDÔºö

    | Handle |  Name  |   Description   |
    |--------|--------|-----------------|
    |      0 | stdin  | Standard input  |
    |      1 | stdout | Standard output |
    |      2 | stderr | Standard error  |

Âú®ÂëΩ‰ª§Ë°å‰∏≠ÔºåÂèØ‰ª•‰ΩøÁî®Ëøô‰∫õÊñá‰ª∂ ID Êù•ÂÅöÈáçÂÆöÂêëÔºå‰æãÂ¶Ç ls ÂëΩ‰ª§ÁöÑÊ†áÂáÜËæìÂá∫Âà∞Êñá‰ª∂Ôºö

    # redirect stdout to list.txt
    ls > list.txt
    ls 1> list.txt

    # append stdout to list.txt
    ls -l >> list.txt

‰æãÂ¶ÇÔºåÂ∞Ü grep ÂëΩ‰ª§ÁöÑ stderr ÈáçÂÆöÂêëÂà∞Êñá‰ª∂Ôºö

    grep -R 'MASTER' $HOME 2> err.txt

ÂêåÊó∂Â∞Ü stdout Âíå stderr ÈáçÂÆöÂêëÂà∞Êñá‰ª∂ÔºåÊ≥®ÊÑèÔºåÂêéÈù¢ÁöÑ`2>&1`Ë°®Á§∫Â∞Ü stderr ÈáçÂÆöÂêëÂà∞ stdoutÔºö

    $ ls > list.txt 2>&1

    ## bash only ##
    $ ls &> list.txt

Windows Á≥ªÁªüËøòÊîØÊåÅ‰ª•‰∏ãËøôÊ†∑ÁöÑËØ≠Ê≥ïÔºö

    dir 2>&1 > out.txt
    dir 2> nul
    dir > output.msg 2> output.err
    dir 1> output.msg 2>&1

### üü¢üîµ CLAP ÂëΩ‰ª§Ë°åÂèÇÊï∞Ëß£ÊûêÂô®
- CLAP - Command Line Argument Parser for Rust https://crates.io/crates/clap
- https://github.com/clap-rs/clap/blob/HEAD/examples/

CLAP ÂëΩ‰ª§Ë°åËß£ÊûêÂ∑•ÂÖ∑ÈùûÂ∏∏ÊòìÁî®ÔºåÂπ∂‰∏îÁî®Êà∑‰πüÂ§öÔºåÂÆÉÊèê‰æõ‰∏∞ÂØåÁöÑÂäüËÉΩÔºö

* Generate a CLI simply by defining a struct!
* **Auto-generated Help, Version, and Usage information**
* **Auto-generated completion scripts (Bash, Zsh, Fish, Elvish and PowerShell)**
* **Flags / Switches** (i.e. bool fields)
* **Positional Arguments** (i.e. those which are based off an index from the program name)
* **Option Arguments** (i.e. those that take values)
* **Sub-Commands** (i.e. `git add <file>` where `add` is a sub-command of `git`)
* **Support for building CLIs from YAML**
* **Requirement Rules**: Arguments can define the following types of requirement rules
* **Confliction Rules**: Arguments can optionally define the following types of exclusion rules
* **Groups**: Arguments can be made part of a group
* **Specific Value Sets**: (i.e. a `--mode` option may has two values, such as `--mode fast` or `--mode slow`)
* **Default Values**
* **Automatic Version from Cargo.toml**: use Rust's `env!()` macro to read the version in your Cargo.toml. 
* **Typed Values**: some macros provided by `clap` to get typed values (i.e. `i32`, `u8`, etc.) 
* **Suggestions**: Suggests corrections when the user enters a typo.
* **Colorized Errors (Non Windows OS only)**
* **Global Arguments**: Arguments can optionally be defined once, and be available to all child subcommands.
* **Custom Validations**: You can define a function to use as a validator of argument values.
* **POSIX Compatible Conflicts/Overrides**

ÈÖçÁΩÆ‰æùËµñÔºö

    [dependencies]
    clap = "2.33"

    [dependencies]
    clap = {version = "2.33", features = ["yaml"]}

    [dependencies.clap]
    features = ["yaml"]

Âêé‰∏§ÁßçÈÖçÁΩÆÂèØ‰ª•Ëß£Êûê yaml ÈÖçÁΩÆÊñá‰ª∂„ÄÇ

Á§∫ËåÉÂàõÂª∫‰∏Ä‰∏™ÂèÇÊï∞ÊûÑÈÄ†Âô® Builder PatternÔºö

```rust,ignore
// (Full example with detailed comments in examples/01b_quick_example.rs)
//
// This example demonstrates clap's full 'builder pattern' style of creating arguments which is
// more verbose, but allows easier editing, and at times more advanced options, or the possibility
// to generate arguments dynamically.
extern crate clap;
use clap::{Arg, App, SubCommand};

fn main() {
    let matches = App::new("My Super Program")
                  .version("1.0")
                  .author("Kevin K. <kbknapp@gmail.com>")
                  .about("Does awesome things")
                  .arg(Arg::with_name("config")
                       .short("c")
                       .long("config")
                       .value_name("FILE")
                       .help("Sets a custom config file")
                       .takes_value(true))
                  .arg(Arg::with_name("INPUT")
                       .help("Sets the input file to use")
                       .required(true)
                       .index(1))
                  .arg(Arg::with_name("v")
                       .short("v")
                       .multiple(true)
                       .help("Sets the level of verbosity"))
                  .subcommand(SubCommand::with_name("test")
                              .about("controls testing features")
                              .version("1.3")
                              .author("Someone E. <someone_else@other.com>")
                              .arg(Arg::with_name("debug")
                                  .short("d")
                                  .help("print debug information verbosely")))
                  .get_matches();

    // Gets a value for config if supplied by user, or defaults to "default.conf"
    let config = matches.value_of("config").unwrap_or("default.conf");
    println!("Value for config: {}", config);

    // Calling .unwrap() is safe here because "INPUT" is required (if "INPUT" wasn't
    // required we could have used an 'if let' to conditionally get the value)
    println!("Using input file: {}", matches.value_of("INPUT").unwrap());

    // Vary the output based on how many times the user used the "verbose" flag
    // (i.e. 'myprog -v -v -v' or 'myprog -vvv' vs 'myprog -v'
    match matches.occurrences_of("v") {
        0 => println!("No verbose info"),
        1 => println!("Some verbose info"),
        2 => println!("Tons of verbose info"),
        3 | _ => println!("Don't be crazy"),
    }

    // You can handle information about subcommands by requesting their matches by name
    // (as below), requesting just the name used, or both at the same time
    if let Some(matches) = matches.subcommand_matches("test") {
        if matches.is_present("debug") {
            println!("Printing debug info...");
        } else {
            println!("Printing normally...");
        }
    }

    // more program logic goes here...
}
```

ÂàõÂª∫Ëß£Êûê yaml ÈÖçÁΩÆÊñá‰ª∂ÁöÑÁ§∫ËåÉÁ®ãÂ∫èÔºö

```rust,ignore
// (Full example with detailed comments in examples/17_yaml.rs)
//
// This example demonstrates clap's building from YAML style of creating arguments which is far
// more clean, but takes a very small performance hit compared to the other two methods.
#[macro_use]
extern crate clap;
use clap::App;

fn main() {
    // The YAML file is found relative to the current file, similar to how modules are found
    let yaml = load_yaml!("cli.yml");
    let matches = App::from_yaml(yaml).get_matches();

    // Same as previous examples...
}
```

ÂÜçÂàõÂª∫ cli.yml ÈÖçÁΩÆÊñá‰ª∂ÔºåÁÑ∂Âêé‰ΩøÁî® `--help` or `-h` ÂèÇÊï∞ËøêË°å‰ª•‰∏äÁ®ãÂ∫èÂç≥ÂèØËß£ÊûêÈÖçÁΩÆÊñá‰ª∂ÔºåËß£ÊûêÁªìÊûúÂ≠òÊîæ‰∫é matches ‰∏≠Ôºö

```yaml
name: myapp
version: "1.0"
author: Kevin K. <kbknapp@gmail.com>
about: Does awesome things
args:
    - config:
        short: c
        long: config
        value_name: FILE
        help: Sets a custom config file
        takes_value: true
    - INPUT:
        help: Sets the input file to use
        required: true
        index: 1
    - verbose:
        short: v
        multiple: true
        help: Sets the level of verbosity
subcommands:
    - test:
        about: controls testing features
        version: "1.3"
        author: Someone E. <someone_else@other.com>
        args:
            - debug:
                short: d
                help: print debug information
```


### üü¢üîµ Files Êñá‰ª∂ËØªÂÜô
- https://doc.rust-lang.org/book/ch12-02-reading-a-file.html
- https://doc.rust-lang.org/book/ch13-03-improving-our-io-project.html

Rust Êèê‰æõÁöÑ fs::read_to_string ÊñπÊ≥ïÂè™Êé•Êî∂‰∏Ä‰∏™Êñá‰ª∂ÂêçÔºåÂÆÉÂèØ‰ª•Â∞ÜÊåáÂÆöÊñá‰ª∂ËØªÂÖ•Âà∞ÂÜÖÂ≠ò‰∏≠„ÄÇ

```rust,ignore
#[stable(feature = "fs_read_write", since = "1.26.0")]
pub fn read_to_string<P: AsRef<Path>>(path: P) -> io::Result<String> {
    fn inner(path: &Path) -> io::Result<String> {
        let mut file = File::open(path)?;
        let mut string = String::with_capacity(initial_buffer_size(&file));
        file.read_to_string(&mut string)?;
        Ok(string)
    }
    inner(path.as_ref())
}
```

‰ΩøÁî®Á§∫ËåÉÔºö

```rust,ignore
use std::env;
use std::fs;

fn main() {
    let args: Vec<String> = env::args().collect();
  
    if let Ok(config) = parse_config(&args) {
        println!("Searching for {}", config.query);
        println!("In file {}", config.filename);
    
        let contents = fs::read_to_string(config.filename)
            .expect("Something went wrong reading the file");
        println!("{}", contents);
    }
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &[String]) -> Result<Config, &str> {
    if args.len() != 3 {
        // panic!("Usage: {} query filename", args[0]);
        // cannot return value referencing local variable `s` 
        // let s = format!("Usage: {} query filename", args[0]);
        // return Err(s.as_str());
        return Err("Require query and filename.");
    }
    let query = args[1].clone();
    let filename = args[2].clone();
    return Ok(Config{ query, filename })
}
```

Ë¶ÅÁÇπÔºö

- ‰ΩøÁî®Ê®°ÂºèÂåπÈÖç if let ËøõË°åÈîôËØØÂ§ÑÁêÜÔºåÂè™Êúâ parse_config ËøîÂõû Ok ÂÄºÊâçÁªßÁª≠ÊâßË°å„ÄÇ
- parse_config ÂáΩÊï∞‰ΩøÁî® Result<T, E> Á±ªÂûãÔºåÁªôË∞ÉÁî®ÊñπÊèê‰æõÈîôËØØÂ§ÑÁêÜÁöÑÊú∫‰ºö„ÄÇ

ÂÅáÂÆö poem.txt Êñá‰ª∂ÂåÖÂê´ËâæÁ±≥Ëéâ¬∑ÁãÑÈáëÊ£ÆÁöÑ‰∏ÄÈ¶ñËØóËØçÂÜÖÂÆπÔºö

    Emily Dickinson

    I‚Äôm Nobody! Who are you?
    Are you ‚Äì Nobody ‚Äì too?
    Then there‚Äôs a pair of us!
    Don‚Äôt tell! they‚Äôd advertise ‚Äì you know!

    How dreary ‚Äì to be ‚Äì Somebody!
    How public ‚Äì like a Frog ‚Äì  
    To tell one‚Äôs name ‚Äì the livelong June ‚Äì  
    To an admiring Bog!

ÊâßË°åÂëΩ‰ª§Â∞±ÂèØ‰ª•ËØªÂèñÊñá‰ª∂ÂÜÖÂÆπÔºö

    cargo run the poem.txt

Ê≥®ÊÑè‰ª£Á†Å‰∏≠ÁöÑ clone ÊñπÊ≥ïÔºåËøôÂèØ‰ª•ËØ¥ÊòØ‰∏ÄÁßç‰ΩéÊïàÁéáÁöÑÂÅöÊ≥ïÔºåÂΩìÁÑ∂ÔºåÂØπ‰∫éÂçïÊ¨°ÊâßË°åÊàñÊï∞ÊçÆÈáèÂ∞èÁöÑÊÉÖÂÜµ‰∏ãÂèØ‰ª•ÂøΩÁï•Ôºå‰ΩÜÊòØÊ≤°ÂøÖË¶ÅÁöÑÂ§çÂà∂Êï∞ÊçÆÁ°ÆÂÆûÊòØÊµ™Ë¥πÔºåÊõ¥ÊúâÊïàÁöÑÂÅöÊ≥ïÊòØÁõ¥Êé•‰ΩøÁî®Ëø≠‰ª£Âô®Ôºåenv::args ÂáΩÊï∞ËøîÂõûÁöÑ std::env::Args ÂèØ‰ª•Ëø≠‰ª£Âú∞Ëé∑ÂèñÂêÑ‰∏™ÂëΩ‰ª§Ë°åÂèÇÊï∞„ÄÇ

```rust,ignore
let args = env::args();
args.next();

let query = match args.next() {
    Some(arg) => arg,
    None => return Err("Didn't get a query string"),
};

let filename = match args.next() {
    Some(arg) => arg,
    None => return Err("Didn't get a file name"),
};
```



# üü°üü† Memory Layout ÂÜÖÂ≠òÊ®°Âûã
- Rust ÂÜÖÂ≠òÊ®°Âûã https://zhuanlan.zhihu.com/p/189694498
- https://github.com/usagi/rust-memory-container-cs

Rust ÁöÑÂÜÖÂ≠òÊ®°ÂûãÊòØ‰∏∫‰∫Ü‰∏â‰∏™È¢áÂÖ∑ÊåëÊàòÁöÑÁõÆÊ†áÊúçÂä°ÁöÑÔºö

- ÂÜÖÂ≠òÂÆâÂÖ®ÔºöËÉΩÂ§üÊìç‰ΩúÁöÑÂÜÖÂ≠òÂøÖÈ°ª‰øùËØÅÊúâÊïàÔºåÊ≠£Â∏∏ÊÉÖÂÜµ‰∏ãÔºå‰∏çÂèØËÉΩËß¶ÂèëÊÆµÈîôËØØÊàñËÄÖÂèëÁîüÂÜÖÂ≠òÊ≥ÑÊºè„ÄÇ
- ÊÄßËÉΩÔºöÈ´òÊÄßËÉΩÁöÑ‰ΩéÁ∫ß‰ª£Á†ÅÂøÖÈ°ªËÉΩÂ§ü‰ΩøÁî®‰∏Ä‰∫õ‰∏çÂêåÁöÑÂÜÖÂ≠òÂàÜÈÖçÁ≠ñÁï•„ÄÇÂûÉÂúæÂõûÊî∂ÂøÖÈ°ªÊòØÈùûÂº∫Âà∂ÁöÑÔºåÂèØ‰ª•‰ΩøÁî®ÂçïÁã¨ÁöÑ„ÄÅÂü∫‰∫é GC ÁöÑ„ÄÅÂ†ÜÂÜÖÂ≠òÂàÜÈÖçÁ≠ñÁï•„ÄÇ
- Âπ∂ÂèëÔºöÂøÖÈ°ªÂÖç‰∫éÂÜÖÂ≠òÊï∞ÊçÆÁ´û‰∫âÔºåÂÖ∂‰ªñÂΩ¢ÂºèÁöÑÁ´û‰∫â‰æùÁÑ∂ÂèØËÉΩÂ≠òÂú®„ÄÇ

c++ ËØ≠Ë®ÄÂÜÖÂ≠òÊ®°Âûã‰∏≠ÂàÜ‰∏∫Âõõ‰∏™Âå∫ÔºöÂ†ÜÔºåÊ†àÔºåÈùôÊÄÅÂÖ®Â±ÄÂèòÈáèÂéªÔºåÂ∏∏ÈáèÂå∫„ÄÇ 

Ê†πÊçÆ C++ ÂØπË±°ÁîüÂëΩÂë®Êúü‰∏çÂêåÔºåÂÜÖÂ≠òÊ®°ÂûãÊúâËá™Áî±Â≠òÂÇ®Âå∫ÔºåÂä®ÊÄÅÂå∫„ÄÅÈùôÊÄÅÂå∫‰∏âÁßç‰∏çÂêåÁöÑÂÜÖÂ≠òÂå∫Âüü„ÄÇ

- Ëá™Áî±Â≠òÂÇ®Âå∫ÔºöÂ±ÄÈÉ®ÈùûÈùôÊÄÅÂèòÈáèÁöÑÂ≠òÂÇ®Âå∫ÂüüÔºåÂç≥Âπ≥Â∏∏ÊâÄËØ¥ÁöÑÊ†àÔºõ
- Âä®ÊÄÅÂå∫ÔºöÁî® operator new Ôºåmalloc ÂàÜÈÖçÁöÑÂÜÖÂ≠òÔºåÂç≥Âπ≥Â∏∏ÊâÄËØ¥ÁöÑÂ†ÜÔºõ
- ÈùôÊÄÅÂå∫ÔºöÂÖ®Â±ÄÂèòÈáè ÈùôÊÄÅÂèòÈáè Â≠óÁ¨¶‰∏≤Â∏∏ÈáèÂ≠òÂú®‰ΩçÁΩÆÔºõ

ËÄå‰ª£Á†ÅËôΩÁÑ∂Âç†ÂÜÖÂ≠òÔºå‰ΩÜ‰∏çÂ±û‰∫é C++ ÂÜÖÂ≠òÊ®°ÂûãÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇ



# üü°üü† Advanced Features
- RustÁöÑÁ±ªÂûãÁ≥ªÁªü https://www.cnblogs.com/Davirain/p/13455953.html

ËøôÈÉ®ÂàÜÈ´òÁ∫ßÂÜÖÂÆπÂåÖÊã¨Ôºö

- Unsafe Rust: how to opt out of some of Rust‚Äôs guarantees and take responsibility for manually upholding those guarantees
- Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits
- Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types
- Advanced functions and closures: function pointers and returning closures
- Macros: ways to define code that defines more code at compile time


## ‚ö° Unsafe Rust 
- https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html
- The Rustonomicon - The Dark Arts of Unsafe Rust https://doc.rust-lang.org/nightly/nomicon/index.html
- Rust's Unsafe Code Guidelines Reference https://rust-lang.github.io/unsafe-code-guidelines/introduction.html

Rust ÂÜÖÂ≠òÂÆâÂÖ®‰æùËµñ‰∫éÂº∫Â§ßÁöÑÁ±ªÂûãÁ≥ªÁªüÂíåÁºñËØëÊó∂ËøΩË∏™Ê£ÄÊµãÔºå‰∏çËøáÂÆÉÂπ∂‰∏çËÉΩÈÄÇÂ∫îÊâÄÊúâÁöÑÂú∫ÊôØ„ÄÇ

- È¶ñÂÖàÔºåÊâÄÊúâÁöÑÁºñÁ®ãËØ≠Ë®ÄÈÉΩÈúÄË¶ÅË∑üÂ§ñÈÉ®ÁöÑ‰∏çÂÆâÂÖ®Êé•Âè£Êâì‰∫§ÈÅìÔºåË∞ÉÁî®Â§ñÈÉ®Â∫ìÁ≠âÔºåÂú®ÂÆâÂÖ®ÁöÑ Rust ÁâπÊÄß‰∏ãÊòØÊó†Ê≥ïÂÆûÁé∞ÁöÑÔºõ
- ÂÖ∂Ê¨°ÔºåÂÆâÂÖ®ÁöÑ Rust ÁâπÊÄßÊó†Ê≥ïÈ´òÊïàË°®Á§∫Â§çÊùÇÁöÑÊï∞ÊçÆÁªìÊûÑÔºåÁâπÂà´ÊòØÊï∞ÊçÆÁªìÊûÑÂÜÖÈÉ®ÊúâÂêÑÁßçÊåáÈíà‰∫íÁõ∏ÂºïÁî®ÁöÑÊó∂ÂÄôÔºõ
- ÂÜçÊ¨°Ôºå‰∫ãÂÆû‰∏äËøòÂ≠òÂú®ÁùÄ‰∏Ä‰∫õÊìç‰ΩúÔºåËøô‰∫õÊìç‰ΩúÊòØÂÆâÂÖ®ÁöÑÔºå‰ΩÜ‰∏çËÉΩÈÄöËøáÁºñËØëÂô®ÁöÑÈ™åËØÅ„ÄÇ

Âõ†Ê≠§Âú®ÂÆâÂÖ®ÁöÑ Rust ËÉåÂêéÔºåËøòÈúÄË¶Å unsafe ÁöÑÊîØÊåÅÔºå‰∏çÂÆâÂÖ®Ê†áÁ§∫Â¶ÇÊûúÊâßË°åÂÆÉÂèØËÉΩ‰ºöËøùÂèç Rust ÁöÑÂÜÖÂ≠òÂÆâÂÖ®ËØ≠ÊÑèÔºåsafe != no bug„ÄÇ

Unsafe Ê®°Âºè‰∏ã‰∏çËøõË°åÂÆâÂÖ®ÊÄßÊ£ÄÊü•ÔºåÊÑèÂë≥Êúâ‰∏ÄÂÆöÁöÑÊÄßËÉΩÊèêÂçáÔºåÂπ∂‰∏îÂÜÖÂ≠òÁöÑÂÆâÂÖ®Â∞ÜÁî±ÂºÄÂèëËÄÖË¥üË¥£„ÄÇ

Unsafe ËØ≠Âè•ÂùóËÉΩÂÖÅËÆ∏Á®ãÂ∫èÂëòÂÅöÁöÑÈ¢ùÂ§ñ‰∫ãÊÉÖÊúâÔºö

- Dereference a raw pointer `&num as *const i32`
- Call an unsafe function or method
- Access or modify a mutable `static` variable
- Implement an unsafe trait
- Access fields of unions

‰ΩøÁî®Ëøô‰∫õËÉΩÂäõÔºåÂèØ‰ª•ËÆ© Rust ÂíåÂ§ñÈÉ®ËØ≠Ë®ÄËøõË°å‰∫§‰∫í„ÄÇ

```rust,ignore
let x = 5;
let raw = &x as *const i32;
let points_at = unsafe { *raw };
println!("raw points at {}", points_at);

static mut N: i32 = 5;
unsafe {
    N += 1;
    println!("N: {}", N);
}
```

```rust,ignore
unsafe fn danger_will_robinson() {
    // unsafe function
}

unsafe {
    // unsafe block
}

unsafe trait DangerTrait { }
unsafe impl DangerTrait for i32 {}
```

Rust 1.51.0 ÂºïÂÖ•‰∫Ü‰∏§‰∏™ÂÆèÔºå`addr_of` Âíå `addr_of_mut` Áî®Êù•Ëé∑ÂèñÂèòÈáèÁöÑÂ∏∏Ë£∏ÊåáÈíà const raw pointer„ÄÇ

```rust,ignore
use std::ptr;

#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}

let packed = Packed { f1: 1, f2: 2 };
// `&packed.f2` would create an unaligned reference, and thus be Undefined Behavior!
let raw_f2 = ptr::addr_of!(packed.f2);
assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);
```


## ‚ö° FFI - Foreign Function Interface
- The (unofficial) Rust FFI Guide https://michael-f-bryan.github.io/rust-ffi-guide/overview.html
- Dynamically Sized Types https://doc.rust-lang.org/reference/dynamically-sized-types.html
- Build Scripts https://doc.rust-lang.org/cargo/reference/build-scripts.html
- rustc Command-line arguments https://doc.rust-lang.org/rustc/command-line-arguments.html
- Rust By Example - FFI https://doc.rust-lang.org/rust-by-example/std_misc/ffi.html
- Rust FFI Examples https://github.com/alexcrichton/rust-ffi-examples
- The Rustonomicon - FFI https://doc.rust-lang.org/nomicon/ffi.html
- https://doc.rust-lang.org/stable/std/ffi/index.html
- https://doc.rust-lang.org/stable/std/os/raw/index.html
- https://www.bookstack.cn/read/RustPrimer/ffi-calling-ffi-function.md
- Rust FFI ÁºñÁ®ã - FFI Ê¶ÇËø∞ https://rustcc.cn/article?id=3b8241d0-c4ca-4f49-8e07-0a5142b00f59
- The `bindgen` User Guide https://rust-lang.github.io/rust-bindgen/introduction.html

‰Ωú‰∏∫Á≥ªÁªüÁ∫ßÁºñÁ®ãËØ≠Ë®ÄÔºå‰∏éÂÖ∂ÂÆÉËØ≠Ë®ÄËøõË°å‰∫§ÊµÅÊòØÂæàÂü∫Êú¨ÁöÑËÉΩÂäõÔºåRust FFI Â∞±ÊòØÂÅöËøô‰∏™Â∑•‰ΩúÁöÑ„ÄÇ

FFI Ëøô‰∏™ÊúØËØ≠ÊúÄÊó©Êù•Ëá™ Common Lisp ÁöÑËßÑËåÉÔºå‰∏çÂêåËØ≠Ë®ÄÁß∞ÂëºËøôÁßçËØ≠Ë®ÄÈó¥Ë∞ÉÁî®ÁöÑÂäüËÉΩÂêçÂ≠óÂèØËÉΩ‰∏çÂêå„ÄÇCommon Lisp„ÄÅHaskell„ÄÅPython„ÄÅRust Ëøô‰∫õÂè´ FFIÔºåJava Âè´ JNI Êàñ JNAÔºåËøòÊúâ‰∏Ä‰∫õÂÖ∂ÂÆÉËØ≠Ë®ÄÂè´ÁªëÂÆö Binding„ÄÇ‰∏•Ê†ºÊù•ËØ¥ÔºåFFI ‰∏é ÁªëÂÆöÔºåÊÑè‰πâÂπ∂‰∏çÁõ∏ÂêåÔºåÁªëÂÆöÂèØ‰ª•ÁêÜËß£‰∏∫ FFI ‰∏≠ÁöÑ‰∏ÄÁßçÂÆûÁé∞„ÄÇ

ÊâÄÊúâÁöÑËØ≠Ë®ÄÂú®ÁºñËØëÂêéÔºåÈÉΩ‰ºö‰ª•‰∫åËøõÂà∂ÁöÑÂΩ¢ÂºèÂéªÊâßË°åÔºåÂç≥‰ΩøÊòØÂú®ËôöÊãüÊú∫ËøêË°åÁöÑÂ≠óËäÇÁ†Å„ÄÇÂ¶ÇÊûúÁõ¥Êé•ÈÄöËøá‰∫åËøõÂà∂ËøõË°å FFIÔºåÊØïÁ´üÂ§™Â∫ïÂ±ÇÔºåÂÆûÁé∞Ëµ∑Êù•Â∞±‰ºöÂæàÂ§çÊùÇ„ÄÇ

Âõ†ËÄåÔºåABI - application binary interface Â∫îÁî®Á®ãÂ∫è‰∫åËøõÂà∂Êé•Âè£Á∫¶ÂÆöÂ∞±ÊòØ‰∏Ä‰∏™Ëß£ÂÜ≥ÊñπÊ°àÔºåÂÆö‰πâ‰∫ÜË∞ÉÁî®Á∫¶ÂÆö„ÄÅÁ±ªÂûãË°®Á§∫ÂíåÂêçÁß∞‰øÆÈ•∞„ÄÇ

Â∞ΩÁÆ°Êúâ‰∫Ü ABIÔºå‰ΩÜÊòØËøô‰∏™‰∏ñÁïå‰∏äÂèØÁî®ÁöÑËØ≠Ë®ÄÂæàÂ§öÔºåÂÆÉ‰ª¨Âπ∂‰∏çÊòØÁªü‰∏Ä‰ΩøÁî®Âêå‰∏ÄÂ•ó ABI ËßÑËåÉÔºåÂ∏∏ËßÅÁöÑËßÑËåÉÊúâ‰ª•‰∏ãËøô‰∫õÔºö

- cdecl
- syscall
- optlink
- pascal
- register
- stdcall
- fastcall
- thiscall
- winapi
- Intel ABI
- System V

Â•ΩÂú®ÔºåËÆ°ÁÆóÊú∫‰∏≠ C ËØ≠Ë®ÄÊòØÂü∫Áü≥ÔºåÂÆÉÊèê‰æõ‰∫ÜÂ§ßÈáèÁöÑ‰ª£Á†ÅÈÅó‰∫ßÔºåRust ÂèØ‰ª•Âú®ËøûÊé•Â∫ìÁöÑÂ±ÇÊ¨°‰∏é C ËØ≠Ë®ÄÁõ∏‰∫íË∞ÉÁî®„ÄÇ

‰æãÂ¶ÇÔºåË∞ÉÁî® C Ê†áÂáÜÂáΩÊï∞ÔºåRust Êèê‰æõ‰∫ÜÁõ∏Â∫îÁöÑÂÆûÁé∞ÔºåÈªòËÆ§‰ºöÈìæÊé• libc Âíå libm Ê†áÂáÜÂ∫ìÔºö

```rust,ignore
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```

ËøôÈáåÁöÑ extern "C" ‰ª£Á†ÅÂùóÂÆö‰πâ‰∫ÜÂ§ñÈÉ®ËØ≠Ë®ÄÁöÑÂáΩÊï∞ÂàóË°®ÔºåËøô‰∫õÂáΩÊï∞ÊÄªÊòØ unsafeÔºåÂÖ∂‰∏≠ "C" Ë°®Á§∫Â§ñÈÉ®Á®ãÂ∫è‰ΩøÁî®ÁöÑ ABIÔºåËøôÈáåË°®Á§∫ÁöÑÊòØ C ËØ≠Ë®ÄËßÑËåÉ„ÄÇ

Â¶ÇÊûúÔºåÈúÄË¶Å‰ªé C/C++ ËØ≠Ë®Ä‰∏≠Ë∞ÉÁî® Rust ÂáΩÊï∞ÔºåÂàôÈúÄË¶ÅÊ†áÊ≥® `#[no_mangle]`Ôºå‰ª•ÈÅøÂÖçÂáΩÊï∞Ë¢´ÊîπÂêç„ÄÇMangling ÊòØÂØπÂêëÂØπË±°ËØ≠Ë®ÄÁöÑ‰∏ÄÁßçÁ¨¶Âè∑ÈáçÂëΩÂêçÁâπÊÄßÔºåÂÉè C++ ËøôÊ†∑ÁöÑËØ≠Ë®ÄÔºåÁºñËØëÊó∂‰ºöÂ∞ÜÂØπË±°ÁöÑÊñπÊ≥ïÂêçÁß∞ËøõË°åËßÑÂàôÁöÑÁîüÂëΩÂêç„ÄÇÈáçÂëΩÂêçÂêéÔºåÊ†πÊçÆÂáΩÊï∞ÂêçÁß∞Â∞±ÂèØ‰ª•Áü•ÈÅìËøô‰∏™ÂáΩÊï∞Á≠æÂêç‰ø°ÊÅØÔºåÂ¶ÇÊúâÂá†‰∏™ÂèÇÊï∞Ôºå‰ªÄ‰πàÂèÇÊï∞Á±ªÂûãÁ≠â„ÄÇ

```rust,ignore
#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
```

Ë∞ÉÁî®ÈùûÊ†áÂáÜ C Â∫ìÂáΩÊï∞ÔºåÂàôÈúÄË¶Å‰ΩøÁî® `#[link(name = "libname")]`„ÄÇ

- `#[link(name = "libname")]` Dynamic Library
- `#[link(name = "libname", kind = "static")]` Static Library
- `#[link(name = "libname", kind = "framework")]` MacOS Framework

Âú® Rust Â∑•Á®ã‰∏≠ÂàõÂª∫ hello ÁõÆÂΩï‰Ωú‰∏∫ C Á®ãÂ∫èÔºåÁºñÂÜô hello.c ÊºîÁ§∫ÂáΩÊï∞ÔºåÁºñËØëÁîüÊàêÈìæÊé•Â∫ì hello.lib Êàñ libhelloÔºö

```rust,ignore
// fatal error LNK1107: invalid or corrupt file: cannot read at 0x8
// #include <cstdio> 
#include <stdio.h> 

typedef struct {
    unsigned char a;
    int b;
} Object;

Object add(Object it){
    it.a++;
    it.b++;
    return it;
}

int greet(int it){
    // error LNK2019: unresolved external symbol printf
    // printf("Hello %d!\n", 2);
    printf("Hello from C!\n");
    return it + 1;
}
```

ÊµãËØï‰ª£Á†Å‰ΩøÁî®Â∏¶ÂèÇÊï∞ÁöÑ printf ‰ºöÂØºËá¥Á¨¶Âè∑Â§±Ë∏™Ôºå‰ΩøÁî®ÁöÑÊòØ MinGW GCC ÁºñËØëÂô®ÔºåÊú™Áü•ÂÖ∑‰ΩìÂéüÂõ†„ÄÇ 

ÁÑ∂ÂêéÂú® Rust ‰∏ªÁ®ãÂ∫è src/main.rs ÂºïÁî®‰ª•‰∏äÁöÑ C ÂáΩÊï∞ÔºåÁºñËØëÊó∂‰ºöÂºïÁî® hello.lib Â∫ì‰∏≠ÁöÑÁ¨¶Âè∑Ôºö

```rust,ignore
use std::os::raw::c_int;

#[link(name = "hello")]
extern {
    fn add(it: RustObject) -> RustObject;
    fn greet(it: i32) -> c_int;
}

#[repr(C)]
#[derive(Debug, Clone)]
pub struct RustObject{
    a: u8,
    b: i32,
}

fn main() {
    unsafe {
        let mut it:RustObject = RustObject{a:255, b:1};
        let b = it.clone();
        println!("{:?} => {:?}", b, add(it));
        assert_eq!(2, greet(1));
    }
}
```

‰∏∫‰∫ÜÊõ¥Ëá™Âä®Âåñ‰∏ÄÁÇπÔºåÂèØ‰ª•Âú®Â∑•Á®ãÁõÆÂΩï‰∏ãÂàõÂª∫ build.rs ËÑöÊú¨Ë∞ÉÁî® C/C++ ÁºñËØëÂëΩ‰ª§ÔºåCargo ‰ºöÊâßË°åÂÆÉÔºö

```rust,ignore
use std::env;
use std::process::Command;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    println!("cargo:rustc-link-search=native={}", out_dir);
    println!("cargo:rustc-link-lib=static=hello");
 
    Command::new("cc").args(&["hello/hello.c", "-O3","-c", "-fPIC", "-o"])
        .arg(&format!("{}/hello.o", out_dir))
        .status().unwrap();
 
    Command::new("ar").args(&["crus", "libhello.a", "hello.o"])
        .current_dir(&Path::new(&out_dir))
        .status().unwrap();
}
```

ÂÖ∂‰∏≠Ôºå`OUT_DIR` ÊòØ Rust ÁºñËØëËá™Âä®ÈÖçÁΩÆÁöÑÁéØÂ¢ÉÂèòÈáèÔºåË°®Á§∫ÂΩìÂâçÁºñËØëËæìÂá∫ÁõÆÂΩïÔºåÂú® Windows Âπ≥Âè∞‰∏äÔºåÂèØ‰ª•ÂÆâË£Ö MinGW GCC ÁºñËØëÂ∑•ÂÖ∑Ôºå‰ΩøÁî® `gcc` ÂëΩ‰ª§ÊõøÊç¢ `cc` ÂëΩ‰ª§ÔºåÂ∫ìÊñá‰ª∂ËæìÂá∫ `libhello.a` ÂèØ‰ª•Áî® `hello.lib` Êõø‰ª£„ÄÇ‰πüÂèØ‰ª•‰ΩøÁî® cc crate Êèê‰æõÁöÑÁºñËØëËÉΩÂäõÔºåÂÆÉÂèØ‰ª•ÁºñËØë C/C++/assembly ÁîüÊàêÂ∫ìÊñá‰ª∂‰æõ Rust Á®ãÂ∫è‰ΩøÁî®„ÄÇ

ÈÄöËøáÊâìÂç∞Ê†áÂáÜËæìÂá∫ÔºåBuild scripts ÂèØ‰ª•‰∏é Cargo ÈÄö‰ø°ÔºåÊâìÂç∞ËæìÂá∫Ê†ºÂºèË¶ÅÊ±Ç `cargo:` ÂºÄÂ§¥Ôºö

- `cargo:rerun-if-changed=PATH` ‚Äî Tells Cargo when to re-run the script.
- `cargo:rerun-if-env-changed=VAR` ‚Äî Tells Cargo when to re-run the script.
- `cargo:rustc-link-lib=[KIND=]NAME` ‚Äî Adds a library to link, KIND can be `dylib`, `static`, or `framework`.
- `cargo:rustc-link-search=[KIND=]PATH` ‚Äî Adds to the library search path, KIND can be `dependency`, `crate`, `native`, `framework`, `all`.
- `cargo:rustc-flags=FLAGS` ‚Äî Passes certain flags to the compiler.
- `cargo:rustc-cfg=KEY[="VALUE"]` ‚Äî Enables compile-time cfg settings.
- `cargo:rustc-env=VAR=VALUE` ‚Äî Sets an environment variable.
- `cargo:rustc-cdylib-link-arg=FLAG` ‚Äî Passes custom flags to a linker for cdylib crates.
- `cargo:warning=MESSAGE` ‚Äî Displays a warning on the terminal.
- `cargo:KEY=VALUE` ‚Äî Metadata, used by links scripts.

Rust Âú® OS Ê†áÂáÜÂ∫ì std::os::raw Êèê‰æõ‰∫Ü C ËØ≠Ë®ÄÁöÑÂêÑÁßç‰∏äÁ±ªÂûãÂÆö‰πâÔºåÂèØ‰ª•Âú®Â£∞Êòé extern Êé•Âè£Êó∂‰ΩøÁî®Ôºö

- `c_char`  Á≠â‰ª∑ `char`
- `c_double`    Á≠â‰ª∑ `double`
- `c_float` Á≠â‰ª∑ `float`
- `c_int`   Á≠â‰ª∑ `signed int` (`int`)
- `c_long`  Á≠â‰ª∑ `signed long `(`long`)
- `c_longlong`  Á≠â‰ª∑ `signed long long` (`long long`)
- `c_schar` Á≠â‰ª∑ `signed char`
- `c_short` Á≠â‰ª∑ `signed short` (`short`)
- `c_uchar` Á≠â‰ª∑ `unsigned char`
- `c_uint`  Á≠â‰ª∑ `unsigned int`
- `c_ulong` Á≠â‰ª∑ `unsigned long`
- `c_ulonglong` Á≠â‰ª∑ `unsigned long long`
- `c_ushort`    Á≠â‰ª∑ `unsigned short`

Ëøò Linux/Unix/Windows Âπ≥Âè∞Â∑ÆÂºÇÁâπÊÄßÊ®°Âùó„ÄÇ

Rust ‰∏çÊîØÊåÅ C++ FFI Êó†Ê≥ïË∞ÉÁî®Á±ªÊûÑÈÄ†ÔºåÈúÄË¶ÅÁºñÂÜô C Êé•Âè£ÁöÑËΩ¨Êç¢Â±ÇÔºåÁÑ∂ÂêéÁªëÂÆö„ÄÇ


Rust ÊòØ‰∏ÄÁßçÁ•ûÂ•áÁöÑËØ≠Ë®ÄÔºåÊúâÁùÄÊõ¥Â•ΩÁöÑÁîüÊÄÅÁ≥ªÁªü„ÄÇËÆ∏Â§ö Rust ÁöÑËÆæËÆ°ÂÜ≥Á≠ñÈÉΩÈùûÂ∏∏ÈÄÇÂêàÂêëÁé∞ÊúâÁöÑ C/C++ Á≥ªÁªüÊ∑ªÂä†Êñ∞ÂäüËÉΩÔºåÊàñËÄÖÈÄêÊ≠•ÊõøÊç¢Ëøô‰∫õÁ≥ªÁªüÁöÑÈÉ®ÂàÜ„ÄÇ

ËÄåÁé∞ÊúâÁöÑ‰∏Ä‰∫õ‰ª£Á†Å‰πüÂèØ‰ª•ËøõË°å Binding ‰ª•‰ª£ Rust Ë∞ÉÁî®ÔºåÂ¶Ç OpenGL ËøôÁ±ªÁöÑ C/C++ API„ÄÇ

Êúâ‰∏Ä‰∫õ‰∏çÈîôÁöÑÂ∑•ÂÖ∑ÔºåÂÆÉ‰ª¨ÊúâÂä©‰∫éÂáèÂ∞ëÊ†∑ÊùøÔºåÂπ∂Ëá™Âä®ÂåñÂÆπÊòìÂá∫ÈîôÁöÑÁ±ªÂûãÂíåÂáΩÊï∞ÁªëÂÆöÔºåÊØîÂ¶ÇÔºö

- `bindgen` automatically generates Rust FFI bindings to C (and some C++) libraries.
- `cbindgen` creates C/C++11 headers for Rust libraries which expose a public C API.
- `cpp` rust-cpp - Embed C++ code directly in Rust.

Rust ‰∏≠‰ΩøÁî® `cpp` crate ÂÆö‰πâÁöÑ `cpp!` ÂÆèÊù•ÂµåÂÖ• C++ ‰ª£Á†ÅÔºåÂÆÉÈÄöËøáËé∑ÂèñÊâÄÊúâÁöÑÂÜÖËÅî C++ ‰ª£Á†ÅÂπ∂Â∞ÜÂÖ∂ÂÜôÂÖ•‰∏Ä‰∏™ÂçïÁã¨ÁöÑ cpp Êñá‰ª∂Êù•ÂÆûÁé∞Ëøô‰∏ÄÁÇπÔºåËØ•Êñá‰ª∂Â∞ÜË¢´ÁºñËØë‰∏∫ Rust crate ÁöÑÊúÄÁªàÁõÆÊ†á‰ª£Á†Å„ÄÇ

ÂΩìÂ∞Ü Rust Â∫ìÁªëÂÆöÂà∞ C/C++ Êó∂ÔºåÊ†∏ÂøÉÈÄªËæëÂ±ÇÂíå FFI Â±Ç‰πãÈó¥Â∫îËØ•Â≠òÂú®ÊòéÊòæÁöÑÂàÜÁ¶ª„ÄÇÂú®ÂÅöÂ•ΩÁöÑÊÉÖÂÜµ‰∏ãÔºåFFI ‰ª£Á†ÅÂ∫îËØ•‰Ωç‰∫é‰∏Ä‰∏™ÂçïÁã¨ÁöÑ crate ‰∏≠ÔºåÂõ†Ê≠§ËÆæËÆ° Rust API ‰∏ç‰ºöÂèóÂà∞ FFI ÁöÑÂ§™Â§öÂΩ±ÂìçÔºåÂπ∂‰∏îÈÄâÊã©ÂèØÂèòÊÄß‰øÆÈ•∞Á¨¶ÂèòÂæóÊõ¥Âä†ÂÆπÊòì„ÄÇ


## ‚ö° Type Layout
- Type Layout https://doc.rust-lang.org/reference/type-layout.html
- Data Representation in Rust https://doc.rust-lang.org/nomicon/data.html
- The Rustonomicon - Data Layout https://doc.rust-lang.org/nomicon/repr-rust.html
- Rust's Unsafe Code Guidelines Reference https://rust-lang.github.io/unsafe-code-guidelines/introduction.html

Á±ªÂûãÂ∏ÉÂ±Ä Type layout ÊòØÊåáÁ±ªÂûãÂú®ÂÜÖÂ≠òÂ≠òÂÇ®ÁöÑÁõ∏ÂÖ≥‰ø°ÊÅØÔºåÂåÖÊã¨‰ª•‰∏ã‰∏âÈÉ®ÂàÜÂÜÖÂÆπÔºö

- size Â§ßÂ∞èÔºåË°®Á§∫Âç†Áî®ÂÜÖÂ≠òÂ≠óËäÇÊï∞„ÄÇ
- alignment ÂØπÈΩêÔºåÁî®Â≠óËäÇÊï∞ËÆ°ÈáèÔºåÊúÄÂ∞èÂÄº‰∏∫ 1ÔºåÊåâ 2 Ê¨°ÊñπÂ¢ûÂä†ÔºåË°®Á§∫Âú®ÂÜÖÂ≠òÂú∞ÂùÄÁöÑÂºÄÂßã‰ΩçÁΩÆË¶ÅÊ±ÇÔºåÂ¶Ç u32 ‰∏∫ 4 bytes ÂØπÈΩêÔºåÂÖ∂ÂÜÖÂ≠òÂú∞ÂùÄÂ∞±Ë¶ÅÊª°Ë∂≥Êï¥Èô§‰ª• 4„ÄÇ
- relative offsets of fields Â≠óÊÆµÂÅèÁßªÔºåÁî®Êà∑ÂÆö‰πâÁ±ªÂûãÁöÑÂ≠óÊÆµÔºåÂ¶ÇÊûúËøûÁª≠‰øùÂ≠òÊª°Ë∂≥‰∏ç‰∫ÜÂØπÈΩêÈúÄÊ±ÇÔºåÂàôÈúÄË¶Å‰∏Ä‰∏™ÂÅèÁßª„ÄÇ

ÊâÄÊúâÂéüÂßãÂÄºÁ±ªÂûãÈÉΩÊòØ `Sized` Á±ªÂûãÔºåÂç≥Âõ∫ÂÆöÂ§ßÂ∞èÔºå‰ΩøÁî® std::mem::size_of/size_of_val ÊñπÊ≥ïÂèØ‰ª•Ëé∑ÂèñÂÖ∂Â≠óËäÇÊï∞Ôºö

    |     Type    | size_of::<Type>() |
    |-------------|-------------------|
    | bool        |                 1 |
    | u8 / i8     |                 1 |
    | u16 / i16   |                 2 |
    | u32 / i32   |                 4 |
    | u64 / i64   |                 8 |
    | u128 / i128 |                16 |
    | f32         |                 4 |
    | f64         |                 8 |
    | char        |                 4 |

ËÄå `usize` and `isize` Ëøô‰∏§‰∏™ÁâπÊÆä‰∏ÄÁÇπÔºåÂíåÁ®ãÂ∫èËøêË°åÊú∫Âô®ÁöÑÊúÄÂ§ßÂØªÂùÄËÉΩÂäõÁõ∏ÂÖ≥ÔºåÂ¶Ç 32 bit Á≥ªÁªüÂ∞±ÊòØ 4 bytesÔºåËÄåÂú® 64 bit Á≥ªÁªü‰∏äÂ∞±ÊòØ 8 bytes„ÄÇ

Rust Êèê‰æõ‰∫Ü‰ª•‰∏ãÁªÑÂêàÁ±ªÂûãÔºö

- structs (named product types)
- tuples (anonymous product types)
- arrays (homogeneous product types)
- enums (named sum types -- tagged unions)
- unions (untagged unions)

Âõ∫ÂÆöÁ±ªÂûã‰∏≠ÔºåÊúâ‰∏ÄÁßçÁâπÊÆäÊÉÖÂΩ¢ÔºåÂ∞±ÊòØÈõ∂Â§ßÂ∞èÁ±ªÂûã ZST - Zero Sized TypesÔºö

```rust,ignore
enum Void {} // Empty Type

struct Nothing; // No fields = no size

// All fields have no size = no size
struct LotsOfNothing {
    foo: Nothing,
    qux: (),      // empty tuple has no size
    baz: [u8; 0], // empty array has no size
}
```

ÊâÄÊúâÈùû `Sized` Á±ªÂûãÈÉΩÊòØ DST - Dynamically Sized TypesÔºåÂèØ‰ª•‰ΩøÁî® `?Sized` Ë°®Á§∫„ÄÇ

Rust Êèê‰æõ‰ª•‰∏ã‰∏§Áßç DST Á±ªÂûãÔºö

- Trait ObjectsÔºåÂ¶Ç `dyn MyTrait`„ÄÇ
- ÂàáÁâáÁ±ªÂûãÔºåÂ¶Ç `[T]`, `str` Á≠â„ÄÇ

‰ΩøÁî® std::mem::align_of/align_of_val ÊñπÊ≥ïÂèØ‰ª•Ëé∑ÂèñÂêÑÁßçÁ±ªÂûãÁöÑÂØπÈΩêÂ≠óËäÇÊï∞ÔºåÂ§ßÂ§öÊï∞ÂéüÂßãÂÄºÁ±ªÂûãÈÉΩÊåâÂÆÉ‰ª¨ÁöÑÂ§ßÂ∞èÂØπÈΩêÔºåËøôÊòØÁ≥ªÁªüË°å‰∏∫„ÄÇÁâπÂà´Âú∞ÔºåÂú® x86 Á≥ªÁªüÔºåu64 Âíå f64 Êåâ 32 bits Âç≥ 4 Â≠óËäÇÂØπÈΩê„ÄÇ

Áé∞‰ª£ËÆ°ÁÆóÊú∫ÂÜÖÂ≠òÁ©∫Èó¥‰ª•Â≠óËäÇ‰∏∫Âü∫Êú¨Âçï‰ΩçÔºåÁêÜËÆ∫‰∏äÂèØ‰ª•‰ªé‰ªª‰ΩïÂú∞ÂùÄÂºÄÂßãËÆøÈóÆÊï∞ÊçÆÔºå‰ΩÜÂÆûÈôÖËÄÉËôëËØªÂÜôÊïàÁéáÔºåÂú®ËÆøÈóÆÁâπÂÆöÁ±ªÂûãÂèòÈáèÁöÑÊó∂ÂÄôÁªèÂ∏∏Âú®ÁâπÂÆöÁöÑÂÜÖÂ≠òÂú∞ÂùÄËÆøÈóÆÔºåËøôÂ∞±ÈúÄË¶ÅÂêÑÁßçÁ±ªÂûãÊï∞ÊçÆÊåâÁÖß‰∏ÄÂÆöÁöÑËßÑÂàôÂú®Á©∫Èó¥‰∏äÊéíÂàóÔºåËÄå‰∏çÊòØÈ°∫Â∫èÁöÑ‰∏Ä‰∏™Êé•‰∏Ä‰∏™ÁöÑÊéíÊîæÔºåËøôÂ∞±ÊòØÂØπÈΩê„ÄÇ

ÂÖ∂ÂÆÉ‰∏Ä‰∫õÁ±ªÂûãÂ∏ÉÂ±ÄÔºö

- ÊåáÈíàÂíåÂºïÁî®ÊúâÁõ∏ÂêåÁöÑÂ∏ÉÂ±ÄÔºåÂºïÁî®Âõ∫ÂÆöÂ§ßÂ∞èÁ±ªÂûãÔºåÂàôÂ∏ÉÂ±ÄÁ≠âÂêå‰∫é usize„ÄÇÂºïÁî® DST Á±ªÂûãÔºåÂàôÂ∏ÉÂ±ÄÊòØ usize ÁöÑÂèåÂÄçÂ§ßÂ∞èÔºåÂç≥ËÉñÊåáÈíà„ÄÇ
- Array Layout Êï∞ÁªÑÂÖÉÁ¥†ÂÖ∑ÊúâÁõ∏ÂêåÁ±ªÂûãÔºåÂØπ‰∫éÊï∞ÁªÑ [T; n] Â§ßÂ∞è‰∏∫ size_of::<T>() * nÔºåÂØπÈΩêÁ≠âÂêå T„ÄÇ
- Slice Layout ÂàáÁâáÁ±ªÂûãÂ∏ÉÂ±ÄÁ≠âÂêåÊï∞ÁªÑÂàáÁâáÈÉ®ÂàÜÔºåÊ≥®ÊÑèÊòØÂÄºÁ±ªÂûã [T] ‰∏çÊòØÂºïÁî® &[T], Box<[T]>...
- str Layout Â≠óÁ¨¶‰∏≤ÂàáÁâáÊòØ UTF-8 Â≠óÁ¨¶‰∏≤ÔºåÊï∞ÊçÆÁ±ªÂûãÊòØ [u8]ÔºåÊØè‰∏™ÂÖÉÁ¥†ÁöÑÊï∞ÊçÆÁ±ªÂûã‰∏∫ u8ÔºåÊâÄ‰ª•Á±ªÂûãÂ∏ÉÂ±Ä‰πüÁ≠âÂêå u8„ÄÇ
- Tuple Layout Êó†ÁªÑÁ±ªÂûãÊ≤°ÊúâÂ∏ÉÂ±ÄËßÑÂàô‰øùËØÅÔºåÈô§Âçï‰ΩçÂÖÉÁªÑ `()` Â§ñÔºåÂÆÉÊòØ Zero-sized Á±ªÂûãÔºåÂØπÈΩê‰∏∫ 1 Â≠óËäÇ„ÄÇ
- Trait Object Layout Á≠âÂêå Trait ÂØπË±°ÂÄºÊú¨Ë∫´ÔºåÊ≥®ÊÑèÊòØÂØπË±°‰∏çÊòØÂºïÁî® (`&dyn Trait`, `Box<dyn Trait>`, etc.)„ÄÇ
- Closure Layout Èó≠ÂåÖÊ≤°ÊúâÂ∏ÉÂ±ÄËßÑÂàô‰øùËØÅ„ÄÇ

ÊâÄÊúâÁî®Êà∑ÂÆö‰πâÁ±ªÂûã structs, enums, unions ÂèØ‰ª•ÈÄöËøá Data Representation Êï∞ÊçÆË°®ËææÊù•ÊåáÂÆöÁ±ªÂûãÂ∏ÉÂ±ÄÔºåÊúâÂõõÁ±ªÂ∏ÉÂ±ÄË°®ËææÔºö

- ÈªòËÆ§ÁöÑ Rust Êï∞ÊçÆË°®ËææÔºå‰∏ç‰ΩøÁî® repr Ê†áÊ≥®„ÄÇ
- ÂÖºÂÆπ C ËØ≠Ë®ÄÁöÑÊï∞ÊçÆË°®Ëææ `#[repr(C)]`
- ÂéüÂßãÁ±ªÂûãË°®ËææÔºåÂ¶Ç `#[repr(usize)]`„ÄÇ
- ÈÄèÊòéË°®Ëææ `#[repr(transparent)]` Âè™ÊúâÂçï‰∏™ÈùûÈõ∂Â§ßÂ∞èÂ≠óÊÆµÁöÑ struct Êàñ enum ‰ΩøÁî®ÔºåÊàñËÄÖÂØπÈΩê‰∏∫ 1 Â≠óËäÇÁöÑ Zero-sized Â≠óÊÆµÔºåÂ¶Ç PhantomData<T>„ÄÇ

ÂÖ∂‰∏≠ÔºåC Êï∞ÊçÆË°®ËææÂºïÂÖ•ÁöÑÁõÆÁöÑÊúâ‰∏§‰∏™Ôºö‰∏ÄÊòØ‰∏∫‰∫ÜÂíå C ËØ≠Ë®Ä‰∫§‰∫íÔºå‰∫åÊòØÂàõÂª∫Á±ªÂûãÔºå‰ª•Âú®Ëøô‰∫õÁ±ªÂûã‰∏äÂèØÈù†Âú∞ÊâßË°å‰æùËµñ‰∫éÊï∞ÊçÆÂ∏ÉÂ±ÄÁöÑÊìç‰ΩúÔºå‰æãÂ¶ÇÂ∞ÜÂÄºÈáçÊñ∞Ëß£Èáä‰∏∫‰∏çÂêåÁöÑÁ±ªÂûã„ÄÇ

ÈÄöËøáÊåáÂÆö align„ÄÅpacked Êù•Êä¨Âçá„ÄÅÈôç‰Ωé structs Âíå unions ÁöÑÂØπÈΩêÔºåpacked ËøòÂèØ‰ª•ÂèòÊõ¥Â≠óÊÆµÈó¥ÁöÑÂ°´ÂÖÖ„ÄÇÂØπ‰∫é‰∏Ä‰∏™Áî®Êà∑ÂÆö‰πâÁ±ªÂûãÔºåÂØπÈΩêÂèñÂÄº‰∫éÂç†Áî®Â≠óËäÇÊúÄÂ§ßÁöÑÂ≠óÊÆµÔºåÂ¶ÇÊûú align ÊåáÂÆö‰∫Ü‰∏Ä‰∏™Â∞è‰∫éÂÆûÂÆûÈôÖÂØπÈΩêÁöÑÂÄºÔºåÂàôÊó†Êïà„ÄÇÂ¶ÇÊûú packed ÊåáÂÆöÁöÑÂÄºÂ§ß‰∫éÂÆûÈôÖÂØπÈΩêÂÄºÔºåÂàôÊó†Êïà„ÄÇalign Âíå packed Âè™ÂèØ‰ª•Áî®‰∫éÈªòËÆ§ÁöÑ Rust Êï∞ÊçÆË°®ËææÂíå C ËØ≠Ë®ÄÊï∞ÊçÆË°®Ëææ„ÄÇ

ÈÄöËøá `#[repr(align(x))]` or `#[repr(packed(x))]` ÊåáÂÆöÂÖ∑‰ΩìÂÄºÔºå‰∏îÂèñÂÄºËåÉÂõ¥ [1, 2^29]„ÄÇÂØπ‰∫é packed ÊåáÂÆöÊñπÂºèÔºåÂèØ‰ª•ÁúÅÁï•Êï∞ÂÄºË°®Á§∫ 1 Â≠óËäÇÂØπÈΩê `#[repr(packed)]`„ÄÇ


ÊåáÂÆö union Á±ªÂûãÁöÑÊï∞ÊçÆË°®ËææÔºö

```rust,ignore
#[repr(C)]
union Union {
    f1: u16,
    f2: [u8; 4],
}

assert_eq!(std::mem::size_of::<Union>(), 4);  // From f2
assert_eq!(std::mem::align_of::<Union>(), 2); // From f1

#[repr(C)]
union SizeRoundedUp {
   a: u32,
   b: [u16; 3],
}

assert_eq!(std::mem::size_of::<SizeRoundedUp>(), 8);  // Size of 6 from b,
                                                      // rounded up to 8 from
                                                      // alignment of a.
assert_eq!(std::mem::align_of::<SizeRoundedUp>(), 4); // From a
```

ÂèØ‰ª•ÁªÑÂêà C ÂíåÂéüÂßãÁ±ªÂûãÊï∞ÊçÆË°®ËææÔºö

```rust,ignore
enum EnumDefault {
    Variant0(u8),
    Variant1,
}

#[repr(C)]
enum EnumC {
    Variant0(u8),
    Variant1,
}

#[repr(C, u8)]
enum Enum8 {
    Variant0(u8),
    Variant1,
}

#[repr(C, u16)]
enum Enum16 {
    Variant0(u8),
    Variant1,
}

// One byte for Variant0 and one byte for Variant1
assert_eq!(std::mem::size_of::<EnumDefault>(), 2);
// The size of the C representation is platform dependant
assert_eq!(std::mem::size_of::<EnumC>(), 8);
// One byte for the discriminant and one byte for the value in Enum8::Variant0
assert_eq!(std::mem::size_of::<Enum8>(), 2);
// Two bytes for the discriminant and one byte for the value in Enum16::Variant0
// plus one byte of padding.
assert_eq!(std::mem::size_of::<Enum16>(), 4);
```

ÂØπ‰∫éÂêå‰∏Ä‰∏™ÁªìÊûÑ‰ΩìÔºåC Êï∞ÊçÆË°®ËææÂíå Rust ÈªòËÆ§Êï∞ÊçÆË°®ËææÂ∑ÆÂà´Âú®‰∫éÔºåÂâçËÄÖÁ±ªÂûãÂ∏ÉÂ±ÄÊòØÊåâÂ≠óÊÆµÈ°∫Â∫è‰øùÂ≠òÁöÑÔºåÂêéËÄÖÂàô‰ºöË∞ÉÊï¥Â≠óÊÆµÈ°∫Â∫èËøõË°å‰ºòÂåñÂáèÂ∞èÂÜÖÂ≠òÔºö

```rust,ignore
#[repr(C)]
pub struct RustObject{
    a: i8,
    b: i8,
    c: i32,
    d: i32,
}

let o = RustObject{a:1, b:2, c:3, d:4}; 
assert!(12, std::mem::size_of_val(&o));
//                         #[repr(C)]       Default
println!("{:p}", &o);   // 0x8d8358f6d8     0x70a66ff8c8
println!("{:p}", &o.a); // 0x8d8358f6d8     0x70a66ff8d0
println!("{:p}", &o.b); // 0x8d8358f6d9     0x70a66ff8d1
println!("{:p}", &o.c); // 0x8d8358f6dc     0x70a66ff8c8
println!("{:p}", &o.d); // 0x8d8358f6e0     0x70a66ff8cc
```

ÂØπ‰∫éÂêåÊ†∑ÁöÑÁ±ªÂûãÔºåÂÖ∂Â§ßÂ∞èÂíåÂØπÈΩêÈÉΩÊòØ‰∏ÄÊ†∑ÁöÑÔºå‰ª•‰∏äÁöÑÁªìÊûÑ‰ΩìÊåâÊúÄÂ§ßÁöÑÂ≠óÊÆµ i32 Âç≥ 4 Â≠óËäÇÂØπÈΩêÔºå‰∏§‰∏™ i8 Á±ªÂûãÂ≠óÊÆµ roundup ‰∏∫‰∏Ä‰∏™ i32ÔºåÊâÄ‰ª•Êï¥‰∏™ÁªìÊûÑ‰ΩìÂ§ßÂ∞è‰∏∫ 12 bytesÔºå‰ΩÜÊòØ i8 Êï∞ÊçÆÁ±ªÂûãÊú¨Ë∫´Êåâ 1 Â≠óËäÇËøõË°åÂØπÈΩê„ÄÇ

ÂèØ‰ª•ËßÇÂØüÂà∞ÔºåÂú® `#[repr(C)]` ÊñπÂºè‰∏≠ÔºåÂ≠óÊÆµ b Âà∞ c ÁöÑÈó¥ÈöîÊòØ 3 ‰∏™Â≠óËäÇÔºåi8 Êú¨Ë∫´Âç† 1 ‰∏Ä‰∏™Â≠óËäÇÔºåËÄåÂè¶Â§ñ 2 ‰∏™Â≠óËäÇÂ∞±ÊòØÂ≠óÊÆµ c ÁöÑÂÅèÁßªÔºåËøôÊòØ‰∏∫‰∫ÜÁ°Æ‰øù i32 Á±ªÂûãÂ≠óÊÆµÂØπÈΩêÂà∞ 4 Â≠óËäÇÁöÑÂÜÖÂ≠òÂú∞ÂùÄ‰∏ä„ÄÇ

ÂÅèÁßªËÆ°ÁÆóËßÑÂàôÊòØÊåâÂ≠óÊÆµÈ°∫Â∫èËÆ°ÁÆóÁöÑÔºåÈ¶ñÂÖàÔºåÂàùÂßãÂÅèÁßª‰∏∫ 0ÔºåÂÖàÁ°ÆÂÆöÂΩìÂâçÂ≠óÊÆµÁöÑÂ§ßÂ∞èÂíåÂØπÈΩêÔºåÂ¶ÇÊûúÂΩìÂâçÂÅèÁßª‰∏çÊòØÂΩìÂâçÂ≠óÊÆµÂØπÈΩêÁöÑÊï¥Êï∞ÂÄçÔºåÂàôÂ°´ÂÖÖÂ≠óËäÇ‰ΩøÂÖ∂‰∏∫Êï¥Êï∞ÂÄç„ÄÇÂ°´ÂÖÖÂ≠óËäÇÊï∞ÊçÆÁ¥ØÂä†Âà∞ÂÅèÁßªÂÄº‰∏äÔºåÈÇ£‰πàÂΩìÂâçÁöÑÂÅèÁßªÂÄºÂ∞±ÊòØÂΩìÂâçÂ≠óÊÆµÁöÑÂÅèÁßªÂÄºÔºåÁÑ∂ÂêéÂ∞ÜÂΩìÂâçÂ≠óÊÆµÁöÑÂ§ßÂ∞èÁ¥ØÂä†Âà∞ÂÅèÁßªÂÄº‰∏äÔºåÂÖ∂ÂÆÉÂ≠óÊÆµ‰æùÊ†∑Â§ÑÁêÜ„ÄÇ


## ‚ö° Advanced traits
- Traits Defining Shared Behavior https://doc.rust-lang.org/book/ch10-02-traits.html
- Advanced Traits https://doc.rust-lang.org/book/ch19-03-advanced-traits.html
- The Iterator Trait and The Next Method https://doc.rust-lang.org/book/ch13-02-iterators.html

ÈÄâÊù•ÁúãËø≠‰ª£Âô® Trait ÁöÑÂÆö‰πâÔºö

```rust,ignore
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

ËøôÈáåÁöÑ Item ÊòØ‰ªÄ‰πàÁ±ªÂûãÂë¢Ôºü‰∏çÁü•ÈÅìÔºåÂõ†‰∏∫Ê≤°ÊúâÂäûÊ≥ïÊòØ‰ªÄ‰πàÁ±ªÂûãÂú®‰ΩøÁî®Ëø≠‰ª£Âô®ÔºåËøô‰∏™Á±ªÂûãÂ∞±Âè´‰Ωú Associated typesÔºåÂá∫Áé∞Âú®Ëøô‰∏™‰ΩçÁΩÆÂ∞±Âè´ÂÅöÂç†‰ΩçÔºå‰πüÂè™ÂèØ‰ª•Âè´‰Ωú placeholder type„ÄÇÂ∞±ÊòØÂÖàÂç†‰∏™Á±ªÂûã‰ΩçÁΩÆÔºåÁ≠âÂà∞ÂÖ∑‰ΩìÁ±ªÂûãË∞ÉÁî®Êó∂Â∞±Áî®ÂÆûÁé∞ÁöÑÁ±ªÂûãÂ°´ËøõÊù•„ÄÇÊâÄ‰ª•Áé∞Âú®‰∏çÈúÄË¶ÅÂÖ≥ÂøÉÂÆÉÂÖ∑‰ΩìÊòØ‰ªÄ‰πàÁ±ªÂûãÔºåË∞ÉÁî® `next()` ÊñπÊ≥ïÂêéÔºåÈÄöËøá Option Êûö‰∏æÁ±ªÂûãÂåÖË£ÖÂÖ∑‰ΩìÁöÑÂÄº„ÄÇ

‰ΩøÁî®Ê≥õÂûãÂèÇÊï∞ÔºåÂèØ‰ª•ÁªôËøô‰∏™Ê≥õÂûãËÆæÁΩÆÈªòËÆ§Á±ªÂûãÔºåÂèÇËÄÉÂ¶ÇÂÜÖÁΩÆÁöÑ + Êìç‰ΩúËøêË°åÁ¨¶Âè∑ÂÆö‰πâÔºö

```rust,ignore
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```
Rhs Ë°®Á§∫ Right hand sideÔºåÂç≥Âè≥ÂÄºÁ±ªÂûãÔºåËøô‰∏™Ê†ºÂºè `<T=SomeType>` ‰πüÂè´ÂÅö default type parameters„ÄÇ

‰ª•‰∏ãÁ§∫ËåÉÂÆûÁé∞ Millimeters + Meters ËøêÁÆóÔºö

```rust,ignore
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
assert_eq!((Millimeters(1000) + Meters(1001)).0, 1002000);
dbg!((Millimeters(1000) + Meters(1001)).0);
```

ÈªòËÆ§Á±ªÂûãÂèÇÊï∞‰∏ªË¶ÅÁöÑÁî®ÈÄîÔºö

- Êâ©Â±ïÁ±ªÂûãËÄåÊó†ÈúÄÁ†¥ÂùèÁé∞Êúâ‰ª£Á†ÅÔºõ
- ÂÆöÂà∂ÈùûÂ∏∏Áî®ÁöÑÁâπÊÆäÂäüËÉΩÔºõ

```rust,ignore
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> &'static str;
}

impl Add<Self> for bool {
    type Output = bool;
    fn add(self, other: Self) -> &'static str {
        if self && other { "TT" } else { "FF" } 
    }
}
println!("Boolean + {}", true.add( true));
```

Rust ÂÖÅËÆ∏ÂØπË±°ÂÆûÁé∞Â§ö‰∏™ Trait ‰∏îÂÆÉ‰ª¨ÊúâÁõ∏ÂêåÁöÑÊñπÊ≥ïÂÆö‰πâÔºåÂêåÊó∂‰πüÊèê‰æõ‰∫ÜÊ∂àÈô§Ê≠ß‰πâÁöÑË∞ÉÁî®ËØ≠Ê≥ïÔºåÂêåÊó∂Â§öÊÄÅÊú∫Âà∂‰πüÂÆåÂÖ®‰ΩìÁé∞Âú®Á±ªÂûãÂ£∞Êòé‰∏≠Ôºö

```rust,ignore
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}

let person = Human;
person.fly();           // Human fly()
Pilot::fly(&person);    // Pilot fly()
Wizard::fly(&person);   // Wizard fly()

wizard_fly(&person);
pilot_fly(&person);

fn wizard_fly(it: &impl Wizard) {
    it.fly();
}
fn pilot_fly(it: &dyn Pilot) {
    it.fly();
}
```

ÂÜçÊé•ÁùÄ‰∏äÈù¢ÁöÑ‰æãÂ≠êÊâ©Â±ïÔºö

```rust,ignore
trait Super: Pilot + Wizard { }

impl Super for Human {}

fn super_fly(it: &dyn Super) {
    // multiple applicable items in scope
    // it.fly(); it can't fly
}
```
Â¶ÇÊûú‰∏∫ Human ÂÆûÁé∞‰∏Ä‰∏™ Super Trait ÂÆÉÂêåÊó∂ÁªßÊâø Pilot + WizardÔºåÈÇ£‰πàÂÜçÈÄöËøá Super Ë∞ÉÁî® `fly()` ÊñπÊ≥ïÂ∞±‰∏çË°å‰∫ÜÔºåÂõ†‰∏∫Ê≠ß‰πâÊ∂àÈô§‰∏ç‰∫ÜÔºåÁºñËØëÂô®‰∏çÁü•ÈÅìË¶ÅÊâßË°åÂì™‰∏™ÊñπÊ≥ï„ÄÇ

Â¶ÇÊûúÔºåÂ§öÊÄÅÂàÜÊ≠ßÂèëÁîüÂú®ÈùôÊÄÅÊñπÊ≥ï‰∏≠ÔºåÈÇ£‰πàÂ∞±ÈúÄË¶ÅÂØπÁ±ªÂûã‰ΩúÊ≥õÂûãËΩ¨Êç¢Ê≥®Ëß£Ôºö

```rust,ignore
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

println!("A baby dog is called a {}", Dog::baby_name());
println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
```

Âõ†‰∏∫ Trait ÊòØ‰∏çËÉΩ‰Ωú‰∏∫ÂÖ∑‰ΩìÁ±ªÂûãÊù•ÊâßË°åÊñπÊ≥ïÁöÑÔºåÂ¶Ç `Animal::baby_name()` ËøôÁßçË°å‰∏∫ÊòØ‰∏çËÉΩÂÆûÁé∞ÁöÑÔºåÂÆûÁé∞ Animal ÁöÑÁ±ªÂûãÂèØ‰ª•Êúâ‰∏ÄÂ§ßÂ†ÜÔºåËøôÁßçËØ≠Ê≥ïÁªìÊûÑÊó†Ê≥ïËÆ©ÁºñËØëÂô®Áü•ÈÅìÂú®Ë∞ÉÁî®ÊñπÊ≥ï„ÄÇ

Á±ªÂûãÊ≥®Ëß£ËØ≠Ê≥ïÊ†ºÂºèÂ¶Ç‰∏ãÔºö

    <Type as Trait>::function(receiver_if_method, next_arg, ...);

Trait ÁöÑÁªßÊâøÂÖ≥Á≥ªÂèØ‰ª•Â∞ÜÂÖ∂ÂÆÉ Trait Ë°å‰∏∫ÂºïÁî®ËøáÊù•ÔºåÂåÖÂê´ÂÖ∂ÂÆÉ Trait ÂäüËÉΩÁöÑ‰πüÂè´ÂÅö Supertraits„ÄÇ

Âú®ÂÆòÊñπÊñáÊ°£‰∏≠Âπ∂Ê≤°ÊúâÁî®ÁªßÊâøËøô‰∏™ËØçÂéªÊèèËø∞ÔºåËøô‰∏™ËØç‰πü‰∏çÊÅ∞ÂΩìÔºåÂõ†‰∏∫ Trait ÁöÑËøôÁßçÂÖ≥ËÅîÊòØ‰∏ÄÁßçÁªÑÂêàÁ∫¶ÊùüÔºåÂπ∂‰∏çÂÉè C++ ÈÇ£Ê†∑ÁöÑÁ±ªÂûã‰πãÈó¥ÁöÑÁªßÊâøÔºö

```rust,ignore
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

impl OutlinePrint for Point {}

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

Point{ x:0, y:0 }.outline_print();
```

ÂâçÈù¢Ëß£ÊûêÈáçËΩΩÊó∂ÔºåÊèêÂà∞‰∏çÂèØ‰ª•‰∏∫Á¨¨‰∏âÊñπ Crate ÂÆûÁé∞Á¨¨‰∏âÊñπÁöÑ TraitÔºåËøôÈÅøÂÖç‰∫Ü‰æµÂÖ•Âºè‰ª£Á†ÅÊù•Á†¥ÂùèÁé∞ÊúâÁöÑ‰ª£Á†Å„ÄÇ

‰ΩÜÊòØÔºåÊúâÊó∂ÂÄôÁ¨¨‰∏âÊñπÊèê‰æõÁöÑÂØπË±°ÂäüËÉΩÁ°ÆÂÆûÈúÄË¶ÅËøõË°å‰øÆÊîπ‰ª•ÈÄÇÂ∫îÈúÄË¶ÅÔºå‰æãÂ¶Ç Rust Âπ∂Ê≤°ÊúâÊèê‰æõ Vec[T] Á±ªÂûãÁöÑ Display ÂäüËÉΩ„ÄÇ

ËøôÂ∞±ÈúÄË¶ÅÂèòÈÄöÁöÑÊñπÊ≥ïÊù•ÁÆóÊòØÔºåÂèØ‰ª•ÂºïÂÖ• Newtype ËøôÁßçÁ±ªÂûãÂåÖË£ÖÊäÄÊúØÔºåÂÆÉÊ∫ê‰∫é Haskell ÁºñÁ®ãËØ≠Ë®ÄÔºå‰ΩøÁî®Ê≠§Ê®°Âºè‰∏ç‰ºöÂØπËøêË°åÊó∂ÊÄßËÉΩÈÄ†Êàê‰ªª‰ΩïÊçüÂ§±ÔºåÂπ∂‰∏îÂú®ÁºñËØëÊó∂Â∞ÜÁúÅÁï•ÂåÖË£ÖÂô®Á±ªÂûã„ÄÇ

```rust,ignore
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

let w = Wrapper(vec![String::from("hello"), String::from("world")]);
println!("w = {}", w);
```


## ‚ö° Advanced types
- Dynamically Sized Types and the Sized Trait https://doc.rust-lang.org/book/ch19-04-advanced-types.html
- Rc - Reference Counted https://doc.rust-lang.org/stable/std/rc/index.html
- Box - heap allocation https://doc.rust-lang.org/stable/std/boxed/index.html

The Never Type that Never Returns Ê∞∏Ëøú‰∏çËøîÂõûÁöÑÁ±ªÂûãÔºÅ

Rust ÊúÄÁâπÊÆäÁöÑÁ±ªÂûãÂ§ßÊ¶ÇÊòØ Never `!` ËÆ∞‰∏çËøîÂõûÁ±ªÂûãÔºåËøô‰∏™Ë¶ÅÊ¶ÇÂøµÊ∫êËá™ lingo Á±ªÂûãÁêÜËÆ∫ÔºåÂÆÉÊòØ‰∏Ä‰∏™Ê≤°ÊúâÂÄºÁöÑÁ±ªÂûãÔºåÂú® TypeScript Ëøô‰∫õÁé∞‰ª£ËØ≠Ë®Ä‰∏≠‰πüÊúâ„ÄÇ

‰∏Ä‰∏™ËøîÂõû Never Á±ªÂûãÁöÑÂáΩÊï∞ÂÆö‰πâÁ§∫ËåÉÔºö

```rust,ignore
fn bar() -> ! {
    // --snip--
}
```

Ëøô‰∏™‰ª£Á†ÅÁöÑÊÑèÊÄùÂ∞±ÊòØ‰∏Ä‰∏™ËøîÂõû Never ÁöÑ `bar()` ÂáΩÊï∞ÔºåÊ∞∏‰∏çËøîÂõûÁöÑÂáΩÊï∞Âè´ÂÅöÂèëÊï£ÂáΩÊï∞ diverging functionsÔºåÁî®ÊÑüÂèπÂè∑Ë°®Á§∫Âõ†‰∏∫ÂÆÉÊ≤°ÊúâÂÄº„ÄÇ

Êó†ÈôêÂæ™ÁéØÁöÑÂáΩÊï∞‰Ωì‰πüÊó†Ê≥ïËøîÂõûÂÄºÔºåÂç≥ËøîÂõû never„ÄÇ

ÂõûÂà∞ÂàöÂºÄÂßãÁöÑÁåúÊï∞Â≠óÊ∏∏ÊàèÔºåÂÖ∂‰∏≠ÈÄöËøá `math` ÂåπÈÖçËæìÂÖ•ÂÄºÁöÑËØ≠Âè•‰∏≠Â∞±Ê∂âÂèä‰∫Ü Never Á±ªÂûãÔºö

```rust,ignore
let guess: u32 = match guess.trim().parse() {
  Ok(num) => num,
  Err(_) => continue,
};
```

ÂÖ∂‰∏≠Ôºåcontinue Áõ¥Êé•ÊéßÂà∂‰∫ÜÊµÅÁ®ãË∑≥ËΩ¨ÔºåÊâÄ‰ª•ÈÄöËøá `parse()` ÂáΩÊï∞Ëß£ÊûêÁöÑÂÄºÂπ∂Ê≤°ÊúâËøîÂõûÁªô guess ÂèòÈáèÔºåËøôÂ∞±ÊòØ Never Á±ªÂûã„ÄÇÂ¶ÇÊûúÂ∞Ü continue ÊõøÊç¢ÊàêÂÖ∂ÂÆÉÊï∞ÊçÆÁ±ªÂûãËøîÂõûÂàô‰∏çË°åÔºåÂõ†‰∏∫ guess ÂÆö‰πâÁöÑÊòØ u32 Êï∞ÂÄºÁ±ªÂûã„ÄÇÂç≥ `match` ÂøÖÈúÄËøîÂõûÂêå‰∏ÄÁ±ªÂûãÔºåÂπ∂‰∏î `impl trait` ËøôÊ†∑ÁöÑËØ≠Ê≥ïÊó†Ê≥ïÂú®ËøôÁßçËØ≠Â¢É‰∏≠‰ΩøÁî®„ÄÇ

Never Á±ªÂûãÈÄöÂ∏∏Âíå `panic!` ÂÆè‰∏ÄËµ∑‰ΩøÁî®ÔºåOption<T> ÁöÑ `unwrap()` ÊñπÊ≥ïÂ∞±‰ΩøÁî®‰∫ÜÂÆÉ‰ª¨Ôºö

```rust,ignore
impl<T> Option<T> {
    pub fn unwrap(self) -> T {
        match self {
            Some(val) => val,
            None => panic!("called `Option::unwrap()` on a `None` value"),
        }
    }
}
```
Â¶ÇÊûúÂØπ‰∏Ä‰∏™ None ÂÄºÊâßË°å `unwrap()` Â∞±‰ºöÂØºËá¥Á®ãÂ∫è‰∏çÁü•ÈÅìËØ•ÊÄé‰πàËµ∞‰∏ã‰∏ÄÊ≠•ÁöÑÁä∂ÂÜµ„ÄÇ


Creating Type Synonyms with Type Aliases

‰ΩøÁî®Á±ªÂûãÂà´Âêç‰ª•ÂáèÂ∞ëÈáçÂ§ç‰ª£Á†ÅÔºåËøôÊòØÁ±ªÂûãÂà´ÂêçÁöÑ‰∏ªË¶ÅÁî®ÈÄîÔºö

```rust,ignore
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!("x + y = {}", x + y);
```

‰ª•‰∏äÂè™ÊòØÊºîÁ§∫Â¶Ç‰Ωï‰ΩøÁî®Âà´ÂêçÔºåËÄÉËôë‰ª•‰∏ãËøôÊ†∑ÁöÑÁ±ªÂûãÔºö

    Box<dyn Fn() + Send + 'static>

Â¶ÇÊûúÊØè‰∏ÄË°å‰ª£Á†ÅÈÉΩÈúÄË¶ÅËøô‰∏™Á±ªÂûãÔºåÈÇ£‰πàÂÆö‰πâÂà´ÂêçÂ∞±ÊòØ‰∏™Â•Ω‰∏ªÊÑèÔºö

```rust,ignore
type Thunk = Box<dyn Fn() + Send + 'static>;

let f: Thunk = Box::new(|| println!("hi"));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -> Thunk {
    // --snip--
}
```

Âú® Rust ÂÜÖÈÉ®ÔºåÂáΩÊï∞ËøîÂõûÂÄº‰ΩøÁî®ÁöÑÊòØ `Result<T, E>` Êûö‰∏æÁ±ªÂûãÔºåÂú® std::io Ê®°Âùó‰∏≠ÔºåÊ≥õÂûãÂèÇÊï∞ E ÊòØÊåá std::io::ErrorÔºåÈÇ£‰πàÂú®‰ΩøÁî® io ÂáΩÊï∞Êó∂Â∞±ÂèØ‰ª•ÂÆö‰πâÁ±ªÂûãÂà´ÂêçÊù•ÁÆÄÂåñ‰ª£Á†ÅÔºö

```rust,ignore
type Result<T> = std::result::Result<T, std::io::Error>;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}
```

Âä®ÊÄÅÂ§ßÂ∞èÁ±ªÂûã DST - Dynamically Sized TypesÔºåÂ¶ÇÂ≠óÁ¨¶‰∏≤ÂàáÁâáÁ±ªÂûã `str`ÔºåÂÆÉÊú¨Ë∫´ÊòØ `[u8]`„ÄÇÁ±ª‰ººÁöÑËøòÊúâÂÖ∂ÂÆÉÁöÑ `[T]` ÂàáÁâáÁ±ªÂûã‰πüÊòØ DST Á±ªÂûãÔºåÂåÖÊã¨ Trait ÈÉΩÊòØÔºö

```rust,ignore
dbg!(size_of::<&u32>());        // 8
dbg!(size_of::<&[u32; 2]>());   // 8
dbg!(size_of::<&[u32]>());      // 16
dbg!(size_of::<&str>());        // 16
```

DST Á±ªÂûã‰∏çËÉΩÁõ¥Êé•‰Ωú‰∏∫ÂèÇÊï∞‰ΩøÁî®Ôºå‰ª•‰∏ãËøôÁßçÂ∞±‰∏çËÉΩÈÄöËøáÁºñËØëÔºö

```rust,ignore
// doesn't have a size known at compile-time
let s1: str = "Hello there!";
let s2: str = "How's it going?";
```

Ê≥®ÊÑè `&str` ÂºïÁî®ÊòØÂõ∫ÂÆöÂ§ßÂ∞èÁöÑÔºåÂÆÉÊòØËÉñÊåáÈíà‰∏Ä‰∏™ÔºåRust Â≠óÁ¨¶‰∏≤Â≠óÈù¢ÈáèÊòØ `&str` Á±ªÂûãÔºåÂáÜÁ°ÆÂú∞ËÆ≤ÊòØ `&'static str`„ÄÇ

Â¶ÇÊûú `str` ÊòØÂõ∫ÂÆöÂ§ßÂ∞èÁöÑÁ±ªÂûãÔºåÈÇ£‰πà s1 Â∞±‰ºöÂíå s2 Êã•ÊúâÂêåÊ†∑Â§ßÂ∞èÁöÑÂÜÖÂ≠òÁ©∫Èó¥ÔºåËøôÊòæÁÑ∂ÊòØ‰∏çËÉΩÊàêÁ´ãÁöÑ„ÄÇËÄå `&str` ÂºïÁî®Á±ªÂûãÂàô‰∏çÂêåÔºåÂÆÉ‰Ωú‰∏∫‰∏Ä‰∏™ËÉñÊåáÈíàÔºå‰∏ç‰ªÖÊúâÊï∞ÊçÆÂ≠òÂÇ®ÂÜÖÂ≠òÁ©∫Èó¥ÁöÑÊåáÈíàÔºåËøòÊúâÊï∞ÊçÆÁöÑÂ§ßÂ∞è‰ø°ÊÅØ„ÄÇ

Á±ª‰ººÁöÑÂÖ≥Á≥ªËøòÂá∫Áé∞Âú®ÂàáÁâáÁ±ªÂûã `Stirng` Ë∫´‰∏äÔºåÂ≠óÁ¨¶‰∏≤Á±ªÂûãÁöÑÊï∞ÊçÆÂú®ÂÜÖÂ≠ò‰∏≠‰ª•  `[u8]` ÂàáÁâáÁ±ªÂûãÂΩ¢ÂºèÂ≠òÂÇ®ÔºåÂ∞±ÂÉè str Á±ªÂûã‰∏ÄÊ†∑ÔºåÂàáÁâáÁ±ªÂûãÊú¨Ë∫´‰∏çËÉΩÂú®ÁºñËØëÊúüÁ°ÆÂÆöÂ§ßÂ∞è„ÄÇ

```rust,ignore
let a:String = "Hello";
// doesn't have a size known at compile-time
let slice = a[..];
```

Ëøô‰∫õÁºñËØëÊúüÊó†Á°ÆÂÆöÂ§ßÂ∞èÁöÑÁ±ªÂûãÈúÄË¶Å‰ΩøÁî®ÊåáÈíàÊó∂ÔºåÂ∞±‰∏çËÉΩÁî®Â∏∏ËßÑÊåáÈíàÔºåÂõ†‰∏∫ÂÆÉ‰ª¨ËøòÊ∂âÂèäÈ¢ùÂ§ñÁöÑÂ§ßÂ∞è‰ø°ÊÅØÔºåÂèØ‰ª•Áî®Á±ª‰ºº‰ª•‰∏ãÁöÑÁªìÊûÑË°®ËææÔºö

```rust,ignore
struct FatPointer { 
    ptr: *const u32, 
    len: usize,
}
```

Âõ†‰∏∫ÊòØÊôÆÈÄöÊåáÈíàÁöÑ‰∏ÄÂÄçÂ§ßÔºåÊâÄ‰ª•‰πüÂè´‰Ωú fat pointerÔºåÂ§öÂá∫Êù•ÁöÑÁ©∫Èó¥ÊòØÁî®Êù•‰øùÂ≠òÈïøÂ∫¶‰ø°ÊÅØ„ÄÇ

Âè¶‰∏ÄÁßçÂ∏∏ËßÅÁöÑÂä®ÊÄÅÁ±ªÂûãÂ∞±ÊòØ Trait ObjectÔºåÁ±ªÂûãÂ£∞ÊòéÂΩ¢Âºè‰∏∫ `dyn Trait`ÔºåÈÄöÂ≠¶ÈúÄË¶Å‰ΩøÁî®ÂºïÁî® `&dyn Trait` ÊàñËÄÖÊô∫ËÉΩÊåáÈíàËøõË°åÂåÖË£Ö `Box<dyn Trait>`„ÄÅ`Rc<dyn Trait>`„ÄÇ

‰ª•‰∏ãÊòØËøô‰∫õÂ∏∏ËßÅ DST Á±ªÂûãÁöÑÊô∫ËÉΩÊåáÈíàË°®ËææÔºö

- `Box<str>`
- `Rc<str>`
- `Box<dyn Trait>`
- `Rc<dyn Trait>`

ÂÆÉ‰ª¨ÈÉΩÊòØÂ≠òÂÇ®Âú® Heap ÂÜÖÂ≠ò‰∏≠ÁöÑÔºåRc - Reference Counted ÊòØÂºïÁî®ËÆ°Êï∞ÔºåÁî®Êà∑Ëá™ÂÆö‰πâÁöÑËµÑÊ∫êÂõûÊî∂Ê∏ÖÁêÜ„ÄÇ

‰∏∫‰∫ÜÊõ¥Â•ΩÂú∞Âå∫Âà´ DST Á±ªÂûãÔºåRust ‰ºöÈªòËÆ§Âú∞ÂêëÊ≥õÂûãÂáΩÊï∞Ê∑ªÂä†ÈöêÂê´ÁöÑ `Sized` trait ÁªëÂÆöÔºåÊù•Â£∞ÊòéÊ≥õÂûãÂèÇÊï∞ÊòØÁºñËØëÊúüÊòéÁ°ÆÂ§ßÂ∞èÁöÑÔºåÂØπ‰∫é‰ª•‰∏ãËøô‰∏™Ê≥õÂûãÂáΩÊï∞Ôºö

```rust,ignore
fn generic<T>(t: T) {
    // --snip--
}
```

ÂÆÉÁöÑÂÆûÈôÖÂΩ¢ÂºèÂ¶Ç‰∏ãÔºö

```rust,ignore
fn generic<T: Sized>(t: T) {
    // --snip--
}
```

ÂØπ‰∫é DST Ê≥õÂûãÂèÇÊï∞Á±ªÂûãÔºå‰ΩøÁî® `?Sized` Ë°®Á§∫Ôºö

```rust,ignore
fn generic<T: ?Sized>(t: &T) {
    // --snip--
}
```

Trait ÁªëÂÆö `?Sized` ÂêéÔºåÂ∞±Ë°®Á§∫‰∏Ä‰∏™ DST Á±ªÂûãÔºåÂç≥Ê≥õÂûãÂèÇÊï∞ T ÂèØ‰ª•ÊòØ„ÄÅ‰πüÂèØ‰ª•‰∏çÊòØ Sized Á±ªÂûãÔºåËøôÁßçËØ≠Ê≥ïÂè™ÂØπ‰∫é Sized Trait ÁªëÂÆöÊúâÊïà„ÄÇ


<!-- Âõ∫ÂÆöÂ§ßÂ∞èÁöÑ Sized TraitÔºå -->


## ‚ö° Closures Èó≠ÂåÖ
- https://doc.rust-lang.org/book/ch19-05-advanced-functions-and-closures.html
- https://doc.rust-lang.org/rust-by-example/fn/closures.html
- https://doc.rust-lang.org/stable/std/ops/trait.Fn.html
- https://doc.rust-lang.org/stable/reference/types/closure.html
- Finding Closure in Rust https://huonw.github.io/blog/2015/05/finding-closure-in-rust/
- Functional Language Features: Iterators & Closures https://doc.rust-lang.org/book/ch13-00-functional-features.html
- Closures: Anonymous Functions that Can Capture Their Environment https://doc.rust-lang.org/book/ch13-01-closures.html
- Why Rust Closures are Hard https://stevedonovan.github.io/rustifications/2018/08/18/rust-closures-are-hard.html
- Higher-Rank Trait Bounds (HRTBs) https://doc.rust-lang.org/nomicon/hrtb.html
- ÁêÜËß£ Rust ‰∏≠ÁöÑ Closure https://zhuanlan.zhihu.com/p/64417628

ÂáΩÊï∞ÂèØ‰ª•Áî®ÊåáÈíàË∞ÉÁî®ÔºåÂç≥ÂáΩÊï∞ÂèØ‰ª•ÂÉèÊôÆÈÄöÂèòÈáè‰∏ÄÊ†∑‰º†ÈÄíÔºö

```rust,ignore
fn add_one(v: i32) -> i32 {
    v + 1
}

fn do_twice(f: fn(i32) -> i32, v: i32) -> i32 {
    f(v) + f(v)
}

fn main() {
    let answer = do_twice(add_one, 5);
    print!("answer is {}", answer);
}
```

‰∏éÈó≠ÂåÖ‰∏çÂêåÔºåÂÖ≥ÈîÆÂ≠ó `fn` ÊòØÂÆö‰πâ‰∏Ä‰∏™Á±ªÂûãËÄå‰∏çÊòØ Fn TraitÔºåÁî® fn ÊåáÂÆöÂèÇÊï∞Á±ªÂûãÔºåËÄå‰∏çÊòØÂ£∞Êòé‰∏Ä‰∏™Ê≥õÂûãÂèÇÊï∞ÂéªÁªëÂÆö Trait„ÄÇ

Èó≠ÂåÖÂ∞±ÊòØ‰∏Ä‰∏™ÁªìÊûÑËÆ∞ÂΩïÔºåÂÆÉ‰øùÂ≠ò‰∏Ä‰∏™ÂáΩÊï∞‰∏éÂΩìÂâçÁéØÂ¢ÉÂÖ≥ËÅî„ÄÇËØ≠Ê≥ï‰∏äÁõ∏ÂΩìÊòØ‰∏Ä‰∏™ÂåøÂêçÂáΩÊï∞ÔºåÊúâÊó∂ÂÄô‰πüÁß∞‰Ωú lambda Ë°®ËææÂºè„ÄÇ

ËØ≠Ê≥ïÊ†ºÂºè `|val| exps`ÔºåÂÖ∏ÂûãÊ†áÂøóÊòØ‰∏§Êù°Á´ñÁ∫øÔºåÂÖ∂ÁâπÂæÅÂ¶Ç‰∏ãÔºö

- ‰ΩøÁî® `||` ÂåÖÊã¨ÂèÇÊï∞ÂàóË°®ÔºåËÄå‰∏çÊòØ `()`Ôºõ
- ÂáΩÊï∞‰ΩìÂèØÈÄâÁöÑËä±Êã¨Âè∑ `{}`ÔºåÂØπ‰∫éÂçï‰∏™Ë°®ËææÁöÑÈó≠ÂåÖÈùûÂ∏∏ÊòìÁî®ÔºåÊØîÂ¶ÇÂè™ÂèçÂõû‰∏Ä‰∏™Êï∞ÂÄºÁöÑÈó≠ÂåÖ `|i: i32| -> i32 { i + 1 };`Ôºõ
- ÊçïÊçâ‰ΩúÁî®ÂüüÁéØÂ¢ÉÁöÑËÉΩÂäõÔºåÂèØ‰ª•Ëá™Âä®Â§ÑÁêÜÊâÄÊúâÊùÉÁöÑÁßªÂä®„ÄÅÂÄüÁî®ÔºåÊ†πÊçÆÊâÄÊúâÊùÉÂ§ÑÁêÜÊñπÂºè‰∏çÂêåËÄåÂÆûÁé∞ÁöÑÔºõ
    - `Fn`: Èó≠ÂåÖÊçïÊçâÂºïÁî® `&T`Ôºõ
    - `FnMut`: Èó≠ÂåÖÊçïÊçâÂèØÂèòÂºïÁî® `&mut T`Ôºõ
    - `FnOnce`: Èó≠ÂåÖÊçïÊçâÊâÄÊúâÊùÉ `T`ÔºåÂØπÂ∫îÁÆÄÂÜôÂΩ¢Âºè `move ||`Ôºõ

ËÄåÈªòËÆ§ÁöÑÊçïËé∑ÈÄâÊã©È°∫Â∫èÔºö

- Â¶ÇÊûúÂèØ‰ª•ÔºåÂàôÂ∞ΩÈáèÁî® & ÂÄüÁî®Ôºõ
- Âê¶ÂàôÔºåÂ¶ÇÊûúÂèØ‰ª•ÔºåÂàôÊÄªÊòØ &mut ÂÄüÁî®Ôºõ
- ÊúÄÂêéÔºåÊó†ËÆ°ÂèØÊñΩÂøÖÈ°ªË¶Å ownership ÁöÑËØùÔºåÊâç‰ºö moveÔºõ

Âè¶Â§ñÔºåÈó≠ÂåÖ‰πüÂèØ‰ª•ÂÉèÂÖ∂ÂÆÉÂèòÈáè‰∏ÄÊ†∑ÔºåÊúâÂÖ±‰∫´ÂºïÁî®„ÄÅÂèØÂèòÂºïÁî®ÁöÑË°®ËææÂΩ¢ÂºèÔºö

- Èó≠ÂåÖÂÖ±‰∫´ÂºïÁî®ÂΩ¢Âºè `& ||`Ôºõ
- Èó≠ÂåÖÂèØÂèòÂºïÁî®ÂΩ¢Âºè `&mut ||`Ôºõ

Rust ÂÜÖÂ≠òÊ®°Âûã‰∏≠ÁöÑÊï∞ÊçÆÊúâ‰∏âÂ§ÑÂ≠òÂÇ®Á±ªÂûãÔºöÊ†à‰∏ä„ÄÅÊâòÁÆ°Â†Ü‰∏ä„ÄÅ‰ª•Âèä‰∫§Êç¢Â†Ü‰∏ä„ÄÇÊâÄ‰ª•ÔºåÂØπÂ∫îÊúâ‰∏âÁßçÈó≠ÂåÖÔºöstack closure„ÄÅmanaged closure„ÄÅowned closure„ÄÇ

ÂâçÈù¢Á§∫ËåÉ‰ª£Á†Å‰∏≠ `do_twice()` ÊñπÊ≥ïÂèØ‰ª•Á≠â‰ª∑ÂÆûÁé∞‰∏∫ Fn ÊñπÂºèÔºö

```rust,ignore
fn do_twice<F>(f: F, v: i32) -> i32 
where F: Fn(i32) -> i32
{
    f(v) + f(v)
}
```

ÂáΩÊï∞ÊåáÈíàÁ±ªÂûãÂÆûÁé∞‰∫Ü `Fn` `FnMut` `FnOnce` Ëøô‰∏â‰∏™ Traits Á±ªÂûãÔºåÊâÄ‰ª•Âì™ÈáåÈúÄË¶Å‰º†ÂÖ•Èó≠ÂåÖÔºåÂ∞±ÂèØ‰ª•‰º†ÂÖ•ÂáΩÊï∞ÊåáÈíàÔºåÂ¶ÇÂêëÈáèÂàóË°®ÂØπË±°ÁöÑ map() ÊñπÊ≥ï„ÄÇ

```rust,ignore
let nums = vec![1, 2, 3];
let closure = |i: &i32| i.to_string();
let closure = ToString::to_string;
let strings: Vec<String> = nums.iter().map(closure).collect();
println!("The largest {:?}", strings);
```

ÂèØ‰ª•Â∞Ü tuple structs Êàñ tuple-struct enum ‰∏≠ÁöÑÊàêÂëòÂàùÂßãÂåñÂáΩÊï∞‰Ωú‰∏∫ÂáΩÊï∞ÊåáÈíàÊù•‰ΩøÁî®Ôºö

```rust,ignore
#[derive(Debug)]
enum Status {
    Value(u32),
    Stop,
}
let statuses: Vec<Status> = (0u32..5).map(Status::Value).collect();
println!("The largest {:?}", statuses);
```

‰∏äÈù¢ÁöÑÁ§∫ËåÉ‰∏≠ÔºåÊûö‰∏æÁ±ªÂûãÁöÑ `Value()` Â∞±ÊòØ‰∏Ä‰∏™ÂàùÂßãÂåñÂáΩÊï∞ÔºåÂÆÉËøîÂõûÁöÑÊòØ‰∏Ä‰∏™Âè™Êúâ‰∏Ä‰∏™ u32 ÂÄºÁöÑÂÖÉÁªÑ„ÄÇ


Âú®Èó≠ÂåÖÂÆö‰πâ‰∏≠‰ΩøÁî® move ÂÖ≥ÈîÆÂ≠óÔºåÂèØ‰ª•Âº∫Âà∂‰∏∫Èó≠ÂåÖÊçïËé∑ÊâÄÊúâÊùÉÔºö

    let num = 5;
    let owns_num = move |x: i32| x + num;

Â∞±ÁÆóÁî® move Âº∫Âà∂ÊçïËé∑ÂèòÈáèÁöÑÊâÄÊúâÊùÉÔºåÂè™Ë¶Å‰∏çÁßªËµ∞ÊâÄÊúâÊùÉËÄå‰ªÖ‰ªÖÊòØ‰øÆÊîπÊàñËØªÂèñÂèòÈáèÔºåËøôÁßçÊÉÖÂÜµ‰æùÁÑ∂‰ºöÂÆûÁé∞ FnMut Êàñ Fn„ÄÇ

ÂºïÁî®ÁΩëÂèãÁöÑÁ§∫ËåÉ‰ª£Á†ÅÔºåÁßªÂä®ÊâÄÊúâÊùÉÂêéÂ∞±Êó†Ê≥ïÂÜç main ÂáΩÊï∞‰ΩøÁî® homu Êàñ madoÔºö

```rust,ignore
#![allow(unused_variables)]
struct Madoka;
struct Homura;

fn main() {
    let homu = Homura;
    let mado = Madoka;
    let marry = move || {
        (&homu, &mado);
    };
    marry();
    // values used here after move
    let moved = (homu, mado);
}
```

‰ª•‰∏ãÁ§∫ËåÉÈó≠ÂåÖÊòØÂ¶Ç‰ΩïÊçïÊçâÂ§ñÈÉ®ÁéØÂ¢ÉÁöÑÔºö

```rust,ignore
use std::mem;

let mut color = String::from("green");

let print = || println!("`color`: {}", color);

// let  _reborrow = &mut color;
// cannot borrow `color` as mutable because it is also borrowed as immutable

// Call the closure using the borrow, one or more time.
print();

// A move or reborrow is allowed after the final use of `print`
let mut _color_moved = color;
let  _reborrow = &mut _color_moved;

// A non-copy type.
let movable = Box::new(2);

// `mem::drop` requires `T` so this must take by value. A copy type
// would copy into the closure leaving the original untouched.
// A non-copy must move and so `movable` immediately moves into
// the closure.
let consume = || {
    println!("`movable`: {:?}", movable);
    mem::drop(movable);
};

// `consume` consumes the variable so this can only be called once.
consume();
```

Èó≠ÂåÖ‰∏ÄÊó¶ÂÆö‰πâÔºåÂÖ∂‰ΩøÁî®ÁöÑÂèòÈáèÂ∞±‰ºöÊåâ‰ΩøÁî®ÊñπÂºèËΩ¨ÁßªÊâÄÊúâÊùÉ„ÄÅÊàñÂÄüÁî®ÊâÄÊúâÊùÉÔºåÂπ∂‰øùÂ≠òÂà∞ print ÂèòÈáè‰∏≠ÔºåÂõ†‰∏∫ `println!` ÂÆèÂè™ÈúÄË¶ÅÂÄüÁî® imutable ÁöÑÂèòÈáèÔºåÊâÄ‰ª• color Âè™ÊòØÂÄüÁî®ÊâÄÊúâÊùÉÁªôÈó≠ÂåÖÔºåÂç≥‰ΩøÂÆÉÊòØ Spring Á±ªÂûã‰πüÊ≤°ÊúâÂèëÁîüÊâÄÊúâÊùÉËΩ¨Áßª„ÄÇ

Â¶ÇÊûúÊòØÂéüÂßãÂÄºÔºåÂ¶ÇÊï∞ÂÄºË¢´Èó≠ÂåÖ‰ΩøÁî®Êó∂Ôºå‰º†ÂÄº‰ºö‰∫ßÁîü Copy Ë°å‰∏∫ÔºåËÄå `mem::drop()` Ë¶ÅÊ±Ç‰º†ÂÄºÔºåÊâÄ‰ª•‰æãÂ≠ê‰ΩøÁî®‰∫ÜÊô∫ËÉΩÊåáÈíàÊù•ÊâìÂåÖÊï∞ÂÄºÔºå‰ΩøÂÖ∂‰øùÂ≠òÂú® Heap ÂÜÖÂ≠ò‰∏≠ÔºåËøôÊ†∑ÂèØ‰ª•ÈÅøÂÖç Copy„ÄÇÊ≥®ÊÑèÔºå‰∏äÈù¢Á§∫ËåÉÁöÑ `movable` ÂèòÈáèÔºå‰ºöË¢´ÂÄüÁî®Âèà‰ºöÂõ† `drop()` Ë∞ÉÁî®‰∫ßÁîüÊâÄÊúâÊùÉËΩ¨Áßª„ÄÇ

ÊâÄ‰ª•ÔºåÂêéÈù¢ `consume` Ëøô‰∏™Èó≠ÂåÖÂ∞±Áõ∏ÂΩìÊòØ `Fn` Âä† `FnOnce` ‰∏§ÁßçÊÉÖÂÜµÔºåÂ¶ÇÊûúÂÆö‰πâÂáΩÊï∞ÈúÄË¶Å‰ΩøÁî®ËøôÊ†∑ÁöÑÈó≠ÂåÖÊó∂ÔºåÂ∞±ÈúÄË¶ÅÁõ∏Â∫îÊåáÊòéÂèÇÊï∞Á±ªÂûã‰∏∫ `Fn` Âíå `FnOnce`„ÄÇ

```rust,ignore
// let call = |mut f: FnOnce()| { f() };
fn call<F>(mut func: F)
where F: FnOnce()
{
    func();
}
call(consume);
```

### üü¢üîµ Closures Lifetime

ÂÖ≥‰∫éÈó≠ÂåÖÁîüÂëΩÂë®ÊúüÔºåËØ∑Áúã Stackoverflow ‰∏äÁöÑ‰∏Ä‰∏™ÈóÆÈ¢òÔºö

```rust,ignore
// https://stackoverflow.com/questions/65985081
// temporary value dropped while borrowed

struct Animal<'a> {
    format: &'a dyn Fn() -> (),
}
impl<'a> Animal<'a> {
    // Getting rid of 'a here satisfies the compiler, why?
    pub fn set_formatter(&mut self, _fmt: &'a dyn Fn() -> ()) -> () {}
    pub fn bark(&self) {}
}

fn main() {
    let mut dog: Animal = Animal { format: &|| {()} };
    let x = 0;
    dog.set_formatter(&|| {
        // Commenting this out gets rid of the error. Why?
        println!("{}", x);
    });
    // Commenting this out gets rid of the error. Why?
    dog.bark();
    dbg!(x);
}
```

‰ªéÁºñËØëÂô®ÊèêÁ§∫ÁöÑÈîôËØØ‰ø°ÊÅØÂèØ‰ª•ÂæóÁü•ÔºåÈó≠ÂåÖÂºïÁî®‰º†ÂÖ•Êó∂‰∫ßÁîü‰∫Ü‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáèÔºö

    22 |       dog.set_formatter(&|| {
       |  ________________________^
    23 | |         // Commenting this out gets rid of the error. Why?
    24 | |         println!("{}", x);
    25 | |     });
       | |     ^ - temporary value is freed at the end of this statement
       | |_____|
       |       creates a temporary which is freed while still in use
    26 |       // Commenting this out gets rid of the error. Why?
    27 |       dog.bark();
       |       --- borrow later used here
       |
       = note: consider using a `let` binding to create a longer lived value

Ë¶ÅÁÇπÂàÜÊûêÔºö

- `&||()` ËøôÈáåÂÆö‰πâ‰∫Ü‰∏Ä‰∏™Êó†ËøîÂõûÂÄºÁöÑÈó≠ÂåÖÔºåÂêåÊó∂ÂèñÂºïÁî®‰º†ÂÖ•‰∫ÜÂáΩÊï∞‰Ωú‰∏∫ÂõûË∞É„ÄÇ
- `&||()` Ëøô‰∏™Èó≠ÂåÖÂºïÁî®ÊòØ `'static` ÁîüÂëΩÂë®Êúü„ÄÇ
- ÈúÄË¶Å‰øùËØÅÈó≠ÂåÖÊçïÊçâÁöÑÂèòÈáèÁîüÂëΩÂë®Êúü‰∏çÁü≠‰∫éÈó≠ÂåÖÁîüÂëΩÂë®Êúü„ÄÇ
- ``

The first thing to understand is that &|| () has a 'static lifetime:

fn main() {
    let closure: &'static dyn Fn() = &|| (); // compiles
}



### üü¢üîµ Closures Type Anonymity

Èó≠ÂåÖÂÖ∑Êúâ`Á±ªÂûãÂåøÂêçÊÄß`ÔºåÊØè‰∏™Èó≠ÂåÖÁõ∏ÂΩì‰∫éÂàõÂª∫‰∏Ä‰∏™ÂåøÂêçÁöÑÁªìÊûÑ‰ΩìÔºåÁºñËØëÂô®‰ºö‰∏∫ÂÆÉÊçïËé∑‰ΩøÁî®Âà∞ÁöÑÂΩìÂâç‰∏ä‰∏ãÊñáÂ§ñÈÉ®ÁöÑÂèòÈáèÁÑ∂ÂêéÂ°ûËøõËøô‰∏™ÁªìÊûÑ‰ΩìÈáåÈù¢„ÄÇ

Ëøô‰πüÊòØ Rust Èó≠ÂåÖÈöæÁî®ÁöÑÊ†πÊ∫êÔºö

- Rust ‰∏≠ÁªìÊûÑ‰ΩìÁöÑÂèØÂèòÊÄß‰ª•Âèä lifetime Êú¨Ë∫´Â∞±ÊòØÂ§çÊùÇÁöÑÊú∫Âà∂„ÄÇ
- Closure ÁöÑËßÑÂàôÈÉΩÊòØÈöêÂºèÁöÑÔºöÈó≠ÂåÖÊçïËé∑ÂÄºÁöÑÊñπÂºèÔºå‰ª•ÂèäÊâÄÁîüÊàêÁöÑÈó≠ÂåÖÁ±ªÂûãÈÉΩÊòØÊåâÁÖßÈöêÂºèÁöÑËßÑÂàôÂÜ≥ÂÆöÁöÑ„ÄÇ
- Closure ‰ºöÊçïËé∑Êï¥‰∏™Â§çÂêàÁ±ªÂûãÔºåÂ¶Ç struct, tuple Âíå enumÔºåËÄå‰∏çÂè™ÊòØÂçï‰∏™Â≠óÊÆµ„ÄÇ

‰æãÂ¶ÇÔºå‰ª•‰∏ãÁöÑÈó≠ÂåÖÁ§∫ËåÉÔºö

```rust,ignore
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);
// expected struct `std::string::String`, found integer
```

Âú®Á¨¨‰∏Ä‰∏™Èó≠ÂåÖË∞ÉÁî®Ë°®ËææÂºèÊâßË°åÊó∂Ôºåexample_closure ÁöÑÁ±ªÂûãÂ∞±Á°ÆÂÆö‰∏ãÊù•‰∫ÜÔºåÂΩìÁ¨¨‰∫åÊ¨°Áî®‰∏çÂêåÁöÑÂèÇÊï∞ÂéªË∞ÉÁî®Êó∂ÔºåÂ∞±Âá∫Áé∞ÁªôÈó≠ÂåÖËæìÂÖ•ÁöÑÂèÇÊï∞Á±ªÂûã‰∏çÂåπÈÖç„ÄÇ

ËøôËß£Èáä‰∫Ü‰∏∫‰ªÄ‰πà Rust ‰∏≠‰∏§‰∏™ÂèÇÊï∞ÂíåËøîÂõûÂÄº‰∏ÄÊ†∑ÁöÑÈó≠ÂåÖÊòØ‰∏çÂêåÁöÑÁ±ªÂûãÔºåÂõ†‰∏∫ÂÆÉ‰ª¨ËÉåÂêéÁöÑÂåøÂêçÁªìÊûÑ‰Ωì‰∏çÂêåÔºåÊúâÁùÄ‰∏çÂêåÁöÑÂ§ßÂ∞è„ÄÅÂ≠óÊÆµÂíå lifetime„ÄÇ

‰ª•‰∏ãÔºåÁî®Á≠â‰ª∑ÁöÑÁªìÊûÑ‰ΩìÊù•Ê®°ÂùóÈó≠ÂåÖÔºåÂõ†‰∏∫Â§ñÈÉ®ÂèòÈáè `c` ÊúâÁîüÂëΩÂë®ÊúüÈôêÂà∂ÔºåÊâÄ‰ª•Èó≠ÂåÖ‰∏çËÉΩÈïøÂØøËøáÂÆÉÔºö

```rust,ignore
let c = 2.0;

let closure = |x: f64| x + c;

struct AnonymClosureType<'a> {
    c: &'a f64
}

impl<'a> AnonymClosureType<'a> {
    fn call(&self, x: f64) -> f64 {
        x + self.c
    }
}
```

ÂâçÈù¢Â∞èËäÇÁöÑÁ§∫ËåÉ‰ª£Á†Å‰∏≠Ôºå`do_twice()` ÊñπÊ≥ïÂèØ‰ª•Á≠â‰ª∑ÂÆûÁé∞‰∏∫ Fn ÊñπÂºèÔºå‰ΩÜÊòØÂøÖÈúÄÈÄöËøáÊ≥õÂûãÊñπÂºèÂ£∞ÊòéÁöÑÔºö

```rust,ignore
fn do_twice<F>(f: F, v: i32) -> i32 
where F: Fn(i32) -> i32
{
    f(v) + f(v)
}
```

Â∞ùËØïÁî®ÈùûÊ≥õÂûãÊñπÂºèÊîπÂÜô‰ºöËé∑ÂèñÊèêÁ§∫Ôºö

    fn do_twice(f: dyn Fn(i32) -> i32, v: i32) -> i32 { ... }

    the size for values of type `(dyn std::ops::Fn(i32) -> i32 + 'static)` cannot be known at compilation time

Â∞±ÊòØÂõ†‰∏∫ÂáΩÊï∞Êé•Êî∂ÁöÑÈó≠ÂåÖÁ±ªÂûãÊó†Ê≥ïÂú®ÁºñËØëÊúüÁ°ÆÂÆöÂ§ßÂ∞èÔºåÂõ†Ê≠§‰∏çÂèØÈ¢ÑÊµãÂáΩÊï∞Âú®ËøêË°åÊó∂‰ºöÊé•Êî∂‰ªÄ‰πàÁ±ªÂûãÁöÑÈó≠ÂåÖ„ÄÇÈúÄË¶ÅÈÄöËøáÊ≥õÂûãÊù•ÂÆûÁé∞Âä®ÊÄÅË∞ÉÁî®ÔºàDynamic DispatchÔºâÁöÑÊú∫Âà∂Ôºå‰ª•Âú®ËøêË°åÊó∂Á°ÆÂÆöÈó≠ÂåÖÁ±ªÂûãÂ§ßÂ∞è„ÄÇ

```rust,ignore
// `F` must be generic.
fn apply<F>(f: F) where
    F: FnOnce() {
    f();
}
```

ËÄå‰ΩøÁî® `Fn` `FnMut` `FnOnce` Á±ªÂûãÁöÑÈó≠ÂåÖËÉΩÈöêÂºèÂú∞‰ªéÂ∞ÅÈó≠‰ΩúÁî®ÂüüÊçïËé∑ÂèòÈáèÔºåËøô‰πüÂ∏¶Êù•‰∫ÜÁõ∏ÂΩìÂ§öÁöÑÁñëÊÉëÊÄß„ÄÇ


Èó≠ÂåÖÂèØ‰ª•ÂáΩÊï∞ÁöÑÂÅöËæìÂÖ•ÂèÇÊï∞ÔºåÊàñËÄÖËæìÂá∫ÂÄº„ÄÇÂáΩÊï∞ÂèØ‰ª•ËøîÂõûÈó≠ÂåÖÔºå‰ΩÜÊòØ‰∏çËÉΩÁõ¥Êé•ËøîÂõûÈó≠ÂåÖÔºö

    fn returns_closure() -> dyn Fn(i32) -> i32 {
                            ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
        |x| x + 1
    }

ËøôÊòØÂõ†‰∏∫Èó≠ÂåÖÁ±ªÂûãÊòØÂåøÂêçÁöÑÔºåÁî± Traits Ë°®Á§∫ÔºåËøôÊÑèÂë≥ÁùÄ‰∏çËÉΩÁõ¥Êé•ËøîÂõûÈó≠ÂåÖÔºåÊàñËÄÖËØ¥ËøîÂõûÁöÑË£ÖÈ•≠Á±ªÂûã‰∏éÂ£∞ÊòéÁöÑËøîÂõûÂÄºÁ±ªÂûã‰∏çÊòØÂêå‰∏ÄÁ±ªÂûã„ÄÇÂèØ‰ª•‰ΩøÁî®ÂÆûÁé∞Áõ∏Â∫î Trait ÁöÑÂÖ∑‰ΩìÁ±ªÂûã‰Ωú‰∏∫ÂáΩÊï∞ÁöÑËøîÂõûÂÄºÔºåÈó≠ÂåÖ‰Ωú‰∏∫ÂåøÂêçÁ±ªÂûã‰∏çËÉΩËøôÊ†∑ÂÅö„ÄÇ

ÊúÄÊñ∞ Rust 2018 Êèê‰æõ‰∫Ü‰∏§ÁßçËØ≠Ê≥ïÂÆûÁé∞ impl Trait Âíå dyn TraitÔºå‰ª•‰∏ã‰∏§ÁßçÊñπÂºèÈÉΩÂèØ‰ª•ÂÆûÁé∞Èó≠ÂåÖÁöÑËøîÂõûÔºö

```rust,ignore
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}

fn returns_closure() -> Box<impl Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```

impl Trait Âíå dyn Trait ÂàÜÂà´ÂØπÂ∫îÈùôÊÄÅÂàÜÂèëÂíåÂä®ÊÄÅÂàÜÂèëÊú∫Âà∂ÔºåÁî®Âú®ËøîÂõûÂÄºÁ±ªÂûãÂÆö‰πâ‰∏≠ÔºåË°®Á§∫ËøîÂõûÂÄºÊòØÂÆûÁé∞‰∫Ü Fn ÁöÑÁ±ªÂûã„ÄÇ


ÂèØ‰ª•Â∞ÜÈó≠ÂåÖ‰øùÂ≠òÂà∞ÁªìÊûÑ‰Ωì‰∏≠Ôºå‰ª•‰∏ãÂÆûÁé∞‰∏Ä‰∏™Èò∂‰πòÁÆóÊ≥ïÁöÑÈó≠ÂåÖÔºö

```rust,ignore
struct Fact<'s> { 
    f: &'s dyn Fn(&Fact, u32) -> u32 
}
let fact = Fact {
    f: &|fact, x| if x == 0 {1} else {x * (fact.f)(fact, x - 1)}
};

println!("{}", (fact.f)(&fact, 5));
```

Âõ†‰∏∫Èó≠ÂåÖÂæàÂ•ΩÁî®Ôºå‰ΩÜÊòØÊàë‰ª¨‰∏çÊÉ≥‰ªòÂá∫ËøêË°åÊó∂‰ª£‰ª∑„ÄÇ

Rust ÈÄâÊã©„ÄåÈõ∂È¢ùÂ§ñÂºÄÈîÄ„ÄçÔºàZero OverheadÔºâÊâÄ‰ª•ÂøÖÈ°ªÁî®ËøôÁßçÊñπÂºèÊù•ÂÆûÁé∞ closure„ÄÇ‰ΩøÁî®È´òÁ∫ßÊäΩË±°ÁöÑÂêåÊó∂‰øùÊåÅ‰∫ÜÊÄßËÉΩÊó†Êçü„ÄÇÊØîÂ¶ÇËØ¥Êàë‰ª¨ËÉΩÁî®ÂæàÂáΩÊï∞ÂºèÁöÑÊñπÊ≥ïÂ§ÑÁêÜËø≠‰ª£Âô®Ôºå‰ΩÜÊúÄÂêéÁîüÊàêÁöÑÊ±áÁºñÂíåÊâãÂÜôÂæ™ÁéØÊ≤°‰ªÄ‰πàÂå∫Âà´„ÄÇ

Rust Êèê‰æõ‰∫Ü `Box<Fn() -> T>` Âíå `Rc` ËÆ©‰Ω†ÂèØ‰ª•ÊâãÂä®ÂÅöÂà∞Âà´ÁöÑËØ≠Ë®ÄËá™Âä®ÂÅöÂà∞ÁöÑ‰∫ãÊÉÖ„ÄÇ‰Ω†ÈúÄË¶ÅÊòæÂºè‰ΩøÁî®Ëøô‰∫õËÆæÊñΩÔºåÂõ†‰∏∫Ëøô‰ª£Ë°®È¢ùÂ§ñÁöÑÂºÄÈîÄ„ÄÇ

ËÄåÈÄâÊã©ÈöêÂºèÁöÑÊçïËé∑ËßÑÂàôÊòØÂõ†‰∏∫Èó≠ÂåÖÊú¨Ë∫´Ë¢´ËÆæËÆ°Âá∫Êù•ÁöÑÁõÆÁöÑÂ∞±ÊòØ‰∏∫Âú®Êüê‰∏™ÁâπÂÆö‰∏ä‰∏ãÊñáÂÜÖ‰ª•Áü≠Â∞è„ÄÅÁÆÄÊ¥ÅËÄåÈ¢ëÁπÅÁöÑÊñπÂºè‰π¶ÂÜô„ÄÇÂõ†Ê≠§ÈááÁî®‰∫ÜËøôÁßçÈöêÂºè‰∏îÊúÄ‰øùÂÆàÁöÑÊçïËé∑ÊñπÂºèÔºå‰ª£‰ª∑Â∞±ÊòØÂÆπÊòìËÆ©‰∫∫Êë∏‰∏çÁùÄÂ§¥ËÑë„ÄÇ


‰ª•‰∏ãÁî® move Closures Èó≠ÂåÖÂÆûÁé∞‰∏Ä‰∏™ÂáΩÊï∞ÈÄªËæëÔºö

```rust,ignore
// const sum = (f, g) => x => f(x) + g(x);
fn sum<F, G>(f: F, g: G) -> Box<(impl Fn(i32) -> i32)>
where F: Fn(i32) -> i32,
G: Fn(i32) -> i32
{
    Box::new(move |x: i32| f(x) + g(x))
}

fn main() {
    let f1 = |x: i32| x * x;
    let f2 = |x: i32| x * 2 + 1;
    let a = sum(f1, f2);
    println!("{}", a(1i32));
    println!("{}", a(2i32));
    println!("{}", a(3i32));
}
```

‰ΩøÁî® Box ‰πüÊòØÂèØ‰ª•ÁöÑÔºåÂÖ∂ÂÆûËøô‰πàÂÜôÊå∫ËõãÁñºÁöÑÔºåÂøÖÈ°ªË¶ÅÁî® trait objectÔºåÂõ†‰∏∫Èó≠ÂåÖÁöÑÁ±ªÂûãÊòØÂåøÂêçÁöÑ„ÄÇÂ¶ÇÊûúÈó≠ÂåÖÊòØ‰º†ÂÖ•ÁöÑÔºåÈÇ£‰πà‰º†ÂÖ•ÁöÑÁ±ªÂûãÊòØÂèØ‰ª•Êé®ÂÄíÂá∫Êù•ÁöÑÔºåÂ¶ÇÊûúÊ≤°Êúâ‰º†ÂÖ•ÔºåÂ∞±ÂæàÈ∫ªÁÉ¶‰∫Ü„ÄÇ


## ‚ö° Macros ÂÆèÁºñÁ®ã
- [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
- [The Little Book of Rust Macros](https://danielkeep.github.io/tlborm/book/index.html)
- [Introduction to Procedural Macros in Rust](https://tinkering.xyz/introduction-to-proc-macros/)
- [Procedural Macros in Rust 2018](https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html)
- [3.2. Procedural Macros](https://doc.rust-lang.org/reference/procedural-macros.html)
- https://doc.rust-lang.org/rust-by-example/macros.html
- https://doc.rust-lang.org/book/ch19-06-macros.html
- https://doc.rust-lang.org/stable/reference/attributes.html#active-and-inert-attributes
- https://docs.rs/json/0.12.4/json/


È¶ñÂÖàÔºå‰∏çÂÉè C/C++ ÁöÑÂÆèÂÆö‰πâÔºåÂè™ÊòØÁÆÄÂçïÁöÑ‰ª£Á†ÅÈ¢ÑÂ§ÑÁêÜÁ®ãÂ∫èÔºåÁî®ÂÆè‰ª£Á†ÅÊõøÊç¢‰∏Ä‰∏ãÈÉ®ÂàÜÊ∫ê‰ª£Á†Å„ÄÇRust ÁöÑÂÆèÂÖ∑ÊúâÁõ∏ÂΩìÂ§çÊùÇÁöÑÂäüËÉΩÔºåÊõ¥Ë¥¥ËøëÁºñËØëÂô®ÁöÑËØ≠Ê≥ïÊ†ëÂ§ÑÁêÜ„ÄÇ

ÁÆÄÂçïÂú∞ËØ¥ÔºåRust ÂÆèÂ∞±ÊòØÂÜÖÂµåÁöÑ DSL - Domain Specific Languages ÂèØ‰ª•ËÆ©‰Ω†ÂèØ‰ª•ÂèëÊòéËá™Â∑±ÁöÑËØ≠Ê≥ïÔºåÁºñÂÜôÂá∫ÂèØ‰ª•Ëá™Ë°åÂ±ïÂºÄÁöÑ‰ª£Á†ÅÔºåÂπ∂‰∏îËøòÂèØ‰ª•ÂÆûÁé∞ÈùôÊÄÅÂèçÂ∞ÑÂäüËÉΩ„ÄÇ

ÂÆèÁöÑÂ∫îÁî®ÊòØÁ¨¶Âêà DRY (Don't Repeat Yourself) ËΩØ‰ª∂Â∑•Á®ãÂéüÁêÜÁöÑÔºåÊúâËΩÆÂ≠êÁöÑËΩ¶Â∞±ËÆ©ÂÆÉË∑ëÔºåÊ≤°ÊúâÂøÖË¶ÅÈáçÊñ∞ÈÄ†ËΩÆÂ≠êÔºåDon't write DRY code!

ÈÄöËøá `macro_rules` ÂÖ≥ÈîÆÂ≠óÂÆö‰πâÁöÑ‰∏ÄÁ≥ªÂàóËßÑÂàôÔºåÂú®Ë∞ÉÁî®ÂÆèÊó∂ÔºåÁºñËØëÂô®‰ºöÂÖàÂåπÈÖçËßÑÂàôÔºåÂåπÈÖç‰∏≠ÁöÑ $expansion ÊâçË¢´Â±ïÂºÄ„ÄÇ

Èô§‰∫Ü‰ΩøÁî® `macro_rules` ÂÖ≥ÈîÆÂ≠óÂÆö‰πâÂÆèËßÑÂàôÔºåRust Êúâ‰∏âÁßçÂÆèÁ®ãÂ∫èÔºö

- Function-like macros - `custom!(...)` ‰ΩøÁî® `#[proc_macro]` ÂÆö‰πâÔºõ
- Derive macros - `#[derive(CustomDerive)]` ‰ΩøÁî® `#[proc_macro_derive]` ÂÆö‰πâÔºõ
- Attribute macros - `#[CustomAttribute]` ‰ΩøÁî® `#[proc_macro_attribute]` ÂÆö‰πâÔºõ

ÂÆèÁ®ãÂ∫è‰ΩøÁî® Cargo new --lib ÂëΩ‰ª§ÂàõÂª∫‰∏Ä‰∏™Â∫ìÔºåÂπ∂‰∏îÊåáÂÆö proc-macro Á±ªÂûãÔºåËøôÊ†∑ÊâçËÉΩÂ§ü‰ΩøÁî®ËøáÁ®ãÂÆèÔºö

    [lib]
    proc-macro = true

    [dependencies]
    quote = "1.0"
    syn = "1.0"
    proc-macro2 = "1.0"


ÂÆèÁ®ãÂ∫è‰∏éÂáΩÊï∞ÁöÑÂå∫Âà´Âú®‰∫éÂêéÁºÄÁöÑÊÑüÂèπÂè∑Ôºö

```rust,ignore
macro_rules! $name {
    ($pattern) => {$expansion}; // $rule0 ;
    ($pattern) => {$expansion}; // $rule1 ;
    ($pattern) => {$expansion}; // ...
    ($pattern) => {$expansion}; // $ruleN ;
}
```

ÂÆèËá≥Â∞ëÂÆö‰πâ‰∏ÄÊù°ËßÑÂàôÔºåÊúÄÂêé‰∏ÄÊù°ËßÑÂàôÁöÑÂàÜÂè∑ÂèØÁúÅÁï•„ÄÇ

ÂàóÂ¶ÇÔºåÊúâ‰ª•‰∏ãËøôÊ†∑‰∏Ä‰∏™ÂÆèÂÆö‰πâÔºö

    macro_rules! four {
        () => {1 + 3};
    }

Ë∞ÉÁî®ÂÆèÊó∂ÔºåÁºñËØëÂô®‰ºöÂåπÈÖçÂà∞ËæìÂÖ•‰∏∫Á©∫ÁöÑÊù°‰ª∂ÔºåÂåÖÊã¨ `four!()`, `four![]` or `four!{}` ËøôÂá†ÁßçË∞ÉÁî®ÂΩ¢Âºè„ÄÇ

Patterns ÂèØ‰ª•Á≤æÁ°ÆÂåπÈÖç literal token treesÔºå‰æãÂ¶Ç `4 fn ['spang "whammo"] @_@` ÂØπËßÑÂàôÂ∫îÂ¶Ç‰∏ãÔºö

    macro_rules! gibberish {
        (4 fn ['spang "whammo"] @_@) => {...};
    }

Á§∫ËåÉÔºåËæìÂÖ•ÂåÖÂê´ 3 ‰∏™Ë°®ËææÂºèÁöÑÂåπÈÖçÊ®°ÊùøÔºö

    macro_rules! multiply_add {
        ($a:expr, $b:expr, $c:expr) => {$a * ($b + $c)};
    }

ÂåπÈÖçÊ®°ÊùøÊîØÊåÅ Captures ÂäüËÉΩÔºåËØ≠Ê≥ïÊ†ºÂºè `$identifier:capture`Ôºåcapture Ë°®ËææÂ¶Ç‰∏ãÔºö

- `item`: an item, like a function, struct, module, etc.
- `block`: a block (i.e. a block of statements and/or an expression, surrounded by braces)
- `stmt`: a statement
- `pat`: a pattern
- `expr`: an expression
- `ty`: a type
- `ident`: an identifier is used for variable/function names
- `path`: a path (e.g. `foo`, `::std::mem::replace`, `transmute::<_, int>`, ‚Ä¶)
- `meta`: a meta item; the things that go inside `#[...]` and `#![...]` attributes
- `tt`: a single token tree


ÂåπÈÖçÊ®°ÊùøËøòÊîØÊåÅÈáçÂ§çÔºåËØ≠Ê≥ïÊ†ºÂºè `$ ( ... ) sep rep`ÔºåËøôÁßçÂèÇÊï∞ÂèØÂèòÁöÑÂΩ¢ÂºèÁß∞‰∏∫ Variadic InterfacesÔºö

- `$` is a literal dollar token.
- `( ... )` is the paren-grouped pattern being repeated.
- `sep` is an optional separator token. Common examples are `,`, and `;`.
- `rep` is the required repeat control. 
    - `*` (indicating zero or more repeats)
    - `+` (indicating one or more repeats).

‰æãÂ¶ÇÔºå‰ª•‰∏ãÂÆö‰πâ‰∏Ä‰∏™ÂÆèÁî®Êù•ÂØπÂèÇÊï∞ËøõË°åËÆ°Êï∞Ôºö

```rust
macro_rules! count_tts {
    () => {0usize};
    ($_head:tt $($tail:tt)*) => {1usize + count_tts!($($tail)*)};
}
```

ÂèÇËÄÉ fromat ÂÆèÂÆö‰πâÔºö

```rust,ignore
    /// # Examples
    ///
    /// ```
    /// format!("test");
    /// format!("hello {}", "world!");
    /// format!("x = {}, y = {y}", 10, y = 30);
    /// ```
    #[macro_export]
    #[stable(feature = "rust1", since = "1.0.0")]
    #[cfg_attr(not(test), rustc_diagnostic_item = "format_macro")]
    macro_rules! format {
        ($($arg:tt)*) => {{
            let res = $crate::fmt::format($crate::__export::format_args!($($arg)*));
            res
        }}
    }
```

Á§∫ËåÉÔºåËæìÂÖ•ÂåÖÂê´ 0 ÊàñÂ§öÊù°Ë°®ËææÂºèÁöÑÂåπÈÖçÊ®°ÊùøÔºö

```rust,ignore
    #![allow(unused)]

    #[macro_export]
    macro_rules! vec_strs {
        ( 
            // Start a repetition:
            $( $element:expr ), * 
        ) => {
            // Enclose the expansion in a block so that we can use
            // multiple statements.
            {
                let mut v = Vec::new();

                // Start a repetition:
                $(
                    // Each repeat will contain the following statement, with
                    // $element replaced with the corresponding expression.
                    v.push(format!("{}", $element));
                )*

                v
            }
        };
    }

    fn main() {
        println!("The vector is {}", vec_strs!(1, 2, 3, 4).join(" "));
    }
```

‰ΩøÁî® `#[macro_export]` ÂÖÉÊï∞ÊçÆÊ†áÊ≥®Ë°®Á§∫Êó†ËÆ∫‰ΩïÊó∂ÔºåËøô‰∏™ÂÆèÂØπË±°ÂØπ crate ‰ΩúÁî®ÂüüÈÉΩÊúâÊïà„ÄÇ 


### üü¢üîµ proc_macro ËøáÁ®ãÂÆèÁ®ãÂ∫è

Èô§‰∫Ü‰ΩøÁî® `macro_rules` ÂÖ≥ÈîÆÂ≠óÂÆö‰πâÂÆèËßÑÂàôÔºåRust Êúâ‰∏âÁßçÂÆèÁ®ãÂ∫èÔºö

- Function-like macros - `custom!(...)` ‰ΩøÁî® `#[proc_macro]` ÂÆö‰πâÔºõ
- Derive macros - `#[derive(CustomDerive)]` ‰ΩøÁî® `#[proc_macro_derive]` ÂÆö‰πâÔºõ
- Attribute macros - `#[CustomAttribute]` ‰ΩøÁî® `#[proc_macro_attribute]` ÂÆö‰πâÔºõ

‰ΩøÁî® `#[proc_macro]` ÂÆö‰πâ‰∏Ä‰∏™ÂÖ¨ÂºÄÂáΩÊï∞‰Ωú‰∏∫ÂÆèÁ®ãÂ∫èÔºåÂáΩÊï∞ÁªìÊûÑ (TokenStream) -> TokenStream„ÄÇ
ÂáΩÊï∞ËæìÂÖ•ÁöÑ TokenStream Â∞±ÊòØÂÆèË∞ÉÁî®Êó∂ËæìÂÖ•ÁöÑÂÜÖÂÆπÔºåÂáΩÊï∞ÂêåÊ†∑ËøîÂõûÊäΩË±°ËØ≠Ê≥ïÊ†ë‰ª•Êõø‰ª£ÂÆèË∞ÉÁî®ÁöÑÂÜÖÂÆπ„ÄÇ

‰æãÂ¶ÇÔºå‰ª•‰∏ãÂàõÂª∫‰∏Ä‰∏™ proc_macro_examples lib ÂÆûÁé∞‰∏Ä‰∏™ `answer()` ÂáΩÊï∞ÊèíÂÖ•ÁöÑÂÆèÁ®ãÂ∫èÔºö

```rust,ignore
extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn make_answer(_item: TokenStream) -> TokenStream {
    "fn answer() -> u32 { 42 }".parse().unwrap()
}
```

ÂÆö‰πâÂ•ΩËøáÁ®ãÂÆèÁ®ãÂ∫èÂêéÔºåÂ∞±ÂèØ‰ª•ÂÖ∂ÂÆÉÂ∑•Á®ã‰∏ä‰ΩøÁî®ÔºåÂàõÂª∫‰∏Ä‰∏™ Binary Crate Â∑•Á®ãÊµãËØïËøô‰∏™ÂÆèÁ®ãÂ∫èÔºö

```rust,ignore
extern crate proc_macro_examples;
use proc_macro_examples::make_answer;

make_answer!();

fn main() {
    println!("{}", answer());
}
```

Á±ª‰ººÂú∞ÔºåÂÆö‰πâ‰∏Ä‰∏™ÂèØ‰ª• Derive macrosÔºåÂèØ‰ª•‰ΩøÁî® proc_macro_derive Êù•ÂÆö‰πâÔºö

```rust,ignore
extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_item: TokenStream) -> TokenStream {
    "fn answer() -> u32 { 42 }".parse().unwrap()
}
```

‰ΩøÁî® Derive macros ÊñπÂºèÊúâÁÇπÂ∑ÆÂà´Ôºö

```rust,ignore
extern crate proc_macro_examples;
use proc_macro_examples::AnswerFn;

#[derive(AnswerFn)]
struct Struct;

fn main() {
    assert_eq!(42, answer());
}
```

Derive macro ËøòÂèØ‰ª•ÁªôÂØπË±°Ê∑ªÂä†ËæÖÂä©Â±ûÊÄßÔºåderive macro inert helper attributesÔºåËøô‰∫õÂ±ûÊÄßÊòØ
ÊÉ∞ÊÄßÁöÑÔºåÂÆÉ‰ª¨ÁöÑÂîØ‰∏ÄÁõÆÁöÑÊòØË¢´ËæìÂÖ•Âà∞ÂÆö‰πâÂÆÉ‰ª¨ÁöÑÊ¥æÁîüÂÆè‰∏≠Ôºå‰πüÂ∞±ÊòØËØ¥ÔºåÂÆÉ‰ª¨ÂèØ‰ª•Ë¢´ÊâÄÊúâÂÆèÁúãÂà∞„ÄÇ

‰æãÂ¶ÇÔºå‰ª•‰∏ãÂÆö‰πâ‰∫Ü‰∏Ä‰∏™‰ªÄ‰πà‰πü‰∏çÂÅöÁöÑËæÖÂä©Â±ûÊÄßÔºö

```rust,ignore
#[proc_macro_derive(HelperAttr, attributes(helper))]
pub fn derive_helper_attr(_item: TokenStream) -> TokenStream {
    TokenStream::new()
}
```

ÊºîÁ§∫‰ΩøÁî®Ôºö

```rust,ignore
#[derive(HelperAttr)]
struct Struct {
    #[helper] field: ()
}
```

Attribute macros ÂÆö‰πâÂ§ö‰∫Ü‰∏Ä‰∏™ËæìÂÖ•ÔºåÁ¨¨‰∏ÄËæìÂÖ• TokenStream ‰∏∫Â±ûÊÄßÂêçÂêéÈù¢ÁöÑÂÜÖÂÆπÔºåÁ¨¨‰∫å‰∏™ TokenStream ‰∏∫ÂÆèÂ∫îÁî®ÂØπË±°ÁöÑÂâ©‰ΩôÈÉ®ÂàÜ„ÄÇ

```rust,ignore
#[proc_macro_attribute]
pub fn show_streams(attr: TokenStream, item: TokenStream) -> TokenStream {
    println!("attr: \"{}\"", attr.to_string());
    println!("item: \"{}\"", item.to_string());
    item
}

// src/lib.rs
extern crate my_macro;

use my_macro::show_streams;

// Example: Basic function
#[show_streams]
fn invoke1() {}
// out: attr: ""
// out: item: "fn invoke1() { }"

// Example: Attribute with input
#[show_streams(bar)]
fn invoke2() {}
// out: attr: "bar"
// out: item: "fn invoke2() {}"

// Example: Multiple tokens in the input
#[show_streams(multiple => tokens)]
fn invoke3() {}
// out: attr: "multiple => tokens"
// out: item: "fn invoke3() {}"

// Example:
#[show_streams { delimiters }]
fn invoke4() {}
// out: attr: "delimiters"
// out: item: "fn invoke4() {}"
```

Êé•‰∏ãÊù•Ôºå‰ΩøÁî®Á¨¨‰∏âÊñπÊ®°ÂùóÁºñÂÜôËøáÁ®ãÂÆèÔºåÂú® Rust stable ÁâàÊú¨ÈáåÔºåÈúÄË¶ÅÂÄüÂä©‰∏â‰∏™ crateÔºö

- `syn`ÔºåËøô‰∏™ÊòØÁî®Êù•Ëß£ÊûêËØ≠Ê≥ïÊ†ë(AST)ÁöÑ„ÄÇÂêÑÁßçËØ≠Ê≥ïÊûÑÊàê
- `quote`ÔºåËß£ÊûêËØ≠Ê≥ïÊ†ëÔºåÁîüÊàê Rust ‰ª£Á†ÅÔºå‰ªéËÄåÂÆûÁé∞‰Ω†ÊÉ≥Ë¶ÅÁöÑÊñ∞ÂäüËÉΩ„ÄÇ
- `proc_macro`(std) Âíå proc_macro2(3rd-party)

‰ΩÜÂú® nightly ÁâàÊú¨ÈáåÔºå‰ª•‰∏äÁöÑËøô‰∫õ crate ÈÉΩ‰∏çÈúÄË¶Å‰∫ÜÔºå‰∏ç‰æùËµñÁ¨¨‰∏âÊñπ crateÔºåËøòÊúâÂ∞±ÊòØËØ≠Ê≥ï‰∏äÊòØÁ®çÂæÆÊúâ‰∫õ‰∏çÂêåÔºåÂ§ßÈÉ®ÂàÜÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ

ÂàõÂª∫‰∏Ä‰∏™Â∫ì hello_macro_deriveÔºåÂπ∂ÈÖçÁΩÆ‰æùËµñÔºåËøòÊúâËÆæÁΩÆÂ∫ìÁ±ªÂûã‰∏∫ proc-macroÔºåÂç≥‰∏Ä‰∏™ÂÆèÂ∫ìÔºö

    [lib]
    proc-macro = true

    [dependencies]
    syn = "0.14.4"
    quote = "0.6.3"

ÁÑ∂ÂêéÂú® hello_macro_derive/lib.rs Êñá‰ª∂‰∏≠Ëá™ÂÆö‰πâÂÆèÁöÑÂäüËÉΩÂÆûÁé∞„ÄÇ

```rust,ignore
extern crate proc_macro;

use crate::proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}", stringify!(#name));
            }
        }
    };
    gen.into()
}
```

Ëá™ÂÆö‰πâÂÆè‰ΩøÁî®ÁöÑÊ≥®Ëß£ÊòØ `#[proc_macro_derive(HelloMacro)]`ÔºåÂÖ∂‰∏≠ HelloMacro ÊòØÂÆèÁöÑÂêçÁß∞ÔºåÂú®
‰ΩøÁî®Êó∂ÔºåÂè™ÈúÄË¶Å‰ΩøÁî®Ê≥®Ëß£ `#[derive(HelloMacro)]` Âç≥ÂèØ„ÄÇ

Âú®‰ΩøÁî®Êó∂Êàë‰ª¨Â∫îËØ•ÂÖàÂºïÂÖ•Ëøô‰∏§‰∏™‰æùËµñ

    hello_macro_derive = { path = "../hello_macro_derive" }

ÁÑ∂ÂêéÂÜçÊù•‰ΩøÁî®ÔºåËøôÈáåÂÆö‰πâ‰∏Ä‰∏™ trait ÂêçÂ≠ó HelloMacro ÂíåÊñπÊ≥ïÂêçÂØπÂ∫î‰∏äÈù¢ quote! ÂÆèÂÆö‰πâÁöÑÂÜÖÂÆπÁõ∏ÂåπÈÖçÔºö

```rust,ignore
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

pub trait HelloMacro {
    fn hello_macro();
}

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
```


### üü¢üîµ TokenStream ËØ≠Ê≥ïÊ†ëÊï∞ÊçÆÊµÅÂ§ÑÁêÜ
- https://docs.rs/syn/1.0.1/syn/
- https://docs.rs/quote/1.0.0/quote/
- https://doc.rust-lang.org/proc_macro/
- https://docs.rs/proc-macro2/1.0.0/proc_macro2/

Âú®ËøôÈáåÔºåÂæàÊúâÂøÖË¶Å‰ªéÁºñËØëÂô®ËØ≠Ê≥ïÊ†ëÊûÑÂª∫ÂéüÁêÜÁöÑËßíÂ∫¶Êù•Ëß£ÊûêÂÆèÁöÑÊ¶ÇÂøµ„ÄÇ

Rust Á≥ªÁªü‰∏≠ÊúâËÆ∏Â§öÁ±ªÂûãÁöÑ TokensÔºö

- Identifiers: foo, Bambous, self, we_can_dance, LaCaravane, ‚Ä¶
- Integers: 42, 72u32, 0_______0, ‚Ä¶
- Keywords: _, fn, self, match, yield, macro, ‚Ä¶
- Lifetimes: 'a, 'b, 'a_rare_long_lifetime_name, ‚Ä¶
- Strings: "", "Leicester", r##"venezuelan beaver"##, ‚Ä¶
- Symbols: [, :, ::, ->, @, <-, ‚Ä¶

Ëøô‰∫õ‰ºöÂá∫Áé∞Âú®‰ª£Á†Å‰∏≠ÁöÑ Tokens ÁªèËøáÁºñËØëÂô®ÂàùÊ≠•Â§ÑÁêÜÔºåÂ∞±‰ºöËΩ¨Êç¢Êàê AST - Abstract Syntax TreeÔºå
Token trees ÂàôÊòØ‰ªã‰∫é Tokens ‰∏é AST ‰πãÈó¥ÁöÑ‰∏úË•ø„ÄÇ‰ª•Ê†ëÁä∂Êï∞ÊçÆÁªìÊûÑÊñπÂºèÂ≠òÊîæÔºåÊâÄ‰ª•Âè´ÂÅöËØ≠Ê≥ïÊ†ë„ÄÇ

Â∞ÜÊ∫ê‰ª£Á†ÅÁöÑÂ≠óÁ¨¶ÊµÅËΩ¨Êç¢Êàê Token ÊòØÁºñËØëÂéüÁêÜÊúÄÂºÄÂßãÁöÑÈÉ®ÂàÜÔºåÂÅöËøô‰∏ÄÊ≠•Â∑•‰ΩúÁöÑÁ®ãÂ∫èÂè´ÂÅö Lexical Analyzer
ËØçÊ≥ïÂàÜÊûêÂô®ÔºåÁÑ∂ÂêéÂ∞ÜÊ∫ê‰ª£Á†Å‰∏≠Â≠óÁ¨¶‰∏≤‰∏≠ÁöÑ Tokens ËΩ¨Êç¢‰∏∫ ASTÔºåËøô‰∏ÄÊ≠•ÂØπÂ∫îÁöÑÁ®ãÂ∫èÂè´ÂÅö Syntax AnalyzerÔºå
Âç≥ËØçÊ≥ïËß£ÊûêÂô® Parser„ÄÇ

ÁºñÂÜôËøáÁ®ãÂÆèÔºåÈÄöÂ∏∏ÈúÄË¶ÅÂÄüÂä©‰∏â‰∏™ crate Êù•Ëß£ÊûêËØ≠Ê≥ïÊ†ë‰∏≠ÁöÑËäÇÁÇπÊï∞ÊçÆ:

001. syn Ê®°ÂùóÁî®Êù•Ëß£ÊûêËØ≠Ê≥ïÊ†ë(AST)ÁöÑÂêÑÁßçËØ≠Ê≥ïÊûÑÊàêÔºåÂç≥ÊòØ Syntax Analyzer„ÄÇ
002. quote Ëß£ÊûêËØ≠Ê≥ïÊ†ëÔºåÁîüÊàê Rust ‰ª£Á†ÅÔºå‰ªéËÄåÂÆûÁé∞ÊÉ≥Ë¶ÅÁöÑÂäüËÉΩ„ÄÇ
003. proc_macro(std) Âíå proc_macro2(3rd-party)

‰æãÂ¶ÇÔºå‰ª•‰∏ãÊòØ‰ΩøÁî® `println!("{input:#?}");` ÊâìÂç∞ `2, 2` Ëøô‰∏™Ë°®ËææÂºèÂØπÂ∫îÁöÑ TokenStream ÂØπË±°Ôºö

    TokenStream [
        Literal {
            kind: Integer,
            symbol: "2",
            suffix: None,
            span: #0 bytes(615..616),
        },
        Punct {
            ch: ',',
            spacing: Alone,
            span: #0 bytes(616..617),
        },
        Literal {
            kind: Integer,
            symbol: "2",
            suffix: None,
            span: #0 bytes(618..619),
        },
    ]

‰ª•‰∏ãËøô‰∏™ÁÆÄÂçïË°®ËææÂºè‰∏∫‰æãÔºö

    a + b + (c + d[0]) + e

Ë°®ËææÂºèÁªèËøáÁºñËØëÂô® Parser ËøáÁ®ãÂêéÔºåËΩ¨Âåñ‰∏∫‰ª•‰∏ãËøôÊ†∑ÁöÑ ASTÔºåÂΩìÁÑ∂ÂÆÉÂú®ÂÜÖÂ≠ò‰∏≠ÁöÑÊï∞ÊçÆÂπ∂‰∏çÊòØÈïøËøôÊ†∑ÔºåËøôÈáåÂè™ÊòØÂõæÂΩ¢Â∞ÜÊï∞ÊçÆÂÖ≥Á≥ªË°®ËææÂá∫Êù•ËÄåÂ∑≤Ôºö

                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ BinOp   ‚îÇ
                  ‚îÇ op: Add ‚îÇ
                ‚îå‚ï¥‚îÇ lhs: ‚óå  ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ rhs: ‚óå  ‚îÇ‚ï∂‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Var     ‚îÇ‚ï∂‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚ï¥‚îÇ BinOp   ‚îÇ
    ‚îÇ name: a ‚îÇ                 ‚îÇ op: Add ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îå‚ï¥‚îÇ lhs: ‚óå  ‚îÇ
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ rhs: ‚óå  ‚îÇ‚ï∂‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ Var     ‚îÇ‚ï∂‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚ï¥‚îÇ BinOp   ‚îÇ
                  ‚îÇ name: b ‚îÇ                 ‚îÇ op: Add ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îå‚ï¥‚îÇ lhs: ‚óå  ‚îÇ
                                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ rhs: ‚óå  ‚îÇ‚ï∂‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                ‚îÇ BinOp   ‚îÇ‚ï∂‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚ï¥‚îÇ Var     ‚îÇ
                                ‚îÇ op: Add ‚îÇ                 ‚îÇ name: e ‚îÇ
                              ‚îå‚ï¥‚îÇ lhs: ‚óå  ‚îÇ                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ rhs: ‚óå  ‚îÇ‚ï∂‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ Var     ‚îÇ‚ï∂‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚ï¥‚îÇ Index   ‚îÇ
                  ‚îÇ name: c ‚îÇ               ‚îå‚ï¥‚îÇ arr: ‚óå  ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ind: ‚óå  ‚îÇ‚ï∂‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                ‚îÇ Var     ‚îÇ‚ï∂‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚ï¥‚îÇ LitInt  ‚îÇ
                                ‚îÇ name: d ‚îÇ                 ‚îÇ val: 0  ‚îÇ
                                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

ÊØè‰∏™ÊñπÂùóÈÉΩË°®Á§∫ AST ÁöÑ‰∏Ä‰∏™ËäÇÁÇπÔºåÂØπÂ∫îÁöÑÊòØ‰∏ÄÁßçÊìç‰ΩúÔºåÂÆÉÂê´Êúâ‰∏§‰∏™ËæìÂÖ•ÔºåËøôÊ†∑ÁöÑÁªìÊûÑÈùûÂ∏∏ÊúâÂà©‰∫é‰∫åÂèâÊ†ëËøôÁßçÊï∞ÊçÆÁªìÊûÑÁöÑÂÆûÁé∞„ÄÇ

ÂèçËøáÊù•ÔºåÊ†πÊçÆ AST ÂèØ‰ª•ÊûÑÈÄ†Âá∫‰ªªÊÑèËØ≠Ê≥ïÁöÑÁªìÊûÑÁöÑÊ∫ê‰ª£Á†ÅÔºö

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Let         ‚îÇ
    ‚îÇ name: eight ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ init: ‚óå     ‚îÇ‚ï∂‚îÄ‚ï¥‚îÇ BinOp   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ op: Mul ‚îÇ
                    ‚îå‚ï¥‚îÇ lhs: ‚óå  ‚îÇ                    -----------> let eight = 2 * four!();
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ rhs: ‚óå  ‚îÇ‚ï∂‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ LitInt ‚îÇ‚ï∂‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚ï¥‚îÇ Macro      ‚îÇ
         ‚îÇ val: 2 ‚îÇ                 ‚îÇ name: four ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ body: ()   ‚îÇ
                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Rust ÁºñËØëÂô®Âú®Â±ïÂºÄÂÆèÊó∂Ôºå‰ºöÊúâ‰∏çÂêåÁöÑ‰ΩøÁî®ÂΩ¢ÂºèÔºö

- `# [ $arg ];` attributes style, e.g. `#[derive(Clone)]`, `#[no_mangle]`, ‚Ä¶
- `#![ $arg ];` e.g. `#![allow(dead_code)]`, `#![crate_name="blang"]`, ‚Ä¶
- `$name! $arg;` e.g. `println!("Hi!")`, `concat!("a", "b")`, ‚Ä¶
- `$name! $arg0 $arg1;` e.g. `macro_rules! dummy { () => {}; }`.

ÂØπ‰∫éÁ¨¨‰∏âÁßçÂΩ¢Âºè `$name! $arg`ÔºåÈóÆÈ¢òÊòØ Rust Ëß£ÊûêÂô®Â¶Ç‰ΩïÁü•ÈÅìÊØè‰∏™ $arg ÂèØËÉΩÁöÑËØ≠Ê≥ïÊâ©Â±ïÁöÑÊòØ‰ªÄ‰πàÊ†∑Â≠êÁöÑÔºü
Á≠îÊ°àÊòØ‰∏çÂøÖ„ÄÇÁõ∏ÂèçÔºåËØ≠Ê≥ïÊâ©Â±ïË∞ÉÁî®ÁöÑÂèÇÊï∞ÊòØÂçï‰∏™‰ª§ÁâåÊ†ë„ÄÇÊõ¥ÂÖ∑‰ΩìÂú∞ËØ¥ÔºåÂÆÉÊòØ‰∏Ä‰∏™Âçï‰∏ÄÁöÑÔºåÊó†Â≠êÂè∂ Token TreeÔºõ

‚úÖ Crate Syn

Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.

Currently this library is geared toward use in Rust procedural macros, but contains 
some APIs that may be useful more generally.

- **Data structures** ‚Äî Syn provides a complete syntax tree that can represent 
    any valid Rust source code. The syntax tree is rooted at **syn::File** which 
    represents a full source file, but there are other entry points that may be 
    useful to procedural macros including **syn::Item**, **syn::Expr** and **syn::Type**.

- **Derives** ‚Äî Of particular interest to derive macros is **syn::DeriveInput** which
    is any of the three legal input items to a derive macro. An example below shows 
    using this type in a library that can derive implementations of a user-defined trait.

- **Parsing** ‚Äî Parsing in Syn is built around parser functions with the signature 
    `fn(ParseStream) -> Result<T>`. Every syntax tree node defined by Syn is individually 
    parsable and may be used as a building block for custom syntaxes, or you may 
    dream up your own brand new syntax without involving any of our syntax tree types.

- **Location information** ‚Äî Every token parsed by Syn is associated with a Span 
    that tracks line and column information back to the source of that token. 
    These spans allow a procedural macro to display detailed error messages 
    pointing to all the right places in the user's code. There is an example of this below.

- **Feature flags** ‚Äî Functionality is aggressively feature gated so your procedural 
    macros enable only what they need, and do not pay in compile time for all the rest.


Example of a derive macro

The canonical derive macro using Syn looks like this. We write an ordinary Rust 
function tagged with a **proc_macro_derive** attribute and the name of the trait 
we are deriving. Any time that derive appears in the user's code, the Rust compiler 
passes their data structure as tokens into our macro. We get to execute arbitrary 
Rust code to figure out what to do with those tokens, then hand some tokens back 
to the compiler to compile into the user's crate.


```rust,ignore
extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyMacro)]
pub fn my_macro(input: TokenStream) -> TokenStream {
    // Parse the input tokens into a syntax tree
    let input = parse_macro_input!(input as DeriveInput);

    // Build the output, possibly using quasi-quotation
    let expanded = quote! {
        // ...
    };

    // Hand the output tokens back to the compiler
    TokenStream::from(expanded)
}
```

‚úÖ Crate quote

The following quasi-quoted block of code is something you might find in a procedural 
macro having to do with data structure serialization. The #var syntax performs 
interpolation of runtime variables into the quoted tokens. 

Check out the documentation of the **quote!** macro for more detail about the syntax.

See also the **quote_spanned!** macro which is important for implementing hygienic procedural macros.


```rust,ignore
let tokens = quote! {
    struct SerializeWith #generics #where_clause {
        value: &'a #field_ty,
        phantom: core::marker::PhantomData<#item_ty>,
    }

    impl #generics serde::Serialize for SerializeWith #generics #where_clause {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #path(self.value, serializer)
        }
    }

    SerializeWith {
        value: #value,
        phantom: core::marker::PhantomData::<#item_ty>,
    }
};
```


‚úÖ Crate proc_macro2

A wrapper around the procedural macro API of the compiler's proc_macro crate. 
This library serves two purposes:

- Bring proc-macro-like functionality to other contexts like build.rs and main.rs. 

Types from proc_macro are entirely specific to procedural macros and cannot ever 
exist in code outside of a procedural macro. Meanwhile proc_macro2 types may exist 
anywhere including non-macro code. By developing foundational libraries like syn 
and quote against proc_macro2 rather than proc_macro, the procedural macro ecosystem 
becomes easily applicable to many other use cases and we avoid reimplementing 
non-macro equivalents of those libraries.

- Make procedural macros unit testable. 

As a consequence of being specific to procedural macros, nothing that uses proc_macro 
can be executed from a unit test. In order for helper libraries or components of 
a macro to be testable in isolation, they must be implemented using proc_macro2.


Usage
The skeleton of a typical procedural macro typically looks like this:

```rust,ignore
extern crate proc_macro;

#[proc_macro_derive(MyDerive)]
pub fn my_derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let input = proc_macro2::TokenStream::from(input);

    let output: proc_macro2::TokenStream = {
        /* transform input */
    };

    proc_macro::TokenStream::from(output)
}
```

If parsing with Syn, you'll use parse_macro_input! instead to propagate parse errors correctly back to the compiler when parsing fails.




# üü°üü† Reflection
- https://doc.rust-lang.org/stable/std/any
- https://doc.rust-lang.org/stable/std/any/struct.TypeId.html
- https://doc.rust-lang.org/stable/std/intrinsics/fn.type_id.html

Rust ÊòØÈùôÊÄÅÁ±ªÂûãËØ≠Ë®ÄÔºå‰∏çÂÉè Java ËøôÁ±ª‰ΩøÁî®ËôöÊãüÊú∫ÁöÑËØ≠Ë®ÄÔºåÊ≤°ÊúâÂº∫Â§ßÁöÑÂèçÂ∞ÑÊú∫Âà∂„ÄÇRust Êèê‰æõÁöÑÂèçÂ∞Ñ‰∏ÄÁßçÁºñËØëÊó∂ÂèçÂ∞ÑÔºåÂè™ËÉΩÂØπ `'static` ÁîüÂëΩÂë®ÊúüÁöÑÂèòÈáèÔºàÂ∏∏ÈáèÔºâËøõË°åÂèçÂ∞ÑÔºÅ

Ruat Êèê‰æõ trait Any Êù•Ê®°Êãü‰∏Ä‰∏™Âä®ÊÄÅÁ±ªÂûãÔºåÂÆÉÊú¨Ë∫´Â∞±ÊòØ `'static`ÔºåÁªìÂêà TypeId Êèê‰æõ‰∫ÜÁÆÄÂçïÁöÑËøêË°åÊó∂ÂèçÂ∞ÑÁöÑËÉΩÂäõ„ÄÇ‰ΩøÁî®ÂÆÉ‰ª¨ÔºåÂ∞±ÂèØ‰ª•Áî®Êù•ÂÆûÁé∞‰æùËµñÂèçËΩ¨Ê®°ÂºèÔºåÂÆûÁé∞‰ªªÊÑèÁ±ªÂûãÂÆπÂô®„ÄÇ

```rust,ignore
#![feature(type_name_of_val)]
use std::any::{Any, TypeId, type_name_of_val};

let boxed: Box<dyn Any> = Box::new(3_i32);

// You're more likely to want this:
let actual_id = (&*boxed).type_id();
// ... than this:
let boxed_id = boxed.type_id();

assert_eq!(actual_id, TypeId::of::<i32>());
assert_eq!(boxed_id, TypeId::of::<Box<dyn Any>>());
assert_eq!("core::any::TypeId", type_name_of_val(&actual_id));
```

Èô§‰∫Ü trait Any ÂÆö‰πâÁöÑ type_id ÊñπÊ≥ïÔºåÂú® std::any Ê®°ÂùóËøò‰∏∫‰ª•‰∏ã‰∏âÁßç `dyn Any` Á±ªÂûãÂÆûÁé∞‰∫ÜÂè¶Â§ñ‰∏â‰∏™ÊñπÊ≥ïÔºö

```rust,ignore
pub trait Any: 'static {
    pub fn type_id(&self) -> TypeId;
}

impl dyn Any + 'static
impl dyn Any + 'static + Send
impl dyn Any + 'static + Send + Sync

pub fn is<T: Any>(&self) -> bool
pub fn downcast_ref<T: Any>(&self) -> Option<&T>
pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T>
```

TypeId ÂåÖÂê´Á±ªÂûãÊ†áËØÜÔºåÂêå‰∏ÄÁßçÁ±ªÂûãÂΩìÁÑ∂ÂÖ∑ÊúâÁõ∏ÂêåÁöÑÁ±ªÂûãÊ†áËØÜ„ÄÇ

```rust,ignore
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[stable(feature = "rust1", since = "1.0.0")]
pub struct TypeId {
    t: u64,
}

impl TypeId {
    #[stable(feature = "rust1", since = "1.0.0")]
    #[rustc_const_unstable(feature = "const_type_id", issue = "77125")]
    pub const fn of<T: ?Sized + 'static>() -> TypeId {
        TypeId { t: intrinsics::type_id::<T>() }
    }
}
```



# üü°üü† Test Ëá™Âä®ÊµãËØï
- https://doc.rust-lang.org/book/ch11-00-testing.html
- https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests
- https://doc.rust-lang.org/book/ch12-04-testing-the-librarys-functionality.html

Ëá™Âä®ÂåñÊµãËØïÊòØÁé∞‰ª£ÂåñÁºñÁ®ãÂøÖ‰∏çÂèØÂ∞ëÁöÑÂ∑•ÂÖ∑ÔºåÂÆÉËÉΩÊûÅÊúâÊïàÂú∞ÊèêÈ´òÁ®ãÂ∫èÂºÄÂèëÊïàÁéáÔºåÂêåÊó∂Êõ¥ÊúâÊïàÂú∞ÊèêÈ´òËΩØ‰ª∂ÁöÑÂèØÁî®ÊÄß„ÄÇ‰ªéËøôÁÇπÂá∫ÂèëÔºåÊúâ‰∏ÄÁßçÂºÄÂèëÊ®°ÂºèÂ∞±Âè´ÂÅöÊµãËØïÈ©±Âä®ÂºÄÂèë TDD - Test-Driven Development„ÄÇ

- ÁºñÂÜôÊúüÊúõÂæóÂà∞ fails ÁöÑÊµãËØï„ÄÇ
- ÁºñÂÜôÊàñ‰øÆÊîπ‰ª£Á†Å‰ª•‰ΩøÊñ∞ÁöÑÊµãËØïÈÄöËøá„ÄÇ
- ÈáçÊûÑÂàöÂàöÊ∑ªÂä†ÊàñÊõ¥ÊîπÁöÑ‰ª£Á†ÅÔºå‰øùÊåÅÊµãËØïÈÄöËøá„ÄÇ
- ÈáçÂ§ç step 1!

Edsger W. Dijkstra Âú®‰ªñ 1972 Âπ¥ÁöÑËÆ∫Êñá„ÄäË∞¶ÂçëÁöÑÁ®ãÂ∫èÂëò„Äã‰∏≠ËØ¥Ôºö‚ÄúÊµãËØï‰ª•‰∏ÄÁßçÈùûÂ∏∏ÊúâÊïàÁöÑÊñπÊ≥ïÊù•ÊòæÁ§∫ bug ÁöÑÂ≠òÂú®Ôºå‰ΩÜÊòØÂÆÉÂØπ‰∫éÊòæÁ§∫ bug ÁöÑ‰∏çÂ≠òÂú®ÊòØÊó†Ê≥ïÂÆûÁé∞ÁöÑ„ÄÇ‚Äù

Rust Êèê‰æõ‰∫Ü‰∏Ä‰∫õÂÆèÂ∏ÆÂä©ÁºñÂÜôÊµãËØïËÑöÊú¨ÔºåÂ¶ÇÂ∞Ü `#[test]` ÂÜôÂú®ÂáΩÊï∞ÂâçË°®Á§∫‰∏Ä‰∏™ÊâßË°åÊµãËØïÊó∂ cargo test ËøêË°åÁöÑÂáΩÊï∞Ôºö

```rust,ignore
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}
```

‰ΩøÁî®`#[test]`Ëøô‰∏™ÂÆèÊ†áËÆ∞ÁöÑÂáΩÊï∞ÔºåÂú®‰ΩøÁî® cargo build ÁºñËØëÊó∂ÔºåÂ∞±‰ºöË¢´ÂøΩÁï•ÔºåËÄå‰ΩøÁî® cargo test ÂèØ‰ª•ËøêË°åËøô‰∫õÂáΩÊï∞„ÄÇ

ËøòÂèØ‰ª•ÊåáÂÆöÂ§öÁ∫øÁ®ãËøõË°åÊµãËØïÔºåÊàñËÄÖ‰ΩøÁî®`show-output`ÊòæÁ§∫ `println!()` ÊâìÂç∞ÁöÑ‰ø°ÊÅØÔºö

    cargo test -- --test-threads=2
    cargo test -- --show-output

ÂèàÊàñËÄÖÊåáÂÆöÊâßË°åÊüê‰∏™ÊµãËØïÂáΩÊï∞Ôºå‰πüÂèØ‰ª•Âè™ÊåáÂÆöÂâçÁºÄÔºåËøôÊ†∑ÂèØ‰ª•ËøêË°åÊüê‰∫õÊµãËØïÂáΩÊï∞Ôºö

    cargo test it_works


Âà©Áî®‰ª•‰∏ãÂÆèÂèØ‰ª•ËøõË°åÊñ≠Ë®ÄÔºåÂØπÈúÄË¶ÅËøõË°åÊµãËØïÁöÑ‰ª£Á†ÅËøîÂõûÂÄºËøõË°åÊØîËæÉÔºö

- `assert!(boolean)` ‰øùËØÅÊù°‰ª∂ÊàêÁ´ã„ÄÇ
- `assert_eq!(a, b)` ‰øùËØÅ‰∏§‰∏™ÂÄºÁ≠â‰ª∑„ÄÇ
- `assert_ne!(a, b)` ‰øùËØÅ‰∏§‰∏™ÂÄº‰∏çÁ≠â‰ª∑„ÄÇ

```rust,ignore
let a = 3; let b = 27;
assert!(a + b == 30, "a = {}, b = {}", a, b);
assert_eq!(a, b, "we are testing addition with {} and {}", a, b);
```

Â¶ÇÊûúË¢´ÊµãËØïÁöÑ‰ª£Á†ÅÂú®ÊåáÂÆöÊù°‰ª∂ÊâßË°åÊó∂‰ºö panicÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•Âú®ÊµãËØïÊñπÊ≥ï‰∏≠‰ΩøÁî® `#[should_panic]` ÊèêÁ§∫ Rust„ÄÇ

```rust,ignore
#[test]
#[should_panic(expected = "Guess value must be less than or equal to 100")]
fn greater_than_100() {
    Guess::new(200);
}
```

ÂØπ‰∫éÂ§çÊùÇÁöÑÊù°‰ª∂ÔºåÂèØ‰ª•Âú®ÊµãËØïÂáΩÊï∞‰∏≠‰ΩøÁî®`Result<T, E>`ÔºåËøîÂõû Ok ÂÄºË°®Á§∫ÈÄöËøáÊµãËØïÔºö

```rust,ignore
#[test]
fn it_works_2() -> Result<(), String> {
    if 2 + 2 == 4 {
        Ok(())
    } else {
        Err(String::from("two plus two does not equal four"))
    }
}
```

Â¶ÇÊûúÊüê‰∏™ÊµãËØïÂáΩÊï∞ÈùûÂ∏∏ËÄóÊó∂ÔºåÊàñÊöÇÊó∂Ê≤°Êõ¥Êñ∞ÔºåÂèØ‰ª•‰ΩøÁî®`#[ignore]`ÂÆèÊ†áËÆ∞ÂÆÉÔºå‰∏çËÆ©ÂÆÉÂèÇ‰∏éÊµãËØïÔºö

```rust,ignore
#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
```

Rust ÁöÑÊµãËØïÁâπÊÄßÊåâÁ≤æÁªÜÂ∫¶ÂàíÂàÜÔºåÂàÜ‰∏∫ÂáΩÊï∞Á∫ß„ÄÅÊ®°ÂùóÁ∫ß„ÄÅÂ∑•Á®ãÁ∫ß 3 ‰∏™Â±ÇÊ¨°ÔºåÊâßË°åÊµãËØï‰πüÂØπÂ∫îÊúâ 3 ‰∏™ÊµãËØïËæìÂá∫„ÄÇÊúÄÂêéÔºåËøòÊúâ Doc-tests ËæìÂá∫ÁöÑÊòØÊ≥®Ëß£ÊñáÊ°£ÈÉ®ÂàÜÁöÑÊµãËØï„ÄÇ

Â∑•Á®ãÁ∫ßÁöÑÊµãËØïËÑöÊú¨Âú®Ê†πÊçÆËÆøË∞àÂΩï‰∏ãÁöÑ tests Êñá‰ª∂Â§πÂÆö‰πâÔºå‰ª£Á†ÅÊñá‰ª∂Âêç‰ªªÊÑè„ÄÇ

ÂØπ‰∫éÈúÄË¶ÅÂú®Â§ö‰∏™ÊµãËØïÂáΩÊï∞‰ΩøÁî®ÁöÑÈÖçÁΩÆÔºåÂèØ‰ª•Âú® tests/common.rs ÂÆö‰πâÔºåÂ¶Ç‰∏ãÔºö

```rust,ignore
pub fn setup() {
    // setup code specific to your library's tests would go here
}
```

Âú®ÂÖ∂ÂÆÉÊµãËØïÂáΩÊï∞ÈúÄË¶Å‰ΩøÁî®Êó∂ÔºåÂºïÁî®‰ª•‰∏äÂÆö‰πâÁöÑÂáΩÊï∞Ôºö

```rust,ignore
use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
```


‰ΩøÁî® `#[cfg(test)]` ÈÖçÁΩÆ‰∏Ä‰∏™‰Ωú‰∏∫ÊµãËØï‰∏ìÁî®Ê®°ÂùóÊòØÂæàÂ•ΩÁöÑ‰π†ÊÉØÔºåËøôÊ†∑ÁªÑÁªáÁöÑ‰ª£Á†ÅÊõ¥ÊúâÊù°ÁêÜÔºö

```rust,ignore
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

Rust Ê≥®Ëß£ÊñáÊ°£ÊòØÂÖ∑ÊúâÂäüËÉΩÁöÑÔºåÂÆÉÂèØ‰ª•ÈÄöËøáÊ≥®Ëß£ÁîüÊàêÊñáÊ°£ÔºåËÄå‰∏çÊòØÂçïÁã¨ÁºñÂÜôÊñáÊ°£„ÄÇ‰∏ÄÊòØ‰ª£Á†ÅÊú¨Ë∫´ÊòØÊñáÊ°£Ôºå‰∫åÊòØ‰ª£Á†ÅÁöÑÊ≥®ÈáäÂ∞±ÊòØÊñáÊ°£„ÄÇRust ‰∏ç‰ΩÜÂèØ‰ª•Ëá™Âä®ÊäΩÂèñ‰ª£Á†Å‰∏≠ÁöÑÊñáÊ°£ÔºåÂΩ¢ÊàêÊ†áÂáÜÂΩ¢ÂºèÁöÑÊñáÊ°£ÈõÜÂêàÔºåËøòÂèØ‰ª•ÂØπÊñáÊ°£‰∏≠ÁöÑÁ§∫‰æã‰ª£Á†ÅËøõË°åÊµãËØï„ÄÇ

ÊØîÂ¶ÇÔºåÊàë‰ª¨Áªô‰∏äÈù¢Â∫ìÂä†ÁÇπÊñáÊ°£Ôºö

```rust,ignore
//! The `adder` crate provides functions that add numbers to other numbers.
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// This function adds two to its argument.
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```

pub fn add_two(a: i32) -> i32 {
   a + 2
}

#[cfg(test)]
mod tests {
   use super::*;

   #[test]
   fn it_works() {
      assert_eq!(4, add_two(2));
   }
}
```




# üü°üü† Asynchronous ÂºÇÊ≠•ÁºñÁ®ã
- Asynchronous Programming in Rust https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html
- Rust ‰∏≠ÁöÑÂºÇÊ≠•ÁºñÁ®ã https://huangjj27.github.io/async-book/01_getting_started/01_chapter.html
- Rust ÂºÇÊ≠•ÁºñÁ®ã https://learnku.com/docs/async-book/2018/translation-notes/4798


# üü°üü† Fearless Concurrency
- https://doc.rust-lang.org/book/ch16-00-concurrency.html
- https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html
- https://doc.rust-lang.org/stable/std/sync/index.html
- https://doc.rust-lang.org/stable/std/thread/index.html
- „ÄêËØë„ÄëRustÔºåÊó†ÁïèÂπ∂Âèë https://www.cnblogs.com/praying/p/13912955.html
- C++ Concurrency in Action by Anthony Williams https://2lib.org/book/3688262/d57395?id=3688262
- Rust ÁºñÁ®ã‰πãÈÅì Âº†Ê±â‰∏ú https://2lib.org/book/5539891/6f3df0
- Ê∑±ÂÖ•ÊµÖÂá∫ Rust ËåÉÈïøÊò• https://2lib.org/book/5063683/cb5839
- Programming Rust: Fast, Safe Systems Development https://2lib.org/book/3400043/791885

Ê≠§Â∞èËäÇ‰∏ªË¶ÅÂÜÖÂÆπÔºö

- Using Threads to Run Code Simultaneously
- Using Message Passing to Transfer Data Between Threads
- Shared-State Concurrency
- Extensible Concurrency with the Sync and Send Traits

Rust Âè∑Áß∞Êó†ÊâÄÁïèÊÉßÁöÑÂπ∂Âèë Fearless ConcurrencyÔºåÁ©∂Á´üÊúâÂà©ÂÆ≥Âë¢Ôºü

Rust È°πÁõÆÊó®Âú®Ëß£ÂÜ≥Ëøô‰∏§‰∏™Ê£òÊâãÁöÑÈóÆÈ¢òÔºö

- Â¶Ç‰ΩïËøõË°åÂÆâÂÖ®ÁöÑÁ≥ªÁªüÁºñÁ®ãÔºü
- Â¶Ç‰Ωï‰ΩøÂæóÂπ∂ÂèëÊõ¥ÂÆπÊòìÔºü

ÊÑèÂ§ñÁöÑÊòØÂÆÉ‰ª¨Ëß£ÂÜ≥ÊñπÊ°àÊòØ‰∏ÄËá¥ÁöÑÔºöÂÜÖÂ≠òÂÆâÂÖ®ÊºèÊ¥ûÂíåÂπ∂ÂèëÊºèÊ¥ûÈÄöÂ∏∏ÈÉΩÂèØ‰ª•ÂΩíÁªì‰∫éËÆøÈóÆ‰∫Ü‰∏çÂ∫îËØ•ËÆøÈóÆÁöÑÊï∞ÊçÆ„ÄÇRust ÁöÑÁßòÂØÜÊ≠¶Âô®ÊòØÊâÄÊúâÊùÉÊú∫Âà∂ÔºåËøôÊòØÁ≥ªÁªüÁ®ãÂ∫èÂëòËØïÂõæÈÅµÂæ™ÁöÑ‰∏ÄÁßçËÆøÈóÆÊéßÂà∂ÂéüÂàôÔºåËÄå Rust ÁºñËØëÂô®Â∞Ü‰∏∫‰Ω†ÈùôÊÄÅÊ£ÄÊü•„ÄÇ

ÂØπ‰∫éÂÜÖÂ≠òÂÆâÂÖ®ÊÄßÔºåËøôÊÑèÂë≥ÁùÄ‰Ω†ÂèØ‰ª•Âú®Ê≤°ÊúâÂûÉÂúæÊî∂ÈõÜÂô®ÁöÑÊÉÖÂÜµ‰∏ãÁºñÁ®ãÔºåËÄå‰∏î‰∏çÈúÄË¶ÅÂÆ≥ÊÄïÊÆµÈîôËØØÔºåÂõ†‰∏∫ Rust Â∞Ü‰ºöÊçïÊçâ‰Ω†ÁöÑÈîôËØØ„ÄÇ

ÂØπ‰∫éÂπ∂ÂèëÔºåËøôÊÑèÂë≥ÁùÄ‰Ω†ÂèØ‰ª•ÈÄâÊã©ÂêÑÁßçÂêÑÊ†∑ÁöÑËåÉÂºèÔºàÊ∂àÊÅØ‰º†ÈÄíÔºåÂÖ±‰∫´Áä∂ÊÄÅÔºåÊó†ÈîÅÔºåÁ∫ØÂáΩÊï∞ÂºèÔºâÔºåËÄå Rust Â∞Ü‰ºöÂ∏ÆÂä©‰Ω†ÈÅøÂÖçÂ∏∏ËßÅÁöÑÈîôËØØ„ÄÇ

Â§öÁ∫øÁ®ãÈó¥ÂÖ±‰∫´Êï∞ÊçÆÊó∂ÂèØËÉΩ‰ºöÂá∫ÂæàÂ§öÈóÆÈ¢òÔºåÊúÄÂ∏∏ËßÅÁöÑ‰∏§Áßç‰∏ªË¶ÅÈóÆÈ¢òÊòØÔºö

- `Race Conditions` Á´ûÊÄÅÊù°‰ª∂ÔºåÂ∏∏ÂèëÁîü‰∫éÂ§ö‰∏™Á∫øÁ®ã‰ª•‰∏ç‰∏ÄËá¥ÁöÑÈ°∫Â∫èËÆøÈóÆ/‰øÆÊîπÂÖ±‰∫´Êï∞ÊçÆÔºåËøô‰ºöÁ†¥ÂùèÊï∞ÊçÆ‰∏ÄËá¥ÊÄß„ÄÇ
- `Deadlocks` Ê≠ªÈîÅÂèëÁîü‰∫éÂ§ö‰∏™Á∫øÁ®ã‰∫íÁõ∏Á≠âÂæÖÂØπÊñπÈáäÊîæËµÑÊ∫êÂØºËá¥Êó†ÈôêÊåÇËµ∑„ÄÇÊ¥ªÈîÅ livelock Á±ª‰ººÔºå‰ΩÜÊúâ‰∏ÄÂÆöÂá†ÁéáËß£ÂºÄÔºåËÄåÊ≠ªÈîÅÊó†Ëß£„ÄÇ

Ê≠ªÈîÅ‰∫ßÁîüÁöÑÂøÖË¶ÅÊù°‰ª∂Ôºö

- ‰∫íÊñ• mutual exclusionÔºöÁ≥ªÁªüÂ≠òÂú®ÁùÄ‰∏¥ÁïåËµÑÊ∫êÔºõ
- Âç†ÊúâÂπ∂Á≠âÂæÖ hold and waitÔºöÂ∑≤ÁªèÂæóÂà∞Êüê‰∫õËµÑÊ∫êÁöÑËøõÁ®ãËøòÂèØ‰ª•Áî≥ËØ∑ÂÖ∂‰ªñÊñ∞ËµÑÊ∫êÔºõ
- ‰∏çÂèØÂâ•Â§∫ no preemptionÔºöÂ∑≤ÁªèÂàÜÈÖçÁöÑËµÑÊ∫êÂú®ÂÖ∂ÂÆø‰∏ªÊ≤°ÊúâÈáäÊîæ‰πãÂâç‰∏çÂÖÅËÆ∏Ë¢´Ââ•Â§∫Ôºõ
- Âæ™ÁéØÁ≠âÂæÖ circular waitingÔºöÁ≥ªÁªü‰∏≠Â≠òÂú®Â§ö‰∏™ËøõÁ®ãÂΩ¢ÊàêÁöÑÂ∞ÅÈó≠ÁöÑËøõÁ®ãÁ≠âÂæÖÈìæÔºåÊØè‰∏™ËøõÁ®ãÈÉΩÂú®Á≠âÂæÖÂÆÉÁöÑ‰∏ã‰∏Ä‰∏™ËøõÁ®ãÊâÄÂç†ÊúâÁöÑËµÑÊ∫êÔºõ


Âπ∂Âèë„ÄÅÂπ∂Ë°åÔºå‰∏éÂºÇÊ≠•ÊòØÂÆπÊòìÊ∑∑Ê∑ÜÁöÑÊ¶ÇÂøµ„ÄÇ

ÂºÇÊ≠• Asynchronous ‰∏éÂêåÊ≠• Synchronous ÊòØÂØπÁ´ãÊ¶ÇÂøµÔºåÊòØÊèèËø∞‰ª£Á†ÅÊâßË°åÁöÑÊñπÂºè„ÄÇÂºÇÊ≠•ÂèØ‰ª•ËÆ©ÈúÄË¶ÅÁ≠âÂæÖÁöÑ‰ª£Á†ÅËøõÂÖ•ÊöÇÂÅúÁä∂ÊÄÅÔºåÁ≠âÂæÖ‰∏≠Êñ≠‰ø°Âè∑Êù•Âî§ÈÜí„ÄÇÂêåÊó∂ÁªßÁª≠ÊâßË°åÂêéÁª≠ÁöÑ‰ª£Á†ÅÔºåËÄåÂêåÊ≠•Âàô‰∏ç‰ºöËøôÊ†∑ÔºåÂêåÊ≠•‰ºö‰∏ÄËµ∑Á≠âÂæÖÊó∂Èó¥Ê∂àËÄóÂ§ßÁöÑ‰ªªÂä°ÂÆåÊàêËøîÂõûÂêéÊâçÁªßÁª≠ÊâßË°å„ÄÇ

ÂºÇÊ≠•ÔºåÂú®ÂçïÁ∫øÁ®ã‰∏äÂ∞±ÂèØ‰ª•ÂÆûÁé∞ÔºåËÄåÂπ∂Ë°å Parallel ÂàôÈúÄË¶ÅÂ§öÁ∫øÁ®ãÔºåÂç≥Âú®Â§öÊ†∏ËäØ CPU ‰∏äÊâçÊúâÊïàÂäõ„ÄÇËøõÁ®ãÊòØÊìç‰ΩúÁ≥ªÁªüËøõË°åÂÜÖÂ≠òÊàñÁ°¨‰ª∂ËµÑÊ∫êÂàÜÈÖçÁöÑÂü∫Êú¨Âçï‰ΩçÔºåÁ∫øÁ®ãÂàôÊòØÊìç‰ΩúÁ≥ªÁªüÁöÑË∞ÉÂ∫¶Á®ãÂ∫èÊâßË°åÁöÑÂü∫Êú¨Âçï‰Ωç„ÄÇ

Âπ∂Ë°åÊòØÂêåÊó∂ËøêË°å‰ª£Á†Å Run Code SimultaneouslyÔºåÂπ∂ÂèëÁ±ª‰ººÂπ∂Ë°åÔºåÂÖ≥ÈîÆÊòØ‰Ω†ÊúâÂ§ÑÁêÜÂ§ö‰∏™‰ªªÂä°ÁöÑËÉΩÂäõÔºå‰∏ç‰∏ÄÂÆöË¶ÅÂêåÊó∂„ÄÇÂπ∂Ë°åÁöÑÂÖ≥ÈîÆÊòØ‰Ω†ÊúâÂêåÊó∂Â§ÑÁêÜÂ§ö‰∏™‰ªªÂä°ÁöÑËÉΩÂäõ„ÄÇÊâÄ‰ª•ÊàëËÆ§‰∏∫ÂÆÉ‰ª¨ÊúÄÂÖ≥ÈîÆÁöÑÁÇπÂ∞±ÊòØÔºöÊòØÂê¶ÊòØ„ÄéÂêåÊó∂„Äè„ÄÇ

Á∫øÁ®ãÂêåÊ≠• Thread Synchronization Ëøô‰∏ÄÊ¶ÇÂøµÂ∞ÜÂêåÊ≠•Êâ©Â±ïÂà∞Â§öÁ∫øÁ®ãÁ®ãÂ∫è‰∏≠Êù•ÔºåÂÆûÁé∞Á∫øÁ®ãÂêåÊ≠•ÁöÑ‰ª£Á†ÅÂ∞±ÂÖ∑ÊúâÂØπÂêå‰∏ÄÊï∞ÊçÆËÆøÈóÆÁöÑÂêåÊ≠•ËÆøÈóÆÔºåÂÖ∑ÊúâÂ§öÁ∫øÁ®ãÂÆâÂÖ®ÊÄß„ÄÇ

‰∏Ä‰∏™ÊäΩË±°ÁöÑÊØîÂñªÔºö

- ‰Ω†ÂêÉÈ•≠ÂêÉÂà∞‰∏ÄÂçäÔºåÁîµËØùÊù•‰∫ÜÔºå‰Ω†‰∏ÄÁõ¥Âà∞ÂêÉÂÆå‰∫Ü‰ª•ÂêéÊâçÂéªÊé•ÔºåËøôÂ∞±ËØ¥Êòé‰Ω†‰∏çÊîØÊåÅÂπ∂Âèë‰πü‰∏çÊîØÊåÅÂπ∂Ë°å„ÄÇ
- ‰Ω†ÂêÉÈ•≠ÂêÉÂà∞‰∏ÄÂçäÔºåÁîµËØùÊù•‰∫ÜÔºå‰Ω†ÂÅú‰∫Ü‰∏ãÊù•Êé•‰∫ÜÁîµËØùÔºåÊé•ÂÆåÂêéÁªßÁª≠ÂêÉÈ•≠ÔºåËøôËØ¥Êòé‰Ω†ÊîØÊåÅÂπ∂Âèë„ÄÇ
- ‰Ω†ÂêÉÈ•≠ÂêÉÂà∞‰∏ÄÂçäÔºåÁîµËØùÊù•‰∫ÜÔºå‰Ω†‰∏ÄËæπÊâìÁîµËØù‰∏ÄËæπÂêÉÈ•≠ÔºåËøôËØ¥Êòé‰Ω†ÊîØÊåÅÂπ∂Ë°å„ÄÇ

Erlang ‰πãÁà∂ Joe Armstrong Áî®‰∏ÄÂº† 5 Â≤ÅÂ∞èÂ≠©ÈÉΩËÉΩÁúãÊáÇÁöÑÂíñÂï°Êú∫Â∑•‰ΩúÂõæËß£Èáä‰∫ÜÂπ∂Âèë‰∏éÂπ∂Ë°åÁöÑÂå∫Âà´Ôºö

![Erlang](https://pic4.zhimg.com/80/v2-674f0d37fca4fac1bd2df28a2b78e633_1440w.jpg)

- Âπ∂ÂèëÔºö‰∏§‰∏™ÈòüÂàó‰∫§Êõø‰ΩøÁî®‰∏ÄÂè∞ÂíñÂï°Êú∫ÔºåÂç≥‰∏Ä‰∏™Á∫øÁ®ãÂ§ÑÁêÜÂ§ö‰∏™‰ªªÂä°ÔºåÂΩìÁÑ∂ÂÆûÁé∞ÊñπÂºè‰∏ç‰ªÖÈôê‰∫éÂ§öÁ∫øÁ®ã„ÄÅÂ§öËøõÁ®ãÊñπÂºèÔºõ
- Âπ∂Ë°åÔºö‰∏§‰∏™ÈòüÂàóÂêåÊó∂‰ΩøÁî®‰∏§Âè∞ÂíñÂï°Êú∫ÔºåÂç≥Â§ö‰∏™Á∫øÁ®ãÂ§ÑÁêÜÂ§ö‰∏™‰ªªÂä°Ôºõ
- ‰∏≤Ë°åÔºö‰∏Ä‰∏™‰ªªÂä°ÈòüÂàó‰ΩøÁî®‰∏ÄÂè∞ÂíñÂï°Êú∫ÔºåÂ§ö‰∏™‰ªªÂä°ÈòüÂàóÂ∞±ÈúÄË¶ÅÊéíÈô§ÔºåÂç≥‰∏Ä‰∏™Á∫øÁ®ãÂ§ÑÁêÜ‰∏Ä‰∏™‰ªªÂä°Ôºõ

Âú®Âπ∂ÂèëÊ®°Âûã‰∏äÈù¢ÔºåRust ÊòØÂÖ∏ÂûãÁöÑ Actor ModelÔºåËÄå Go ÂàôÊòØ CSP - Communicating Sequential Processes Model„ÄÇÂú®ËØ≠Ê≥ï‰∏äÈù¢ Rust Âíå Go ÈùûÂ∏∏Á±ª‰ººÔºåÈÉΩÊòØÈÄöËøá Channel Êù•ÂÆûÁé∞Ëá™Â∑±ÁöÑÊ®°ÂûãÔºå‰ΩÜÊòØÂÖ∑‰ΩìÁöÑË°å‰∏∫Âç¥Êúâ‰∫õÁªÜÂæÆÁöÑÂ∑ÆÂà´„ÄÇ

Âú® AM Âπ∂ÂèëÊ®°ÂûãÔºåÊØè‰∏™ËøõÁ®ãÈÉΩÊòØ‰∏Ä‰∏™Áã¨Á´ãÁöÑËßíËâ≤ÔºåÊØè‰∏™ËßíËâ≤Êã•Êúâ‰∏Ä‰∏™Áã¨Â±ûÁöÑÂëΩÂêçÈÇÆÁÆ±„ÄÇActors ‰πãÈó¥ÈÄöËøáÂºÇÊ≠•ÁöÑÂæÄÂØπÊñπÈÇÆÁÆ±ÊäïÈÄí‰ø°ÊÅØÊù•ËøõË°åÈÄö‰ø°„ÄÇ

Âú® CSP Âπ∂ÂèëÊ®°ÂûãÔºåËøõÁ®ã‰∏éËøõÁ®ã‰πãÈó¥ÈÄöËøá‰∏Ä‰∏™ÁÆ°ÈÅìÊù•ËøõË°åÈÄö‰ø°„ÄÇÊ∂àÊÅØÂèØ‰ª•È°∫Â∫èÁöÑÂ°´ÂÖ•Ëøô‰∏™ÁÆ°ÈÅìÔºå‰πüÂèØ‰ª•Ë¢´ÈÄêÊ¨°ÁöÑ‰ªéÁÆ°ÈÅìÂèñÂá∫„ÄÇÊ≥®ÊÑèÂà∞Ëøô‰∏™ÁÆ°ÈÅìÂπ∂‰∏çÂΩíÂ±û‰∫éÊüê‰∏™ËøõÁ®ã„ÄÇ‰º†Áªü‰∏äÔºåCSP ÁÆ°ÈÅìÊ≤°ÊúâÁºìÂ≠òÔºåÂ°´ÂÖ•‰∏éÂèñÂá∫ÊòØÂêåÊ≠•ÁöÑÔºåÁî±Ê≠§‰πüÂ∞±‰øùËØÅ‰∫ÜÊ∂àÊÅØ‰∏ç‰ºöÂú®ÈÄö‰ø°ÁöÑËøáÁ®ã‰∏≠‰∏¢Â§±„ÄÇGo È¢ùÂ§ñÁöÑÊîØÊåÅ‰∫ÜÂ∏¶ buffer ÁöÑÁÆ°ÈÅìÔºåÁî®‰∫éÊèê‰æõ‰∏é AM Ê®°ÂûãÁ±ª‰ººÁöÑÂºÇÊ≠•ÈÄö‰ø°„ÄÇ

Rust Â§öÁ∫øÁ®ãÁºñÁ®ãÈúÄË¶ÅÂ≠¶‰π†‰∏§‰∏™Ê†áÂáÜÂ∫ìÔºåthread Âíå sync ÂêåÊ≠•Ê†áÂáÜÂ∫ìÔºåÊèê‰æõ‰∫ÜÂ§ßÈáèÂú®Á∫øÁ®ãÂêåÊ≠•‰∏≠ÈúÄË¶Å‰ΩøÁî®ÁöÑÂØπË±°ÔºåÂπ∂‰∏îÂåÖÂê´‰ª•‰∏ã‰∏§‰∏™Â≠êÊ®°ÂùóÔºö

- atomic ÂéüÂ≠êÁ±ªÊ®°Âùó„ÄÇ
- mpsc  Âç≥ Multi-producer, single-consumer FIFO ÈòüÂàóÈÄö‰ø°Ê®°Âùó„ÄÇ


## ‚ö° Âü∫Êú¨Â§öÁ∫øÁ®ãÁ®ãÂ∫è
- https://doc.rust-lang.org/book/ch16-01-threads.html
- https://doc.rust-lang.org/book/ch20-00-final-project-a-web-server.html
- https://doc.rust-lang.org/stable/std/thread/fn.park.html
- https://doc.rust-lang.org/stable/std/thread/struct.Builder.html

ÂèóÂà∂‰∫éÁ°¨‰ª∂ÊäÄÊúØÔºåËäØÁâáÁîµË∑ØÂ∞∫ÂØ∏Âú® 10nm Ê∞¥Âπ≥Êé•ËøëÂéüÂ≠êÂ∞∫ÂØ∏ÔºåÂçïÊ†∏ÊÄßËÉΩË∂äÊù•Ë∂äÊé•ËøëÁì∂È¢àÔºåÁé∞‰ª£ CPU ÊôÆÈÅçÊòØÂ§öÊ†∏ÂøÉÔºåÂú®Á°¨‰ª∂‰∏äÂü∫Êú¨ÂÖ®ÊòØÂ§öÁ∫øÁ®ãËøêË°åÁéØÂ¢É„ÄÇ

Á∫øÁ®ã `Thread` ÊòØÊìç‰ΩúÁ≥ªÁªüËÉΩÂ§üËøõË°åË∞ÉÂ∫¶ÁöÑÊúÄÂ∞èÂçï‰ΩçÔºåÂÆÉÊòØËøõÁ®ã `Process` ‰∏≠ÁöÑÂÆûÈôÖËøê‰ΩúÂçï‰ΩçÔºåÊØè‰∏™ËøõÁ®ãËá≥Â∞ëÂåÖÂê´‰∏Ä‰∏™Á∫øÁ®ã„ÄÇÈÄö‰øóÂú∞ÁêÜËß£ÔºåËøõÁ®ãÂ∞±ÊòØÊìç‰ΩúÁ≥ªÁªüËøêË°åÁöÑÁ®ãÂ∫èÔºåÂÖ∑‰Ωì‰ª£Á†ÅÁöÑËøêË°åÂàôÊòØÁ∫øÁ®ãÊâßË°åÁöÑ„ÄÇ

‰∏çÂêåËØ≠Ë®ÄÂÆûÁé∞ÁöÑÂ§öÁ∫øÁ®ãÊñπÂºè‰∏çÂêåÔºåÂ§ßÂ§öÊï∞Êìç‰ΩúÁ≥ªÁªüÊèê‰æõ API Êù•ÂàõÂª∫Á∫øÁ®ãÔºåÈÄöËøá API ÊñπÂºèÂàõÂª∫ÁöÑÁß∞‰∏∫ 1:1 Á∫øÁ®ãÊ®°ÂûãÔºåÂèØ‰ª•Áß∞‰∏∫ native-threading„ÄÇ

ËÄå Rust ÂíåËÆ∏Â§öËØ≠Ë®Ä‰∏ÄÊ†∑Ôºå‰πüÂÆûÁé∞‰∫ÜËá™Â∑±ÁöÑÁ∫øÁ®ãÊ®°ÂûãÔºåËØ≠Ë®ÄÂ±ÇÈù¢‰∏äÁöÑÂÆûÁé∞Áß∞‰∏∫ green-threading Ê®°ÂûãÔºåÂç≥ M:N Á∫øÁ®ãÊ®°ÂûãÔºåM Âíå N ‰∏ç‰∏ÄÂÆöÁõ∏Á≠âÔºåÂç≥Âú® N ‰∏™Êìç‰ΩúÁ≥ªÁªüÁ∫øÁ®ã‰∏äËøêË°å M ‰∏™ÁªøËâ≤Á∫øÁ®ã„ÄÇ

‰∏∫‰∫ÜÈÅøÂÖçÂºïÂÖ•Á¨¨‰∏âÊñπÁöÑÁ∫øÁ®ãÂ∫ìÔºåÊúâ‰∫õÁºñÁ®ãËØ≠Ë®ÄÂºïÂÖ•‰∫ÜÂçèÁ®ã Coroutine ÁöÑÊ¶ÇÂøµÔºåÂú®ËØ≠Ê≥ïÂ±ÇÈù¢ÂÆûÁé∞‰∫ÜÁ∫§Á®ã Fiber ÁöÑÂäüËÉΩ„ÄÇÁ∫§Á®ãÂíåÂçèÁ®ãÊèèËø∞‰∫ÜÁõ∏ÂêåÁöÑÊ¶ÇÂøµÔºå‰ªñ‰ª¨ÈÉΩ‰∏çÊòØÁúüÊ≠£ÊÑè‰πâ‰∏äÁöÑÂπ∂Ë°å„ÄÇ‰ΩÜÊòØÔºåÂÆÉ‰ª¨ËÉΩËÆ©‰Ω†Êõ¥ÂÆπÊòìÂú∞Â§ÑÁêÜÂºÇÊ≠•I/OÁöÑÈóÆÈ¢ò„ÄÇ

Erlang ÈááÁî® M:N Ê®°ÂûãÂæàÂ•ΩÁöÑËß£ÂÜ≥‰∫Ü Green Thread Â≠òÂú®ÁöÑÈóÆÈ¢òÔºåÊØè‰∏™ native thread ÈÉΩÊúâ‰∏Ä‰∏™Ëá™Â∑±ÁöÑË∞ÉÂ∫¶Âô®„ÄÇËÄå‰∏îÔºåErlang ÈááÁî® shared nothing concurrencyÔºåÂèØ‰ª•Êää Native Thread Â≠òÂú®ÁöÑÈóÆÈ¢òÈÉΩÊäõ‰πãËÑëÂêé„ÄÇ

ÂÖ∑‰Ωì‰ΩøÁî®‰ªÄ‰πàÊ®°ÂûãÊòØ‰∏™Âπ≥Ë°°ÂèñËàçÈóÆÈ¢ò„ÄÇ

‰∏Ä‰∏™Á¨ëËØùÔºö

    Èù¢ËØïÂÆòÔºö‰Ω†Áü•ÈÅìÂçèÁ®ãÂêóÔºü
    ‰Ω†ÔºöËÆ¢Êú∫Á•®ÁöÑÈÇ£‰∏™ÂêóÔºåÊàëÂ∏∏Áî®„ÄÇ
    Èù¢ËØïÂÆòÔºöË°åÔºå‰Ω†ÂÖàÂõûÂéªÂêßÔºåÁ≠âÁîµËØùÈÄöÁü•„ÄÇ


‰ª•‰∏ãÁªìÂêàÈó≠ÂåÖÊºîÁ§∫Â§öÁ∫øÁ®ãÔºö

```rust,ignore
#![allow(unused)]

use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("spawned thread: number {}!", i);
            thread::sleep(Duration::from_millis(100));
        }
    });

    for i in 1..5 {
        println!("main thread: number {}!", i);
        thread::sleep(Duration::from_millis(10));
    }
    
    // handle.join().unwrap();
}
```

Á®ãÂ∫èËæìÂá∫ÂèØ‰ª•ÁúãÂà∞Ôºåspawn ‰∫ßÁîüÁöÑÁ∫øÁ®ãÂπ∂Ê≤°ÊúâÂÆåÂÖ®ËøêË°åÔºåÂõ†‰∏∫Â≠êÁ∫øÁ®ãÁöÑ sleep Êó∂Èó¥Êõ¥ÈïøÔºå‰∏ªÁ∫øÁ®ã sleep Êó∂Èó¥Êõ¥Áü≠ËÄåÊèêÂâçÂÆåÊàêÁªìÊùüËøêË°åÔºö

    main thread: number 1!
    spawned thread: number 1!
    main thread: number 2!
    main thread: number 3!
    main thread: number 4!

ÂàõÂª∫Á∫øÁ®ãÊó∂Ôºåthread::spawn ‰ºöËøîÂõû‰∏Ä‰∏™ `JoinHandle<()>` ÂØπË±°ÔºåÂúÜÊã¨Âè∑Ë°®Á§∫‰∏Ä‰∏™Êó†ÂèÇÊï∞ÁöÑÂáΩÊï∞Á±ªÂûã„ÄÇÂè™ÈúÄË¶ÅÊâßË°åËøô‰∏™Âè•ÊüÑÂØπË±°ÁöÑ `join()` ÊñπÊ≥ïÈòªÂ°û‰∏ªÁ∫øÁ®ãÂ∞±ÂèØ‰ª•Á≠âÂæÖÂ≠êÁ∫øÁ®ãÂÆåÊàêÊâçÁªìÊùüÁ®ãÂ∫è„ÄÇ 

Â¶ÇÊûúÈó≠ÂåÖÂÜÖÈúÄË¶ÅÂÄüÁî®Â§ñÈÉ®‰ΩúÁî®‰ΩúÁî®ÂüüÁöÑÂèòÈáèÔºåÂèØ‰ª•Áõ¥Êé•‰ΩøÁî® move Closures ÁßªÂä®ÊâÄÊúâÊùÉÔºö

```rust,ignore
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
    // drop(v); // oh no!
}
```

‰∏äÈù¢ÁöÑ‰ª£Á†Å‰∏≠ÔºåÂêëÈáè v ‰ºöË¢´Èó≠ÂåÖÂÄüÁî®Ôºå‰ΩÜÊòØÁ®ãÂ∫è‰∏≠Â≠êÁ∫øÁ®ã‰∏≠ÂØπ v ÁöÑÂÄüÁî®ÂèØËÉΩ‰ºöÊúâÊõ¥ÈïøÁöÑÁîüÂëΩÂë®Êúü„ÄÇËÄå‰∏ªÁ∫øÁ®ã‰∏≠ÔºåÂÆÉ‰ºöÂú®‰∏ªÂáΩÊï∞ÁªìÊùüÊó∂Ë¢´ÂõûÊî∂ÔºåËøôÂ∞±‰∫ßÁîüÂÜ≤Á™Å‰∫ÜÔºåÊâÄ‰ª•ÈúÄË¶Å‰ΩøÁî® move ÂÖ≥ÈîÆÂ≠óÊù•Âº∫Âà∂ÊçïÊçâÊâÄÊúâÊùÉ„ÄÇ

‰πüÂèØ‰ª•‰ΩøÁî® `Builder` Á∫øÁ®ãÂ∑•ÂéÇÂØπË±°ÂàõÂª∫Á∫øÁ®ãÔºåËøôÊ†∑ÂèØ‰ª•‰∏∫Â≠êÁ∫øÁ®ãÊåáÂÆöËøõÁ®ãÂêçÁß∞„ÄÅË∞ÉÁî®Ê†àÂ§ßÂ∞èÔºö

```rust,ignore
use std::thread;

let builder = thread::Builder::new()
                              .name("foo".into())
                              .stack_size(32 * 1024);
let mut x = 1;
let handler = builder.spawn( move || {
    x += 1;
}).unwrap();

handler.join().unwrap();
assert_eq!(1, x);
```

Âè¶Â§ñÔºå‰ΩøÁî® Builder ÂàõÂª∫Á∫øÁ®ãÂèØ‰ª•‰ªéÂêØÂä®Á∫øÁ®ãÁöÑÂ§±Ë¥•‰∏≠ÊÅ¢Â§çÔºåÂÆûÈôÖ‰∏ä`thread::spawn`ÂáΩÊï∞Âú® Builder ÊñπÊ≥ïËøîÂõû io::Result ÁöÑÂú∞ÊñπÊ≠ªÊú∫ÔºåÂõ†‰∏∫ÂÆÉÁõ¥Êé•‰ΩøÁî® unwrap ËÄåÊ≤°ÊúâÂ§ÑÁêÜÈîôËØØ„ÄÇ


Á∫øÁ®ãÊ†áÂáÜÂ∫ì‰∏≠ÂÆö‰πâÁöÑÂáΩÊï∞Ôºö

- `available_concurrency` 
- `current` 
- `panicking` 
- `park` ÈòªÂ°ûÁ∫øÁ®ãÔºåÈô§ÈùûÊàñÁõ¥Âà∞ÂΩìÂâçÁ∫øÁ®ãÁöÑ‰ª§ÁâåÂèØÁî®ÔºåÊ≥®ÊÑèÔºåË∞ÉÁî® `park()` ÊñπÊ≥ï‰∏çËÉΩ‰øùËØÅÁ∫øÁ®ãÂ∞ÜÊ∞∏ËøúÂ§Ñ‰∫éÈ©ªËΩ¶Áä∂ÊÄÅ„ÄÇ
- `park_timeout` 
- `park_timeout_ms` 
- `sleep` Á∫øÁ®ãÁ≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥ÂêéÔºåÂÜçÊé•ÁùÄÁªßÁª≠ÊâßË°å„ÄÇ
- `sleep_ms` 
- `spawn` Â≠µÂåñ‰∏Ä‰∏™ËøõÁ®ãÂπ∂ËøîÂõû‰∏Ä‰∏™ JoinHandle ÂØπË±°„ÄÇ
- `yield_now` ÊîæÂºÉÂΩìÂâçÁ∫øÁ®ãÁöÑÊó∂Èó¥ÁâáÔºåËÆ©ÁªôÁ≥ªÁªüË∞ÉÂ∫¶Âô®ÈÄâÊã©ÂÖ∂ÂÆÉÁ∫øÁ®ãÊâßË°å„ÄÇ

Á∫øÁ®ãÊöÇÂÅúÊâßË°åÁöÑÊñπÊ≥ïÊúâÂ§öÁßçÊñπÂºèÔºåyield_now Âíå sleep ‰ºöËá™Âä®ÊÅ¢Â§çÊâßË°åÔºåËÄå park ÊñπÂºèÈúÄË¶ÅÊâßË°å unpark ÊääÁ≠âÂæÖÁöÑÁ∫øÁ®ãÂè´ÈÜí„ÄÇ

Á±ª‰ººÁöÑËøòÂèØ‰ª•‰ΩøÁî®ÂêåÊ≠•ÂØπË±° `Condvar` Êù°‰ª∂ÂèòÈáèÊàñ `Barrier` Á≠â„ÄÇ


## ‚ö° Synchronization ÂêåÊ≠•ÂØπË±°
- https://doc.rust-lang.org/stable/std/sync/index.html
- https://doc.rust-lang.org/stable/std/sync/atomic/index.html
- https://doc.rust-lang.org/stable/std/sync/mpsc/index.html

ÂéüÂ≠êÁ±ªÂûãÊòØÊúÄÁÆÄÂçïÁöÑÊéßÂà∂ÂÖ±‰∫´ËµÑÊ∫êËÆøÈóÆÁöÑ‰∏ÄÁßçÊú∫Âà∂ÔºåÁõ∏ÊØîËæÉ‰∫éÂêéÈù¢Â∞Ü‰ªãÁªçÁöÑ‰∫íÊñ•ÈîÅËÄåË®ÄÔºåÂéüÂ≠êÁ±ªÂûã‰∏çÈúÄË¶ÅÂºÄÂèëËÄÖÂ§ÑÁêÜÂä†ÈîÅÂíåÈáäÊîæÈîÅÁöÑÈóÆÈ¢òÔºåÂêåÊó∂ÊîØÊåÅ‰øÆÊîπÔºåËØªÂèñÁ≠âÊìç‰ΩúÔºåËøòÂÖ∑Â§áËæÉÈ´òÁöÑÂπ∂ÂèëÊÄßËÉΩÔºå‰ªéÁ°¨‰ª∂Âà∞Êìç‰ΩúÁ≥ªÁªüÔºåÂà∞ÂêÑ‰∏™ËØ≠Ë®ÄÔºåÂü∫Êú¨ÈÉΩÊîØÊåÅ„ÄÇ

Âú®Ê†áÂáÜÂ∫ì std::sync::atomic ‰∏≠ÔºåÂåÖÂê´ Rust Áé∞ÊúâÁöÑÂéüÂ≠êÁ±ªÂûãÔºåËøô‰∫õÂéüÂ≠êÁ±ªÂûãÂü∫Êú¨ËÉΩÊª°Ë∂≥ÊâÄÊúâÂÖ±‰∫´ËµÑÊ∫êÁ∫øÁ®ãÂÆâÂÖ®ËÆøÈóÆÁöÑÈúÄË¶Å„ÄÇ

- AtomicBool
- AtomicI16 AtomicU16
- AtomicI32 AtomicU32
- AtomicI64 AtomicU64
- AtomicI8 AtomicU8
- AtomicIsize
- AtomicPtr
- AtomicUsize

Ëøô‰∫õÂéüÂ≠êÁ±ªÂûã‰ºöÊèê‰æõ‰ª•‰∏ãÊìç‰ΩúÔºö

- CAS - Compare-And-Swap ÊØîËæÉÂπ∂‰∫§Êç¢Êìç‰Ωú
- Fetch add/sub/and/or ÂéüÂ≠êÁ±ªÂûãÁöÑÂêÑÁßçËøêÁÆó
- Load ‰ªéÂéüÂ≠êÁ±ªÂûãËØªÂèñÂÄº
- Store ÂÜôÂÖ•‰∏Ä‰∏™ÂÄºÂà∞ÂéüÂ≠êÁ±ªÂûã
- Swap ‰∫§Êç¢

ÂéüÂ≠êÁ±ªÂûãÊ®°Âùó‰∏≠Êúâ‰∏Ä‰∏™ Ordering ÊéíÂ∫èÁ∫¶ÊùüÊûö‰∏æÁ±ªÂûãÔºåÂÆÉÁöÑ‰ΩúÁî®ÊòØÂ∞ÜÂÜÖÂ≠òÈ°∫Â∫èÁöÑÊéßÂà∂ÊùÉ‰∫§ÁªôÂºÄÂèëËÄÖÔºåÂê´‰πâÂ¶Ç‰∏ãÔºö

RelaxedÔºöË°®Á§∫„ÄåÊ≤°ÊúâÈ°∫Â∫è„ÄçÔºå‰πüÂ∞±ÊòØÂºÄÂèëËÄÖ‰∏ç‰ºöÂπ≤È¢ÑÁ∫øÁ®ãÈ°∫Â∫èÔºåÁ∫øÁ®ãÂè™ËøõË°åÂéüÂ≠êÊìç‰Ωú

ReleaseÔºöÂØπ‰∫é‰ΩøÁî®ReleaseÁöÑstoreÊìç‰ΩúÔºåÂú®ÂÆÉ‰πãÂâçÊâÄÊúâ‰ΩøÁî®AcquireÁöÑloadÊìç‰ΩúÈÉΩÊòØÂèØËßÅÁöÑ

AcquireÔºöÂØπ‰∫é‰ΩøÁî®AcquireÁöÑloadÊìç‰ΩúÔºåÂú®ÂÆÉ‰πãÂâçÁöÑÊâÄÊúâ‰ΩøÁî®ReleaseÁöÑstoreÊìç‰Ωú‰πüÈÉΩÊòØÂèØËßÅÁöÑ

AcqRelÔºöÂÆÉ‰ª£Ë°®ËØªÊó∂‰ΩøÁî®AcquireÈ°∫Â∫èÁöÑloadÊìç‰ΩúÔºåÂÜôÊó∂‰ΩøÁî®ReleaseÈ°∫Â∫èÁöÑstoreÊìç‰Ωú

SeqCstÔºö‰ΩøÁî®‰∫ÜSeqCstÁöÑÂéüÂ≠êÊìç‰ΩúÈÉΩÂøÖÈ°ªÂÖàÂ≠òÂÇ®ÔºåÂÜçÂä†ËΩΩ„ÄÇ

    |  Êûö‰∏æÂÄº   |           Âê´‰πâ           |      ÂØπÂ∫î C++20      |
    |-----------|--------------------------|----------------------|
    | `Relaxed` | Êó†ÊéíÂ∫èÁ∫¶ÊùüÔºåÂè™ÊòØÂéüÂ≠êÊìç‰Ωú„ÄÇ | memory_order_relaxed |
    | `Release` |                          | memory_order_release |
    | `Acquire` |                          | memory_order_acquire |
    | `AcqRel`  |                          | memory_order_acq_rel |
    | `SeqCst`  |                          | memory_order_seq_cst |

Á§∫ËåÉÂéüÂ≠êÁ±ªÂûã‰ΩøÁî®ÔºåÔºö

```rust,ignore
use std::sync::atomic::{AtomicUsize, Ordering};

let mut some_var = AtomicUsize::new(10);
assert_eq!(*some_var.get_mut(), 10);
*some_var.get_mut() = 5;
assert_eq!(some_var.load(Ordering::SeqCst), 5);
```

Âü∫‰∫éÂéüÂ≠êÁ±ªÂûãÂÆûÁé∞‰∏Ä‰∏™Ëá™ÊóãÈîÅÔºö

```rust,ignore
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::thread;

fn main() {
    let spinlock = Arc::new(AtomicUsize::new(1));

    let spinlock_clone = Arc::clone(&spinlock);
    let thread = thread::spawn(move|| {
        spinlock_clone.store(0, Ordering::SeqCst);
    });

    // Wait for the other thread to release the lock
    while spinlock.load(Ordering::SeqCst) != 0 {}

    if let Err(panic) = thread.join() {
        println!("Thread had an error: {:?}", panic);
    }
}
```



Â§ßÂ§öÊï∞‰ΩéÁ∫ßÂêåÊ≠•ÂéüËØ≠ÈÉΩÈùûÂ∏∏ÂÆπÊòìÂá∫ÈîôÔºå‰ΩøÁî®Ëµ∑Êù•‰πü‰∏çÊñπ‰æøÔºåÊâÄ‰ª•Ê†áÂáÜÂ∫ìÊèê‰æõ‰∫Ü‰∏Ä‰∫õÈ´òÁ∫ßÂêåÊ≠•ÂØπË±°„ÄÇÂÆÉ‰ª¨ÂèØ‰ª•Áî±ËæÉ‰ΩéÁ∫ßÂà´ÁöÑÂéüËØ≠ÊûÑÂª∫Ôºå‰∏∫‰∫ÜÊèêÈ´òÊïàÁéáÔºåÊ†áÂáÜÂ∫ì‰∏≠ÁöÑÂêåÊ≠•ÂØπË±°ÈÄöÂ∏∏ÊòØÂü∫‰∫éÊìç‰ΩúÁ≥ªÁªüÂÜÖÊ†∏ÂÆûÁé∞ÁöÑÔºåÂÜÖÊ†∏ÂèØ‰ª•Âú®Á∫øÁ®ãÂú®Ëé∑ÂèñÈîÅÊó∂Ë¢´ÈòªÂ°ûÊó∂ÈáçÊñ∞Ë∞ÉÂ∫¶Á∫øÁ®ã„ÄÇ

‰ª•‰∏ãËøô‰∫õÈÉΩÊòØÂêåÊ≠•ÂØπË±°Ôºö

- `Arc`: Atomically Reference-Counted pointer ÂéüÂ≠êËÆ°Êï∞ÊåáÈíàÔºåÊòØ Rc ÊåáÈíàÁöÑÂ§öÁ∫øÁ®ãÂÆâÂÖ®ÁâàÊú¨„ÄÇÂÆÉÂèØ‰ª•Âª∂ÈïøÊüê‰∫õÊï∞ÊçÆÁöÑÁîüÂ≠òÊúüÔºåÁõ¥Âà∞ÊâÄÊúâÁ∫øÁ®ãÈÉΩ‰∏çÂÜç‰ΩøÁî®ÂÆÉ„ÄÇ
- `Barrier`: Á°Æ‰øùÂ§öÁ∫øÁ®ãÂú®ÊâßË°åÂà∞‰∏ÄÁÇπÊó∂Ôºå‰ºöÁ≠âÂæÖÂÖ∂ÂÆÉÁ∫øÁ®ãÂÜçÂà∞ËææËøô‰∏ÄÁÇπÂÜç‰∏ÄËµ∑ÁªßÁª≠ÊâßË°å„ÄÇ
- `Condvar`: Êù°‰ª∂ÂèòÈáèÔºåÊèê‰æõÈòªÂ°ûÁ∫øÁ®ãÂπ∂‰∏îÁ≠âÂæÖ‰∫ã‰ª∂ÈÄöÁü•ÊÅ¢Â§çÊâßË°åÁöÑËÉΩÂäõ„ÄÇ
- `mpsc`: MPSC ÈÄö‰ø°ÈòüÂàó Multi-producer, single-consumer queues Êèê‰æõÁªèÈáèÁªÑËøõÁ®ãÈó¥ÁÆ°ÈÅìÂêåÊ≠•ÈÄö‰ø°Êú∫Âà∂„ÄÇ
- `Mutex`: ‰∫íÊñ•Êú∫Âà∂ Mutual ExclusionÔºåÁ°Æ‰øùÊüê‰∏ÄÊó∂ÂàªÊúÄÂ§öÂè™Êúâ‰∏Ä‰∏™Á∫øÁ®ãÂèØ‰ª•ËÆøÈóÆÂêå‰∏Ä‰∏™Êï∞ÊçÆ„ÄÇ
- `Once`: Áî®‰∫éÁ∫øÁ®ãÂÆâÂÖ®„ÄÅ‰∏ÄÊ¨°ÊÄßÂú∞ÊâßË°åÂÖ®Â±ÄÂèòÈáèÂàùÂßãÂåñ„ÄÇ
- `RwLock`: Âü∫‰∫é‰∫íÊñ•Êú∫Âà∂ÂÆûÁé∞ÁöÑËØªÂÜôÈîÅÔºåÂêåÊó∂ÂÖÅËÆ∏Â§ö‰∏™ËØªÔºå‰ΩÜÂè™ËÉΩÊúâ‰∏Ä‰∏™ÂÜôÔºåÂπ∂‰∏îËØªÂíåÂÜô‰∏çËÉΩÂêåÊó∂Â≠òÂú®„ÄÇ

ÊºîÁ§∫‰ΩøÁî® park ÊöÇÂÅú‰∏éÊÅ¢Â§çÁ∫øÁ®ãÊâßË°åÔºö

```rust,ignore
use std::thread;
use std::time::Duration;

let parked_thread = thread::Builder::new()
    .spawn(|| {
        println!("Parking thread");
        thread::park();
        println!("Thread unparked");
    })
    .unwrap();

// Let some time pass for the thread to be spawned.
thread::sleep(Duration::from_millis(10));

println!("Unpark the thread");
parked_thread.thread().unpark();

parked_thread.join().unwrap();
```

Á§∫ËåÉ `Once` ‰ΩøÁî®Ôºö

```rust,ignore
use std::sync::Once;

static START: Once = Once::new();

START.call_once(|| {
    // run initialization here
});
```

Âú®Êìç‰ΩúÁ≥ªÁªüÂíåÁºñÁ®ãËØ≠Ë®Ä‰∏≠ÔºåÂºïÂÖ•‰∫Ü‰∏ÄÁßçÂè´ÁùÄÊù°‰ª∂ÂèòÈáèÁöÑ‰∏úË•ø„ÄÇÂèØ‰ª•Ê®°ÊãüÁé∞ÂÆûÁîüÊ¥ª‰∏≠ÁöÑÈóπÈíüÁöÑË°å‰∏∫ÔºåÊù°‰ª∂ËææÊàêÂ∞±ÈÄöÁü•Á≠âÂæÖÊù°‰ª∂ÁöÑÁ∫øÁ®ã‰ª•ÊÅ¢Â§çÊâßË°å„ÄÇ

Rust ÁöÑÊù°‰ª∂ÂèòÈáèÊòØ CondvarÔºå‰ΩøÁî®ÈÄöÁü•Êú∫Âà∂ÊòØÂõ†‰∏∫ÊúâÁ≠âÂæÖÔºåÊâÄ‰ª•ÈÄöÁü•ÂíåÁ≠âÂæÖÂá†‰πéÈÉΩÊòØÊàêÂØπÂá∫Áé∞ÁöÑ„ÄÇÁ≠âÂæÖÊâÄ‰ΩøÁî®ÁöÑÂØπË±°Ôºå‰∏éÈÄöÁü•ÊâÄ‰ΩøÁî®ÁöÑÂØπË±°ÔºåÊòØÂêå‰∏Ä‰∏™ÂØπË±°ÔºåËÄåËØ•ÂØπË±°ÈúÄË¶ÅÂú®Â§ö‰∏™Á∫øÁ®ã‰πãÈó¥ÂÖ±‰∫´„ÄÇ

Èô§‰∫Ü Condvar ‰πãÂ§ñÔºåÂÖ∂ÂÆûÈîÅ‰πüÊòØÂÖ∑ÊúâËá™Âä®ÈÄöÁü•ÂäüËÉΩÁöÑÔºåÂΩìÊåÅÊúâÈîÅÁöÑÁ∫øÁ®ãÈáäÊîæÈîÅÁöÑÊó∂ÂÄôÔºåÁ≠âÂæÖÈîÅÁöÑÁ∫øÁ®ãÂ∞±‰ºöËá™Âä®Ë¢´Âî§ÈÜíÔºå‰ª•Êä¢Âç†ÈîÅ„ÄÇÈÄöËøáÊù°‰ª∂ÂèòÈáèÂíåÈîÅÔºåËøòÂèØ‰ª•ÊûÑÂª∫Êõ¥Âä†Â§çÊùÇÁöÑËá™Âä®ÈÄöÁü•ÊñπÂºèÔºåÊØîÂ¶Ç Barrier„ÄÇ

ÈÄöÁü•ÂèØ‰ª•ÊòØ 1:1 Êàñ 1:N ÁöÑÔºåÂç≥ Condvar ÂèØ‰ª•ÊéßÂà∂ÈÄöÁü• 1 ‰∏™Êàñ N ‰∏™Á∫øÁ®ãÁöÑÂî§ÈÜí„ÄÇËÄåÈîÅÂàô‰∏çËÉΩÊéßÂà∂ÔºåÂè™Ë¶ÅÈáäÊîæÈîÅÔºåÊâÄÊúâÁ≠âÂæÖÈîÅÁöÑÂÖ∂‰ªñÁ∫øÁ®ãÈÉΩ‰ºöÂêåÊó∂ÈÜíÊù•ÔºåËÄå‰∏çÊòØÂè™ÊúâÊúÄÂÖàÁ≠âÂæÖÁöÑÁ∫øÁ®ã„ÄÇ

Á§∫ËåÉ‰ΩøÁî® `Condvar`ÔºåÂú®‰∏ªÁ∫øÁ®ã‰∏≠Á≠âÂæÖÂ≠êÁ∫øÁ®ãÁöÑÈÄöÁü•Ôºö

```rust,ignore
use std::sync::{Arc, Mutex, Condvar};
use std::thread;

let pair = Arc::new((Mutex::new(false), Condvar::new()));
let pair2 = Arc::clone(&pair);

// Inside of our lock, spawn a new thread, and then wait for it to start.
thread::spawn(move|| {
    let (lock, cvar) = &*pair2;
    let mut started = lock.lock().unwrap();
    *started = true;
    // We notify the condvar that the value has changed.
    cvar.notify_one();
});

// Wait for the thread to start up.
let (lock, cvar) = &*pair;
let mut started = lock.lock().unwrap();
while !*started {
    started = cvar.wait(started).unwrap();
}
```



## ‚ö° Message Passing Ê∂àÊÅØ‰º†ÈÄí
- https://doc.rust-lang.org/book/ch16-02-message-passing.html
- https://learnku.com/docs/effective-go/2020/concurrent/6249
- https://doc.rust-lang.org/stable/std/sync/mpsc/index.html

Âú® Go ËØ≠Ë®ÄÁöÑÊñáÊ°£‰∏≠Êúâ‰∏ÄÂè•Âè£Âè∑Ôºö‚ÄúDo not communicate by sharing memory; instead, share memory by communicating.‚Äù

‰∏çË¶ÅÈÄöËøáÂÖ±‰∫´ÂÜÖÂ≠òÊù•ÈÄö‰ø°ÔºåËÄåÂ∫îÈÄöËøáÈÄö‰ø°Êù•ÂÖ±‰∫´ÂÜÖÂ≠ò„ÄÇ

Rust ‰πüÂíå Go ‰∏ÄÊ†∑Ôºå‰∏ªË¶Å‰ΩøÁî® channel Êù•‰º†ÈÄíÊ∂àÊÅØÔºåÂèØ‰ª•Â∞ÜÂÆÉÊÉ≥Ë±°ÊàêÊ∞¥ÁÆ°ÔºåÊ∂àÊÅØÂ∞±ÂÉèÊ∞¥ÊµÅ‰∏ÄÊ†∑‰ªé‰∏ÄÁ´ØÊµÅÂêëÂè¶‰∏ÄÁ´Ø„ÄÇ

Rust Ê†áÂáÜÂ∫ìÊèê‰æõÂºÇÊ≠•ÈÄöÈÅìÂíåÂêåÊ≠•ÈÄöÈÅì‰∏§ÁßçÔºö

- ÂºÇÊ≠•ÈÄöÈÅìÔºö‰∏çÁÆ°Êé•Êî∂ËÄÖÊòØÂê¶Ê≠£Âú®Êé•Êî∂Ê∂àÊÅØÔºåÊ∂àÊÅØÂèëÈÄÅËÄÖÂú®ÂèëÈÄÅÊ∂àÊÅØÊó∂ÈÉΩ‰∏ç‰ºöÈòªÂ°û„ÄÇ
- ÂêåÊ≠•ÈÄöÈÅìÔºöÈúÄË¶ÅÊåáÂÆöÁºìÂ≠òÊ∂àÊÅØÊï∞ÈáèÔºåÊúÄÂ∞èÂèØ‰ª•ÊòØ 0 ‰∏™ÔºåË°®Á§∫Ê≤°ÊúâÁºìÂ≠ò„ÄÇÂèëÈÄÅÊ∂àÊÅØ‰ºöË¢´ÈòªÂ°ûÁõ¥Âà∞Ë¢´Êé•Êî∂Á´ØËØªÂèñÔºåÂèëÈÄÅÁ´ØÁºìÂ≠òÈòüÂàóÂ°´Êª°Ê∂àÊÅØÂπ∂ÂÜçÊ¨°ÂèëÈÄÅÊ∂àÊÅØÊó∂ÔºåÂ∞±‰ºöËøõÂÖ•ÈòªÂ°û„ÄÇ

ÂáΩÊï∞ÂéüÂûãÂèÇËÄÉÔºö

    pub fn channel<T>() -> (Sender<T>, Receiver<T>)
    pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>)

ÊºîÁ§∫Â¶Ç‰∏ãÔºö

```rust,ignore
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn( move || {
        thread::sleep(Duration::from_millis(1000));
        let val = String::from("hi!");
        tx.send(val).unwrap();
        // println!("{}", val); <-- borrow of moved value: `val`
    });

    let received = rx.recv().unwrap();
    println!("Got message: {}", received);
}
```

Êï∞ÊçÆÂèòÈáèÂú®ÁÆ°ÈÅì‰∏≠‰º†ÈÄíÊó∂ÔºåÊâÄÊúâÊùÉ‰πüÊòØ‰∏ÄËµ∑ÁßªÂä®‰º†ÈÄíÁöÑÔºåËøôÂ∞±Ëß£ÂÜ≥‰∫ÜÊï∞ÊçÆÁ´û‰∫âÈóÆÈ¢ò„ÄÇ

Êé•Êî∂Á´ØÊòØ rxÔºåÊâßË°å `recv()` ÊñπÊ≥ï‰ºöËøõÂÖ•ÈòªÂ°ûÁõ¥Âà∞ tx Á´ØÊúâÊï∞ÊçÆ‰º†ËæìËøáÊù•ÔºåËÄåÂèëÈÄÅÁ´ØÂèØ‰ª•ËøûÁª≠ËæìÂÖ•Êï∞ÊçÆËÄå‰∏ç‰ºöÈòªÂ°û„ÄÇ

Êé•Êî∂Á´ØÊòØ‰∏Ä‰∏™Ëø≠‰ª£Âô®ÔºåÂèØ‰ª•Áõ¥Êé•‰ΩøÁî® for in ËøõË°åÊûö‰∏æÔºö

```rust,ignore
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```

ÁÆ°ÈÅìÊòØ‰∏Ä‰∏™ Multi-producer, single-consumer FIFO ÈÄöËÆØÈòüÂàóÔºåÂç≥ÂèØ‰ª•ÂØπÁÆ°ÈÅìÁöÑÂèëÈÄÅÁ´ØËøõË°åÂÖãÈöÜÔºåËøôÊ†∑Â∞±ÂèØ‰ª•Âú®Â§ö‰∏™Á∫øÁ®ã‰∏≠‰ΩøÁî®Âêå‰∏Ä‰∏™Êé•Êî∂Á´ØËé∑ÂèñÊ∂àÊÅØÔºö 

    let tx = tx.clone();
    let tx = mpsc::Sender::clone(&tx);

Âú®Â§öÁ∫øÁ®ã‰∏≠Ôºå‰πüÂèØ‰ª•Â∞ÜÂÖãÈöÜÊé•Êî∂Á´ØÔºåËøôÊ†∑Â∞±ÂèØ‰ª•Âú®ÂêÑ‰∏™Á∫øÁ®ã‰∏≠Êé•Êî∂ÁÆ°ÈÅì‰º†ÈÄíÁöÑÊ∂àÊÅØ„ÄÇ


## ‚ö° Shared State ÂÖ±‰∫´Áä∂ÊÄÅ 
- https://doc.rust-lang.org/book/ch16-03-shared-state.html

Rust ÁöÑ static ÈùôÊÄÅÂèòÈáèÔºåÁîüÂëΩÂë®ÊúüÂú®Êï¥‰∏™Â∫îÁî®Á®ãÂ∫èÊúâÊïàÔºåÂπ∂‰∏îÂú®ÂÜÖÂ≠ò‰∏≠Êüê‰∏™Âõ∫ÂÆöÂú∞ÂùÄÂ§ÑÂè™Â≠òÂú®‰∏Ä‰ªΩÂÆû‰æã„ÄÇÊâÄÊúâÁ∫øÁ®ãÈÉΩËÉΩÂ§üËÆøÈóÆÂà∞ÂÆÉÔºåÈÄöËøáÂÆÉÂèØ‰ª•ÂÆûÁé∞ÊúÄÁÆÄÂçïÁöÑÁ∫øÁ®ãÈó¥ÂÜÖÂ≠òÂÖ±‰∫´„ÄÇ

```rust,ignore
use std::thread;
static C32: i32 = 5;
fn main() {
    let new_thread = thread::spawn(move|| {
        println!("static value in new thread: {:p}", &C32);
    });
    new_thread.join().unwrap();
    println!("static value in main thread: {:p}", &C32);
}
```

Ê≠£Â¶ÇÂâçÈù¢ÊâÄËØ¥Ôºå‰∏çË¶ÅÈÄöËøáÂÖ±‰∫´ÂÜÖÂ≠òÊù•ÈÄö‰ø°ÔºåËÄåÂ∫îÈÄöËøáÈÄö‰ø°Êù•ÂÖ±‰∫´ÂÜÖÂ≠ò„ÄÇ

What would communicating by sharing memory look like? In addition, why would message-passing enthusiasts not use it and do the opposite instead?

ÈÇ£‰πàÔºåÂÖ±‰∫´ÂÜÖÂ≠òÊñπÂºèÁöÑÈÄöËÆØ‰ºöÊúâ‰ªÄ‰πàÈóÆÈ¢òÂë¢ÔºüÂÖ∂ÂÆûÂÖ±‰∫´ÂÜÖÂ≠òÊñπÂºèÂ∞±Â¶ÇÂêåÂ§ö‰∏™ÊâÄÊúâÊùÉÔºå‰∏çÂêåÁ∫øÁ®ãÂèØÂú®Âêå‰∏ÄÊó∂ÂàªËÆøÈóÆÂêå‰∏ÄÊï∞ÊçÆÔºåËøôÂ∞±‰ºö‰∫ßÁîüÊï∞ÊçÆÁ´û‰∫âÈóÆÈ¢ò„ÄÇ

Âú®ÂâçÈù¢ÈÉ®ÂàÜÂÜÖÂÆπÂèØ‰ª•ÁúãÂà∞ÔºåÈÄöËøá Box Rc RefCell Á≠âÊô∫ËÉΩÊåáÈíàÂèØ‰ª•ÂÆûÁé∞Â§ö‰∏™ÊâÄÊúâÊùÉ„ÄÇ

‰ΩøÁî®‰∫íÊñ•Èáè Mutexes Âç≥ Mutual Exclusion ÂèØ‰ª•Á°Æ‰øùÂêå‰∏ÄÊó∂ËØ•Âè™Êúâ‰∏Ä‰∏™Á∫øÁ®ãÂèØ‰ª•ËÆøÈóÆÂêå‰∏Ä‰∏™ÂÜÖÂ≠òÊï∞ÊçÆÔºåËøôÂ∞±ÊòØÈîÅÂ∞ÅÊú∫Âà∂ÁöÑÂÆûÁé∞„ÄÇ

‰∫íÊñ•ÈîÅ‰ª•Èöæ‰ª•‰ΩøÁî®ËÄåÈóªÂêçÔºåÂøÖÈ°ªËÆ∞‰Ωè‰∏§Êù°ËßÑÂàôÔºö

- ÂøÖÈúÄÂú®‰ΩøÁî®Êï∞ÊçÆ‰πãÂâçÂ∞ùËØïËé∑ÂèñÈîÅ„ÄÇ
- ÂÆåÊàêÊìç‰Ωú‰∫íÊñ•ÈîÅ‰øùÊä§ÁöÑÊï∞ÊçÆÂêéÔºåÂøÖÈ°ªËß£ÈîÅÊï∞ÊçÆÔºå‰ª•‰æøÂÖ∂‰ªñÁ∫øÁ®ãÂèØ‰ª•Ëé∑ÂèñÈîÅ„ÄÇ

‰∫íÊñ•ÈáèÁöÑÁÆ°ÁêÜÈùûÂ∏∏Ê£òÊâãÔºåËøôÂ∞±ÊòØ‰∏∫‰ªÄ‰πàÈÇ£‰πàÂ§ö‰∫∫ÁÉ≠Ë°∑‰∫é‰ΩøÁî®ÈÄö‰ø°ÁÆ°ÈÅì„ÄÇ

‰ª•‰∏ãÊºîÁ§∫‰∫íÊñ•Èáè `Mutex<T>` ÁöÑ‰ΩøÁî®Ôºö

```rust,ignore
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {:?}", m);
}
```

ÂáÜÁ°ÆÂú∞ËØ¥Ôºå`Mutex<T>` ÁöÑ `lock()` ÊñπÊ≥ïËøîÂõûÁöÑÊòØ‰∏Ä‰∏™ `MutexGuard` Êô∫ËÉΩÂáΩÊï∞ÔºåÁî± `LockResult` ÂåÖË£ÖÔºå`unwrap()` Ëß£ÂåÖÔºåÈîÅÂÆöÂêéÂ∞±ÂèØ‰ª•ÈÄöËøáÊô∫ËÉΩÊåáÈíàËÆøÈóÆ‰∫íÊñ•ÈáèÂÜÖÈÉ®ÁöÑÊï∞ÊçÆ„ÄÇ

Êô∫ËÉΩÊåáÈíà `MutexGuard` ÂÆûÁé∞‰∫Ü `Deref` Êù•ËÆøÈóÆÂÜÖÈÉ®ÊåáÂêëÁöÑÊï∞ÊçÆÔºåËøòÂÆûÁé∞‰∫Ü `Drop`ÔºåËøôÊ†∑Âú® MutexGuard ËÑ±Á¶ª‰ΩúÁî®ÂüüÂêéÂ∞±‰ºöËá™Ë°åËß£ÈîÅ„ÄÇ

Áé∞Âú®ÁöÑÈóÆÈ¢òÊòØÂ¶Ç‰ΩïÂú®Â§öÁ∫øÁ®ã‰∏≠‰ΩøÁî®‰∫íÊñ•ÈáèÔºå‰πüÂ∞±ÊòØ‰ΩøÁî®Êô∫ËÉΩÊåáÈíàÂ§ÑÁêÜ Multiple Ownership ÈóÆÈ¢ò„ÄÇ

‰ΩÜÊòØ‰∏çËÉΩÁõ¥Êé•‰ΩøÁî® `Rc<Mutex<i32>>` ËøôÊ†∑ÁöÑÊô∫ËÉΩÊåáÈíàÔºåÂõ†‰∏∫Ê≤°ÊúâÂÆûÁé∞ trait `Send`Ôºå‰∏çËÉΩÂú®Â§öÁ∫øÁ®ã‰∏≠ÂÆâÂÖ®ÂÖ±‰∫´„ÄÇ 

    let counter = Rc::new(Mutex::new(0));
    let counter = Rc::clone(&counter);

ÂèñËÄå‰ª£‰πãÁöÑÊòØ Atomic Reference CountingÔºåÂç≥ `Arc<T>`ÔºåÂÆÉÂíå `Rc<T>` Êô∫ËÉΩÊåáÈíàÂæàÂÉèÔºå‰ΩÜÊòØÊîØÊåÅÂéüÂ≠êÊìç‰Ωú„ÄÇ

‰ª•‰∏ãÊºîÁ§∫‰ΩøÁî® `Arc<T>` ÂåÖË£Ö‰∫íÊñ•Èáè‰ª•ÂÆûÁé∞Â§öÁ∫øÁ®ãÂÆâÂÖ®ÂÖ±‰∫´Ôºö

```rust,ignore
use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 1..10 { 
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

ËøôÈáåÊúâÂøÖË¶ÅÊØîËæÉ‰∏Ä‰∏ã `RefCell<T>`/`Rc<T>` ‰∏é `Mutex<T>`/`Arc<T>`„ÄÇ

Á§∫ËåÉ‰ª£Á†Å‰∏≠ `counter` ÊòØ‰∏çÂèØÂèòÈáèÔºå‰ΩÜÊòØÈÄöËøá `Mutex<T>` Êèê‰æõÁöÑÂÜÖÈÉ®ÂèØÂèòÊÄßÂÆûÁé∞‰∫ÜÂØπ `Arc<T>` ÂÜÖÈÉ®Êï∞ÊçÆÁöÑ‰øÆÊîπÔºåÂíå `Cell` ÊóèÊåáÈíàÂèØ‰ª•ÂÅöÁöÑ‰∏ÄÊ†∑„ÄÇÂú®Êô∫ËÉΩÊåáÈíàÈÉ®ÂàÜÁöÑÂÜÖÂÆπ‰∏≠Ôºå‰ΩøÁî® `RefCell<T>` ÂØπ‰∫é `Rc<T>` ÂåÖË£ÖÁöÑ‰∏çÂèØÂèòÈáèÂÅö‰∫Ü‰∏ÄÊ†∑ÁöÑ‰∫ã„ÄÇ 

‰ΩÜÊòØÊ≥®ÊÑèÔºå‰ΩøÁî® `Mutex<T>` Â∞±ÊÑèÂë≥ Rust ‰∏çËÉΩÂÜçÊèê‰æõÂÆåÊï¥ÁöÑÈÄªËæëÈîôËØØÊ£ÄÊü•„ÄÇÊô∫ËÉΩÊåáÈíàÈÉ®ÂàÜÔºåÊºîÁ§∫‰∫Ü‰∏§‰∏™ `Rc<T>` Âæ™ÁéØÂºïÁî®ÂØºËá¥ÂÜÖÂ≠òÊ≥ÑÊºèÔºåËÄå `Mutex<T>` ÂàôÂèØËÉΩÂ∏¶Êù•Ê≠ªÈîÅÈóÆÈ¢òÔºåÂΩì‰∏§‰∏™ËµÑÊ∫êÈÅá‰∏ä‰∏§‰∏™ÊåÅÊúâÂÖ∂‰∏ÄÁöÑÁ∫øÁ®ãÔºåÂπ∂‰∏î‰∏§Á∫øÁ®ãÈÉΩÂú®Á≠âÂæÖÂè¶‰∏Ä‰∏™ËµÑÊ∫êÔºåËøôÂ∞±ÊòØÊ≠ªÈîÅ„ÄÇ

Arc ÊåáÈíàÂØπÊ≠§‰πü‰∏çËÉΩÂπ∏ÂÖçÔºåÂÆÉ‰ª¨ÈÉΩÂèØËÉΩÂºïÂÖ•Ê≠ªÈîÅÈóÆÈ¢òÔºå‰ΩÜÊòØÁ±ª‰ººÁöÑÔºåÂÆÉÂèØ‰ª•ÈÄöËøá Atomic Weak ÊåáÈíàÂáèÂ∞ëËøôÁßçÊÉÖÂÜµ„ÄÇ

Âú®‰ΩøÁî®ÁÆ°ÈÅì‰º†ÈÄíÊ∂àÊÅØÊó∂‰πü‰ºöÂèëÁîüÊ≠ªÈîÅÔºåÂ¶Ç‰∏ãÈù¢‰ª£Á†ÅÊâÄÁ§∫Ôºö

```rust,ignore
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx1, rx1) = mpsc::channel();
    let (tx2, rx2) = mpsc::channel();

    thread::spawn(move || {
        rx1.recv().unwrap();
        tx2.send(()).unwrap();
    });

    rx2.recv().unwrap();
    tx1.send(()).unwrap();
    println!("Never Done!");
}
```

ÊØè‰∏™Á∫øÁ®ãÈúÄË¶ÅÂÖà‰ªé channel Êé•Êî∂‰∏Ä‰∏™Ê∂àÊÅØÂÜçÂêëÂè¶‰∏ÄÁ´ØÂèëÈÄÅÊ∂àÊÅØÔºåÊâÄ‰ª•‰∏§‰∏™Á∫øÁ®ãÈÉΩ‰ºö‰∏ÄÁõ¥Á≠âÂæÖ‰∏ãÂéª„ÄÇ



## ‚ö° Send & Sync traits
- https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html

Rust ËØ≠Ë®ÄÊèê‰æõÁöÑÂπ∂ÂèëÊ¶ÇÂøµÂæàÂ∞ëÔºå‰∏ªË¶ÅÊòØÊ†áÂáÜÂ∫ìÂÖ≥‰∫éÂπ∂ÂèëÁöÑÈÉ®ÂàÜÂÜÖÂÆπ„ÄÇ

‰ΩÜÊòØÊúâ‰∏§‰∏™ÂÜÖÂµå‰∫é Rust ËØ≠Ë®Ä‰∏≠ÁöÑÂπ∂ÂèëÊ¶ÇÂøµÔºåÂ∞±ÊòØ Sync Âíå Send Ëøô‰∏§‰∏™ÂÆö‰πâÂú® std::marker Ê®°Âùó‰∏≠ÁöÑ trait„ÄÇ

Marker trait ÂÆûÈôÖÂ∞±ÊòØ‰∏ÄÁßçÁ∫¶ÂÆöÔºåÊ≤°ÊúâÊñπÊ≥ïÁöÑÂÆö‰πâÔºå‰πüÊ≤°ÊúâÂÖ≥ËÅîÂÖÉÁ¥†ÔºåÂÆûÁé∞ÂÆÉÂ∞±ÂøÖÈ°ªÊª°Ë∂≥ËøôÁßçÁ∫¶ÂÆö„ÄÇ‰∏ÄÁßçÁ±ªÂûãÊòØÂê¶Âä†‰∏äËøôÁßçÁ∫¶ÂÆöÔºåË¶Å‰πàÊòØÁºñËØëÂô®ÁöÑË°å‰∏∫ÔºåË¶Å‰πàÊòØ‰∫∫Â∑•ÊâãÂä®ÁöÑË°å‰∏∫„ÄÇ

- Allowing Transference of Ownership Between Threads with `Send`
- Allowing Access from Multiple Threads with `Sync`

Send Âíå Sync Âú®Â§ßÈÉ®ÂàÜÊÉÖÂÜµ‰∏ã‰ºöÁî±ÁºñËØëÂô®Ëá™Âä®Êé®ÂØºÂá∫Êù•ÔºåÈíàÂØπ Rust ÁöÑÂü∫Á°ÄÁ±ªÂûãÂíå std ‰∏≠ÁöÑÂ§ßÈÉ®ÂàÜÁ±ªÂûã„ÄÇÂØπ‰∫é‰∏çËÉΩÁî±ÁºñËØëÂô®Ëá™Âä®Êé®ÂØºÂá∫Êù•ÁöÑÁ±ªÂûãÔºåË¶Å‰ΩøÂÆÉ‰ª¨ÂÖ∑Êúâ Send Êàñ Sync ÁöÑÁ∫¶ÂÆöÔºåÂèØ‰ª•Áî±‰∫∫ÊâãÂä®ÂÆûÁé∞„ÄÇÂÆûÁé∞ÁöÑÊó∂ÂÄôÔºåÂøÖÈ°ª‰ΩøÁî® `unsafe` ÊñπÂºèÔºåÂõ†‰∏∫ Rust ‰∏≠Áî±Á®ãÂ∫èÂëòËá™Â∑±ÊéßÂà∂ÁöÑ‰∏úË•øÔºåÁªüÁªüÊ†áËÆ∞‰∏∫ unsafeÔºåÂá∫‰∫ÜÈóÆÈ¢òÁî±Á®ãÂ∫èÂëòËá™Ë°åË¥üË¥£„ÄÇÊØîÂ¶ÇÔºåÁªô‰∏çÊòØÁ∫øÁ®ãÂÆâÂÖ®ÁöÑÂØπË±°Âä†‰∏ä Sync Á∫¶ÂÆö„ÄÇ

Ëøô‰∏§‰∏™Á∫¶ÂÆöÁöÑÂê´‰πâÂ¶Ç‰∏ãÔºö

- ÂØπ‰∫é T: SendÔºåÂ∞Ü T ‰º†Âà∞Âè¶‰∏Ä‰∏™Á∫øÁ®ãÔºåÊâÄÊúâÊùÉ‰πü‰∏ÄÂπ∂‰º†ÈÄíÔºå‰∏ç‰ºöÂØºËá¥Êï∞ÊçÆÁ´û‰∫âÊàñÂÖ∂ÂÆÉ‰∏çÂÆâÂÖ®ÊÉÖÂÜµÔºåÂ¶ÇÊåâÂÄº‰º†ÈÄÅÔºåÂ§öÊâÄÊúâÊùÉÁöÑ `Rc<T>` Âàô‰∏çÂèØ„ÄÇ
    - Send ÊòØÂØπË±°ÂèØ‰ª•ÂÆâÂÖ®ÂèëÈÄÅÂà∞Âè¶‰∏Ä‰∏™ÊâßË°å‰Ωì‰∏≠Ôºõ
    - Send ‰ΩøË¢´ÂèëÈÄÅÂØπË±°ÂèØ‰ª•Âíå‰∫ßÁîüÂÆÉÁöÑÁ∫øÁ®ãËß£ËÄ¶ÔºåÈò≤Ê≠¢ÂéüÁ∫øÁ®ãÂ∞ÜÊ≠§ËµÑÊ∫êÈáäÊîæÂêéÔºåÂú®ÁõÆÊ†áÁ∫øÁ®ã‰∏≠‰ΩøÁî®Âá∫ÈîôÔºàuse after freeÔºâ„ÄÇ
- ÂØπ‰∫é T: SyncÔºåÂ∞Ü &T ‰º†Âà∞Âè¶‰∏Ä‰∏™Á∫øÁ®ã‰∏≠Êó∂Ôºå‰∏ç‰ºöÂØºËá¥Êï∞ÊçÆÁ´û‰∫âÊàñÂÖ∂ÂÆÉ‰∏çÂÆâÂÖ®ÊÉÖÂÜµÔºå`Rc<T>` ‰πü‰∏çÂèØ‰ª•„ÄÇ
    - Sync ÊòØÂèØ‰ª•Ë¢´ÂêåÊó∂Â§ö‰∏™ÊâßË°å‰ΩìËÆøÈóÆËÄå‰∏çÂá∫ÈîôÔºõ
    - Sync Èò≤Ê≠¢ÁöÑÊòØÁ´û‰∫âÔºõ

Êé®ËÆ∫Ôºö

- T: Sync ÊÑèÂë≥ÁùÄ &T: SendÔºõ
- Sync + Copy = SendÔºõ
- ÂΩì T: Send Êó∂ÔºåÂèØÊé®ÂØºÂá∫ &mut T: SendÔºõ
- ÂΩì T: Sync Êó∂ÔºåÂèØÊé®ÂØºÂá∫ &mut T: SyncÔºõ
- ÂΩì &mut T: Send Êó∂Ôºå‰∏çËÉΩÊé®ÂØºÂá∫ T: SendÔºõ

ÂÖ∑‰ΩìÁöÑÁ±ªÂûãÔºö

- ÂéüÂßãÁ±ªÂûãÔºàÊØîÂ¶ÇÔºö u8, f64ÔºâÔºåÈÉΩÊòØ SyncÔºåÈÉΩÊòØ CopyÔºåÂõ†Ê≠§ÈÉΩÊòØ SendÔºõ
- Âè™ÂåÖÂê´ÂéüÂßãÁ±ªÂûãÁöÑÂ§çÂêàÁ±ªÂûãÔºåÈÉΩÊòØ SyncÔºåÈÉΩÊòØ CopyÔºåÂõ†Ê≠§ÈÉΩÊòØ SendÔºõ
- ÂΩì T: SyncÔºåBox<T>, Vec<T> Á≠âÈõÜÂêàÁ±ªÂûãÊòØ SyncÔºõ
- ÂÖ∑ÊúâÂÜÖÈÉ®ÂèØÂèòÊÄßÁöÑÁöÑÊåáÈíàÔºå‰∏çÊòØ Sync ÁöÑÔºåÊØîÂ¶Ç Cell, RefCell, UnsafeCellÔºõ
- Rc ‰∏çÊòØ Sync„ÄÇÂõ†‰∏∫Âè™Ë¶Å‰∏ÄÂÅö &Rc<T> Êìç‰ΩúÔºåÂ∞±‰ºöÂÖãÈöÜ‰∏Ä‰∏™Êñ∞ÂºïÁî®ÔºåÂÆÉ‰ºö‰ª•ÈùûÂéüÂ≠êÊÄßÁöÑÊñπÂºè‰øÆÊîπÂºïÁî®ËÆ°Êï∞ÔºåÊâÄ‰ª•ÊòØ‰∏çÂÆâÂÖ®ÁöÑÔºõ
- Ë¢´ Mutex Âíå RWLock ÈîÅ‰ΩèÁöÑÁ±ªÂûã T: SendÔºåÊòØ Sync ÁöÑÔºõ
- ÂéüÂßãÊåáÈíàÔºà`*mut`, `*const`ÔºâÊó¢‰∏çÊòØ Send ‰πü‰∏çÊòØ SyncÔºõ

Rust Ê≠£ÊòØÈÄöËøáÊâÄÊúâÊùÉÂíåÁîüÂëΩÂë®Êúü + Send Âíå SyncÔºàÊú¨Ë¥®‰∏ä‰∏∫Á±ªÂûãÁ≥ªÁªüÔºâÊù•‰∏∫Âπ∂ÂèëÁºñÁ®ãÊèê‰æõ‰∫ÜÂÆâÂÖ®ÂèØÈù†ÁöÑÂü∫Á°ÄËÆæÊñΩÔºå‰ΩøÂæóÁ®ãÂ∫èÂëòÂèØ‰ª•ÊîæÂøÉÂú®ÂÖ∂‰∏äÊûÑÂª∫Á®≥ÂÅ•ÁöÑÂπ∂ÂèëÊ®°Âûã„ÄÇËøô‰πüÊ≠£ÊòØ Rust ÁöÑÊ†∏ÂøÉËÆæËÆ°ËßÇÁöÑ‰ΩìÁé∞ÔºöÂÜÖÊ†∏Âè™Êèê‰æõÊúÄÂü∫Á°ÄÁöÑÂéüËØ≠ÔºåÁúüÊ≠£ÁöÑÂÆûÁé∞ËÉΩÂàÜÁ¶ªÂá∫ÂéªÂ∞±ÂàÜÁ¶ªÂá∫Âéª„ÄÇ



# üü°üü† Multithreaded Web Server
- https://doc.rust-lang.org/book/ch20-00-final-project-a-web-server.html
- https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html
- The I/O Prelude https://doc.rust-lang.org/stable/std/io/prelude/index.html
- Filesystem manipulation operations https://doc.rust-lang.org/stable/std/fs/index.html
- Hypertext Transfer Protocol -- HTTP/1.1 https://tools.ietf.org/html/rfc2616
- Tokio - Event-driven NBIO asynchronous I/O https://crates.io/crates/tokio
- hyper - A fast and correct HTTP library https://crates.io/crates/Hyper
- Actix Web framework https://crates.io/crates/actix-web
- Rocket Web framework https://crates.io/crates/rocket
- Rocket web framework Community contributed https://crates.io/crates/rocket_contrib
- Iron is a high level web framework https://docs.rs/iron/0.6.1/iron/
- A standard library for the client-side Web https://crates.io/crates/stdweb
- Gotham - A flexible web framework https://github.com/gotham-rs/gotham

ËøôÈÉ®ÂàÜ‰∏ªË¶ÅÂÜÖÂÆπÔºö

- Building a Single-Threaded Web Server
- Turning Our Single-Threaded Server into a Multithreaded Server
- Graceful Shutdown and Cleanup

ÂâçÊèêÂü∫Á°ÄÔºåÈúÄË¶Å‰∫ÜËß£ TCP/IP ÂçèËÆÆÔºå‰∏ªË¶ÅÊòØ HTTP ÂçèËÆÆ„ÄÇ

HTTP ËØ∑Ê±ÇÊï∞ÊçÆÂåÖÊ†ºÂºèÁªìÊûÑÂ§ßÊ¶ÇÂ¶Ç‰∏ãÔºö

    Method Request-URI HTTP-Version CRLF
    header CRLF
    ...
    CRLF
    message-body

HTTP ÂìçÂ∫îÊï∞ÊçÆÂåÖÊ†ºÂºèÁªìÊûÑÂ§ßÊ¶ÇÂ¶Ç‰∏ãÔºö

    HTTP-Version Status-Code Reason-Phrase CRLF
    header CRLF
    ...
    CRLF
    message-body

È¶ñÂÖàÂàõÂª∫Â∑•Á®ãÔºö

    cargo new webserver

ÂÆûÁé∞‰∏Ä‰∏™ÂçïÁ∫øÁ®ãÁöÑÊúçÂä°Âô®Ôºö

```rust,ignore
use std::net::TcpListener;
use std::net::TcpStream;
use std::io::prelude::*;
use std::fs;

fn main(){
    let listener = TcpListener::bind("127.0.0.1:80").unwrap();
    for stream in listener.incoming(){
        // let ts: TcpStream = stream.unwrap();
        // handle(ts);
        match stream {
            Ok(ts) => {
                println!("Connection established! {:?}", ts);
                handle(ts);
            }
            Err(e) => {
                println!("Error {:?}", e)
            }
        }
    }
}

fn handle(mut ts: TcpStream){
    let mut buf = [0; 1024];
    let size = ts.read(&mut buf).unwrap();
    println!("Request: {:?}", String::from_utf8_lossy(&buf[..=size]));
    
    let home = b"GET / HTTP/1.1\r\n";
    let fav = b"GET /favicon.ico HTTP/1.1\r\n";
    
    let (status_line, contents) = if buf.starts_with(home) {
        let contents = fs::read_to_string("Cargo.toml").expect("FileNotFound");
        ("HTTP/1.1 200 OK\r\n", contents)
    } else if buf.starts_with(fav) {
        ("HTTP/1.1 404 NOT FOUND\r\n", String::from(""))
    } else {
        let msg = "
        <h1>Message</h1>
        <p>Hello World!</p>
        ";
        ("HTTP/1.1 200 OK\r\n", String::from(msg))
    };
    let status = format!("{}Content-Type: html\r\nContent-Length: {}\r\n\r\n", status_line, contents.len());
    ts.write(status.as_bytes()).unwrap();
    ts.write(contents.as_bytes()).unwrap();
    ts.flush().unwrap();
}
```

Ë¶ÅÁÇπÔºö

- `bind(addr)` ÊñπÊ≥ïËøîÂõû `Result<T, E>` Êûö‰∏æÁ±ªÂûãÔºåÁªëÂÆöÊàêÂäüÂ∞±ÂèØ‰ª•ÂæóÂà∞ TcpListener ÂÆû‰æãÔºõ
- `incoming()` ÊñπÊ≥ïËøîÂõû‰∏Ä‰∏™Ê∞∏‰∏çËøîÂõû None ÁöÑËø≠‰ª£Âô®ÔºåÂíåÂÆ¢Êà∑Á´ØÂª∫Á´ãËøûÊé•Â∞±ËøîÂõû‰∏Ä‰∏™ÊµÅÂØπË±°Ôºõ
- std::fs Êñá‰ª∂Á≥ªÁªüÊ®°ÂùóÊèê‰æõÂáΩÊï∞Êìç‰ΩúÊñá‰ª∂Ôºõ
- std::io::prelude The I/O Prelude Êèê‰æõÊñá‰ª∂Êìç‰ΩúÊñπÊ≥ïÁöÑÂÆûÁé∞Ôºõ
- `read(&mut buffer)` ËØªÂèñËØ∑Ê±ÇÊµÅÊï∞ÊçÆÔºõ
- `write(&mut buffer)` ÂÜôÂÖ•ÂìçÂ∫îÊµÅÊï∞ÊçÆÔºõ

‰ΩøÁî® String::from_utf8_lossy ÊñπÊ≥ïÂèØ‰ª•ÂÆΩÊùæÂ§ÑÁêÜÈùû UTF8 ÁºñÁ†ÅÂÜÖÂÆπÔºå‰ºö‰ΩøÁî® U+FFFD REPLACEMENT CHARACTER Âç≥ ÔøΩ Á¨¶Âè∑ÂéªÊõøÊç¢ÈùûÊ≥ïÂ≠óÁ¨¶„ÄÇ

‰ΩøÁî® autocannon ËøõË°åÊµãËØïÔºö

    $ autocannon -c 100 -d 5 -p 2 http://localhost/i
    Running 5s test @ http://localhost/i
    100 connections with 2 pipelining factor

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Stat    ‚îÇ 2.5%   ‚îÇ 50%     ‚îÇ 97.5%   ‚îÇ 99%     ‚îÇ Avg        ‚îÇ Stdev     ‚îÇ Max     ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ Latency ‚îÇ 269 ms ‚îÇ 1762 ms ‚îÇ 3091 ms ‚îÇ 3144 ms ‚îÇ 1745.47 ms ‚îÇ 829.25 ms ‚îÇ 3220 ms ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Stat      ‚îÇ 1%     ‚îÇ 2.5%   ‚îÇ 50%    ‚îÇ 97.5%  ‚îÇ Avg    ‚îÇ Stdev   ‚îÇ Min    ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ Req/Sec   ‚îÇ 1631   ‚îÇ 1631   ‚îÇ 2585   ‚îÇ 2813   ‚îÇ 2413   ‚îÇ 419.27  ‚îÇ 1631   ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ Bytes/Sec ‚îÇ 197 kB ‚îÇ 197 kB ‚îÇ 313 kB ‚îÇ 340 kB ‚îÇ 292 kB ‚îÇ 50.7 kB ‚îÇ 197 kB ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    Req/Bytes counts sampled once per second.

    12k requests in 5.07s, 1.46 MB read
    13k errors (0 timeouts)

Ëøô‰∏™ÂçïÁ∫øÁ®ãÂÆûÁé∞ÁöÑ Web ÊúçÂä°Âô®ÁöÑÂìçÂ∫îÊïàÁéáÂπ∂‰∏çÈ´òÔºåÂõ†‰∏∫ÊØè‰∏™ÂÆ¢Êà∑Á´ØËøûÊé•ÈÉΩÈúÄË¶ÅÁ≠âÂæÖÂâç‰∏Ä‰∏™ËøûÊé•Â§ÑÁêÜÂÆåÊàêÂêéÂÜçË∑üËøõÂ§ÑÁêÜÔºåÈúÄË¶Å‰ΩøÁî®Â§öÁ∫øÁ®ãÂØπÂÖ∂ËøõË°åÊîπÈÄ†„ÄÇ

ÈÄöÂ∏∏Ôºå‰ΩøÁî®Á∫øÁ®ãÊ±† thread pool ÊòØ‰∏Ä‰∏™‰∏çÈîôÁöÑÊñπÊ°àÔºåËÆæÁΩÆ‰∏ÄÂÆöÊï∞ÈáèÁöÑÁ∫øÁ®ãÊù•Â§ÑÁêÜÂÆ¢Êà∑Á´ØËøûÊé•ÔºåÊØè‰∏™Á∫øÁ®ãÂú®Â§ÑÁêÜÂÆå‰∏Ä‰∏™ËøûÊé•ÂêéÂ∞±ËøõÂÖ•Á©∫Èó≤Áä∂ÊÄÅÔºåÁ≠âÂæÖÊñ∞ÁöÑËøûÊé•ËøõÂÖ•„ÄÇËøôÁßçÊñπÊ°àÊØîÂçïÁã¨‰∏Ä‰∏™Á∫øÁ®ãÂØπÂ∫î‰∏Ä‰∏™ËøûÊé•ÁöÑÊñπÊ°àÊõ¥ËäÇÁúÅËµÑÊ∫êÔºåÁªìÂêà single-threaded async I/O ÂèØ‰ª•ÂÆûÁé∞ÊÄßËÉΩÈùûÂ∏∏È´òÁöÑÊúçÂä°Âô®„ÄÇÂπ∂‰∏îÔºåÁî±‰∫éÁ∫øÁ®ãÊï∞ÈáèÂèØÊéßÔºåËøôÁßçÊñπÊ°àÊõ¥ÂÆπÊòìÂ∫î‰ªò DoS - Denial of Service ÊîªÂáªÔºå‰∏ç‰ºöÂõ†‰∏∫Â§ßÈáèÊ∂åÂÖ•ÁöÑÊîªÂáªËØ∑Ê±ÇËÄåÂØºËá¥ÊúçÂä°Âô®ÂÆïÊú∫„ÄÇ

‰ΩøÁî®`unwrap`ÊñπÊ≥ïÁöÑÂéüÂõ†ÊòØÊàë‰ª¨Áü•ÈÅìÂ§±Ë¥•ÊÉÖÂΩ¢‰∏ç‰ºöÂèëÁîüÔºå‰ΩÜÊòØÁºñËØëÂô®‰∏çÁü•ÈÅìËøô‰∏ÄÁÇπ„ÄÇ

Âè¶Â§ñÔºåÊúçÂä°Âô®‰πüÊ≤°ÊúâÂØπÂèØ‰ª•Âú®Â§ÑÁêÜËøáÁ®ã‰∏≠Âá∫Áé∞‰∏≠Êñ≠ËøûÊé•ÁöÑÊÉÖÂΩ¢ËøõË°åÂ§ÑÁêÜÔºåÂØπ‰ªª‰ΩïÂ∑≤Áªè‰∏≠Êñ≠ËøûÊé•ÁöÑ`TcpStream`ÂØπË±°ËøõË°åÊìç‰ΩúÈÉΩ‰ºöÂØºËá¥Â§ÑÁêÜÁ∫øÁ®ã panic„ÄÇ

Âú®Â§ÑÁêÜÂáΩÊï∞‰∏≠ÔºåËØªÂèñÊï∞ÊçÆÊó∂ÈúÄË¶ÅÂà§Êñ≠‰∏Ä‰∏ãÔºö

```rust,ignore
if let Ok(size) = ts.read(&mut buf) {
    println!("Read TcpStream bytes {}.", size);
}else{
    println!("Fail to read TcpStream.");
    return ;
}
```


## ‚ö° Thread Pool Á∫øÁ®ãÊ±†ÂÆûÁé∞
- https://crates.io/crates/scheduled-thread-pool

ÂèØ‰ª•Âú® crates.io ‰∏äÊâæÂà∞Áé∞ÊúâÁöÑÁ∫øÁ®ãÊ±†ÂÆûÁé∞ÔºåÂ≠¶‰π†‰ªñ‰∫∫ÁöÑÂÆûÁé∞‰∏éËøôÈáåÁöÑÂÆûÁé∞Â∑ÆÂºÇÔºåÊØîËæÉ‰∏Ä‰∏ãÂì™ÁßçÂÆûÁé∞Êõ¥Âº∫Â£Æ„ÄÇ

Áé∞Âú®Êù•ËÆæËÆ°Á∫øÁ®ãÊ±†Êé•Âè£ÔºåÂè™ÈúÄË¶Å ThreadPool ÂèØ‰ª•ÈÖçÁΩÆÁ∫øÁ®ãÊï∞ÈáèÂç≥ÂèØÔºåÊèê‰æõ‰∏Ä‰∏™ `execute()` ÊñπÊ≥ïÊù•Â§ÑÁêÜÂÆ¢Êà∑Á´ØËØ∑Ê±ÇÔºö

```rust,ignore
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle(stream);
        });
    }
}
```

Â∞ùËØïÁºñËØë‰ª•‰∏ä‰ª£Á†ÅÔºåÁºñËØëÂô®‰ºöÁªôÂá∫ÈîôËØØÊèêÁ§∫Ôºå`ThreadPool` Ê≤°ÊúâÂÆûÁé∞Ôºå‰πüÊ≤°Êúâ `execute()` ÊñπÊ≥ïÔºåÈúÄË¶ÅÂéªÂÆûÁé∞ÂÆÉ‰ª¨„ÄÇRust Â∞ÜËøôÁßçÊ†πÊçÆÁºñËØëÂô®ÊèêÁ§∫Êù•Ë∑üËøõ‰ª£Á†ÅÂÆûÁé∞ÁöÑÂºÄÂèëÊµÅÁ®ãÁß∞‰∏∫ Compiler Driven Development„ÄÇ

Âè¶Â§ñÔºåËøòÈúÄË¶ÅÊäΩË±°‰∏Ä‰∏™Â∑•‰ΩúÁ∫øÁ®ã `Worker` ÂØπË±°Êù•ÁÆ°ÁêÜÁ∫øÁ®ãÁöÑËøêË°åÔºåÂπ∂‰øùÂ≠òÂú®Á∫øÁ®ãÊ±†‰øùÂÜÖÁöÑÈòüÂàó‰∏≠ÔºåÊØè‰∏™Â∑•‰ΩúÁ∫øÁ®ãÂú®ÊâßË°å‰ª£Á†ÅÊó∂Â∞±ÂàõÂª∫Êñ∞ÁöÑÁ∫øÁ®ãÔºåÂÆåÊàêÂêéÂ∞±ËøõÂÖ•Á©∫Èó≤Áä∂ÊÄÅ„ÄÇ

Â∑•‰ΩúÁ∫øÁ®ã‰ΩøÁî®ÁÆ°ÈÅìËøõË°åÈÄö‰ø°ÔºåÂè™ÈúÄÊé•Êî∂‰ªéÁ∫øÁ®ãÊ±†‰º†ÈÄíËøáÊù•ÁöÑÂ∞ÜÂÆ¢Êà∑ËøûÊé•‰ªªÂä°Ôºå‰ª•ÂèäÁªìÊùüÊ∂àÊÅØÁöÑÂ§ÑÁêÜÂç≥ÂèØ„ÄÇÊâÄ‰ª•ÔºåÈúÄË¶ÅÂú®Á∫øÁ®ãÊ±†ÂØπË±°‰∏≠ÂàõÂª∫ÁÆ°ÈÅìÔºåÂπ∂Â∞ÜÊé•Êî∂Á´Ø‰∫§Áªô Worker ‰ª•Êé•Êî∂Á∫øÁ®ãÊ±†‰∏≠ÈÄöËøáÂèëÈÄÅÁ´Ø‰º†ÈÄíÊù•ËøáÁöÑÊ∂àÊÅØ„ÄÇ

Á∫øÁ®ãÊ±†Âú®ÂÆû‰æãÂåñÊó∂Â∞±ÂàõÂª∫Â∑•‰ΩúÁ∫øÁ®ãÔºåÂπ∂Áî±Â∑•‰ΩúÁ∫øÁ®ãÊâßË°åÁ∫øÁ®ãÁöÑÂ≠µÂåñÂáΩÊï∞ÔºåÂÄüÂä©ÁÆ°ÈÅìÁöÑ `recv()` ÊñπÊ≥ïÁöÑÈòªÂ°ûÂäüËÉΩÔºåÂèØ‰ª•ÁªìÂêà `loop` Âæ™ÁéØÁªìÊûÑÊù•ÊåÅÁª≠‰∏çÊñ≠Âú∞ÊâßË°åÔºöËøûÊé•Â§ÑÁêÜ -> ÂÆåÊàêÂ§ÑÁêÜ -> ËøõÂÖ•Á©∫Èó≤ -> Â§ÑÁêÜÊñ∞ËøûÊé•„ÄÇ

Á∫øÁ®ãÊ±†ÈúÄË¶ÅÂú® `execute()` ÊñπÊ≥ïÂ∞ÜÂÆ¢Êà∑ËøûÊé•ÁöÑÂ§ÑÁêÜÂáΩÊï∞ÈÄöËøáÁÆ°ÈÅìÊ∂àÊÅØËΩ¨ÂèëÁªôÂ∑•‰ΩúÁ∫øÁ®ãÔºåÁî±Â∑•‰ΩúÁ∫øÁ®ãÊâßË°åÂ§ÑÁêÜÂáΩÊï∞Ôºö

    pub fn spawn<F, T>(f: F) -> JoinHandle<T> 
    where
        // F: FnOnce() -> T + Send + 'static,
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static, 

Ê†πÊçÆ Traits Êâ©Â±ïÁöÑÂÜÖÈÉ®ÂèØÁü•ÔºåÈó≠ÂåÖÊúâ Fn, FnMut, FnOnce Á≠âÂü∫Êú¨ÊñπÂºèÔºåËÄå `spawn` ÊñπÊ≥ïË¶ÅÊ±Ç‰∫Ü FnOnce Âç≥ÈúÄË¶ÅÁßªÂä®ÂºïÁî®ÁöÑÂ§ñÈÉ®Êï∞ÊçÆÊâÄÊúâÊùÉ„ÄÇÂõ†Ê≠§ÂÆûÁé∞Á∫øÁ®ãÊ±†ÁöÑ `execute()` ÊñπÊ≥ï‰πüÈúÄË¶ÅÊé•Êî∂‰∏Ä‰∏™ F Á±ªÂûãÁöÑÂèÇÊï∞ÔºåÊ≥®ÊÑèÔºå‰º†ÂÖ•ÁöÑ Fn ËøòÂÆûÁé∞‰∫Ü Send Ë°®Á§∫Âú®Á∫øÁ®ãÈó¥ÁßªÂä®ÊâÄÊúâÊùÉÂÖ∑ÊúâÁ∫øÁ®ãÂÆâÂÖ®ÁâπÊÄßÔºåËøòÊúâ `'static` ÁîüÂëΩÂë®ÊúüÔºå‰ª•„ÄÇ

‰∏∫‰∫ÜÊõ¥Â•ΩÂú∞ÁªÑÁªá‰ª£Á†ÅÊñá‰ª∂ÔºåÂ∞ÜÁ∫øÁ®ãÊ±†ÈÉ®ÂàÜ‰ª£Á†ÅÂÜôÂà∞ lib.rs Êñá‰ª∂Ôºå‰Ωú‰∏∫Â∫ìÊñá‰ª∂„ÄÇ

‰∏ªÁ®ãÂ∫è server.rs Âíå client.rs ÂàÜÂà´‰ΩúÁî®ÊúçÂä°Âô®ÔºåÂíåÂÆ¢Êà∑Á´ØÁ®ãÂ∫èÔºåÂèØ‰ª•ÊîæÂÖ• bin ÁõÆÂΩï‰∏≠ÔºåÁªìÊûÑÂ¶Ç‰∏ãÔºö

    src
     +-- bin
     |    +-- main.rs
     |    +-- main.rs
     +-- lib.rs

Ê≥®ÊÑèÔºåÂàõÂª∫Â∑•Á®ãÊó∂‰ΩøÁî®ÁöÑÊòØ webserver ‰Ωú‰∏∫ÂêçÁß∞ÔºåÂºïÁî®Â∫ìÈúÄË¶ÅÊåáÂÆöÂΩìÂâçÂ∑•Á®ãÂëΩÂêçÁ©∫Èó¥Ôºö

    use webserver::ThreadPool;

ÊâßË°åÁ®ãÂ∫èÂèØ‰ª•‰ΩøÁî®‰ª•‰∏ãÂëΩ‰ª§Ôºö

    cargo run --release --bin server
    cargo run --release --bin client

ÂÆ¢Êà∑Á´ØÁ®ãÂ∫èÂè™ÊòØÁÆÄÂçïÁöÑ Echo ClientÔºö

```rust,ignore
use std::io::{self, Read};
use std::net::TcpStream;
use std::io::prelude::*;
// use std::io::Write;
use std::env;

fn main() {
  let args:Vec<String> = env::args().collect();
  if args.len()==1 {
    println!("Usage: {} 127.0.0.1:80", args[0]);
    return ;
  }
  let mut stream = TcpStream::connect(&args[1])
      .expect("Couldn't connect to the server...");
  stream.set_nonblocking(true).expect("set_nonblocking call failed");

  stream.write("GET / HTTP/1.1\r\n".as_bytes());

  let mut buf = vec![];
  loop {
      match stream.read_to_end(&mut buf) {
          Ok(_) => break,
          Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {
            // wait until network socket is ready, typically implemented
            // via platform-specific APIs such as epoll or IOCP
            // wait_for_fd();
          }
          Err(e) => panic!("encountered IO error: {}", e),
      };
  };
  println!("{}", String::from_utf8_lossy(&buf[..]));
}
```

‰ª•‰∏ãÊòØÈúÄË¶ÅÁöÑÊúçÂä°Âô®Á´ØÂü∫Êú¨Á±ªÂûãÂÆö‰πâÔºö

```rust,ignore
pub struct ThreadPool {
    workers: Vec<Worker>,
    sender: mpsc::Sender<Message>,
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

enum Message {
    NewJob(Job),
    Terminate,
}
```

Èô§‰∫ÜÂü∫Êú¨ÁöÑÁ∫øÁ®ãÊ±†„ÄÅÂ∑•‰ΩúÁ∫øÁ®ãÂØπË±°ÔºåËøòÂÆö‰πâ‰∫ÜÔºö

- `Job` Á±ªÂûãÔºå‰ΩøÁî®Êô∫ËÉΩÊåáÈíàÂåÖË£ÖËøûÊé•Â§ÑÁêÜÂáΩÊï∞Â∞ÅË£ÖÂêéÁöÑÈó≠ÂåÖÔºåÂπ∂ÈÄöËøáÊ∂àÊÅØÂú®ÁÆ°ÈÅì‰∏≠‰º†ÈÄíÔºåÁî±Á∫øÁ®ãÊ±†ÂèëÈÄÅÁªôÂ∑•‰ΩúÁ∫øÁ®ã„ÄÇ
- `Message` Ê∂àÊÅØÊûö‰∏æÁ±ªÂûãÔºå‰∏ªË¶ÅÊúâ `NewJob(Job)` Âíå `Terminate` ‰∏§ÁßçÂèñÂÄº„ÄÇ

Êé•‰∏ãÊù•Â∞±ÈúÄË¶ÅÂÆûÁé∞Á∫øÁ®ãÊ±†ÂíåÂ∑•‰ΩúÁ∫øÁ®ãÔºö

```rust,ignore
impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);
        let (sender, receiver) = mpsc::channel();
        let receiver = Arc::new(Mutex::new(receiver));
        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&receiver)));
        }

        ThreadPool { workers, sender }
    }

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&mut self) {

        for _ in &mut self.workers {
            if let Err(val) = self.sender.send(Message::Terminate){
                println!("Fail to send Terminate to worker: {}.", val);
            }
        }

        for worker in &mut self.workers {
            if let Some(thread) = worker.thread.take() {
                if let Err(inf) = thread.join(){
                    println!("Fail to join thread: {:?}", inf);
                }
            }
        }
    }
}

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Message>>>) -> Worker {
        let name = "Worker-".to_string() + &id.to_string();
        let builder = thread::Builder::new().name(name.into());
        // let thread = thread::spawn(move || loop {
        let thread = builder.spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) => {
                    job();
                }
                Message::Terminate => {
                    break;
                }
            }
        });
        Worker { id, thread: Some(thread), }
    }
}
```

Ë¶ÅÁÇπÔºö

- ‰ΩøÁî®Êñ≠Ë®ÄÁ°Æ‰øùÊù°‰ª∂ÊàêÁ´ã `assert!(size > 0);`ÔºåÂÜçÈÖçÂêàÈõÜ‰ΩìÂ∫ìÊèê‰æõÁöÑ `with_capacity` ÂàõÂª∫ÊåáÂÆöÂÆπÈáèÁöÑÂêëÈáèÂàóË°®„ÄÇ
- ‰ΩøÁî®‰∏âÊñúÊù†Ê≥®Ëß£‰ª•ÁªôÁî®Êà∑Êèê‰æõÂ∏ÆÂä©‰ø°ÊÅØ `/// markdown`ÔºåÁî®Êà∑Âú®‰ΩøÁî®Ëøô‰∏™Â∫ìÊó∂‰ºöÂæóÂà∞ÊèêÁ§∫‰ø°ÊÅØ„ÄÇ
- ‰ΩøÁî®Èó≠ÂåÖÂ∞ÜÂÆ¢Êà∑ËøûÊé•ÁöÑÂ§ÑÁêÜÂáΩÊï∞Âíå‰∏ä‰∏ãÊñáÁªÑÁªáÂú®‰∏ÄËµ∑ÔºåËÄåÂâç‰∫§ÁªôÁ∫øÁ®ãÊ±†ÁöÑÂè™ÊòØ‰∏Ä‰∏™Êó†ÂèÇÊï∞ÁöÑÈó≠ÂåÖÂáΩÊï∞„ÄÇ
- Âú®Â∑•‰ΩúÁ∫øÁ®ã‰∏≠ÔºåÂÄüÂä©ÁÆ°ÈÅìÁöÑ `recv()` ÊñπÊ≥ïÁöÑÈòªÂ°ûÂäüËÉΩÂíå `loop` Âæ™ÁéØÁªìÊûÑÊù•ÊåÅÁª≠‰∏çÊñ≠Âú∞ÊâßË°åÂÆ¢Êà∑ËøûÊé•Â§ÑÁêÜ„ÄÇ
- ‰ΩøÁî® `Vec<Worker>` ÂêëÈáèÂàóË°®‰øùÂ≠òÂ∑•‰ΩúÁ∫øÁ®ãÂØπË±°„ÄÇ
- ‰∏∫Á∫øÁ®ãÊ±†ÂÆûÁé∞ `Drop` ‰ª•Âú®ÁªìÊùüÁ®ãÂ∫èÊó∂Ê∏ÖÁêÜÁ∫øÁ®ãÔºåËøôÊ†∑Â∞±ÂèØ‰ª•Âú®Á∫øÁ®ãÊ±†ÂÆû‰æãÁªìÊùüÁîüÂëΩÂë®ÊúüÊó∂Ê∏ÖÁêÜÊéâÂ∑•‰ΩúÁ∫øÁ®ã„ÄÇ
- ‰∏∫‰∫ÜÂú®Â∑•‰ΩúÁ∫øÁ®ã‰∏≠ÂÆûÁé∞Á∫øÁ®ãÂÆâÂÖ®ÂÖ±‰∫´ÁÆ°ÈÅìÂØπË±°Ôºå‰ΩøÁî® `Mutex` ÂØπÁÆ°ÁêÜÂØπË±°ËøõË°åÂåÖË£Ö„ÄÇ
- Âπ∂‰∏î‰ΩøÁî® `Arc` ‰∏∫ÂåÖË£Ö‰∫ÜÁÆ°ÈÅìÂØπË±°ÁöÑ‰∫íÊñ•ÈáèÂàõÂª∫Â§öÊâÄÊúâÊùÉÔºå‰ΩøÂæóÊé•Êî∂Á´ØÂèØ‰ª•Ë¢´Â§ö‰∏™Â∑•‰ΩúÁ∫øÁ®ã‰ΩøÁî®Ôºå‰ª•Êé•Êî∂Á∫øÁ®ãÊ±†‰∏≠‰º†ÈÄíÁöÑÊ∂àÊÅØ„ÄÇ

Ê≥®ÊÑèÔºåWorker ‰∏≠ÁöÑ thread ‰∏çÊòØÁõ¥Êé•‰øùÂ≠ò `JoinHandle<()>` ËÄåÊòØÂ∞ÜÁ∫øÁ®ãÂè•ÊüÑÂ∞ÅË£ÖÂú® Option Á±ªÂûãÂÜÖ„ÄÇÂõ†‰∏∫ÈúÄË¶ÅÂú®Â§ö‰∏™Á∫øÁ®ãÁßçÊâßË°åÂíåÁ∫øÁ®ãÁöÑ`join`ÔºåÂç≥ÈúÄË¶ÅÂ§ö‰∏™ÂèØÂèòÂºïÁî®„ÄÇËÄåÂÆÉ‰ª¨Ê≤°ÊúâÂÆûÁé∞ `Copy` traitÔºåÂç≥Ê≤°ÊúâÂ§öÊâÄÊúâÊùÉÁöÑÂØπË±°‰∏çËÉΩÂú®Â§ö‰∏™Á∫øÁ®ã‰∏≠ÁßªÂä®Âçï‰∏ÄÁöÑÊâÄÊúâÊùÉ„ÄÇ

ÁÆ°ÈÅìÁöÑ Receiver ÂØπË±°‰∏çËÉΩÁõ¥Êé•Âú®Â§ö‰∏™Á∫øÁ®ãÈó¥ËΩ¨ÁßªÔºåÂÆÉÊ≤°ÊúâÂÆûÁé∞ Copy TraitÔºåÊó†Ê≥ïÂú®ËΩ¨ÁßªÊâÄÊúâÊùÉËøáÁ®ã‰∏≠ËøõË°åÊã∑Ë¥ùÔºåÂ∞±Êó†Ê≥ïÂú®Â∞ÜÂÖ∂ÊâÄÊúâÊùÉÂú®Â§ö‰∏™Á∫øÁ®ãÈó¥ÁßªÂä®„ÄÇÊúÄÁÆÄÂçïÁöÑÊñπÊ≥ïÂ∞±ÊòØ‰ΩøÁî® `Arc<Mutex<T>>` ËøõË°åÂ∞ÅË£ÖÔºåÂÆûÁé∞Á∫øÁ®ãÂÆâÂÖ®ÁöÑÂ§öÊâÄÊúâÊùÉ„ÄÇ

Mutex ÂØπË±°Ê≤°Êúâ `unlock` ÊñπÊ≥ïÔºåËé∑ÂèñÈîÅÂêéËøîÂõû‰∏Ä‰∏™ `MutexGuard<T>` ÂØπË±°ÔºåÂ∞ÅË£ÖÂú® `LockResult` ÂÜÖÔºåÂÆÉÂú®ÁîüÂëΩÂë®ÊúüÁªìÊùüÊó∂Ôºå‰ºöËá™Âä®ÂØπÈîÅÂÆöÂØπË±°ËøõË°åËß£ÈîÅ„ÄÇ 

Â¶ÇÊûúÔºåÊâÄÊúâÂ≠êÁ∫øÁ®ãÂÖ®ÈÉ®ÁªìÊùüÂêéÔºåÂÜçÊ¨°ÈÄöËøáÁÆ°ÈÅìÂèëÈÄÅÊ∂àÊÅØÔºåÁî±‰∫éÊ≤°ÊúâÊé•Êî∂ÊñπÔºåÊâÄ‰ª• `send` ÊñπÊ≥ï‰ºöËøîÂõû‰∏Ä‰∏™ `SendError`„ÄÇ

ÊµãËØïÂ§öÁ∫øÁ®ãÁâàÊú¨ÁöÑ WebServerÔºö

    loadtest -n 1000 -c 100 --rps 100 http://localhost/i
    autocannon -c 100 -d 5 -p 2 http://localhost/i

Âú®Â§öÁ∫øÁ®ãËøêË°åÊù°‰ª∂‰∏ãÔºåautocannon ÊµãËØï‰ºöÂá∫Áé∞Â§ßÈáè‰∏≠Êñ≠ËøûÊé•ÁöÑÊÉÖÂÜµÔºö

    $ autocannon -c 100 -d 5 -p 2 http://localhost/i
    Running 5s test @ http://localhost/i
    100 connections with 2 pipelining factor

    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Stat    ‚îÇ 2.5%    ‚îÇ 50%     ‚îÇ 97.5%   ‚îÇ 99%     ‚îÇ Avg        ‚îÇ Stdev      ‚îÇ Max     ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ Latency ‚îÇ 1766 ms ‚îÇ 2620 ms ‚îÇ 4923 ms ‚îÇ 4985 ms ‚îÇ 3229.41 ms ‚îÇ 1002.56 ms ‚îÇ 4985 ms ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Stat      ‚îÇ 1%  ‚îÇ 2.5% ‚îÇ 50%     ‚îÇ 97.5%   ‚îÇ Avg    ‚îÇ Stdev   ‚îÇ Min     ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ Req/Sec   ‚îÇ 0   ‚îÇ 0    ‚îÇ 13      ‚îÇ 42      ‚îÇ 18.2   ‚îÇ 14.75   ‚îÇ 9       ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ Bytes/Sec ‚îÇ 0 B ‚îÇ 0 B  ‚îÇ 1.57 kB ‚îÇ 5.08 kB ‚îÇ 2.2 kB ‚îÇ 1.78 kB ‚îÇ 1.09 kB ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

    Req/Bytes counts sampled once per second.

    91 requests in 5.08s, 11 kB read
    16k errors (0 timeouts)


# üü°üü† Game
- Bevy data-driven game engine built in Rust https://bevyengine.org
- Bevy Getting Started https://bevyengine.org/learn/book/getting-started/
- Amethyst Game Engine https://github.com/amethyst/amethyst
- Amethyst Documentation https://book.amethyst.rs/book/stable/
- cargo-apk https://lib.rs/crates/cargo-apk
- Rust-SDL2 https://crates.io/crates/sdl2
- Safe Rust wrapper around the Vulkan API http://vulkano.rs
- Elegant and safe OpenGL wrapper https://crates.io/crates/glium
- glutin - OpenGL, UTilities and INput https://crates.io/crates/glutin
- Code generators for creating bindings to the Khronos OpenGL APIs https://crates.io/crates/gl_generator

SDL ÂºÄÂèëÈúÄË¶ÅÂà∞ÂÆòÊñπÁΩëÁ´ô‰∏ãËΩΩÈ¢ÑÁºñËØëÁöÑÂ∫ìÊñá‰ª∂ÔºåÂ¶Ç Windows Âπ≥Âè∞Â∞±‰∏ãËΩΩ SDL2-devel-2.0.x-VC.zipÔºåËß£ÂéãÂà∞ Cargo toolchain ÁºìÂ≠òÁõÆÂΩï‰∏≠ÔºåÂπ∂‰∏îÂ∞Ü SDL2.dll Êã∑Ë¥ùÂà∞Á®ãÂ∫èËøêË°åÁõÆÂΩïÔºåÊàñÂèØ‰ª•ÈÄöËøáÁéØÂ¢ÉÂèòÈáèÊêúÁ¥¢Âà∞ÁöÑÁõÆÂΩï„ÄÇ

‰πüÂèØ‰ª•‰ΩøÁî® Vcpkg Â∑•ÂÖ∑ÂÆâË£ÖÔºö

    vcpkg install sdl2:x64-windows
    vcpkg install sdl2-gfx:x64-windows
    vcpkg install sdl2-mixer:x64-windows
    vcpkg install sdl2-mixer[mpg123]:x64-windows
    vcpkg install sdl2-mixer[libvorbis]:x64-windows
    vcpkg install sdl2-net:x64-windows
    vcpkg install sdl2-ttf:x64-windows


# üü°üü† WebAssembly
- [Rust Wasm](https://rustwasm.github.io/docs/wasm-pack/introduction.html)
- [Rust ü¶Ä and WebAssembly üï∏](https://rustwasm.github.io/docs/book/)
- [Developer's Guide](https://webassembly.org/getting-started/developers-guide/)
- [Rust and WebAssembly Working Group](https://github.com/rustwasm/team)
- [Using WebAssembly](https://deno.land/manual@v1.29.0/runtime/webassembly)
- [The `wasm-bindgen` Guide](https://rustwasm.github.io/wasm-bindgen/)
- [WebAssembly MDN](https://developer.mozilla.org/en-US/docs/WebAssembly)
- [JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)
- [Compiling from Rust to WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm)
- [The WebAssembly System Interface (WASI)](https://wasi.dev/)
- [The AssemblyScript Book](https://www.assemblyscript.org/introduction.html)

WebAssembly ÂíåÊ±áÁºñËØ≠Ë®ÄÊòØÊúâ‰∏Ä‰∫õ‰∏çÂêåÁöÑÔºåÂÆÉÊòØ‰∏Ä‰∏™Ê¶ÇÂøµÊú∫‰∏äÁöÑÊú∫Âô®ËØ≠Ë®ÄÔºå‰ΩøÁî®ÁöÑÂ≠óËäÇÁ†Å‰∏∫ËôöÊãüÊåá‰ª§„ÄÇÂÆÉÊØîÁõ¥Êé•
ËøêË°å JavaScript ‰ª£Á†ÅÊõ¥Âø´Êõ¥Áõ¥Êé•ÁöÑËΩ¨Êç¢ÊàêÊú∫Âô®‰ª£Á†ÅÔºå‰ΩÜÂÆÉ‰ª¨‰∏çÁõ¥Êé•ÂíåÁâπÂÆöÁ°¨‰ª∂ÁöÑÁâπÂÆöÊú∫Âô®‰ª£Á†ÅÂØπÂ∫î„ÄÇWeb Â∫îÁî®
Â§ßÂ§öÊï∞ÊÄßËÉΩÈóÆÈ¢òÈÉΩÂú®Âº∫Âà∂Â∏ÉÂ±ÄÂíåËøáÂ§öÁöÑÁªòÂà∂ÔºåÂÅ∂Â∞î‰πüÈúÄË¶ÅÊâßË°å‰∏Ä‰∫õËÄóÊó∂ÁöÑËÆ°ÁÆóÂØÜÈõÜ‰ªªÂä°ÔºåËøôÊ≠£ÊòØÂ≠óËäÇÁ†ÅÁöÑÁî®Â§Ñ„ÄÇ

Note: For this to work, .wasm files should be returned with an **application/wasm** MIME type by the server.

WebAssembly Â≠óËäÇÁ†ÅÊñá‰ª∂ÊúâÊñáÊú¨Ê†ºÂºè .wat Âíå‰∫åËøõÂà∂Ê†ºÂºè .wasm ‰∏§ÁßçÔºåÂèØÁî® wat2wasm Â∑•ÂÖ∑ËøõË°åËΩ¨Êç¢„ÄÇ

WebAssembly key concepts

- **Module**: Represents a WebAssembly binary that has been compiled by the browser 
    into executable machine code. A Module is stateless and thus, like a Blob, 
    can be explicitly shared between windows and workers (via postMessage()). 
    A Module declares imports and exports just like an ES module.
- **Memory**: A resizable ArrayBuffer that contains the linear array of bytes 
    read and written by WebAssembly's low-level memory access instructions.
- **Table**: A resizable typed array of references (e.g. to functions) that could 
    not otherwise be stored as raw bytes in Memory (for safety and portability reasons).
- **Instance**: A Module paired with all the state it uses at runtime including 
    a Memory, Table, and set of imported values. An Instance is like an ES module 
    that has been loaded into a particular global with a particular set of imports.

Â§ßÂ§öÊï∞ WebAssembly Ê®°ÂùóÂºÄÂèëËÄÖ‰ΩøÁî® C Âíå Rust ÁºñÂÜô‰ª£Á†ÅÔºåÁÑ∂ÂêéÁºñËØëÊàê WebAssemblyÔºå‰πüÊúâÂÖ∂‰ªñÈÄîÂæÑ„ÄÇ

    git clone --depth=1 git@github.com:rustwasm/wasm-bindgen.git
    git clone --depth=1 git@github.com:bytecodealliance/wasmtime

ÁõÆÂâç WASM ÂÆûÈôÖÊúâÂ§öÁßçÂ∑•‰ΩúÊ®°ÂºèÔºöEmscripten„ÄÅWASIÂíåÊó†‰ªª‰Ωï‰æùËµñÁöÑÁ∫ØÁ≤πÊ®°ÂºèÔºåÂàÜÂà´ÂØπÂ∫î Rust ÁºñËØëÁõÆÊ†áÔºö

002. wasm32_unknown_emscripten üîí
003. wasm32_unknown_unknown üîí Ë£∏ÁõÆÊ†áÔºåËØ•ËæìÂá∫ÂØπÂÖ∂ÁéØÂ¢ÉÊ≤°Êúâ‰ªª‰ΩïÂÅáËÆæ„ÄÇ
001. wasm64_unknown_unknown üîí Ë£∏ÁõÆÊ†áÔºåËØ•ËæìÂá∫ÂØπÂÖ∂ÁéØÂ¢ÉÊ≤°Êúâ‰ªª‰ΩïÂÅáËÆæ„ÄÇ
004. wasm32_wasi üîí 2019Âπ¥ÂèëËµ∑ÁöÑ‰∏Ä‰∏™ÂÆûÈ™åÁõÆÊ†áÔºåÂ∞öÂú®ÂèëÂ±ï‰∏≠Ôºå‰∏çÂ∫îËøá‰∫é‰æùËµñ„ÄÇ

The WebAssembly System Interface (WASI) ÊòØ‰∏Ä‰∏™Êâ©Â±ïÁöÑ WASM ÁéØÂ¢ÉËßÑËåÉÔºåÂÆÉËØïÂõæÊ®°Êãü‰∏Ä‰∏™ÂÆåÊï¥ÁöÑ
Êìç‰ΩúÁ≥ªÁªüÔºåÂåÖÊã¨‰∏éÊñá‰ª∂Á≥ªÁªü„ÄÅÁΩëÁªúÁ≠âÁ≥ªÁªüË∞ÉÁî®ÂäüËÉΩÔºå‰ª•Êèê‰æõ‰∏Ä‰∏™ Web ‰πãÂ§ñÁöÑËøêË°åÁéØÂ¢É„ÄÇ

Standardizing WASI: A system interface to run WebAssembly outside the web

If you've got the Rust compiler installed then you can take some Rust source code:

    fn main() {
        println!("Hello, world!");
    }

and compile/run it with:

```sh
    $ rustup target add wasm32-wasi
    $ rustc hello.rs --target wasm32-wasi
    $ wasmtime hello.wasm
    Hello, world!
```

Áõ∏ÊØî‰πã‰∏ãÔºåwasm32 Êú™Áü•Á±ªÂûãÁõÆÊ†áÊòØ‰∏Ä‰∏™ bare metal-like targetÔºåÂõ†Ê≠§ÁõÆÊ†á‰∏âÂÖÉÁªÑ‰∏≠ÁöÑÊú™Áü•ÈÉ®ÂàÜÊú™ÊåáÂÆö
Êìç‰ΩúÁ≥ªÁªüÔºåÂÆÉÂú®Á∫ØËÆ°ÁÆó‰πãÂ§ñÊ≤°ÊúâÊèê‰æõÂ§™Â§öÂäüËÉΩ„ÄÇunknown Âç≥Ë°®Á§∫Ê≤°ÊúâÂ§ñÈÉ®Êìç‰ΩúÁ≥ªÁªüÁéØÂ¢É‰æùËµñ„ÄÇ

ÂÆâË£ÖÂ•Ω Rust ÁéØÂ¢É‰πãÂêé‰ªçÁÑ∂ÈúÄË¶Å‰∏Ä‰∏™ wasm-pack Â∑•ÂÖ∑ÂåÖÔºåÂÆÉÈúÄË¶Å Node.js ÁöÑ npm Ê®°ÂùóÁÆ°ÁêÜÂ∑•ÂÖ∑„ÄÇÂêåÊó∂
ÂÆâË£Ö‰∏Ä‰∏™ cargo-generate Â∑•ÂÖ∑ÔºåÊñπ‰æøÁî®‰∫é‰ªé git ‰ªìÂ∫ì‰∏≠ÂÖãÈöÜÂ∑•Á®ãÊ®°ÊùøÔºåÁÑ∂ÂêéÂÖãÈöÜ wasm Ê®°ÊùøÈ°πÁõÆÔºö

    cargo install wasm-pack
    cargo install cargo-generate
    cargo generate --git https://github.com/rustwasm/wasm-pack-template

    wasm-pack build

    wasm-pack test --headless --firefox
    wasm-pack test --headless --chrome
    wasm-pack test --node

You can create a new Rust-WebAssembly webpack project by using the rustwasm webpack-template.

    npm init rust-webpack my-app

ÊâãÂä®ÂàõÂª∫ WebAssembly È°πÁõÆÂè™ÈúÄË¶Å‰ΩøÁî® `cargo init --lib .` ÂëΩ‰ª§ÂàõÂª∫‰∏Ä‰∏™Â∫ìÈ°πÁõÆÔºåÂπ∂‰øÆÊîπ Cargo.toml
ÈÖçÁΩÆÂºïÁî®‰æùËµñ wasm-bindgenÔºåÂπ∂‰∏îË¶ÅÊåáÂÆöÂ∫ìÁ±ªÂûã‰∏∫ cdylibÔºö

    [package]
    name = "rusty-react"
    version = "1.0.0"
    edition = "2021"

    [lib]
    crate-type = ["cdylib"]

    [dependencies]
    wasm-bindgen = "0.2"

ÂÖ∂Âêé‰ΩøÁî® wasm_bindgen ÁºñÂÜô‰ª£Á†ÅÔºö
Import JavaScript things into Rust and export Rust things to JavaScript.


```rust
    use wasm_bindgen::prelude::*;

    // Import the `window.alert` function from the Web.
    #[wasm_bindgen]
    extern "C" {
        fn alert(s: &str);
    }

    // Export a `greet` function from Rust to JavaScript, that alerts a
    // hello message.
    #[wasm_bindgen]
    pub fn greet(name: &str) {
        alert(&format!("Hello, {}!", name));
    }
```

Ê≥®ÊÑèÔºåwasm-pack ÈªòËÆ§ÊûÑÂª∫ÊñπÂºèÊòØ bundlerÔºåÊòØ npm ÂØºÂÖ•ÁöÑÂåÖ„ÄÇÂ¶ÇÊûú‰ΩøÁî® web ÊûÑÂª∫ÂàôÂèØ‰ª•Âú®ÊîØÊåÅ module 
ËÑöÊú¨ÁöÑÊúÄÊñ∞ÊµèËßàÂô®‰∏äÁõ¥Êé•Âä†ËΩΩÔºåÂè™ÈúÄË¶ÅÂ∞ÜÁîüÊàêÁöÑÂÖ•Âè£ËÑöÊú¨ÈÄöËøá import ËØ≠Âè•ÂØºÂÖ•Âç≥ÂèØ‰ΩøÁî®Ôºö

    wasm-pack build --target bundler    --out-name wasm_bundler
    wasm-pack build --target nodejs     --out-name wasm_nodejs
    wasm-pack build --target web        --out-name wasm_web
    wasm-pack build --target no-modules --out-name wasm_nm

ÂÖ•Âè£ËÑöÊú¨ÈªòËÆ§ÂêçÁß∞‰∏∫ project_name.jsÔºåÂèØ‰ª•ÊåáÂÆöÁºñËØëËæìÂá∫Êñá‰ª∂ÂêçÁß∞„ÄÇ

Web È°µÈù¢ÂÜÖÂÆπÂèäËÑöÊú¨ÂèØ‰ª•ÂèÇËÄÉ‰ª•‰∏ã‰ª£Á†ÅÁâáÊÆµÔºö

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>WebAssembly test</title>
</head>
<body>
<!-- <script type="module" src="wasm.js"></script> -->
<script type="module">
  import init, { greet } from "./wasm.js";
  init().then( module => {
    module.greet(); // or greet();
  })
</script>
</body>
</html>
```

ËøêË°å Web ÊúçÂä°Âô®ÊâìÂºÄ‰ª•‰∏äÈ°µÈù¢Âç≥ÂèØ‰ª•ÊµãËØï WebAssembly Á®ãÂ∫èÔºåÂèØ‰ª•‰ΩøÁî®‰∏ìÁî®ÁöÑ Web ÊúçÂä°Âô®ÔºåÂ¶Ç NginxÔºå
ÊàñËÄÖ‰ΩøÁî® PHP„ÄÅPython ÁöÑÂºÄÂèëÁî®ÁöÑ Web ÊµãËØïÊúçÂä°Âô®Ôºö

    php -S localhost:80 -t .
    python3 -m http.server

Ë¶ÅÂú® Rust ‰∏≠Ë∞ÉÁî® Web API Êàñ JavaScript ÂØπË±°ÔºåÂ∞±ÈúÄË¶ÅÈÄöËøá web_sys Âíå js_sys Ê®°ÂùóÔºå‰ΩøÁî®ÂëΩ‰ª§
cargo add Ê∑ªÂä†Áõ∏Â∫îÁöÑÊ®°Âùó„ÄÇ‰æãÂ¶ÇÔºå‰ª•‰∏ãÂäüËÉΩÈÖçÁΩÆ‰ΩøÁî®ÂØºÂÖ•ÁöÑ console ÊéßÂà∂Âè∞‰ø°ÊÅØÊó•ÂøóÊñπÊ≥ï„ÄÇ

    [dependencies.web-sys]
    version = "0.3.60"
    features = [
      'console',
      'Document',
      'Element',
      'HtmlElement',
      'Node',
      'Window',
    ]

ÊâãÂä®ÂØºÂÖ• Web API ÂèÇËÄÉÔºö

```rust
// lifted from the `console_log` example
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(a: &str);
}

macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}


// extern crate web_sys;

// A macro to provide `println!(..)`-style syntax for `console.log` logging.
macro_rules! log {
    ( $( $t:tt )* ) => {
        web_sys::console::log_1(&format!( $( $t )* ).into());
    }
}
```

WebAssembly modules declare a sequence of imports, each with a module name and an 
import name. The module name for an extern { ... } block can be specified using 
#[link(wasm_import_module)], currently it defaults to "env".

Exports have only a single name. In addition to any extern functions the WebAssembly 
instance's default linear memory is exported as "memory".


```rust
// import a JS function called `foo` from the module `mod`
#[link(wasm_import_module = "mod")]
extern { fn foo(); }

// export a Rust function called `bar`
#[no_mangle]
pub extern fn bar() { /* ... */ }
```

Because of wasm's limited value types, these functions must operate only on primitive numeric types.

‰ª•‰∏ãÂàõÂª∫‰∏Ä‰∏™È°πÁõÆÔºåÁõ¥Êé•Âú® Rust ‰ª£Á†Å‰∏≠Êìç‰Ωú Web Canvas ÁªòÂõæÔºåÂàõÂª∫‰∏Ä‰∏™ lib Â∑•Á®ãÔºåÂπ∂Â∞Ü crate-type
ËÆæÁΩÆ‰∏∫ cdylib Á±ªÂûãÔºåÁÑ∂ÂêéÊ∑ªÂä† web-sys Âíå wasm-bindgen ‰∏§‰∏™‰æùËµñÔºåÊ≥®ÊÑè features ËÆæÁΩÆ‰∫ÜÁõ∏ÂÖ≥ÁöÑ
Web Canvas API ÁâπÊÄßÔºö

```sh
    > cargo new --lib wasm-canvas
    > cargo add --features console,CanvasRenderingContext2d,Document,Element,HtmlCanvasElement,Window web-sys
    > cargo add wasm-bindgen
```

```sh
    [package]
    name = "wasm-canvas"
    version = "0.1.0"
    edition = "2021"

    # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

    [lib]
    crate-type = ["cdylib"]

    [dependencies]
    wasm-bindgen = "0.2.83"
    web-sys = { version = "0.3.60", features = ["console", "CanvasRenderingContext2d", "Document", "Element", "HtmlCanvasElement", "Window"] }

    [dev-dependencies]
    wasm-bindgen-test = "0.2"
```

ÁºñÂÜô lib.rs ‰ª£Á†ÅÔºö

```rust
use std::f64;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;

#[wasm_bindgen(start)]
pub fn start() {
    let document = web_sys::window().unwrap().document().unwrap();
    let canvas = document.get_element_by_id("canvas").unwrap();
    let canvas: web_sys::HtmlCanvasElement = canvas
        .dyn_into::<web_sys::HtmlCanvasElement>()
        .map_err(|_|())
        .unwrap();

    let context = canvas
        .get_context("2d").unwrap().unwrap()
        .dyn_into::<web_sys::CanvasRenderingContext2d>().unwrap();

    context.begin_path();

    // Draw the outer circle.
    context.arc(75.0, 75.0, 50.0, 0.0, f64::consts::PI * 2.0).unwrap();

    // Darw the mouth.
    context.move_to(110.0, 75.0);
    context.arc(75.0, 75.0, 35.0, 0.0, f64::consts::PI).unwrap();

    // Darw eyes
    context.move_to(65.0, 65.0);
    context.arc(60.0, 65.0, 5.0, 0.0, f64::consts::PI * 2.0).unwrap();
    context.move_to(90.0, 65.0);
    context.arc(90.0, 65.0, 5.0, 0.0, f64::consts::PI * 2.0).unwrap();

    context.stroke();
}
```

ÁºñËØëÈ°πÁõÆÔºåÁîüÊàêÂÖ•Âè£ËÑöÊú¨ wasm2d.js Âπ∂Âú®È°µÈù¢‰∏≠Âä†ËΩΩÂÆÉÔºåÂõ†‰∏∫‰ΩøÁî®‰∫ÜÂÖ•Âè£Ê†áÊ≥® #[wasm_bindgen(start)]Ôºå
ÂàùÂßãÂåñÊñπÊ≥ïÊâßË°åÂêéÂ∞±‰ºöËá™Âä®ÁªòÁîªÔºö

```sh
    wasm-pack build --target web --out-name wasm2d
```

HTML È°µÈù¢Ê®°ÊùøÂèÇËÄÉÔºö

```html
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>WebAssembly Canvas2D</title>
    </head>
    <body>
      <canvas id="canvas" height="150" width="150"></canvas>
      <script type="module">
        import init from "./wasm2d.js";
        init().then( module => {
          console.log(module, init);
        })
      </script>
    </body>
    </html>
```

ÊñáÊ°£ÂèÇËÄÉÔºö

- [wasm-bindgen canvas online](https://rustwasm.github.io/wasm-bindgen/exbuild/canvas/)
- [wasm-bindgen canvas code](https://github.com/rustwasm/wasm-bindgen/tree/master/examples/canvas)
- [MDN Canvas API tutorial](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes)


How to Add WebAssembly Support to a General-Purpose Crate

This build in-itself did not do much for us, we‚Äôll need to add a useful taraget 
for our builds. To add a new target for Rust, we can run the following command:

    $ rustup target add wasm32-unknown-unknown

    $ cargo build --target wasm32-unknown-unknown

Let‚Äôs install the wasm-bindgen-cli command-line application so we can leverage the WebAssembly code we created:

    $ cargo install -f wasm-bindgen-cli

Once installed, we can take our WebAssembly code generated by Rust and create a wrapping around it for our React code:

    $ wasm-bindgen target/wasm32-unknown-unknown/debug/simple.wasm --out-dir build

This will dump the Javascript wrapping and optimized Wasm code into our build directory ready to be used by React. And that‚Äôs what we‚Äôll do next!


The quickest, most efficient way to fetch a wasm module is using the newer 
WebAssembly.instantiateStreaming() method, which can take a fetch() call as its 
first argument, and will handle fetching, compiling, and instantiating the module 
in one step, accessing the raw byte code as it streams from the server:

```js
WebAssembly.instantiateStreaming(fetch("simple.wasm"), importObject).then(
  (results) => {
    // Do something with the results!
  }
);
```

If we used the older WebAssembly.instantiate() method, which doesn't work on the
direct stream, we'd need an extra step of converting the fetched byte code to an 
ArrayBuffer, like so:

```js
fetch("module.wasm")
  .then((response) => response.arrayBuffer())
  .then((bytes) => WebAssembly.instantiate(bytes, importObject))
  .then((results) => {
    // Do something with the results!
  });
```

Ê≥®ÊÑèÔºåimportObject ÂØπË±°ÂåÖÂê´Ë¶ÅÂØºÂÖ•Âà∞Êñ∞ÂàõÂª∫ÁöÑÂÆû‰æã‰∏≠ÁöÑÂÄºÔºå‰æãÂ¶ÇÂáΩÊï∞Êàñ WebAssembly.Memory ÂÜÖÂ≠òÂØπË±°„ÄÇ
ÁºñËØëÊ®°ÂùóÊàñ WebAssembly ÁöÑÊØè‰∏™Â£∞ÊòéÂØºÂÖ•ÂøÖÈ°ªÊúâ‰∏Ä‰∏™ÂåπÈÖçÂ±ûÊÄßÔºåÂê¶ÂàôÂºïÂèë LinkError„ÄÇ‰∏ÄËà¨ÔºåÂØºÂÖ•Êñá‰ª∂Ëá™Âä®ÁîüÊàê„ÄÇ



# üü°üü† OpenCV in Rust
- https://docs.rs/opencv/0.49.1/opencv/
- https://github.com/twistedfall/opencv-rust
- Rust OpenCV bindings https://crates.io/crates/opencv

‰æùËµñÈ°πÔºö

    [dependencies]
    opencv = "0.49.*"




# üü°üü† rustc-serialize
- https://docs.rs/rustc-serialize/0.3.24/rustc_serialize/

‰∫õÂ∑•ÂÖ∑Êèê‰æõ 3 ‰∏™Ê®°ÂùóÔºö

- base64    Base64 binary-to-text encoding
- hex   Hex binary-to-text encoding
- json  JSON parsing and serialization

ÈÖçÁΩÆ Cargo.toml ‰ΩøÁî®Ôºö

    [dependencies]
    rustc-serialize = "0.3"

and this to your crate root:

    extern crate rustc_serialize;

JSON Á§∫‰æãÔºö

```rust,ignore
extern crate rustc_serialize;
use rustc_serialize::json;

// Automatically generate `RustcDecodable` and `RustcEncodable` trait
// implementations
#[derive(RustcDecodable, RustcEncodable)]
pub struct TestStruct  {
    data_int: u8,
    data_str: String,
    data_vector: Vec<u8>,
}

fn main() {
    let object = TestStruct {
        data_int: 1,
        data_str: "homura".to_string(),
        data_vector: vec![2,3,4,5],
    };

    // Serialize using `json::encode`
    let encoded = json::encode(&object).unwrap();

    // Deserialize using `json::decode`
    let decoded: TestStruct = json::decode(&encoded).unwrap();
}
```

Verbose example of ToJson usage

```rust,ignore
extern crate rustc_serialize;
use std::collections::BTreeMap;
use rustc_serialize::json::{self, Json, ToJson};

// Only generate `Decodable` trait implementation
#[derive(RustcDecodable)]
pub struct TestStruct {
    data_int: u8,
    data_str: String,
    data_vector: Vec<u8>,
}

// Specify encoding method manually
impl ToJson for TestStruct {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        // All standard types implement `to_json()`, so use it
        d.insert("data_int".to_string(), self.data_int.to_json());
        d.insert("data_str".to_string(), self.data_str.to_json());
        d.insert("data_vector".to_string(), self.data_vector.to_json());
        Json::Object(d)
    }
}

fn main() {
    // Serialize using `ToJson`
    let input_data = TestStruct {
        data_int: 1,
        data_str: "madoka".to_string(),
        data_vector: vec![2,3,4,5],
    };
    let json_obj: Json = input_data.to_json();
    let json_str: String = json_obj.to_string();

    // Deserialize like before
    let decoded: TestStruct = json::decode(&json_str).unwrap();
}
```




# üü°üü† webview_sys
- https://docs.rs/web-view/0.6.3/web_view/
- https://lib.rs/crates/webview-sys
- https://github.com/webview/webview
- https://github.com/Boscop/web-view/tree/master/webview-examples/examples

‰øÆÊîπÈÖçÁΩÆÊñá‰ª∂ Cargo.toml Ê†πÊçÆÈúÄË¶ÅÊ∑ªÂä†‰æùËµñÔºåÊåáÂÆö Edge ÊµèËßàÂô®ÂÜÖÊ†∏ÈúÄË¶Å Windows 10 SDKÔºåÂèØ‰ª•Âú® Visual Studio ÂÆâË£ÖÁ®ãÂ∫è‰∏≠Â¢ûÂä†Ôºö

```rust,ignore
[dependencies]
web-view = { version = "0.7" }
web-view = { version = "0.7", features = ["edge"] }
web-view = { git = "https://github.com/Boscop/web-view", rev = "0d92ed6" }
```

ÁÑ∂ÂêéÁºñÂÜôÊµãËØïÁ®ãÂ∫èÔºö

```rust,ignore
use web_view::*;

fn main() {
    let html_content = "<html><body><h1>Hello, World!</h1></body></html>";
    let url = "file:///C:/coding/md-code/deno/demos/src/douyin/videos.html";

    web_view::builder()
        .title("My Project")
        .content(Content::Url(url))
        // .content(Content::Html(html_content))
        .size(320, 480)
        .resizable(false)
        .debug(true)
        .user_data(())
        .invoke_handler(|_webview, _arg| Ok(()))
        .run()
        .unwrap();
}
```

È°µÈù¢‰∫§‰∫íÔºö

```rust,ignore
// ... Simplified for the sake of brevity.
web_view::builder()    
    .invoke_handler(|webview, arg| {
        match arg {
            "test_one" => {
                // Do something in Rust!
            }
            "test_two" => {
                // Invoke a JavaScript function!
                webview.eval(&format!("myFunction({}, {})", 123, 456))
            }
            _ => unimplemented!(),
        };
    })
```

```rust,ignore
// Executes our "invoke_handler" - passing the value "test_one" as the second parameter.
external.invoke('test_one');

// Executes our "invoke_handler", which in turn calls "myFunction" below.
external.invoke('test_two');

function myFunction(paramOne, paramTwo) {
    console.log(paramOne);
    console.log(paramTwo);
}
```


Boscop web-view È°πÁõÆÁÆ°ÁêÜÂèÇËÄÉÔºåÈ°πÁõÆÁªìÊûÑÂ¶Ç‰∏ãÔºö

- ‰∏ªÈ°πÁõÆÂåÖÂê´‰∏§‰∏™Â≠êÈ°πÁõÆ webview-sys Âíå webview-examplesÔºõ
- ‰∏ªÈ°πÁõÆ‰æùËµñÂ≠êÈ°πÁõÆ webview-sysÔºåËøô‰∏™Â≠êÈ°πÁõÆË¥üË¥£ÁªëÂÆö Webview C++ APIÔºõ
- Â≠êÈ°πÁõÆ webview-examples ‰æùËµñ‰∏ªÈ°πÁõÆÔºåËøô‰∏™Â≠êÈ°πÁõÆÂè™Êèê‰æõÁ§∫ËåÉÁ®ãÂ∫èÔºõ

‰∏ªÈ°πÁõÆÈÖçÁΩÆÊñá‰ª∂Ôºö

```rust,ignore
[package]
name = "web-view"
version = "0.7.3"
authors = ["Boscop", "zxey <r.hozak@seznam.cz>", "Sam Green <sam.green81@gmail.com>"]
readme = "README.md"
license = "MIT"
repository = "https://github.com/Boscop/web-view"
description = "Rust bindings for webview, a tiny cross-platform library to render web-based GUIs for desktop applications"
keywords = ["web", "gui", "desktop", "electron", "webkit"]
categories = ["gui", "web-programming", "api-bindings", "rendering", "visualization"]
exclude = ["webview-sys/**", "webview-examples/**", ".github/**", "Cargo.lock"]

[dependencies]
urlencoding = "1.1"
webview-sys = { path = "webview-sys", version = "0.6.2" }
boxfnonce = "0.1"
tinyfiledialogs = "3.3"

[features]
edge = ["webview-sys/edge"]

[workspace]
members = [
    "webview-sys",
    "webview-examples",
]
```

webview-sys ÈÖçÁΩÆÊñá‰ª∂Ôºö

```rust,ignore
[package]
name = "webview-sys"
version = "0.6.2"
authors = ["Boscop", "zxey <r.hozak@seznam.cz>"]
license = "MIT"
repository = "https://github.com/Boscop/web-view"
description = "Rust native ffi bindings for webview"
keywords = ["web", "gui", "desktop", "electron", "webkit"]
categories = ["gui", "web-programming", "api-bindings", "rendering", "visualization"]
build = "build.rs"
links = "webview"
edition = "2018"
exclude = ["Cargo.lock"]

[lib]
name = "webview_sys"
path = "lib.rs"

[features]
edge = []

[target.'cfg(all(target_family = "unix", not(target_os = "macos")))'.dependencies]
javascriptcore-rs-sys = "0.2"
gtk-sys = "0.10"
glib-sys = "0.10"
gobject-sys = "0.10"
webkit2gtk-sys = { version = "0.12.0", features = ["v2_8"] }
gdk-sys = "0.10"
gio-sys = "0.10"
libc = "0.2"

[build-dependencies]
cc = "1"
pkg-config = "0.3"
```

webview-examples ÈÖçÁΩÆÊñá‰ª∂Ôºö

```rust,ignore
[package]
name = "webview-examples"
version = "0.1.0"
authors = ["Boscop", "zxey <r.hozak@seznam.cz>", "Sam Green <sam.green81@gmail.com>"]
license = "MIT"
repository = "https://github.com/Boscop/web-view"
description = "Examples of using Web frontend technologies in desktop apps using the web-view crate"
keywords = ["web", "gui", "desktop", "electron", "webkit"]
categories = ["gui", "web-programming", "api-bindings", "rendering", "visualization"]
exclude = ["examples/todo-ps/dist/**/*", "examples/elm-counter/index.html"]
publish = false

[dependencies]
web-view = { path = "..", version = "0.7.3" }

[features]
edge = ["web-view/edge"]

[dev-dependencies]
tinyfiledialogs = "3.3"
serde = "1.0"
serde_derive = "1.0"
serde_json = "1.0"
actix-web = "1.0"
actix-rt = "0.2"
rust-embed = "5.1.0"
mime_guess = "2.0.1"
futures = "0.1"
grep = "0.2.4"
walkdir = "2.3.1"
```

# üü°üü† Ruffle SWF Player
- https://ruffle.rs/#usage

ÂÖãÈöÜ‰ª£Á†ÅÔºö

    git clone git@github.com:ruffle-rs/ruffle.git

API ÂÖºÂÆπÊÄß

- ActionScript 1 & 2 Language 85%
- ActionScript 1 & 2 API 50%
- ActionScript 3 Language 10%
- ActionScript 3 API 5%

ActionScript is the language which Flash uses to make interactive content. It is primarily split into two groups: "AVM 1" (ActionScript 1 & 2) and "AVM 2" (ActionScript 3).

AVM 1 is ActionScript 1 and ActionScript 2. All movies made before Flash Player 9 (June 2006) will be made with AVM 1, and it remained supported & available to authors until the release of Flash Professional CC (2013).

AVM2 is ActionScript 3, which was introduced with Flash Player 9 (June 2006). After the release of Flash Professional CC (2013), authors are required to use ActionScript 3 - making any movie made after that date very likely to fall under this category.

Ruffle is still working on the foundational support for AVM 2, and does not yet support any content that requires it. A warning will be placed in the log when you attempt to play AVM 2 content, for this reason. We do plan on supporting this soon!




# üü°üü† Rust Reference
- The Rust Standard Library https://doc.rust-lang.org/stable/std/index.html
- The Rust Reference https://doc.rust-lang.org/reference/introduction.html
- Rust Language Cheat Sheet https://cheats.rs

## ‚ö° Primitive Types

- `never`   ‚ù§ The `!` type, also called "never".
- `array`   A fixed-size array, denoted [T; N], for the element type, T, and the non-negative compile-time constant size, N.
- `bool`    The boolean type.
- `char`    A character type.
- `f32` A 32-bit floating point type (specifically, the "binary32" type defined in IEEE 754-2008).
- `f64` A 64-bit floating point type (specifically, the "binary64" type defined in IEEE 754-2008).
- `fn`  Function pointers, like fn(usize) -> bool.
- `i8`  The 8-bit signed integer type.
- `i16` The 16-bit signed integer type.
- `i32` The 32-bit signed integer type.
- `i64` The 64-bit signed integer type.
- `i128`    The 128-bit signed integer type.
- `isize`   The pointer-sized signed integer type.
- `pointer` Raw, unsafe pointers, *const T, and *mut T.
- `reference`   References, both shared and mutable.
- `slice`   A dynamically-sized view into a contiguous sequence, [T]. Contiguous ÊÑèÊÄùÊòØÂêÑÂÖÉÁ¥†Èó¥‰øùÊåÅÁõ∏ÂêåÁöÑÈó¥Èöî„ÄÇ
- `str` String slices.
- `tuple`   A finite heterogeneous sequence, (T, U, ..).
- `u8`  The 8-bit unsigned integer type.
- `u16` The 16-bit unsigned integer type.
- `u32` The 32-bit unsigned integer type.
- `u64` The 64-bit unsigned integer type.
- `u128`    The 128-bit unsigned integer type.
- `unit`    The `()` type, also called "unit".
- `usize`   The pointer-sized unsigned integer type.

## ‚ö° Modules

- `backtrace`   ‚ù§ Support for capturing a stack backtrace of an OS thread
- `intrinsics`  ‚ù§ Compiler intrinsics.
- `lazy`    ‚ù§ Lazy values and one-time initialization of static data.
- `raw` ‚ù§ Contains struct definitions for the layout of compiler built-in types.
- `alloc`   Memory allocation APIs.
- `any` This module implements the Any trait, which enables dynamic typing of any 'static type through runtime reflection.
- `array`   ÂÆûÁé∞ÂÉè Eq ‰∏ÄÊ†∑ÁöÑÂÆöÈïøÊï∞ÁªÑ„ÄÇ
- `ascii`   Operations on ASCII strings and characters.
- `borrow`  A module for working with borrowed data.
- `boxed`   A pointer type for heap allocation.
- `cell`    Shareable mutable containers.
- `char`    A character type.
- `clone`   The Clone trait for types that cannot be 'implicitly copied'.
- `cmp` Functionality for ordering and comparison.
- `collections` Collection types.
- `convert` Traits for conversions between types.
- `default` The Default trait for types which may have meaningful default values.
- `env` Inspection and manipulation of the process's environment.
- `error`   Traits for working with Errors.
- `f32` This module provides constants which are specific to the implementation of the f32 floating point data type.
- `f64` This module provides constants which are specific to the implementation of the f64 floating point data type.
- `ffi` Utilities related to FFI bindings.
- `fmt` Utilities for formatting and printing Strings.
- `fs`  Filesystem manipulation operations.
- `future`  Asynchronous values.
- `hash`    Generic hashing support.
- `hint`    Hints to compiler that affects how code should be emitted or optimized. Hints may be compile time or runtime.
- `i8`  The 8-bit signed integer type.
- `i16` The 16-bit signed integer type.
- `i32` The 32-bit signed integer type.
- `i64` The 64-bit signed integer type.
- `i128`    The 128-bit signed integer type.
- `io`  Traits, helpers, and type definitions for core I/O functionality.
- `isize`   The pointer-sized signed integer type.
- `iter`    Composable external iteration.
- `marker`  Primitive traits and types representing basic properties of types.
- `mem` Basic functions for dealing with memory.
- `net` Networking primitives for TCP/UDP communication.
- `num` Additional functionality for numerics.
- `ops` Overloadable operators.
- `option`  Optional values.
- `os`  OS-specific functionality.
- `panic`   Panic support in the standard library.
- `path`    Cross-platform path manipulation.
- `pin` Types that pin data to its location in memory.
- `prelude` The Rust Prelude.
- `primitive`   This module reexports the primitive types to allow usage that is not possibly shadowed by other declared types.
- `process` A module for working with processes.
- `ptr` Manually manage memory through raw pointers.
- `rc`  Single-threaded reference-counting pointers. 'Rc' stands for 'Reference Counted'.
- `result`  Error handling with the Result type.
- `slice`   A dynamically-sized view into a contiguous sequence, [T].
- `str` Unicode string slices.
- `string`  A UTF-8‚Äìencoded, growable string.
- `sync`    Useful synchronization primitives.
- `task`    Types and Traits for working with asynchronous tasks.
- `thread`  Native threads.
- `time`    Temporal quantification.
- `u8`  The 8-bit unsigned integer type.
- `u16` The 16-bit unsigned integer type.
- `u32` The 32-bit unsigned integer type.
- `u64` The 64-bit unsigned integer type.
- `u128`    The 128-bit unsigned integer type.
- `usize`   The pointer-sized unsigned integer type.
- `vec` A contiguous growable array type with heap-allocated contents, written Vec<T>.

## ‚ö° Macros

- `asm` ‚ù§ Inline assembly.
- `concat_idents`   ‚ù§ Concatenates identifiers into one identifier.
- `format_args_nl`  ‚ù§ Same as format_args, but adds a newline in the end.
- `global_asm`  ‚ù§ Module-level inline assembly.
- `is_aarch64_feature_detected` ‚ù§ Â¶ÇÊûúÂú®Èùû aarch64 Âπ≥Âè∞‰ΩøÁî®ÂàôÈòªÊ≠¢ÁºñËØë„ÄÇ
- `is_arm_feature_detected` ‚ù§ Â¶ÇÊûúÂú®Èùû ARM Âπ≥Âè∞‰ΩøÁî®ÂàôÈòªÊ≠¢ÁºñËØë„ÄÇ
- `is_mips64_feature_detected`  ‚ù§ Â¶ÇÊûúÂú®Èùû MIPS64 Âπ≥Âè∞‰ΩøÁî®ÂàôÈòªÊ≠¢ÁºñËØë„ÄÇ
- `is_mips_feature_detected`    ‚ù§ Â¶ÇÊûúÂú®Èùû MIPS Âπ≥Âè∞‰ΩøÁî®ÂàôÈòªÊ≠¢ÁºñËØë„ÄÇ
- `is_powerpc64_feature_detected`   ‚ù§ Â¶ÇÊûúÂú®Èùû PowerPC64 Âπ≥Âè∞‰ΩøÁî®ÂàôÈòªÊ≠¢ÁºñËØë„ÄÇ
- `is_powerpc_feature_detected` ‚ù§ Â¶ÇÊûúÂú®Èùû PowerPC Âπ≥Âè∞‰ΩøÁî®ÂàôÈòªÊ≠¢ÁºñËØë„ÄÇ
- `llvm_asm`    ‚ù§ LLVM-style inline assembly.
- `log_syntax`  ‚ù§ Prints passed tokens into the standard output.
- `trace_macros`    ‚ù§ Enables or disables tracing functionality used for debugging other macros.
- `assert`  Asserts that a boolean expression is true at runtime.
- `assert_eq`   Asserts that two expressions are equal to each other (using PartialEq).
- `assert_ne`   Asserts that two expressions are not equal to each other (using PartialEq).
- `cfg` Evaluates boolean combinations of configuration flags at compile-time.
- `column`  Expands to the column number at which it was invoked.
- `compile_error`   Causes compilation to fail with the given error message when encountered.
- `concat`  Concatenates literals into a static string slice.
- `dbg` Prints and returns the value of a given expression for quick and dirty debugging.
- `debug_assert`    Asserts that a boolean expression is true at runtime.
- `debug_assert_eq` Asserts that two expressions are equal to each other.
- `debug_assert_ne` Asserts that two expressions are not equal to each other.
- `env` Inspects an environment variable at compile time.
- `eprint`  Prints to the standard error.
- `eprintln`    Prints to the standard error, with a newline.
- `file`    Expands to the file name in which it was invoked.
- `format`  Creates a String using interpolation of runtime expressions.
- `format_args` Constructs parameters for the other string-formatting macros.
- `include` Parses a file as an expression or an item according to the context.
- `include_bytes`   Includes a file as a reference to a byte array.
- `include_str` Includes a UTF-8 encoded file as a string.
- `is_x86_feature_detected` A macro to test at runtime whether a CPU feature is available on x86/x86-64 platforms.
- `line`    Expands to the line number on which it was invoked.
- `matches` Returns whether the given expression matches any of the given patterns.
- `module_path` Expands to a string that represents the current module path.
- `option_env`  Optionally inspects an environment variable at compile time.
- `panic`   Panics the current thread.
- `print`   Prints to the standard output.
- `println` Prints to the standard output, with a newline.
- `stringify`   Stringifies its arguments.
- `thread_local`    Declare a new thread local storage key of type std::thread::LocalKey.
- `todo`    Indicates unfinished code.
- `try` DeprecatedUnwraps a result or propagates its error.
- `unimplemented`   Indicates unimplemented code by panicking with a message of "not implemented".
- `unreachable` Indicates unreachable code.
- `vec` Creates a Vec containing the arguments.
- `write`   Writes formatted data into a buffer.
- `writeln` Write formatted data into a buffer, with a newline appended.


## ‚ö° Keywords

The following keywords currently have the functionality described.

* `as` - perform primitive casting, disambiguate the specific trait containing
  an item, or rename items in `use` and `extern crate` statements
* `async` -  return a `Future` instead of blocking the current thread
* `await` - suspend execution until the result of a `Future` is ready
* `break` - exit a loop immediately
* `const` - define constant items or constant raw pointers
* `continue` - continue to the next loop iteration
* `crate` - link an external crate or a macro variable representing the crate in
  which the macro is defined
* `dyn` - dynamic dispatch to a trait object
* `else` - fallback for `if` and `if let` control flow constructs
* `enum` - define an enumeration
* `extern` - link an external crate, function, or variable
* `false` - Boolean false literal
* `fn` - define a function or the function pointer type
* `for` - loop over items from an iterator, implement a trait, or specify a
  higher-ranked lifetime
* `if` - branch based on the result of a conditional expression
* `impl` - implement inherent or trait functionality
* `in` - part of `for` loop syntax
* `let` - bind a variable
* `loop` - loop unconditionally
* `match` - match a value to patterns
* `mod` - define a module
* `move` - make a closure take ownership of all its captures
* `mut` - denote mutability in references, raw pointers, or pattern bindings
* `pub` - denote public visibility in struct fields, `impl` blocks, or modules
* `ref` - bind by reference
* `return` - return from function
* `Self` - a type alias for the type we are defining or implementing
* `self` - method subject or current module
* `static` - global variable or lifetime lasting the entire program execution
* `struct` - define a structure
* `super` - parent module of the current module
* `trait` - define a trait
* `true` - Boolean true literal
* `type` - define a type alias or associated type
* `union` - define a [union] and is only a keyword when used in a union declaration
* `unsafe` - denote unsafe code, functions, traits, or implementations
* `use` - bring symbols into scope
* `where` - denote clauses that constrain a type
* `while` - loop conditionally based on the result of an expression

Keywords Reserved for Future Use

* `abstract`
* `become`
* `box`
* `do`
* `final`
* `macro`
* `override`
* `priv`
* `try`
* `typeof`
* `unsized`
* `virtual`
* `yield`


## ‚ö° Operators and Symbols

This appendix contains a glossary of Rust‚Äôs syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.

Table B-1: Operators

| Operator | Example | Explanation | Overloadable? |
|----------|---------|-------------|---------------|
| `!`   | `ident!(...)`, `ident!{...}`, `ident![...]` | Macro expansion | |
| `!`   | `!expr` | Bitwise or logical complement | `Not` |
| `!=`  | `var != expr` | Nonequality comparison | `PartialEq` |
| `%`   | `expr % expr` | Arithmetic remainder | `Rem` |
| `%=`  | `var %= expr` | Arithmetic remainder and assignment | `RemAssign` |
| `&`   | `&expr`, `&mut expr` | Borrow | |
| `&`   | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Borrowed pointer type | |
| `&`   | `expr & expr` | Bitwise AND | `BitAnd` |
| `&=`  | `var &= expr` | Bitwise AND and assignment | `BitAndAssign` |
| `&&`  | `expr && expr` | Short-circuiting logical AND | |
| `*`   | `expr * expr` | Arithmetic multiplication | `Mul` |
| `*=`  | `var *= expr` | Arithmetic multiplication and assignment | `MulAssign` |
| `*`   | `*expr` | Dereference | |
| `*`   | `*const type`, `*mut type` | Raw pointer | |
| `+`   | `trait + trait`, `'a + trait` | Compound type constraint | |
| `+`   | `expr + expr` | Arithmetic addition | `Add` |
| `+=`  | `var += expr` | Arithmetic addition and assignment | `AddAssign` |
| `,`   | `expr, expr` | Argument and element separator | |
| `-`   | `- expr` | Arithmetic negation | `Neg` |
| `-`   | `expr - expr` | Arithmetic subtraction | `Sub` |
| `-=`  | `var -= expr` | Arithmetic subtraction and assignment | `SubAssign` |
| `->`  | `fn(...) -> type`, `|...| -> type|` | Function and closure return type | |
| `.`   | `expr.ident` | Member access | |
| `..`  | `..`, `expr..`, `..expr`, `expr..expr` | Right-exclusive range literal | |
| `..=` | `..=expr`, `expr..=expr` | Right-inclusive range literal | |
| `..`  | `..expr` | Struct literal update syntax | |
| `..`  | `variant(x, ..)`, `struct_type { x, .. }` | ‚ÄúAnd the rest‚Äù pattern binding | |
| `...` | `expr...expr` | In a pattern: inclusive range pattern | |
| `/`   | `expr / expr` | Arithmetic division | `Div` |
| `/=`  | `var /= expr` | Arithmetic division and assignment | `DivAssign` |
| `:`   | `pat: type`, `ident: type` | Constraints | |
| `:`   | `ident: expr` | Struct field initializer | |
| `:`   | `'a: loop {...}` | Loop label | |
| `;`   | `expr;`      | Statement and item terminator | |
| `;`   | `[...; len]` | Part of fixed-size array syntax | |
| `<<`  | `expr << expr` | Left-shift | `Shl` |
| `<<=` | `var <<= expr` | Left-shift and assignment | `ShlAssign` |
| `<`   | `expr < expr` | Less than comparison | `PartialOrd` |
| `<=`  | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |
| `=`   | `var = expr`, `ident = type` | Assignment/equivalence | |
| `==`  | `expr == expr` | Equality comparison | `PartialEq` |
| `=>`  | `pat => expr` | Part of match arm syntax | |
| `>`   | `expr > expr` | Greater than comparison | `PartialOrd` |
| `>=`  | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` |
| `>>`  | `expr >> expr` | Right-shift | `Shr` |
| `>>=` | `var >>= expr` | Right-shift and assignment | `ShrAssign` |
| `@`   | `ident @ pat` | Pattern binding | |
| `^`   | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |
| `^=`  | `var ^= expr` | Bitwise exclusive OR and assignment | `BitXorAssign` |
| `|`   | `pat | pat`   | Pattern alternatives | |
| `|`   | `expr | expr` | Bitwise OR | `BitOr` |
| `|=`  | `var |= expr` | Bitwise OR and assignment | `BitOrAssign` |
| `||`  | `expr || expr` | Short-circuiting logical OR | |
| `?`   | `expr?`       | Error propagation | |


Table B-2: Stand-Alone Syntax

| Symbol | Explanation |
|--------|-------------|
| `'ident` | Named lifetime or loop label |
| `...u8`, `...i32`, `...f64`, `...usize`, etc. | Numeric literal of specific type |
| `"..."` | String literal |
| `r"..."`, `r#"..."#`, `r##"..."##`, etc. | Raw string literal, escape characters not processed |
| `b"..."` | Byte string literal; constructs a `[u8]` instead of a string |
| `br"..."`, `br#"..."#`, `br##"..."##`, etc. | Raw byte string literal, combination of raw and byte string literal |
| `'...'` | Character literal |
| `b'...'` | ASCII byte literal |
| `|...| expr` | Closure |
| `!` | Always empty bottom type for diverging functions |
| `_` | ‚ÄúIgnored‚Äù pattern binding; also used to make integer literals readable |


Table B-3: Path-Related Syntax

| Symbol | Explanation |
|--------|-------------|
| `ident::ident` | Namespace path |
| `::path` | Path relative to the crate root (i.e., an explicitly absolute path) |
| `self::path` | Path relative to the current module (i.e., an explicitly relative path).
| `super::path` | Path relative to the parent of the current module |
| `type::ident`, `<type as trait>::ident` | Associated constants, functions, and types |
| `<type>::...` | Associated item for a type that cannot be directly named (e.g., `<&T>::...`, `<[T]>::...`, etc.) |
| `trait::method(...)` | Disambiguating a method call by naming the trait that defines it |
| `type::method(...)` | Disambiguating a method call by naming the type for which it‚Äôs defined |
| `<type as trait>::method(...)` | Disambiguating a method call by naming the trait and type |


Table B-4: Generics

| Symbol | Explanation |
|--------|-------------|
| `path<...>` | Specifies parameters to generic type in a type (e.g., `Vec<u8>`) |
| `path::<...>`, `method::<...>` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., `"42".parse::<i32>()`) |
| `fn ident<...> ...` | Define generic function |
| `struct ident<...> ...` | Define generic structure |
| `enum ident<...> ...` | Define generic enumeration |
| `impl<...> ...` | Define generic implementation |
| `for<...> type` | Higher-ranked lifetime bounds |
| `type<ident=type>` | A generic type where one or more associated types have specific assignments (e.g., `Iterator<Item=T>`) |

Table B-5: Trait Bound Constraints

| Symbol | Explanation |
|--------|-------------|
| `T: U` | Generic parameter `T` constrained to types that implement `U` |
| `T: 'a` | Generic type `T` must outlive lifetime `'a` (meaning the type cannot transitively contain any references with lifetimes shorter than `'a`) |
| `T : 'static` | Generic type `T` contains no borrowed references other than `'static` ones |
| `'b: 'a` | Generic lifetime `'b` must outlive lifetime `'a` |
| `T: ?Sized` | Allow generic type parameter to be a dynamically sized type |
| `'a + trait`, `trait + trait` | Compound type constraint |

Table B-6: Macros and Attributes

| Symbol | Explanation |
|--------|-------------|
| `#[meta]` | Outer attribute |
| `#![meta]` | Inner attribute |
| `$ident` | Macro substitution |
| `$ident:kind` | Macro capture |
| `$(‚Ä¶)‚Ä¶` | Macro repetition |
| `ident!(...)`, `ident!{...}`, `ident![...]` | Macro invocation |


Table B-7: Comments

| Symbol | Explanation |
|--------|-------------|
| `//` | Line comment |
| `//!` | Inner line doc comment |
| `///` | Outer line doc comment |
| `/*...*/` | Block comment |
| `/*!...*/` | Inner block doc comment |
| `/**...*/` | Outer block doc comment |


Table B-8: Tuples

| Symbol | Explanation |
|--------|-------------|
| `()` | Empty tuple (aka unit), both literal and type |
| `(expr)` | Parenthesized expression |
| `(expr,)` | Single-element tuple expression |
| `(type,)` | Single-element tuple type |
| `(expr, ...)` | Tuple expression |
| `(type, ...)` | Tuple type |
| `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants |
| `expr.0`, `expr.1`, etc. | Tuple indexing |


Table B-9: Curly Brackets

| Context | Explanation |
|---------|-------------|
| `{...}` | Block expression |
| `Type {...}` | `struct` literal |


Table B-10: Square Brackets

| Context | Explanation |
|---------|-------------|
| `[...]` | Array literal |
| `[expr; len]` | Array literal containing `len` copies of `expr` |
| `[type; len]` | Array type containing `len` instances of `type` |
| `expr[expr]` | Collection indexing. Overloadable (`Index`, `IndexMut`) |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Collection indexing pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, or `RangeFull` as the ‚Äúindex‚Äù |


## ‚ö° Struct TypeId & Trait Any
- A type to emulate dynamic typing https://static.rust-lang.org/doc/master/std/any/trait.Any.html
- TypeId https://static.rust-lang.org/doc/master/std/any/struct.TypeId.html
- quote! https://docs.rs/quote/1.0.9/quote/
- parser https://docs.rs/syn/1.0.64/syn/
- RustÂÖ•ÂùëÊåáÂçóÔºö‰∏áÁâ©ÂàùÂßã https://www.jianshu.com/p/f26591569b98
- Introduction to Procedural Macros in Rust https://tinkering.xyz/introduction-to-proc-macros/
- Procedural Macros in Rust 2018 https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html
- 3.2. Procedural Macros https://doc.rust-lang.org/reference/procedural-macros.html

ÂèçÂ∞Ñ reflection ÊÑèÂë≥ÁùÄÂèØ‰ª•Âú®ËøêË°åÊó∂Ëé∑ÂæóÁ±ªÂûãÁöÑÊâÄÊúâËØ¶ÁªÜ‰ø°ÊÅØÔºåÂåÖÊã¨Â≠óÊÆµÊñπÊ≥ïÁ≠âÔºåÂπ∂ÂèØ‰ª•ËøõË°åÊõøÊç¢„ÄÇ

Rust Âè™Êúâ‚Äúcompile-time reflection‚ÄùÔºåÂè™Êúâ any ÂèØ‰ª•ÁÆóÊòØËµ∑Âà∞‰∫ÜÈÉ®ÂàÜÂèçÂ∞ÑÁöÑÂäüËÉΩÔºå‰∏çËøáÁ§æÂå∫Êúâ‰∫∫ÂÆûÁé∞‰∫ÜÂà©Áî®ËøáÁ®ãÂÆè reflect ÂÆûÁé∞ÁöÑÁºñËØëÊó∂ÂèçÂ∞ÑÂäüËÉΩÔºå‰ª•ÂÆûÁé∞‰æùËµñÊ≥®ÂÖ•Á≠âÂèçÂ∞ÑÂäüËÉΩ„ÄÇ

std:any Ëµ∑Âà∞‰ª•‰∏ãÂá†‰∏™‰ΩúÁî®Ôºö

- Ëé∑ÂèñÁ±ªÂûãÁöÑÂêçÂ≠ó
- Ëé∑ÂæóÂèòÈáèÁöÑÁ±ªÂûã TypeId
- Âà§Êñ≠ÂèòÈáèÊòØÂê¶ÊòØÊåáÂÆöÁ±ªÂûã
- Êää any ËΩ¨Êç¢ÊàêÊåáÂÆöÁ±ªÂûã

- downcast_ref::<T>() Â∞ÜÁ±ªÂûãËΩ¨Âûã‰∏∫ TÔºåÂÖ∂ËøîÂõûÁöÑÁ±ªÂûãÊòØ `Option<&T>`
- downcast_mut::<T>() Â∞ÜÁ±ªÂûãËΩ¨Âûã‰∏∫ TÔºåÂÖ∂ËøîÂõûÁöÑÁ±ªÂûãÊòØ `Option<&mut T>`
- TypeId::of::<T>() Ëé∑Âèñ T Á±ªÂûã TypeId ÁªìÊûÑ‰Ωì„ÄÇ
- is::<T>() ÊñπÊ≥ïÂàôÁî®Êù•Âà§Êñ≠ÊòØÂê¶ÊòØÊüê‰∏™Á±ªÂûã„ÄÇ

```rust,ignore
use std::any::{Any, TypeId};

fn is_string<T: ?Sized + Any>(_s: &T) -> bool {
    TypeId::of::<String>() == TypeId::of::<T>()
}

fn main() {
    assert_eq!(is_string(&0), false);
    assert_eq!(is_string(&"cookie monster".to_string()), true);
}
```

```rust,ignore
use std::any::Any;

fn is_string(s: &(Any + Send)) {
    if s.is::<String>() {
        println!("It's a string!");
    } else {
        println!("Not a string...");
    }
}

fn main() {
    is_string(&0);
    is_string(&"cookie monster".to_string());
}
```

```rust,ignore
use std::fmt::Debug;
use std::any::Any;

// Logger function for any type that implements Debug.
fn do_log<T: Any + Debug>(value: &T) {
    let value_any = value as &Any;

    // try to convert our value to a String.  If successful, we want to
    // output the String's length as well as its value.  If not, it's a
    // different type: just print it out unadorned.
    match value_any.downcast_ref::<String>() {
        Some(as_string) => {
            println!("String ({}): {}", as_string.len(), as_string);
        }
        None => {
            println!("{:?}", value);
        }
    }
}

fn main() {
    let my_string = "Hello World".to_string();
    do_log(&my_string);

    let my_i8: i8 = 100;
    do_log(&my_i8);
}
```



## ‚ö° Struct Cell
- Shareable mutable containers https://doc.rust-lang.org/std/cell/index.html
- https://doc.rust-lang.org/std/cell/struct.Cell.html

Rust ÂÜÖÂ≠òÂÆâÂÖ®Âü∫‰∫éËøôÊ†∑ÁöÑËßÑÂàôÔºöÁªôÂÆöÂØπË±° TÔºåÊª°Ë∂≥‰∏î‰ªÖÊª°Ë∂≥‰ª•‰∏ã‰∏Ä‰∏™Êù°‰ª∂Ôºö

- ÂåÖÂê´Â§ö‰∏™‰∏çÂèØÂèòÂºïÁî® `&T`ÔºåÂç≥ÂêçÂè•ÂèØ‰ª•ÊúâÂ§ö‰∏™Ôºõ
- Âè™Êúâ‰∏Ä‰∏™ÂèØÂèòÂºïÁî® `&mut T`Ôºõ

ÁºñËØëÂº∫Âà∂Ê£ÄÊü•ÔºåÁ°ÆËÆ§‰∏ç‰ºöÂ≠òÂú®Â§ö‰∏™ÂèØÂèòÂºïÁî®ÔºåÊàñÈÉΩÂèØÂèòÂºïÁî®‰∏é‰∏çÂèØÂèòÂºïÁî®ÂêåÊó∂Â≠òÂú®„ÄÇ

ÊúâÊó∂ÂÄôÔºåÊàë‰ª¨ÈúÄË¶Å‰∏çÂèØÂèòÂºïÁî®ÁöÑÂÜÖÈÉ®ÊàêÂëòÂèØÂèòÔºåÂú® Rust Âè´ÂÅöÂÜÖÈÉ®ÂèØÂèòÊÄß Internal mutability„ÄÇÈÇ£‰πàÔºåÊúâÂ¶Ç‰∏ãÈÄâÊã©Ôºö

- ÂçïÁ∫øÁ®ã
    - Â¶ÇÊûúÁ±ªÂûã T ÂÆûÁé∞‰∫Ü trait CopyÔºåÈÇ£‰πàÂèØ‰ª•‰ΩøÁî® Cell<T>
    - Âê¶ÂàôÔºåÂèØ‰ª•‰ΩøÁî® RefCell<T>
- Â§öÁ∫øÁ®ã
    - ‰ΩøÁî®‰∫íÊñ•ÈîÅÔºöMutex<T>
    - ‰ΩøÁî®ËØªÂÜôÈîÅÔºöRwLock<T>

ÂÆÉ‰ª¨ÂÜÖÈÉ®ÈÉΩ‰æùËµñÂ∫ïÂ±ÇÁöÑ UnsafeCell ÂÆûÁé∞ÔºåÈ°æÂêçÊÄù‰πâËøô‰πàÂÅö‰∏∫ unsafeÔºå‰ΩÜÊòØÁºñËØëÂô®Áü•ÈÅìËøô‰∫õË∞ÉÁî®ÁöÑÂú∞ÊñπÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ„ÄÇ

ÂØπ‰∫éÂÆûÁé∞‰∫Ü Copy ÁöÑÁ±ªÂûãÔºåÂèØ‰ª•‰ΩøÁî® `Cell<T>`Ôºö

- Ëé∑ÂèñÔºöÂ¶ÇÊûú T ÂÆûÁé∞‰∫Ü CopyÔºåÂàôÂèØ‰ª•Ë∞ÉÁî® `get()` ÊñπÊ≥ïÔºåËé∑Âæó T ÁöÑ‰∏Ä‰ªΩÈÄê bit Êã∑Ë¥ù
- ËÆæÁΩÆÔºö‰ΩøÁî® `set()` ÊñπÊ≥ï
- Êõ¥Êñ∞Ôºö‰ΩøÁî® `update()` ËÆæÁΩÆÂπ∂ËøîÂõûÊñ∞ÂÄº
- ÊõøÊç¢Ôºö‰ΩøÁî® `replace()` ÊñπÊ≥ï
- ÂèØÂèòÂºïÁî®Ôºö`get_mut()` ÊñπÊ≥ïËé∑Âæó Cell ÂèòÈáèÁöÑÂèØÂèòÂºïÁî®ÔºåËØ•ÊñπÊ≥ïÁªßÁª≠ÈÅµÂæ™ÂÜÖÂ≠òÂÆâÂÖ®ÂéüÂàô„ÄÇ

```rust,ignore
use std::cell::Cell;

struct SomeStruct {
    regular_field: u8,
    special_field: Cell<u8>,
}

let my_struct = SomeStruct {
    regular_field: 0,
    special_field: Cell::new(1),
};

let new_value = 100;

// ERROR: `my_struct` is immutable
// my_struct.regular_field = new_value;

// WORKS: although `my_struct` is immutable, `special_field` is a `Cell`,
// which can always be mutated
my_struct.special_field.set(new_value);
assert_eq!(my_struct.special_field.get(), new_value);
```

ÂØπ‰∫éÊ≤°ÊúâÂÆûÁé∞ Copy ÁöÑÁ±ªÂûãÔºå‰æãÂ¶Ç `String` Âíå `Vec<T>` Ë¶ÅÂÆûÁé∞Â§ö‰∏™‰∏çÂèØÂèòÂÄüÁî®ÂÜÖÈÉ®ÊàêÂëòÁöÑÂèØÂèòÊÄßÔºåÂ∞±ÈúÄË¶Å‰ΩøÁî® `RefCell<T>`Ôºö

- ÂÜÖÈÉ® T ‰∏çÂèØÂèòÂÄüÁî®Ôºö‰ΩøÁî® `borrow()` ÊñπÊ≥ï
- ÂÜÖÈÉ® T ÂèØÂèòÂÄüÁî®Ôºö‰ΩøÁî® `borrow_mut()` ÊñπÊ≥ï

‰ª•‰∏ä‰∏§‰∏™ÊñπÊ≥ï‰æùÁÑ∂ÈÅµÂÆàÂÜÖÂ≠òÂÆâÂÖ®ÂéüÂàôÔºåÂç≥ `borrow()` `borrow_mut()` ‰∏çÂèØ‰ª•Âú®Âêå‰∏Ä‰ΩúÁî®ÂüüÊâßË°åÔºåËøôÊ†∑‰ºöÂ≠òÂú® `&T` `&mut T`„ÄÇÊ≥®ÊÑè `RefCell` ÁöÑÂÄüÁî®ËßÑÂàôÂú®ÁºñËØëÊúü‰∏ç‰ºöÊ£ÄÊü•Ôºå‰ΩÜÊòØËøêË°åÊúüËøùÂèç‰ºöÂØºËá¥ panic„ÄÇ

```rust,ignore
use std::cell::{RefCell, RefMut};
use std::collections::HashMap;
use std::rc::Rc;

fn main() {
    let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));
    // Create a new block to limit the scope of the dynamic borrow
    {
        let mut map: RefMut<_> = shared_map.borrow_mut();
        map.insert("africa", 92388);
        map.insert("kyoto", 11837);
        map.insert("piccadilly", 11826);
        map.insert("marbles", 38);
    }

    // Note that if we had not let the previous borrow of the cache fall out
    // of scope then the subsequent borrow would cause a dynamic thread panic.
    // This is the major hazard of using `RefCell`.
    let total: i32 = shared_map.borrow().values().sum();
    println!("{}", total);
}
```




## ‚ö° Struct Vec
- https://doc.rust-lang.org/stable/std/vec/struct.Vec.html

Examples

    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);

    assert_eq!(vec.len(), 2);
    assert_eq!(vec[0], 1);

    assert_eq!(vec.pop(), Some(2));
    assert_eq!(vec.len(), 1);

    vec[0] = 7;
    assert_eq!(vec[0], 7);

    vec.extend([1, 2, 3].iter().copied());

    for x in &vec {
        println!("{}", x);
    }
    assert_eq!(vec, [7, 1, 2, 3]);

The vec! macro is provided to make initialization more convenient:

    let mut vec = vec![1, 2, 3];
    vec.push(4);
    assert_eq!(vec, [1, 2, 3, 4]);

It can also initialize each element of a Vec<T> with a given value. This may be more efficient than performing allocation and initialization in separate steps, especially when initializing a vector of zeros:

    let vec = vec![0; 5];
    assert_eq!(vec, [0, 0, 0, 0, 0]);

    // The following is equivalent, but potentially slower:
    let mut vec = Vec::with_capacity(5);
    vec.resize(5, 0);
    assert_eq!(vec, [0, 0, 0, 0, 0]);

For more information, see Capacity and Reallocation.

Use a Vec<T> as an efficient stack:

    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        // Prints 3, 2, 1
        println!("{}", top);
    }

Indexing
The Vec type allows to access values by index, because it implements the Index trait. An example will be more explicit:

    let v = vec![0, 2, 4, 6];
    println!("{}", v[1]); // it will display '2'

However be careful: if you try to access an index which isn't in the Vec, your software will panic! You cannot do this:

    let v = vec![0, 2, 4, 6];
    println!("{}", v[6]); // it will panic!

Use get and get_mut if you want to check whether the index is in the Vec.

Slicing
A Vec can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &. Example:

    fn read_slice(slice: &[usize]) {
        // ...
    }

    let v = vec![0, 1];
    read_slice(&v);

    // ... and that's all!
    // you can also do it like this:
    let u: &[usize] = &v;
    // or like this:
    let u: &[_] = &v;

## ‚ö° Trait Iterator
- https://doc.rust-lang.org/stable/std/iter/index.html

Ëø≠‰ª£Âô®Ê®°ÂùóÊèê‰æõ‰∫Ü‰∏âÂ§ßÂùóÂÜÖÂÆπÔºö

- Structs
- Traits
- Functions

Ëø≠‰ª£Âô®ÂÆö‰πâÊú¨Ë∫´ÂæàÁÆÄÂçïÔºåÂè™Êúâ‰∏Ä‰∏™ `next()` ÊñπÊ≥ïÔºö

```rust,ignore
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
```

‰ΩÜÊòØÔºåRust Êèê‰æõÁöÑ Traits Ë¶ÜÁõñÂÆûÁé∞Êú∫Âà∂ÔºåÂèØ‰ª•‰∏∫ÊâÄÊúâËø≠‰ª£Âô®Á±ªÂûãÊèê‰æõÂêÑÁßçÊñπÊ≥ïÂÆûÁé∞ÔºåÂç≥ blanket implementations„ÄÇ

‰æãÂ¶ÇÔºåÂØπËø≠‰ª£Âô®Ê±ÇÂíåÁöÑ `sum()` ÊñπÊ≥ïÔºåÈÄöËøá trait Sum Êé•Âè£Êèê‰æõÔºö

```rust,ignore
pub trait Sum<A = Self> {
    pub fn sum<I>(iter: I) -> Self
    where
        I: Iterator<Item = A>;
}
```

    pub trait Iterator {
    type Item;
    pub fn next(&mut self) -> Option<Self::Item>;

    pub fn size_hint(&self) -> (usize, Option<usize>) { ... }
    pub fn count(self) -> usize { ... }
    pub fn last(self) -> Option<Self::Item> { ... }
    pub fn advance_by(&mut self, n: usize) -> Result<(), usize> { ... }
    pub fn nth(&mut self, n: usize) -> Option<Self::Item> { ... }
    pub fn step_by(self, step: usize) -> StepBy<Self>‚ìò { ... }
    pub fn chain<U>(self, other: U ) -> Chain<Self, <U as IntoIterator>::IntoIter>‚ìò where U: IntoIterator<Item = Self::Item>, { ... }
    pub fn zip<U>(self, other: U) -> Zip<Self, <U as IntoIterator>::IntoIter>‚ìò where U: IntoIterator, { ... }
    pub fn map<B, F>(self, f: F) -> Map<Self, F>‚ìò where F: FnMut(Self::Item) -> B, { ... }
    pub fn for_each<F>(self, f: F) where F: FnMut(Self::Item), { ... }
    pub fn filter<P>(self, predicate: P) -> Filter<Self, P>‚ìò where P: FnMut(&Self::Item) -> bool, { ... }
    pub fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F>‚ìò where F: FnMut(Self::Item) -> Option<B>, { ... }
    pub fn enumerate(self) -> Enumerate<Self>‚ìò { ... }
    pub fn peekable(self) -> Peekable<Self>‚ìò { ... }
    pub fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P>‚ìò where P: FnMut(&Self::Item) -> bool, { ... }
    pub fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P>‚ìò where P: FnMut(&Self::Item) -> bool, { ... }
    pub fn map_while<B, P>(self, predicate: P) -> MapWhile<Self, P>‚ìò where P: FnMut(Self::Item) -> Option<B>, { ... }
    pub fn skip(self, n: usize) -> Skip<Self>‚ìò { ... }
    pub fn take(self, n: usize) -> Take<Self>‚ìò { ... }
    pub fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>‚ìò where F: FnMut(&mut St, Self::Item) -> Option<B>, { ... }
    pub fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>‚ìò where F: FnMut(Self::Item) -> U, U: IntoIterator, { ... }
    pub fn flatten(self) -> Flatten<Self>‚ìò where Self::Item: IntoIterator, { ... }
    pub fn fuse(self) -> Fuse<Self>‚ìò { ... }
    pub fn inspect<F>(self, f: F) -> Inspect<Self, F>‚ìò where F: FnMut(&Self::Item), { ... }
    pub fn by_ref(&mut self) -> &mut Self‚ìò { ... }

    pub fn collect<B>(self) -> B where B: FromIterator<Self::Item>, { ... }
    pub fn partition<B, F>(self, f: F) -> (B, B) where F: FnMut(&Self::Item) -> bool, B: Default + Extend<Self::Item>, { ... }
    pub fn partition_in_place<'a, T, P>(self, predicate: P) -> usize where Self: DoubleEndedIterator<Item = &'a mut T>, T: 'a, P: FnMut(&T) -> bool, { ... }
    pub fn is_partitioned<P>(self, predicate: P) -> bool where P: FnMut(Self::Item) -> bool, { ... }
    pub fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where F: FnMut(B, Self::Item) -> R, R: Try<Ok = B>, { ... }
    pub fn try_for_each<F, R>(&mut self, f: F) -> R where F: FnMut(Self::Item) -> R, R: Try<Ok = ()>, { ... }
    pub fn fold<B, F>(self, init: B, f: F) -> B where F: FnMut(B, Self::Item) -> B, { ... }
    pub fn fold_first<F>(self, f: F) -> Option<Self::Item> where F: FnMut(Self::Item, Self::Item) -> Self::Item, { ... }
    pub fn all<F>(&mut self, f: F) -> bool where F: FnMut(Self::Item) -> bool, { ... }
    pub fn any<F>(&mut self, f: F) -> bool where F: FnMut(Self::Item) -> bool, { ... }
    pub fn find<P>(&mut self, predicate: P) -> Option<Self::Item> where P: FnMut(&Self::Item) -> bool, { ... }
    pub fn find_map<B, F>(&mut self, f: F) -> Option<B> where F: FnMut(Self::Item) -> Option<B>, { ... }
    pub fn try_find<F, R>(&mut self, f: F ) -> Result<Option<Self::Item>, <R as Try>::Error> where F: FnMut(&Self::Item) -> R, R: Try<Ok = bool>, { ... }
    pub fn position<P>(&mut self, predicate: P) -> Option<usize> where P: FnMut(Self::Item) -> bool, { ... }
    pub fn rposition<P>(&mut self, predicate: P) -> Option<usize> where Self: ExactSizeIterator + DoubleEndedIterator, P: FnMut(Self::Item) -> bool, { ... }
    pub fn max(self) -> Option<Self::Item> where Self::Item: Ord, { ... }
    pub fn min(self) -> Option<Self::Item> where Self::Item: Ord, { ... }
    pub fn max_by_key<B, F>(self, f: F) -> Option<Self::Item> where F: FnMut(&Self::Item) -> B, B: Ord, { ... }
    pub fn max_by<F>(self, compare: F) -> Option<Self::Item> where F: FnMut(&Self::Item, &Self::Item) -> Ordering, { ... }
    pub fn min_by_key<B, F>(self, f: F) -> Option<Self::Item> where F: FnMut(&Self::Item) -> B, B: Ord, { ... }
    pub fn min_by<F>(self, compare: F) -> Option<Self::Item> where F: FnMut(&Self::Item, &Self::Item) -> Ordering, { ... }
    pub fn rev(self) -> Rev<Self>‚ìò where Self: DoubleEndedIterator, { ... }
    pub fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB) where Self: Iterator<Item = (A, B)>, FromA: Default + Extend<A>, FromB: Default + Extend<B>, { ... }
    pub fn copied<'a, T>(self) -> Copied<Self>‚ìò where Self: Iterator<Item = &'a T>, T: 'a + Copy, { ... }
    pub fn cloned<'a, T>(self) -> Cloned<Self>‚ìò where Self: Iterator<Item = &'a T>, T: 'a + Clone, { ... }
    pub fn cycle(self) -> Cycle<Self>‚ìò where Self: Clone, { ... }
    pub fn sum<S>(self) -> S where S: Sum<Self::Item>, { ... }
    pub fn product<P>(self) -> P where P: Product<Self::Item>, { ... }
    pub fn cmp<I>(self, other: I) -> Ordering where I: IntoIterator<Item = Self::Item>, Self::Item: Ord, { ... }
    pub fn cmp_by<I, F>(self, other: I, cmp: F) -> Ordering where F: FnMut(Self::Item, <I as IntoIterator>::Item) -> Ordering, I: IntoIterator, { ... }
    pub fn partial_cmp<I>(self, other: I) -> Option<Ordering> where I: IntoIterator, Self::Item: PartialOrd<<I as IntoIterator>::Item>, { ... }
    pub fn partial_cmp_by<I, F>(self, other: I, partial_cmp: F ) -> Option<Ordering> where F: FnMut(Self::Item, <I as IntoIterator>::Item) -> Option<Ordering>, I: IntoIterator, { ... }
    pub fn eq<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialEq<<I as IntoIterator>::Item>, { ... }
    pub fn eq_by<I, F>(self, other: I, eq: F) -> bool where F: FnMut(Self::Item, <I as IntoIterator>::Item) -> bool, I: IntoIterator, { ... }
    pub fn ne<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialEq<<I as IntoIterator>::Item>, { ... }
    pub fn lt<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd<<I as IntoIterator>::Item>, { ... }
    pub fn le<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd<<I as IntoIterator>::Item>, { ... }
    pub fn gt<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd<<I as IntoIterator>::Item>, { ... }
    pub fn ge<I>(self, other: I) -> bool where I: IntoIterator, Self::Item: PartialOrd<<I as IntoIterator>::Item>, { ... }
    pub fn is_sorted(self) -> bool where Self::Item: PartialOrd<Self::Item>, { ... }
    pub fn is_sorted_by<F>(self, compare: F) -> bool where F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>, { ... }
    pub fn is_sorted_by_key<F, K>(self, f: F) -> bool where F: FnMut(Self::Item) -> K, K: PartialOrd<K>, { ... }
    }


Structs

- `MapWhile`    ExperimentalAn iterator that only accepts elements while predicate returns Some(_).
- `Chain`   An iterator that links two iterators together, in a chain.
- `Cloned`  An iterator that clones the elements of an underlying iterator.
- `Copied`  An iterator that copies the elements of an underlying iterator.
- `Cycle`   An iterator that repeats endlessly.
- `Empty`   An iterator that yields nothing.
- `Enumerate`   An iterator that yields the current count and the element during iteration.
- `Filter`  An iterator that filters the elements of iter with predicate.
- `FilterMap`   An iterator that uses f to both filter and map elements from iter.
- `FlatMap` An iterator that maps each element to an iterator, and yields the elements of the produced iterators.
- `Flatten` An iterator that flattens one level of nesting in an iterator of things that can be turned into iterators.
- `FromFn`  An iterator where each iteration calls the provided closure F: FnMut() -> Option<T>.
- `Fuse`    An iterator that yields None forever after the underlying iterator yields None once.
- `Inspect` An iterator that calls a function with a reference to each element before yielding it.
- `Map` An iterator that maps the values of iter with f.
- `Once`    An iterator that yields an element exactly once.
- `OnceWith`    An iterator that yields a single element of type A by applying the provided closure F: FnOnce() -> A.
- `Peekable`    An iterator with a peek() that returns an optional reference to the next element.
- `Repeat`  An iterator that repeats an element endlessly.
- `RepeatWith`  An iterator that repeats elements of type A endlessly by applying the provided closure F: FnMut() -> A.
- `Rev` A double-ended iterator with the direction inverted.
- `Scan`    An iterator to maintain state while iterating another iterator.
- `Skip`    An iterator that skips over n elements of iter.
- `SkipWhile`   An iterator that rejects elements while predicate returns true.
- `StepBy`  An iterator for stepping iterators by a custom amount.
- `Successors`  An new iterator where each successive item is computed based on the preceding one.
- `Take`    An iterator that only iterates over the first n iterations of iter.
- `TakeWhile`   An iterator that only accepts elements while predicate returns true.
- `Zip` An iterator that iterates two other iterators simultaneously.

Traits

- `InPlaceIterable` ExperimentalAn iterator that when yielding an item will have taken at least one element from its underlying SourceIter.
- `SourceIter`  ExperimentalThis trait provides transitive access to source-stage in an interator-adapter pipeline under the conditions that
- `Step`    ExperimentalObjects that have a notion of successor and predecessor operations.
- `TrustedLen`  ExperimentalAn iterator that reports an accurate length using size_hint.
- `DoubleEndedIterator` An iterator able to yield elements from both ends.
- `ExactSizeIterator`   An iterator that knows its exact length.
- `Extend`  Extend a collection with the contents of an iterator.
- `FromIterator`    Conversion from an Iterator.
- `FusedIterator`   An iterator that always continues to yield None when exhausted.
- `IntoIterator`    Conversion into an Iterator.
- `Iterator`    An interface for dealing with iterators.
- `Product` Trait to represent types that can be created by multiplying elements of an iterator.
- `Sum` Trait to represent types that can be created by summing up an iterator.

Functions

- `empty`   Creates an iterator that yields nothing.
- `from_fn` Creates a new iterator where each iteration calls the provided closure F: FnMut() -> Option<T>.
- `once`    Creates an iterator that yields an element exactly once.
- `once_with`   Creates an iterator that lazily generates a value exactly once by invoking the provided closure.
- `repeat`  Creates a new iterator that endlessly repeats a single element.
- `repeat_with` Creates a new iterator that repeats elements of type A endlessly by applying the provided closure, the repeater, F: FnMut() -> A.
- `successors`  Creates a new iterator where each successive item is computed based on the preceding one.


## ‚ö° std::fs
- The I/O Prelude https://doc.rust-lang.org/stable/std/io/prelude/index.html
- Filesystem manipulation operations https://doc.rust-lang.org/stable/std/fs/index.html

Filesystem manipulation operations.

This module contains basic methods to manipulate the contents of the local filesystem. All methods in this module represent cross-platform filesystem operations. Extra platform-specific functionality can be found in the extension traits of std::os::$platform.

Structs

- `DirBuilder`  A builder used to create directories in various manners.
- `DirEntry`    Entries returned by the ReadDir iterator.
- `File`    A reference to an open file on the filesystem.
- `FileType`    A structure representing a type of file with accessors for each file type. It is returned by Metadata::file_type method.
- `Metadata`    Metadata information about a file.
- `OpenOptions` Options and flags which can be used to configure how a file is opened.
- `Permissions` Representation of the various permissions on a file.
- `ReadDir` Iterator over the entries in a directory.

Examples

```rust,ignore
use std::fs;

fn main() -> std::io::Result<()> {
    for entry in fs::read_dir(".")? {
        let dir = entry?;
        println!("{:?}", dir.path());
    }
    Ok(())
}
```


Functions

- `canonicalize( path )`    ËøîÂõûËßÑËåÉÁªùÂØπÂΩ¢ÂºèË∑ØÂæÑÔºåÊâÄÊúâ‰∏≠Èó¥ÁªÑ‰ª∂ÈÉΩÂ∑≤ËßÑËåÉÂåñÂπ∂Ëß£ÊûêÁ¨¶Âè∑ÈìæÊé•„ÄÇ
- `copy( from, to )`    Â∞Ü‰∏Ä‰∏™Êñá‰ª∂ÁöÑÂÜÖÂÆπÂ§çÂà∂Âà∞Âè¶‰∏Ä‰∏™Êñá‰ª∂ÔºåÂπ∂‰∏îÔºåÊ≠§ÂáΩÊï∞ËøòÂ∞ÜÂéüÂßãÊñá‰ª∂ÁöÑÊùÉÈôê‰ΩçÂ§çÂà∂Âà∞ÁõÆÊ†áÊñá‰ª∂„ÄÇ
- `create_dir( path )`  Creates a new, empty directory at the provided path
- `create_dir_all( path )`  Recursively create a directory and all of its parent components if they are missing.
- `hard_link(original, link)`   Creates a new hard link on the filesystem.
- `metadata( path )`    Given a path, query the file system to get information about a file, directory, etc.
- `read( path )`    Read the entire contents of a file into a bytes vector.
- `read_dir( path )`    Returns an iterator over the entries within a directory.
- `read_link( path )`   Reads a symbolic link, returning the file that the link points to.
- `read_to_string( path )`  Read the entire contents of a file into a string.
- `remove_dir( path )`  Removes an empty directory.
- `remove_dir_all( path )`  Removes a directory at this path, after removing all its contents. Use carefully!
- `remove_file( path )` Removes a file from the filesystem.
- `rename(from, to)`    Rename a file or directory to a new name, replacing the original file if to already exists.
- `set_permissions( path, perm)`    Changes the permissions found on a file or a directory.
- `soft_link( original, link )` DeprecatedCreates a new symbolic link on the filesystem.
- `symlink_metadata( path )`    Query the metadata about a file without following symlinks.
- `write( path, contents )` Write a slice as the entire contents of a file.

Examples

```rust,ignore
use std::fs;

fn main() -> std::io::Result<()> {
    let path = fs::canonicalize("../a/../foo.txt")?;
    let mut perms = fs::metadata(path)?.permissions();
    perms.set_readonly(true);
    fs::set_permissions(path, perms)?;
    Ok(())
}
```

## ‚ö° Range Expressions
- https://doc.rust-lang.org/stable/reference/expressions/range-expr.html
- https://doc.rust-lang.org/stable/std/ops/struct.Range.html

Range expressions

    Syntax
    RangeExpression :
          RangeExpr
       | RangeFromExpr
       | RangeToExpr
       | RangeFullExpr
       | RangeInclusiveExpr
       | RangeToInclusiveExpr

    RangeExpr :
       Expression .. Expression

    RangeFromExpr :
       Expression ..

    RangeToExpr :
       .. Expression

    RangeFullExpr :
       ..

    RangeInclusiveExpr :
       Expression ..= Expression

    RangeToInclusiveExpr :
       ..= Expression

The `..` and `..=` operators will construct an object of one of the `std::ops::Range` (or `core::ops::Range`) variants, according to the following table:

|      Production      |    Syntax   |            Type            |      Range      |
|----------------------|-------------|----------------------------|-----------------|
| RangeExpr            | start..end  | std::ops::Range            | start ‚â§ x < end |
| RangeFromExpr        | start..     | std::ops::RangeFrom        | start ‚â§ x       |
| RangeToExpr          | ..end       | std::ops::RangeTo          | x < end         |
| RangeFullExpr        | ..          | std::ops::RangeFull        | -               |
| RangeInclusiveExpr   | start..=end | std::ops::RangeInclusive   | start ‚â§ x ‚â§ end |
| RangeToInclusiveExpr | ..=end      | std::ops::RangeToInclusive | x ‚â§ end         |

Examples:

```rust,ignore
let arr = [0, 1, 2, 3, 4];
assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);
assert_eq!(arr[ .. 3], [0, 1, 2      ]);
assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);
assert_eq!(arr[1..  ], [   1, 2, 3, 4]);
assert_eq!(arr[1.. 3], [   1, 2      ]); // This is a `Range`
assert_eq!(arr[1..=3], [   1, 2, 3   ]);

1..2;   // std::ops::Range
3..;    // std::ops::RangeFrom
..4;    // std::ops::RangeTo
..;     // std::ops::RangeFull
5..=6;  // std::ops::RangeInclusive
..=7;   // std::ops::RangeToInclusive
```
The following expressions are equivalent.



```rust,ignore
let x = std::ops::Range {start: 0, end: 10};
let y = 0..10;

assert_eq!(x, y);
```

Ranges can be used in for loops:

```rust,ignore
for i in 1..11 {
    println!("{}", i);
}
```
